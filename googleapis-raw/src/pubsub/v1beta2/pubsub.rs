// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/pubsub/v1beta2/pubsub.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

///  A topic resource.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.Topic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Topic {
    // message fields
    ///  Name of the topic.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.Topic.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.Topic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Topic {
    fn default() -> &'a Topic {
        <Topic as ::protobuf::Message>::default_instance()
    }
}

impl Topic {
    pub fn new() -> Topic {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Topic| { &m.name },
            |m: &mut Topic| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Topic>(
            "Topic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Topic {
    const NAME: &'static str = "Topic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Topic {
        Topic::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Topic {
        static instance: Topic = Topic {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Topic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Topic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Topic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Topic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A message data and its attributes.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.PubsubMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PubsubMessage {
    // message fields
    ///  The message payload. For JSON requests, the value of this field must be
    ///  base64-encoded.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PubsubMessage.data)
    pub data: ::std::vec::Vec<u8>,
    ///  Optional attributes for this message.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PubsubMessage.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  ID of this message assigned by the server at publication time. Guaranteed
    ///  to be unique within the topic. This value may be read by a subscriber
    ///  that receives a PubsubMessage via a Pull call or a push delivery. It must
    ///  not be populated by a publisher in a Publish call.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PubsubMessage.message_id)
    pub message_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.PubsubMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubsubMessage {
    fn default() -> &'a PubsubMessage {
        <PubsubMessage as ::protobuf::Message>::default_instance()
    }
}

impl PubsubMessage {
    pub fn new() -> PubsubMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &PubsubMessage| { &m.data },
            |m: &mut PubsubMessage| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &PubsubMessage| { &m.attributes },
            |m: &mut PubsubMessage| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &PubsubMessage| { &m.message_id },
            |m: &mut PubsubMessage| { &mut m.message_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubsubMessage>(
            "PubsubMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubsubMessage {
    const NAME: &'static str = "PubsubMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                26 => {
                    self.message_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.message_id.is_empty() {
            os.write_string(3, &self.message_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubsubMessage {
        PubsubMessage::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.attributes.clear();
        self.message_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubsubMessage {
        static instance: ::protobuf::rt::Lazy<PubsubMessage> = ::protobuf::rt::Lazy::new();
        instance.get(PubsubMessage::new)
    }
}

impl ::protobuf::MessageFull for PubsubMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubsubMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubsubMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubsubMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the GetTopic method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.GetTopicRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTopicRequest {
    // message fields
    ///  The name of the topic to get.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.GetTopicRequest.topic)
    pub topic: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.GetTopicRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTopicRequest {
    fn default() -> &'a GetTopicRequest {
        <GetTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTopicRequest {
    pub fn new() -> GetTopicRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &GetTopicRequest| { &m.topic },
            |m: &mut GetTopicRequest| { &mut m.topic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTopicRequest>(
            "GetTopicRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTopicRequest {
    const NAME: &'static str = "GetTopicRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTopicRequest {
        GetTopicRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTopicRequest {
        static instance: GetTopicRequest = GetTopicRequest {
            topic: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTopicRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTopicRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTopicRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the Publish method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.PublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublishRequest {
    // message fields
    ///  The messages in the request will be published on this topic.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PublishRequest.topic)
    pub topic: ::std::string::String,
    ///  The messages to publish.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PublishRequest.messages)
    pub messages: ::std::vec::Vec<PubsubMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.PublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublishRequest {
    fn default() -> &'a PublishRequest {
        <PublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PublishRequest {
    pub fn new() -> PublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &PublishRequest| { &m.topic },
            |m: &mut PublishRequest| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &PublishRequest| { &m.messages },
            |m: &mut PublishRequest| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishRequest>(
            "PublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PublishRequest {
    const NAME: &'static str = "PublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                18 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublishRequest {
        PublishRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublishRequest {
        static instance: PublishRequest = PublishRequest {
            topic: ::std::string::String::new(),
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the Publish method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.PublishResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublishResponse {
    // message fields
    ///  The server-assigned ID of each published message, in the same order as
    ///  the messages in the request. IDs are guaranteed to be unique within
    ///  the topic.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PublishResponse.message_ids)
    pub message_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.PublishResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublishResponse {
    fn default() -> &'a PublishResponse {
        <PublishResponse as ::protobuf::Message>::default_instance()
    }
}

impl PublishResponse {
    pub fn new() -> PublishResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_ids",
            |m: &PublishResponse| { &m.message_ids },
            |m: &mut PublishResponse| { &mut m.message_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishResponse>(
            "PublishResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PublishResponse {
    const NAME: &'static str = "PublishResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.message_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.message_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublishResponse {
        PublishResponse::new()
    }

    fn clear(&mut self) {
        self.message_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublishResponse {
        static instance: PublishResponse = PublishResponse {
            message_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PublishResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PublishResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PublishResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the ListTopics method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ListTopicsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicsRequest {
    // message fields
    ///  The name of the cloud project that topics belong to.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicsRequest.project)
    pub project: ::std::string::String,
    ///  Maximum number of topics to return.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last ListTopicsResponse; indicates that this is
    ///  a continuation of a prior ListTopics call, and that the system should
    ///  return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ListTopicsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicsRequest {
    fn default() -> &'a ListTopicsRequest {
        <ListTopicsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsRequest {
    pub fn new() -> ListTopicsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &ListTopicsRequest| { &m.project },
            |m: &mut ListTopicsRequest| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListTopicsRequest| { &m.page_size },
            |m: &mut ListTopicsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListTopicsRequest| { &m.page_token },
            |m: &mut ListTopicsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicsRequest>(
            "ListTopicsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicsRequest {
    const NAME: &'static str = "ListTopicsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.project = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicsRequest {
        ListTopicsRequest::new()
    }

    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicsRequest {
        static instance: ListTopicsRequest = ListTopicsRequest {
            project: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the ListTopics method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ListTopicsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicsResponse {
    // message fields
    ///  The resulting topics.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicsResponse.topics)
    pub topics: ::std::vec::Vec<Topic>,
    ///  If not empty, indicates that there may be more topics that match the
    ///  request; this value should be passed in a new ListTopicsRequest.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ListTopicsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicsResponse {
    fn default() -> &'a ListTopicsResponse {
        <ListTopicsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsResponse {
    pub fn new() -> ListTopicsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "topics",
            |m: &ListTopicsResponse| { &m.topics },
            |m: &mut ListTopicsResponse| { &mut m.topics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListTopicsResponse| { &m.next_page_token },
            |m: &mut ListTopicsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicsResponse>(
            "ListTopicsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicsResponse {
    const NAME: &'static str = "ListTopicsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topics.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.topics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.topics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicsResponse {
        ListTopicsResponse::new()
    }

    fn clear(&mut self) {
        self.topics.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicsResponse {
        static instance: ListTopicsResponse = ListTopicsResponse {
            topics: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the ListTopicSubscriptions method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ListTopicSubscriptionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicSubscriptionsRequest {
    // message fields
    ///  The name of the topic that subscriptions are attached to.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicSubscriptionsRequest.topic)
    pub topic: ::std::string::String,
    ///  Maximum number of subscription names to return.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicSubscriptionsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last ListTopicSubscriptionsResponse; indicates
    ///  that this is a continuation of a prior ListTopicSubscriptions call, and
    ///  that the system should return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicSubscriptionsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ListTopicSubscriptionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsRequest {
    fn default() -> &'a ListTopicSubscriptionsRequest {
        <ListTopicSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsRequest {
    pub fn new() -> ListTopicSubscriptionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &ListTopicSubscriptionsRequest| { &m.topic },
            |m: &mut ListTopicSubscriptionsRequest| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListTopicSubscriptionsRequest| { &m.page_size },
            |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListTopicSubscriptionsRequest| { &m.page_token },
            |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicSubscriptionsRequest>(
            "ListTopicSubscriptionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsRequest {
    const NAME: &'static str = "ListTopicSubscriptionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicSubscriptionsRequest {
        ListTopicSubscriptionsRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicSubscriptionsRequest {
        static instance: ListTopicSubscriptionsRequest = ListTopicSubscriptionsRequest {
            topic: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicSubscriptionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicSubscriptionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the ListTopicSubscriptions method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ListTopicSubscriptionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicSubscriptionsResponse {
    // message fields
    ///  The names of the subscriptions that match the request.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicSubscriptionsResponse.subscriptions)
    pub subscriptions: ::std::vec::Vec<::std::string::String>,
    ///  If not empty, indicates that there may be more subscriptions that match
    ///  the request; this value should be passed in a new
    ///  ListTopicSubscriptionsRequest to get more subscriptions.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListTopicSubscriptionsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ListTopicSubscriptionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsResponse {
    fn default() -> &'a ListTopicSubscriptionsResponse {
        <ListTopicSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsResponse {
    pub fn new() -> ListTopicSubscriptionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscriptions",
            |m: &ListTopicSubscriptionsResponse| { &m.subscriptions },
            |m: &mut ListTopicSubscriptionsResponse| { &mut m.subscriptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListTopicSubscriptionsResponse| { &m.next_page_token },
            |m: &mut ListTopicSubscriptionsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicSubscriptionsResponse>(
            "ListTopicSubscriptionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsResponse {
    const NAME: &'static str = "ListTopicSubscriptionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscriptions.push(is.read_string()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.subscriptions {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicSubscriptionsResponse {
        ListTopicSubscriptionsResponse::new()
    }

    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicSubscriptionsResponse {
        static instance: ListTopicSubscriptionsResponse = ListTopicSubscriptionsResponse {
            subscriptions: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicSubscriptionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicSubscriptionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the DeleteTopic method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.DeleteTopicRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteTopicRequest {
    // message fields
    ///  Name of the topic to delete.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.DeleteTopicRequest.topic)
    pub topic: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.DeleteTopicRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTopicRequest {
    fn default() -> &'a DeleteTopicRequest {
        <DeleteTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTopicRequest {
    pub fn new() -> DeleteTopicRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &DeleteTopicRequest| { &m.topic },
            |m: &mut DeleteTopicRequest| { &mut m.topic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTopicRequest>(
            "DeleteTopicRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTopicRequest {
    const NAME: &'static str = "DeleteTopicRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTopicRequest {
        DeleteTopicRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTopicRequest {
        static instance: DeleteTopicRequest = DeleteTopicRequest {
            topic: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTopicRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTopicRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTopicRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A subscription resource.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.Subscription)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subscription {
    // message fields
    ///  Name of the subscription.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.Subscription.name)
    pub name: ::std::string::String,
    ///  The name of the topic from which this subscription is receiving messages.
    ///  This will be present if and only if the subscription has not been detached
    ///  from its topic.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.Subscription.topic)
    pub topic: ::std::string::String,
    ///  If push delivery is used with this subscription, this field is
    ///  used to configure it. An empty pushConfig signifies that the subscriber
    ///  will pull and ack messages using API methods.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.Subscription.push_config)
    pub push_config: ::protobuf::MessageField<PushConfig>,
    ///  This value is the maximum time after a subscriber receives a message
    ///  before the subscriber should acknowledge the message. After message
    ///  delivery but before the ack deadline expires and before the message is
    ///  acknowledged, it is an outstanding message and will not be delivered
    ///  again during that time (on a best-effort basis).
    ///
    ///  For pull delivery this value
    ///  is used as the initial value for the ack deadline. It may be overridden
    ///  for a specific message by calling ModifyAckDeadline.
    ///
    ///  For push delivery, this value is also used to set the request timeout for
    ///  the call to the push endpoint.
    ///
    ///  If the subscriber never acknowledges the message, the Pub/Sub
    ///  system will eventually redeliver the message.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.Subscription.ack_deadline_seconds)
    pub ack_deadline_seconds: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.Subscription.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Subscription {
    fn default() -> &'a Subscription {
        <Subscription as ::protobuf::Message>::default_instance()
    }
}

impl Subscription {
    pub fn new() -> Subscription {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Subscription| { &m.name },
            |m: &mut Subscription| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &Subscription| { &m.topic },
            |m: &mut Subscription| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PushConfig>(
            "push_config",
            |m: &Subscription| { &m.push_config },
            |m: &mut Subscription| { &mut m.push_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_deadline_seconds",
            |m: &Subscription| { &m.ack_deadline_seconds },
            |m: &mut Subscription| { &mut m.ack_deadline_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscription>(
            "Subscription",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Subscription {
    const NAME: &'static str = "Subscription";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.topic = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.push_config)?;
                },
                40 => {
                    self.ack_deadline_seconds = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.ack_deadline_seconds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(v) = self.push_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.ack_deadline_seconds != 0 {
            os.write_int32(5, self.ack_deadline_seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Subscription {
        Subscription::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.topic.clear();
        self.push_config.clear();
        self.ack_deadline_seconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Subscription {
        static instance: Subscription = Subscription {
            name: ::std::string::String::new(),
            topic: ::std::string::String::new(),
            push_config: ::protobuf::MessageField::none(),
            ack_deadline_seconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Subscription {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Subscription").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Subscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subscription {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Configuration for a push delivery endpoint.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.PushConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PushConfig {
    // message fields
    ///  A URL locating the endpoint to which messages should be pushed.
    ///  For example, a Webhook endpoint might use "https://example.com/push".
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PushConfig.push_endpoint)
    pub push_endpoint: ::std::string::String,
    ///  Endpoint configuration attributes.
    ///
    ///  Every endpoint has a set of API supported attributes that can be used to
    ///  control different aspects of the message delivery.
    ///
    ///  The currently supported attribute is `x-goog-version`, which you can
    ///  use to change the format of the push message. This attribute
    ///  indicates the version of the data expected by the endpoint. This
    ///  controls the shape of the envelope (i.e. its fields and metadata).
    ///  The endpoint version is based on the version of the Pub/Sub
    ///  API.
    ///
    ///  If not present during the CreateSubscription call, it will default to
    ///  the version of the API used to make such call. If not present during a
    ///  ModifyPushConfig call, its value will not be changed. GetSubscription
    ///  calls will always return a valid version, even if the subscription was
    ///  created without this attribute.
    ///
    ///  The possible values for this attribute are:
    ///
    ///  * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
    ///  * `v1beta2`: uses the push format defined in the v1beta2 Pub/Sub API.
    ///
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PushConfig.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.PushConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PushConfig {
    fn default() -> &'a PushConfig {
        <PushConfig as ::protobuf::Message>::default_instance()
    }
}

impl PushConfig {
    pub fn new() -> PushConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "push_endpoint",
            |m: &PushConfig| { &m.push_endpoint },
            |m: &mut PushConfig| { &mut m.push_endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &PushConfig| { &m.attributes },
            |m: &mut PushConfig| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PushConfig>(
            "PushConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PushConfig {
    const NAME: &'static str = "PushConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.push_endpoint = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.push_endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.push_endpoint);
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.push_endpoint.is_empty() {
            os.write_string(1, &self.push_endpoint)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PushConfig {
        PushConfig::new()
    }

    fn clear(&mut self) {
        self.push_endpoint.clear();
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PushConfig {
        static instance: ::protobuf::rt::Lazy<PushConfig> = ::protobuf::rt::Lazy::new();
        instance.get(PushConfig::new)
    }
}

impl ::protobuf::MessageFull for PushConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PushConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PushConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A message and its corresponding acknowledgment ID.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ReceivedMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReceivedMessage {
    // message fields
    ///  This ID can be used to acknowledge the received message.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ReceivedMessage.ack_id)
    pub ack_id: ::std::string::String,
    ///  The message.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ReceivedMessage.message)
    pub message: ::protobuf::MessageField<PubsubMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ReceivedMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReceivedMessage {
    fn default() -> &'a ReceivedMessage {
        <ReceivedMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReceivedMessage {
    pub fn new() -> ReceivedMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_id",
            |m: &ReceivedMessage| { &m.ack_id },
            |m: &mut ReceivedMessage| { &mut m.ack_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubsubMessage>(
            "message",
            |m: &ReceivedMessage| { &m.message },
            |m: &mut ReceivedMessage| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReceivedMessage>(
            "ReceivedMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReceivedMessage {
    const NAME: &'static str = "ReceivedMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ack_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ack_id);
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ack_id.is_empty() {
            os.write_string(1, &self.ack_id)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReceivedMessage {
        ReceivedMessage::new()
    }

    fn clear(&mut self) {
        self.ack_id.clear();
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReceivedMessage {
        static instance: ReceivedMessage = ReceivedMessage {
            ack_id: ::std::string::String::new(),
            message: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReceivedMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReceivedMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReceivedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceivedMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the GetSubscription method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.GetSubscriptionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSubscriptionRequest {
    // message fields
    ///  The name of the subscription to get.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.GetSubscriptionRequest.subscription)
    pub subscription: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.GetSubscriptionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSubscriptionRequest {
    fn default() -> &'a GetSubscriptionRequest {
        <GetSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSubscriptionRequest {
    pub fn new() -> GetSubscriptionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &GetSubscriptionRequest| { &m.subscription },
            |m: &mut GetSubscriptionRequest| { &mut m.subscription },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSubscriptionRequest>(
            "GetSubscriptionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSubscriptionRequest {
    const NAME: &'static str = "GetSubscriptionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSubscriptionRequest {
        GetSubscriptionRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSubscriptionRequest {
        static instance: GetSubscriptionRequest = GetSubscriptionRequest {
            subscription: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSubscriptionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSubscriptionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubscriptionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the ListSubscriptions method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ListSubscriptionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSubscriptionsRequest {
    // message fields
    ///  The name of the cloud project that subscriptions belong to.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListSubscriptionsRequest.project)
    pub project: ::std::string::String,
    ///  Maximum number of subscriptions to return.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListSubscriptionsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last ListSubscriptionsResponse; indicates that
    ///  this is a continuation of a prior ListSubscriptions call, and that the
    ///  system should return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListSubscriptionsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ListSubscriptionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsRequest {
    fn default() -> &'a ListSubscriptionsRequest {
        <ListSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsRequest {
    pub fn new() -> ListSubscriptionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &ListSubscriptionsRequest| { &m.project },
            |m: &mut ListSubscriptionsRequest| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListSubscriptionsRequest| { &m.page_size },
            |m: &mut ListSubscriptionsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListSubscriptionsRequest| { &m.page_token },
            |m: &mut ListSubscriptionsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSubscriptionsRequest>(
            "ListSubscriptionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSubscriptionsRequest {
    const NAME: &'static str = "ListSubscriptionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.project = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSubscriptionsRequest {
        ListSubscriptionsRequest::new()
    }

    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSubscriptionsRequest {
        static instance: ListSubscriptionsRequest = ListSubscriptionsRequest {
            project: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSubscriptionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSubscriptionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the ListSubscriptions method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ListSubscriptionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSubscriptionsResponse {
    // message fields
    ///  The subscriptions that match the request.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListSubscriptionsResponse.subscriptions)
    pub subscriptions: ::std::vec::Vec<Subscription>,
    ///  If not empty, indicates that there may be more subscriptions that match
    ///  the request; this value should be passed in a new ListSubscriptionsRequest
    ///  to get more subscriptions.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ListSubscriptionsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ListSubscriptionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsResponse {
    fn default() -> &'a ListSubscriptionsResponse {
        <ListSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsResponse {
    pub fn new() -> ListSubscriptionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscriptions",
            |m: &ListSubscriptionsResponse| { &m.subscriptions },
            |m: &mut ListSubscriptionsResponse| { &mut m.subscriptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListSubscriptionsResponse| { &m.next_page_token },
            |m: &mut ListSubscriptionsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSubscriptionsResponse>(
            "ListSubscriptionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSubscriptionsResponse {
    const NAME: &'static str = "ListSubscriptionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscriptions.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.subscriptions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSubscriptionsResponse {
        ListSubscriptionsResponse::new()
    }

    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSubscriptionsResponse {
        static instance: ListSubscriptionsResponse = ListSubscriptionsResponse {
            subscriptions: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSubscriptionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSubscriptionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the DeleteSubscription method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.DeleteSubscriptionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSubscriptionRequest {
    // message fields
    ///  The subscription to delete.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.DeleteSubscriptionRequest.subscription)
    pub subscription: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.DeleteSubscriptionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSubscriptionRequest {
    fn default() -> &'a DeleteSubscriptionRequest {
        <DeleteSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSubscriptionRequest {
    pub fn new() -> DeleteSubscriptionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &DeleteSubscriptionRequest| { &m.subscription },
            |m: &mut DeleteSubscriptionRequest| { &mut m.subscription },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSubscriptionRequest>(
            "DeleteSubscriptionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSubscriptionRequest {
    const NAME: &'static str = "DeleteSubscriptionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSubscriptionRequest {
        DeleteSubscriptionRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSubscriptionRequest {
        static instance: DeleteSubscriptionRequest = DeleteSubscriptionRequest {
            subscription: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSubscriptionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSubscriptionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSubscriptionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the ModifyPushConfig method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ModifyPushConfigRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModifyPushConfigRequest {
    // message fields
    ///  The name of the subscription.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ModifyPushConfigRequest.subscription)
    pub subscription: ::std::string::String,
    ///  The push configuration for future deliveries.
    ///
    ///  An empty pushConfig indicates that the Pub/Sub system should
    ///  stop pushing messages from the given subscription and allow
    ///  messages to be pulled and acknowledged - effectively pausing
    ///  the subscription if Pull is not called.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ModifyPushConfigRequest.push_config)
    pub push_config: ::protobuf::MessageField<PushConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ModifyPushConfigRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModifyPushConfigRequest {
    fn default() -> &'a ModifyPushConfigRequest {
        <ModifyPushConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyPushConfigRequest {
    pub fn new() -> ModifyPushConfigRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &ModifyPushConfigRequest| { &m.subscription },
            |m: &mut ModifyPushConfigRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PushConfig>(
            "push_config",
            |m: &ModifyPushConfigRequest| { &m.push_config },
            |m: &mut ModifyPushConfigRequest| { &mut m.push_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModifyPushConfigRequest>(
            "ModifyPushConfigRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModifyPushConfigRequest {
    const NAME: &'static str = "ModifyPushConfigRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.push_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if let Some(v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if let Some(v) = self.push_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModifyPushConfigRequest {
        ModifyPushConfigRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.push_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModifyPushConfigRequest {
        static instance: ModifyPushConfigRequest = ModifyPushConfigRequest {
            subscription: ::std::string::String::new(),
            push_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModifyPushConfigRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModifyPushConfigRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModifyPushConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyPushConfigRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the Pull method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.PullRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PullRequest {
    // message fields
    ///  The subscription from which messages should be pulled.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PullRequest.subscription)
    pub subscription: ::std::string::String,
    ///  If this is specified as true the system will respond immediately even if
    ///  it is not able to return a message in the Pull response. Otherwise the
    ///  system is allowed to wait until at least one message is available rather
    ///  than returning no messages. The client may cancel the request if it does
    ///  not wish to wait any longer for the response.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PullRequest.return_immediately)
    pub return_immediately: bool,
    ///  The maximum number of messages returned for this request. The Pub/Sub
    ///  system may return fewer than the number specified.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PullRequest.max_messages)
    pub max_messages: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.PullRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PullRequest {
    fn default() -> &'a PullRequest {
        <PullRequest as ::protobuf::Message>::default_instance()
    }
}

impl PullRequest {
    pub fn new() -> PullRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &PullRequest| { &m.subscription },
            |m: &mut PullRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_immediately",
            |m: &PullRequest| { &m.return_immediately },
            |m: &mut PullRequest| { &mut m.return_immediately },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_messages",
            |m: &PullRequest| { &m.max_messages },
            |m: &mut PullRequest| { &mut m.max_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PullRequest>(
            "PullRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PullRequest {
    const NAME: &'static str = "PullRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                16 => {
                    self.return_immediately = is.read_bool()?;
                },
                24 => {
                    self.max_messages = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if self.return_immediately != false {
            my_size += 1 + 1;
        }
        if self.max_messages != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.max_messages);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if self.return_immediately != false {
            os.write_bool(2, self.return_immediately)?;
        }
        if self.max_messages != 0 {
            os.write_int32(3, self.max_messages)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PullRequest {
        PullRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.return_immediately = false;
        self.max_messages = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PullRequest {
        static instance: PullRequest = PullRequest {
            subscription: ::std::string::String::new(),
            return_immediately: false,
            max_messages: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PullRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PullRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the Pull method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.PullResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PullResponse {
    // message fields
    ///  Received Pub/Sub messages. The Pub/Sub system will return zero messages if
    ///  there are no more available in the backlog. The Pub/Sub system may return
    ///  fewer than the maxMessages requested even if there are more messages
    ///  available in the backlog.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.PullResponse.received_messages)
    pub received_messages: ::std::vec::Vec<ReceivedMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.PullResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PullResponse {
    fn default() -> &'a PullResponse {
        <PullResponse as ::protobuf::Message>::default_instance()
    }
}

impl PullResponse {
    pub fn new() -> PullResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "received_messages",
            |m: &PullResponse| { &m.received_messages },
            |m: &mut PullResponse| { &mut m.received_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PullResponse>(
            "PullResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PullResponse {
    const NAME: &'static str = "PullResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.received_messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.received_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.received_messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PullResponse {
        PullResponse::new()
    }

    fn clear(&mut self) {
        self.received_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PullResponse {
        static instance: PullResponse = PullResponse {
            received_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PullResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PullResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the ModifyAckDeadline method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.ModifyAckDeadlineRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModifyAckDeadlineRequest {
    // message fields
    ///  The name of the subscription.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ModifyAckDeadlineRequest.subscription)
    pub subscription: ::std::string::String,
    ///  The acknowledgment ID.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ModifyAckDeadlineRequest.ack_id)
    pub ack_id: ::std::string::String,
    ///  The new ack deadline with respect to the time this request was sent to the
    ///  Pub/Sub system. Must be >= 0. For example, if the value is 10, the new ack
    ///  deadline will expire 10 seconds after the ModifyAckDeadline call was made.
    ///  Specifying zero may immediately make the message available for another pull
    ///  request.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.ModifyAckDeadlineRequest.ack_deadline_seconds)
    pub ack_deadline_seconds: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.ModifyAckDeadlineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModifyAckDeadlineRequest {
    fn default() -> &'a ModifyAckDeadlineRequest {
        <ModifyAckDeadlineRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyAckDeadlineRequest {
    pub fn new() -> ModifyAckDeadlineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &ModifyAckDeadlineRequest| { &m.subscription },
            |m: &mut ModifyAckDeadlineRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_id",
            |m: &ModifyAckDeadlineRequest| { &m.ack_id },
            |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_deadline_seconds",
            |m: &ModifyAckDeadlineRequest| { &m.ack_deadline_seconds },
            |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_deadline_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModifyAckDeadlineRequest>(
            "ModifyAckDeadlineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModifyAckDeadlineRequest {
    const NAME: &'static str = "ModifyAckDeadlineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                18 => {
                    self.ack_id = is.read_string()?;
                },
                24 => {
                    self.ack_deadline_seconds = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ack_id);
        }
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.ack_deadline_seconds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if !self.ack_id.is_empty() {
            os.write_string(2, &self.ack_id)?;
        }
        if self.ack_deadline_seconds != 0 {
            os.write_int32(3, self.ack_deadline_seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModifyAckDeadlineRequest {
        ModifyAckDeadlineRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_id.clear();
        self.ack_deadline_seconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModifyAckDeadlineRequest {
        static instance: ModifyAckDeadlineRequest = ModifyAckDeadlineRequest {
            subscription: ::std::string::String::new(),
            ack_id: ::std::string::String::new(),
            ack_deadline_seconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModifyAckDeadlineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModifyAckDeadlineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModifyAckDeadlineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyAckDeadlineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the Acknowledge method.
// @@protoc_insertion_point(message:google.pubsub.v1beta2.AcknowledgeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AcknowledgeRequest {
    // message fields
    ///  The subscription whose message is being acknowledged.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.AcknowledgeRequest.subscription)
    pub subscription: ::std::string::String,
    ///  The acknowledgment ID for the messages being acknowledged that was returned
    ///  by the Pub/Sub system in the Pull response. Must not be empty.
    // @@protoc_insertion_point(field:google.pubsub.v1beta2.AcknowledgeRequest.ack_ids)
    pub ack_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1beta2.AcknowledgeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AcknowledgeRequest {
    fn default() -> &'a AcknowledgeRequest {
        <AcknowledgeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AcknowledgeRequest {
    pub fn new() -> AcknowledgeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &AcknowledgeRequest| { &m.subscription },
            |m: &mut AcknowledgeRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_ids",
            |m: &AcknowledgeRequest| { &m.ack_ids },
            |m: &mut AcknowledgeRequest| { &mut m.ack_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AcknowledgeRequest>(
            "AcknowledgeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AcknowledgeRequest {
    const NAME: &'static str = "AcknowledgeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                18 => {
                    self.ack_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AcknowledgeRequest {
        AcknowledgeRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AcknowledgeRequest {
        static instance: AcknowledgeRequest = AcknowledgeRequest {
            subscription: ::std::string::String::new(),
            ack_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AcknowledgeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AcknowledgeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AcknowledgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcknowledgeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"google/pubsub/v1beta2/pubsub.proto\x12\x15google.pubsub.v1beta2\x1a\
    \x1bgoogle/protobuf/empty.proto\"\x1b\n\x05Topic\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"\xd7\x01\n\rPubsubMessage\x12\x12\n\x04data\
    \x18\x01\x20\x01(\x0cR\x04data\x12T\n\nattributes\x18\x02\x20\x03(\x0b24\
    .google.pubsub.v1beta2.PubsubMessage.AttributesEntryR\nattributes\x12\
    \x1d\n\nmessage_id\x18\x03\x20\x01(\tR\tmessageId\x1a=\n\x0fAttributesEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"'\n\x0fGetTopicRequest\x12\x14\n\
    \x05topic\x18\x01\x20\x01(\tR\x05topic\"h\n\x0ePublishRequest\x12\x14\n\
    \x05topic\x18\x01\x20\x01(\tR\x05topic\x12@\n\x08messages\x18\x02\x20\
    \x03(\x0b2$.google.pubsub.v1beta2.PubsubMessageR\x08messages\"2\n\x0fPub\
    lishResponse\x12\x1f\n\x0bmessage_ids\x18\x01\x20\x03(\tR\nmessageIds\"i\
    \n\x11ListTopicsRequest\x12\x18\n\x07project\x18\x01\x20\x01(\tR\x07proj\
    ect\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\npa\
    ge_token\x18\x03\x20\x01(\tR\tpageToken\"r\n\x12ListTopicsResponse\x124\
    \n\x06topics\x18\x01\x20\x03(\x0b2\x1c.google.pubsub.v1beta2.TopicR\x06t\
    opics\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"q\n\
    \x1dListTopicSubscriptionsRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\
    \x05topic\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\
    \n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"n\n\x1eListTopicSubscript\
    ionsResponse\x12$\n\rsubscriptions\x18\x01\x20\x03(\tR\rsubscriptions\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"*\n\x12De\
    leteTopicRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\"\xae\
    \x01\n\x0cSubscription\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x14\n\x05topic\x18\x02\x20\x01(\tR\x05topic\x12B\n\x0bpush_config\x18\
    \x04\x20\x01(\x0b2!.google.pubsub.v1beta2.PushConfigR\npushConfig\x120\n\
    \x14ack_deadline_seconds\x18\x05\x20\x01(\x05R\x12ackDeadlineSeconds\"\
    \xc3\x01\n\nPushConfig\x12#\n\rpush_endpoint\x18\x01\x20\x01(\tR\x0cpush\
    Endpoint\x12Q\n\nattributes\x18\x02\x20\x03(\x0b21.google.pubsub.v1beta2\
    .PushConfig.AttributesEntryR\nattributes\x1a=\n\x0fAttributesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"h\n\x0fReceivedMessage\x12\x15\n\x06ack_id\
    \x18\x01\x20\x01(\tR\x05ackId\x12>\n\x07message\x18\x02\x20\x01(\x0b2$.g\
    oogle.pubsub.v1beta2.PubsubMessageR\x07message\"<\n\x16GetSubscriptionRe\
    quest\x12\"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\"p\n\
    \x18ListSubscriptionsRequest\x12\x18\n\x07project\x18\x01\x20\x01(\tR\
    \x07project\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"\x8e\x01\n\x19ListSub\
    scriptionsResponse\x12I\n\rsubscriptions\x18\x01\x20\x03(\x0b2#.google.p\
    ubsub.v1beta2.SubscriptionR\rsubscriptions\x12&\n\x0fnext_page_token\x18\
    \x02\x20\x01(\tR\rnextPageToken\"?\n\x19DeleteSubscriptionRequest\x12\"\
    \n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\"\x81\x01\n\x17Mo\
    difyPushConfigRequest\x12\"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csub\
    scription\x12B\n\x0bpush_config\x18\x02\x20\x01(\x0b2!.google.pubsub.v1b\
    eta2.PushConfigR\npushConfig\"\x83\x01\n\x0bPullRequest\x12\"\n\x0csubsc\
    ription\x18\x01\x20\x01(\tR\x0csubscription\x12-\n\x12return_immediately\
    \x18\x02\x20\x01(\x08R\x11returnImmediately\x12!\n\x0cmax_messages\x18\
    \x03\x20\x01(\x05R\x0bmaxMessages\"c\n\x0cPullResponse\x12S\n\x11receive\
    d_messages\x18\x01\x20\x03(\x0b2&.google.pubsub.v1beta2.ReceivedMessageR\
    \x10receivedMessages\"\x87\x01\n\x18ModifyAckDeadlineRequest\x12\"\n\x0c\
    subscription\x18\x01\x20\x01(\tR\x0csubscription\x12\x15\n\x06ack_id\x18\
    \x02\x20\x01(\tR\x05ackId\x120\n\x14ack_deadline_seconds\x18\x03\x20\x01\
    (\x05R\x12ackDeadlineSeconds\"Q\n\x12AcknowledgeRequest\x12\"\n\x0csubsc\
    ription\x18\x01\x20\x01(\tR\x0csubscription\x12\x17\n\x07ack_ids\x18\x02\
    \x20\x03(\tR\x06ackIds2\x88\x06\n\nSubscriber\x12^\n\x12CreateSubscripti\
    on\x12#.google.pubsub.v1beta2.Subscription\x1a#.google.pubsub.v1beta2.Su\
    bscription\x12e\n\x0fGetSubscription\x12-.google.pubsub.v1beta2.GetSubsc\
    riptionRequest\x1a#.google.pubsub.v1beta2.Subscription\x12v\n\x11ListSub\
    scriptions\x12/.google.pubsub.v1beta2.ListSubscriptionsRequest\x1a0.goog\
    le.pubsub.v1beta2.ListSubscriptionsResponse\x12^\n\x12DeleteSubscription\
    \x120.google.pubsub.v1beta2.DeleteSubscriptionRequest\x1a\x16.google.pro\
    tobuf.Empty\x12\\\n\x11ModifyAckDeadline\x12/.google.pubsub.v1beta2.Modi\
    fyAckDeadlineRequest\x1a\x16.google.protobuf.Empty\x12P\n\x0bAcknowledge\
    \x12).google.pubsub.v1beta2.AcknowledgeRequest\x1a\x16.google.protobuf.E\
    mpty\x12O\n\x04Pull\x12\".google.pubsub.v1beta2.PullRequest\x1a#.google.\
    pubsub.v1beta2.PullResponse\x12Z\n\x10ModifyPushConfig\x12..google.pubsu\
    b.v1beta2.ModifyPushConfigRequest\x1a\x16.google.protobuf.Empty2\xbf\x04\
    \n\tPublisher\x12I\n\x0bCreateTopic\x12\x1c.google.pubsub.v1beta2.Topic\
    \x1a\x1c.google.pubsub.v1beta2.Topic\x12X\n\x07Publish\x12%.google.pubsu\
    b.v1beta2.PublishRequest\x1a&.google.pubsub.v1beta2.PublishResponse\x12P\
    \n\x08GetTopic\x12&.google.pubsub.v1beta2.GetTopicRequest\x1a\x1c.google\
    .pubsub.v1beta2.Topic\x12a\n\nListTopics\x12(.google.pubsub.v1beta2.List\
    TopicsRequest\x1a).google.pubsub.v1beta2.ListTopicsResponse\x12\x85\x01\
    \n\x16ListTopicSubscriptions\x124.google.pubsub.v1beta2.ListTopicSubscri\
    ptionsRequest\x1a5.google.pubsub.v1beta2.ListTopicSubscriptionsResponse\
    \x12P\n\x0bDeleteTopic\x12).google.pubsub.v1beta2.DeleteTopicRequest\x1a\
    \x16.google.protobuf.EmptyBg\n\x19com.google.pubsub.v1beta2B\x0bPubsubPr\
    otoP\x01Z;google.golang.org/genproto/googleapis/pubsub/v1beta2;pubsubJ\
    \xeds\n\x07\x12\x05\x0e\0\x82\x03\x01\n\xc2\x04\n\x01\x0c\x12\x03\x0e\0\
    \x122\xb7\x04\x20Copyright\x20(c)\x202015,\x20Google\x20Inc.\n\n\x20Lice\
    nsed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\
    \"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\
    \x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtai\
    n\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http\
    ://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\
    \x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20softwar\
    e\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\x08\n\x01\x02\x12\x03\x10\0\x1e\n\t\n\x02\x03\0\x12\x03\x12\0%\n\
    \x08\n\x01\x08\x12\x03\x14\0R\n\t\n\x02\x08\x0b\x12\x03\x14\0R\n\x08\n\
    \x01\x08\x12\x03\x15\0\"\n\t\n\x02\x08\n\x12\x03\x15\0\"\n\x08\n\x01\x08\
    \x12\x03\x16\0,\n\t\n\x02\x08\x08\x12\x03\x16\0,\n\x08\n\x01\x08\x12\x03\
    \x17\02\n\t\n\x02\x08\x01\x12\x03\x17\02\n\x91\x01\n\x02\x06\0\x12\x04\
    \x1b\0Q\x01\x1a\x84\x01\x20The\x20service\x20that\x20an\x20application\
    \x20uses\x20to\x20manipulate\x20subscriptions\x20and\x20to\n\x20consume\
    \x20messages\x20from\x20a\x20subscription\x20via\x20the\x20Pull\x20metho\
    d.\n\n\n\n\x03\x06\0\x01\x12\x03\x1b\x08\x12\n\xd6\x02\n\x04\x06\0\x02\0\
    \x12\x03\"\x02>\x1a\xc8\x02\x20Creates\x20a\x20subscription\x20to\x20a\
    \x20given\x20topic\x20for\x20a\x20given\x20subscriber.\n\x20If\x20the\
    \x20subscription\x20already\x20exists,\x20returns\x20ALREADY_EXISTS.\n\
    \x20If\x20the\x20corresponding\x20topic\x20doesn't\x20exist,\x20returns\
    \x20NOT_FOUND.\n\n\x20If\x20the\x20name\x20is\x20not\x20provided\x20in\
    \x20the\x20request,\x20the\x20server\x20will\x20assign\x20a\x20random\n\
    \x20name\x20for\x20this\x20subscription\x20on\x20the\x20same\x20project\
    \x20as\x20the\x20topic.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\"\x06\x18\
    \n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\"\x19%\n\x0c\n\x05\x06\0\x02\0\x03\
    \x12\x03\"0<\n@\n\x04\x06\0\x02\x01\x12\x03%\x02E\x1a3\x20Gets\x20the\
    \x20configuration\x20details\x20of\x20a\x20subscription.\n\n\x0c\n\x05\
    \x06\0\x02\x01\x01\x12\x03%\x06\x15\n\x0c\n\x05\x06\0\x02\x01\x02\x12\
    \x03%\x16,\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03%7C\n-\n\x04\x06\0\x02\
    \x02\x12\x04(\x02)*\x1a\x1f\x20Lists\x20matching\x20subscriptions.\n\n\
    \x0c\n\x05\x06\0\x02\x02\x01\x12\x03(\x06\x17\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x03(\x180\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03)\x0f(\n\xe9\x02\
    \n\x04\x06\0\x02\x03\x12\x040\x021&\x1a\xda\x02\x20Deletes\x20an\x20exis\
    ting\x20subscription.\x20All\x20pending\x20messages\x20in\x20the\x20subs\
    cription\n\x20are\x20immediately\x20dropped.\x20Calls\x20to\x20Pull\x20a\
    fter\x20deletion\x20will\x20return\n\x20NOT_FOUND.\x20After\x20a\x20subs\
    cription\x20is\x20deleted,\x20a\x20new\x20one\x20may\x20be\x20created\
    \x20with\n\x20the\x20same\x20name,\x20but\x20the\x20new\x20one\x20has\
    \x20no\x20association\x20with\x20the\x20old\n\x20subscription,\x20or\x20\
    its\x20topic\x20unless\x20the\x20same\x20topic\x20is\x20specified.\n\n\
    \x0c\n\x05\x06\0\x02\x03\x01\x12\x030\x06\x18\n\x0c\n\x05\x06\0\x02\x03\
    \x02\x12\x030\x192\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x031\x0f$\n\xfb\x01\
    \n\x04\x06\0\x02\x04\x12\x047\x028&\x1a\xec\x01\x20Modifies\x20the\x20ac\
    k\x20deadline\x20for\x20a\x20specific\x20message.\x20This\x20method\x20i\
    s\x20useful\x20to\n\x20indicate\x20that\x20more\x20time\x20is\x20needed\
    \x20to\x20process\x20a\x20message\x20by\x20the\x20subscriber,\n\x20or\
    \x20to\x20make\x20the\x20message\x20available\x20for\x20redelivery\x20if\
    \x20the\x20processing\x20was\n\x20interrupted.\n\n\x0c\n\x05\x06\0\x02\
    \x04\x01\x12\x037\x06\x17\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x037\x180\n\
    \x0c\n\x05\x06\0\x02\x04\x03\x12\x038\x0f$\n\xe9\x02\n\x04\x06\0\x02\x05\
    \x12\x03A\x02F\x1a\xdb\x02\x20Acknowledges\x20the\x20messages\x20associa\
    ted\x20with\x20the\x20ack\x20tokens\x20in\x20the\n\x20AcknowledgeRequest\
    .\x20The\x20Pub/Sub\x20system\x20can\x20remove\x20the\x20relevant\x20mes\
    sages\n\x20from\x20the\x20subscription.\n\n\x20Acknowledging\x20a\x20mes\
    sage\x20whose\x20ack\x20deadline\x20has\x20expired\x20may\x20succeed,\n\
    \x20but\x20such\x20a\x20message\x20may\x20be\x20redelivered\x20later.\
    \x20Acknowledging\x20a\x20message\x20more\n\x20than\x20once\x20will\x20n\
    ot\x20result\x20in\x20an\x20error.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\
    \x03A\x06\x11\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03A\x12$\n\x0c\n\x05\
    \x06\0\x02\x05\x03\x12\x03A/D\n\xf0\x01\n\x04\x06\0\x02\x06\x12\x03G\x02\
    /\x1a\xe2\x01\x20Pulls\x20messages\x20from\x20the\x20server.\x20Returns\
    \x20an\x20empty\x20list\x20if\x20there\x20are\x20no\n\x20messages\x20ava\
    ilable\x20in\x20the\x20backlog.\x20The\x20server\x20may\x20return\x20UNA\
    VAILABLE\x20if\n\x20there\x20are\x20too\x20many\x20concurrent\x20pull\
    \x20requests\x20pending\x20for\x20the\x20given\n\x20subscription.\n\n\
    \x0c\n\x05\x06\0\x02\x06\x01\x12\x03G\x06\n\n\x0c\n\x05\x06\0\x02\x06\
    \x02\x12\x03G\x0b\x16\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03G!-\n\xef\x02\
    \n\x04\x06\0\x02\x07\x12\x03P\x02P\x1a\xe1\x02\x20Modifies\x20the\x20Pus\
    hConfig\x20for\x20a\x20specified\x20subscription.\n\n\x20This\x20may\x20\
    be\x20used\x20to\x20change\x20a\x20push\x20subscription\x20to\x20a\x20pu\
    ll\x20one\x20(signified\n\x20by\x20an\x20empty\x20PushConfig)\x20or\x20v\
    ice\x20versa,\x20or\x20change\x20the\x20endpoint\x20URL\x20and\x20other\
    \n\x20attributes\x20of\x20a\x20push\x20subscription.\x20Messages\x20will\
    \x20accumulate\x20for\n\x20delivery\x20continuously\x20through\x20the\
    \x20call\x20regardless\x20of\x20changes\x20to\x20the\n\x20PushConfig.\n\
    \n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03P\x06\x16\n\x0c\n\x05\x06\0\x02\
    \x07\x02\x12\x03P\x17.\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03P9N\nj\n\x02\
    \x06\x01\x12\x04U\0m\x01\x1a^\x20The\x20service\x20that\x20an\x20applica\
    tion\x20uses\x20to\x20manipulate\x20topics,\x20and\x20to\x20send\n\x20me\
    ssages\x20to\x20a\x20topic.\n\n\n\n\x03\x06\x01\x01\x12\x03U\x08\x11\n;\
    \n\x04\x06\x01\x02\0\x12\x03W\x02)\x1a.\x20Creates\x20the\x20given\x20to\
    pic\x20with\x20the\x20given\x20name.\n\n\x0c\n\x05\x06\x01\x02\0\x01\x12\
    \x03W\x06\x11\n\x0c\n\x05\x06\x01\x02\0\x02\x12\x03W\x12\x17\n\x0c\n\x05\
    \x06\x01\x02\0\x03\x12\x03W\"'\nf\n\x04\x06\x01\x02\x01\x12\x03[\x028\
    \x1aY\x20Adds\x20one\x20or\x20more\x20messages\x20to\x20the\x20topic.\
    \x20Returns\x20NOT_FOUND\x20if\x20the\x20topic\x20does\n\x20not\x20exist\
    .\n\n\x0c\n\x05\x06\x01\x02\x01\x01\x12\x03[\x06\r\n\x0c\n\x05\x06\x01\
    \x02\x01\x02\x12\x03[\x0e\x1c\n\x0c\n\x05\x06\x01\x02\x01\x03\x12\x03['6\
    \n1\n\x04\x06\x01\x02\x02\x12\x03^\x020\x1a$\x20Gets\x20the\x20configura\
    tion\x20of\x20a\x20topic.\n\n\x0c\n\x05\x06\x01\x02\x02\x01\x12\x03^\x06\
    \x0e\n\x0c\n\x05\x06\x01\x02\x02\x02\x12\x03^\x0f\x1e\n\x0c\n\x05\x06\
    \x01\x02\x02\x03\x12\x03^).\n%\n\x04\x06\x01\x02\x03\x12\x03a\x02A\x1a\
    \x18\x20Lists\x20matching\x20topics.\n\n\x0c\n\x05\x06\x01\x02\x03\x01\
    \x12\x03a\x06\x10\n\x0c\n\x05\x06\x01\x02\x03\x02\x12\x03a\x11\"\n\x0c\n\
    \x05\x06\x01\x02\x03\x03\x12\x03a-?\nC\n\x04\x06\x01\x02\x04\x12\x04d\
    \x02e/\x1a5\x20Lists\x20the\x20name\x20of\x20the\x20subscriptions\x20for\
    \x20this\x20topic.\n\n\x0c\n\x05\x06\x01\x02\x04\x01\x12\x03d\x06\x1c\n\
    \x0c\n\x05\x06\x01\x02\x04\x02\x12\x03d\x1d:\n\x0c\n\x05\x06\x01\x02\x04\
    \x03\x12\x03e\x0f-\n\xbb\x02\n\x04\x06\x01\x02\x05\x12\x03l\x02F\x1a\xad\
    \x02\x20Deletes\x20the\x20topic\x20with\x20the\x20given\x20name.\x20Retu\
    rns\x20NOT_FOUND\x20if\x20the\x20topic\x20does\n\x20not\x20exist.\x20Aft\
    er\x20a\x20topic\x20is\x20deleted,\x20a\x20new\x20topic\x20may\x20be\x20\
    created\x20with\x20the\n\x20same\x20name;\x20this\x20is\x20an\x20entirel\
    y\x20new\x20topic\x20with\x20none\x20of\x20the\x20old\n\x20configuration\
    \x20or\x20subscriptions.\x20Existing\x20subscriptions\x20to\x20this\x20t\
    opic\x20are\n\x20not\x20deleted.\n\n\x0c\n\x05\x06\x01\x02\x05\x01\x12\
    \x03l\x06\x11\n\x0c\n\x05\x06\x01\x02\x05\x02\x12\x03l\x12$\n\x0c\n\x05\
    \x06\x01\x02\x05\x03\x12\x03l/D\n\x1f\n\x02\x04\0\x12\x04p\0s\x01\x1a\
    \x13\x20A\x20topic\x20resource.\n\n\n\n\x03\x04\0\x01\x12\x03p\x08\r\n!\
    \n\x04\x04\0\x02\0\x12\x03r\x02\x12\x1a\x14\x20Name\x20of\x20the\x20topi\
    c.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03r\x02\x08\n\x0c\n\x05\x04\0\x02\
    \0\x01\x12\x03r\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03r\x10\x11\n1\n\
    \x02\x04\x01\x12\x05v\0\x83\x01\x01\x1a$\x20A\x20message\x20data\x20and\
    \x20its\x20attributes.\n\n\n\n\x03\x04\x01\x01\x12\x03v\x08\x15\ng\n\x04\
    \x04\x01\x02\0\x12\x03y\x02\x11\x1aZ\x20The\x20message\x20payload.\x20Fo\
    r\x20JSON\x20requests,\x20the\x20value\x20of\x20this\x20field\x20must\
    \x20be\n\x20base64-encoded.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03y\x02\
    \x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03y\x08\x0c\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x03y\x0f\x10\n4\n\x04\x04\x01\x02\x01\x12\x03|\x02%\x1a'\
    \x20Optional\x20attributes\x20for\x20this\x20message.\n\n\x0c\n\x05\x04\
    \x01\x02\x01\x06\x12\x03|\x02\x15\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03|\x16\x20\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03|#$\n\xa0\x02\n\x04\
    \x04\x01\x02\x02\x12\x04\x82\x01\x02\x18\x1a\x91\x02\x20ID\x20of\x20this\
    \x20message\x20assigned\x20by\x20the\x20server\x20at\x20publication\x20t\
    ime.\x20Guaranteed\n\x20to\x20be\x20unique\x20within\x20the\x20topic.\
    \x20This\x20value\x20may\x20be\x20read\x20by\x20a\x20subscriber\n\x20tha\
    t\x20receives\x20a\x20PubsubMessage\x20via\x20a\x20Pull\x20call\x20or\
    \x20a\x20push\x20delivery.\x20It\x20must\n\x20not\x20be\x20populated\x20\
    by\x20a\x20publisher\x20in\x20a\x20Publish\x20call.\n\n\r\n\x05\x04\x01\
    \x02\x02\x05\x12\x04\x82\x01\x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\
    \x04\x82\x01\t\x13\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\x82\x01\x16\x17\
    \n0\n\x02\x04\x02\x12\x06\x86\x01\0\x89\x01\x01\x1a\"\x20Request\x20for\
    \x20the\x20GetTopic\x20method.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\x86\x01\
    \x08\x17\n-\n\x04\x04\x02\x02\0\x12\x04\x88\x01\x02\x13\x1a\x1f\x20The\
    \x20name\x20of\x20the\x20topic\x20to\x20get.\n\n\r\n\x05\x04\x02\x02\0\
    \x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x88\x01\
    \t\x0e\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x88\x01\x11\x12\n/\n\x02\x04\
    \x03\x12\x06\x8c\x01\0\x92\x01\x01\x1a!\x20Request\x20for\x20the\x20Publ\
    ish\x20method.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x8c\x01\x08\x16\nL\n\
    \x04\x04\x03\x02\0\x12\x04\x8e\x01\x02\x13\x1a>\x20The\x20messages\x20in\
    \x20the\x20request\x20will\x20be\x20published\x20on\x20this\x20topic.\n\
    \n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x8e\x01\x02\x08\n\r\n\x05\x04\x03\
    \x02\0\x01\x12\x04\x8e\x01\t\x0e\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x8e\
    \x01\x11\x12\n(\n\x04\x04\x03\x02\x01\x12\x04\x91\x01\x02&\x1a\x1a\x20Th\
    e\x20messages\x20to\x20publish.\n\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\
    \x91\x01\x02\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x91\x01\x0b\x18\n\r\
    \n\x05\x04\x03\x02\x01\x01\x12\x04\x91\x01\x19!\n\r\n\x05\x04\x03\x02\
    \x01\x03\x12\x04\x91\x01$%\n0\n\x02\x04\x04\x12\x06\x95\x01\0\x9a\x01\
    \x01\x1a\"\x20Response\x20for\x20the\x20Publish\x20method.\n\n\x0b\n\x03\
    \x04\x04\x01\x12\x04\x95\x01\x08\x17\n\xa8\x01\n\x04\x04\x04\x02\0\x12\
    \x04\x99\x01\x02\"\x1a\x99\x01\x20The\x20server-assigned\x20ID\x20of\x20\
    each\x20published\x20message,\x20in\x20the\x20same\x20order\x20as\n\x20t\
    he\x20messages\x20in\x20the\x20request.\x20IDs\x20are\x20guaranteed\x20t\
    o\x20be\x20unique\x20within\n\x20the\x20topic.\n\n\r\n\x05\x04\x04\x02\0\
    \x04\x12\x04\x99\x01\x02\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x99\x01\
    \x0b\x11\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x99\x01\x12\x1d\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\x99\x01\x20!\n2\n\x02\x04\x05\x12\x06\x9d\x01\
    \0\xa8\x01\x01\x1a$\x20Request\x20for\x20the\x20ListTopics\x20method.\n\
    \n\x0b\n\x03\x04\x05\x01\x12\x04\x9d\x01\x08\x19\nD\n\x04\x04\x05\x02\0\
    \x12\x04\x9f\x01\x02\x15\x1a6\x20The\x20name\x20of\x20the\x20cloud\x20pr\
    oject\x20that\x20topics\x20belong\x20to.\n\n\r\n\x05\x04\x05\x02\0\x05\
    \x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x9f\x01\t\
    \x10\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x9f\x01\x13\x14\n3\n\x04\x04\
    \x05\x02\x01\x12\x04\xa2\x01\x02\x16\x1a%\x20Maximum\x20number\x20of\x20\
    topics\x20to\x20return.\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xa2\x01\
    \x02\x07\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xa2\x01\x08\x11\n\r\n\x05\
    \x04\x05\x02\x01\x03\x12\x04\xa2\x01\x14\x15\n\xc0\x01\n\x04\x04\x05\x02\
    \x02\x12\x04\xa7\x01\x02\x18\x1a\xb1\x01\x20The\x20value\x20returned\x20\
    by\x20the\x20last\x20ListTopicsResponse;\x20indicates\x20that\x20this\
    \x20is\n\x20a\x20continuation\x20of\x20a\x20prior\x20ListTopics\x20call,\
    \x20and\x20that\x20the\x20system\x20should\n\x20return\x20the\x20next\
    \x20page\x20of\x20data.\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xa7\x01\
    \x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xa7\x01\t\x13\n\r\n\x05\
    \x04\x05\x02\x02\x03\x12\x04\xa7\x01\x16\x17\n3\n\x02\x04\x06\x12\x06\
    \xab\x01\0\xb2\x01\x01\x1a%\x20Response\x20for\x20the\x20ListTopics\x20m\
    ethod.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xab\x01\x08\x1a\n%\n\x04\x04\
    \x06\x02\0\x12\x04\xad\x01\x02\x1c\x1a\x17\x20The\x20resulting\x20topics\
    .\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xad\x01\x02\n\n\r\n\x05\x04\x06\
    \x02\0\x06\x12\x04\xad\x01\x0b\x10\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\
    \xad\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xad\x01\x1a\x1b\n\
    \x97\x01\n\x04\x04\x06\x02\x01\x12\x04\xb1\x01\x02\x1d\x1a\x88\x01\x20If\
    \x20not\x20empty,\x20indicates\x20that\x20there\x20may\x20be\x20more\x20\
    topics\x20that\x20match\x20the\n\x20request;\x20this\x20value\x20should\
    \x20be\x20passed\x20in\x20a\x20new\x20ListTopicsRequest.\n\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xb1\x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xb1\x01\t\x18\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xb1\x01\x1b\
    \x1c\n>\n\x02\x04\x07\x12\x06\xb5\x01\0\xc0\x01\x01\x1a0\x20Request\x20f\
    or\x20the\x20ListTopicSubscriptions\x20method.\n\n\x0b\n\x03\x04\x07\x01\
    \x12\x04\xb5\x01\x08%\nI\n\x04\x04\x07\x02\0\x12\x04\xb7\x01\x02\x13\x1a\
    ;\x20The\x20name\x20of\x20the\x20topic\x20that\x20subscriptions\x20are\
    \x20attached\x20to.\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xb7\x01\x02\
    \x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb7\x01\t\x0e\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\xb7\x01\x11\x12\n?\n\x04\x04\x07\x02\x01\x12\x04\xba\
    \x01\x02\x16\x1a1\x20Maximum\x20number\x20of\x20subscription\x20names\
    \x20to\x20return.\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xba\x01\x02\
    \x07\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xba\x01\x08\x11\n\r\n\x05\x04\
    \x07\x02\x01\x03\x12\x04\xba\x01\x14\x15\n\xd8\x01\n\x04\x04\x07\x02\x02\
    \x12\x04\xbf\x01\x02\x18\x1a\xc9\x01\x20The\x20value\x20returned\x20by\
    \x20the\x20last\x20ListTopicSubscriptionsResponse;\x20indicates\n\x20tha\
    t\x20this\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20ListTopicSub\
    scriptions\x20call,\x20and\n\x20that\x20the\x20system\x20should\x20retur\
    n\x20the\x20next\x20page\x20of\x20data.\n\n\r\n\x05\x04\x07\x02\x02\x05\
    \x12\x04\xbf\x01\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xbf\x01\t\
    \x13\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xbf\x01\x16\x17\n?\n\x02\x04\
    \x08\x12\x06\xc3\x01\0\xcb\x01\x01\x1a1\x20Response\x20for\x20the\x20Lis\
    tTopicSubscriptions\x20method.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xc3\x01\
    \x08&\nF\n\x04\x04\x08\x02\0\x12\x04\xc5\x01\x02$\x1a8\x20The\x20names\
    \x20of\x20the\x20subscriptions\x20that\x20match\x20the\x20request.\n\n\r\
    \n\x05\x04\x08\x02\0\x04\x12\x04\xc5\x01\x02\n\n\r\n\x05\x04\x08\x02\0\
    \x05\x12\x04\xc5\x01\x0b\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xc5\x01\
    \x12\x1f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc5\x01\"#\n\xc5\x01\n\x04\
    \x04\x08\x02\x01\x12\x04\xca\x01\x02\x1d\x1a\xb6\x01\x20If\x20not\x20emp\
    ty,\x20indicates\x20that\x20there\x20may\x20be\x20more\x20subscriptions\
    \x20that\x20match\n\x20the\x20request;\x20this\x20value\x20should\x20be\
    \x20passed\x20in\x20a\x20new\n\x20ListTopicSubscriptionsRequest\x20to\
    \x20get\x20more\x20subscriptions.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\
    \x04\xca\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xca\x01\t\x18\
    \n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xca\x01\x1b\x1c\n3\n\x02\x04\t\
    \x12\x06\xce\x01\0\xd1\x01\x01\x1a%\x20Request\x20for\x20the\x20DeleteTo\
    pic\x20method.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xce\x01\x08\x1a\n,\n\x04\
    \x04\t\x02\0\x12\x04\xd0\x01\x02\x13\x1a\x1e\x20Name\x20of\x20the\x20top\
    ic\x20to\x20delete.\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xd0\x01\x02\x08\
    \n\r\n\x05\x04\t\x02\0\x01\x12\x04\xd0\x01\t\x0e\n\r\n\x05\x04\t\x02\0\
    \x03\x12\x04\xd0\x01\x11\x12\n(\n\x02\x04\n\x12\x06\xd4\x01\0\xf2\x01\
    \x01\x1a\x1a\x20A\x20subscription\x20resource.\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xd4\x01\x08\x14\n)\n\x04\x04\n\x02\0\x12\x04\xd6\x01\x02\x12\
    \x1a\x1b\x20Name\x20of\x20the\x20subscription.\n\n\r\n\x05\x04\n\x02\0\
    \x05\x12\x04\xd6\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xd6\x01\t\
    \r\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xd6\x01\x10\x11\n\xb7\x01\n\x04\x04\
    \n\x02\x01\x12\x04\xdb\x01\x02\x13\x1a\xa8\x01\x20The\x20name\x20of\x20t\
    he\x20topic\x20from\x20which\x20this\x20subscription\x20is\x20receiving\
    \x20messages.\n\x20This\x20will\x20be\x20present\x20if\x20and\x20only\
    \x20if\x20the\x20subscription\x20has\x20not\x20been\x20detached\n\x20fro\
    m\x20its\x20topic.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xdb\x01\x02\x08\
    \n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xdb\x01\t\x0e\n\r\n\x05\x04\n\x02\
    \x01\x03\x12\x04\xdb\x01\x11\x12\n\xc7\x01\n\x04\x04\n\x02\x02\x12\x04\
    \xe0\x01\x02\x1d\x1a\xb8\x01\x20If\x20push\x20delivery\x20is\x20used\x20\
    with\x20this\x20subscription,\x20this\x20field\x20is\n\x20used\x20to\x20\
    configure\x20it.\x20An\x20empty\x20pushConfig\x20signifies\x20that\x20th\
    e\x20subscriber\n\x20will\x20pull\x20and\x20ack\x20messages\x20using\x20\
    API\x20methods.\n\n\r\n\x05\x04\n\x02\x02\x06\x12\x04\xe0\x01\x02\x0c\n\
    \r\n\x05\x04\n\x02\x02\x01\x12\x04\xe0\x01\r\x18\n\r\n\x05\x04\n\x02\x02\
    \x03\x12\x04\xe0\x01\x1b\x1c\n\xd3\x05\n\x04\x04\n\x02\x03\x12\x04\xf1\
    \x01\x02!\x1a\xc4\x05\x20This\x20value\x20is\x20the\x20maximum\x20time\
    \x20after\x20a\x20subscriber\x20receives\x20a\x20message\n\x20before\x20\
    the\x20subscriber\x20should\x20acknowledge\x20the\x20message.\x20After\
    \x20message\n\x20delivery\x20but\x20before\x20the\x20ack\x20deadline\x20\
    expires\x20and\x20before\x20the\x20message\x20is\n\x20acknowledged,\x20i\
    t\x20is\x20an\x20outstanding\x20message\x20and\x20will\x20not\x20be\x20d\
    elivered\n\x20again\x20during\x20that\x20time\x20(on\x20a\x20best-effort\
    \x20basis).\n\n\x20For\x20pull\x20delivery\x20this\x20value\n\x20is\x20u\
    sed\x20as\x20the\x20initial\x20value\x20for\x20the\x20ack\x20deadline.\
    \x20It\x20may\x20be\x20overridden\n\x20for\x20a\x20specific\x20message\
    \x20by\x20calling\x20ModifyAckDeadline.\n\n\x20For\x20push\x20delivery,\
    \x20this\x20value\x20is\x20also\x20used\x20to\x20set\x20the\x20request\
    \x20timeout\x20for\n\x20the\x20call\x20to\x20the\x20push\x20endpoint.\n\
    \n\x20If\x20the\x20subscriber\x20never\x20acknowledges\x20the\x20message\
    ,\x20the\x20Pub/Sub\n\x20system\x20will\x20eventually\x20redeliver\x20th\
    e\x20message.\n\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xf1\x01\x02\x07\n\r\
    \n\x05\x04\n\x02\x03\x01\x12\x04\xf1\x01\x08\x1c\n\r\n\x05\x04\n\x02\x03\
    \x03\x12\x04\xf1\x01\x1f\x20\n;\n\x02\x04\x0b\x12\x06\xf5\x01\0\x92\x02\
    \x01\x1a-\x20Configuration\x20for\x20a\x20push\x20delivery\x20endpoint.\
    \n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xf5\x01\x08\x12\n\x97\x01\n\x04\x04\
    \x0b\x02\0\x12\x04\xf8\x01\x02\x1b\x1a\x88\x01\x20A\x20URL\x20locating\
    \x20the\x20endpoint\x20to\x20which\x20messages\x20should\x20be\x20pushed\
    .\n\x20For\x20example,\x20a\x20Webhook\x20endpoint\x20might\x20use\x20\"\
    https://example.com/push\".\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xf8\
    \x01\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xf8\x01\t\x16\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xf8\x01\x19\x1a\n\xfe\x07\n\x04\x04\x0b\x02\
    \x01\x12\x04\x91\x02\x02%\x1a\xef\x07\x20Endpoint\x20configuration\x20at\
    tributes.\n\n\x20Every\x20endpoint\x20has\x20a\x20set\x20of\x20API\x20su\
    pported\x20attributes\x20that\x20can\x20be\x20used\x20to\n\x20control\
    \x20different\x20aspects\x20of\x20the\x20message\x20delivery.\n\n\x20The\
    \x20currently\x20supported\x20attribute\x20is\x20`x-goog-version`,\x20wh\
    ich\x20you\x20can\n\x20use\x20to\x20change\x20the\x20format\x20of\x20the\
    \x20push\x20message.\x20This\x20attribute\n\x20indicates\x20the\x20versi\
    on\x20of\x20the\x20data\x20expected\x20by\x20the\x20endpoint.\x20This\n\
    \x20controls\x20the\x20shape\x20of\x20the\x20envelope\x20(i.e.\x20its\
    \x20fields\x20and\x20metadata).\n\x20The\x20endpoint\x20version\x20is\
    \x20based\x20on\x20the\x20version\x20of\x20the\x20Pub/Sub\n\x20API.\n\n\
    \x20If\x20not\x20present\x20during\x20the\x20CreateSubscription\x20call,\
    \x20it\x20will\x20default\x20to\n\x20the\x20version\x20of\x20the\x20API\
    \x20used\x20to\x20make\x20such\x20call.\x20If\x20not\x20present\x20durin\
    g\x20a\n\x20ModifyPushConfig\x20call,\x20its\x20value\x20will\x20not\x20\
    be\x20changed.\x20GetSubscription\n\x20calls\x20will\x20always\x20return\
    \x20a\x20valid\x20version,\x20even\x20if\x20the\x20subscription\x20was\n\
    \x20created\x20without\x20this\x20attribute.\n\n\x20The\x20possible\x20v\
    alues\x20for\x20this\x20attribute\x20are:\n\n\x20*\x20`v1beta1`:\x20uses\
    \x20the\x20push\x20format\x20defined\x20in\x20the\x20v1beta1\x20Pub/Sub\
    \x20API.\n\x20*\x20`v1beta2`:\x20uses\x20the\x20push\x20format\x20define\
    d\x20in\x20the\x20v1beta2\x20Pub/Sub\x20API.\n\n\n\r\n\x05\x04\x0b\x02\
    \x01\x06\x12\x04\x91\x02\x02\x15\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\
    \x91\x02\x16\x20\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x91\x02#$\nB\n\
    \x02\x04\x0c\x12\x06\x95\x02\0\x9b\x02\x01\x1a4\x20A\x20message\x20and\
    \x20its\x20corresponding\x20acknowledgment\x20ID.\n\n\x0b\n\x03\x04\x0c\
    \x01\x12\x04\x95\x02\x08\x17\nH\n\x04\x04\x0c\x02\0\x12\x04\x97\x02\x02\
    \x14\x1a:\x20This\x20ID\x20can\x20be\x20used\x20to\x20acknowledge\x20the\
    \x20received\x20message.\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x97\x02\
    \x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x97\x02\t\x0f\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\x97\x02\x12\x13\n\x1c\n\x04\x04\x0c\x02\x01\x12\
    \x04\x9a\x02\x02\x1c\x1a\x0e\x20The\x20message.\n\n\r\n\x05\x04\x0c\x02\
    \x01\x06\x12\x04\x9a\x02\x02\x0f\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\
    \x9a\x02\x10\x17\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x9a\x02\x1a\x1b\n\
    7\n\x02\x04\r\x12\x06\x9e\x02\0\xa1\x02\x01\x1a)\x20Request\x20for\x20th\
    e\x20GetSubscription\x20method.\n\n\x0b\n\x03\x04\r\x01\x12\x04\x9e\x02\
    \x08\x1e\n4\n\x04\x04\r\x02\0\x12\x04\xa0\x02\x02\x1a\x1a&\x20The\x20nam\
    e\x20of\x20the\x20subscription\x20to\x20get.\n\n\r\n\x05\x04\r\x02\0\x05\
    \x12\x04\xa0\x02\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa0\x02\t\x15\
    \n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa0\x02\x18\x19\n9\n\x02\x04\x0e\x12\
    \x06\xa4\x02\0\xaf\x02\x01\x1a+\x20Request\x20for\x20the\x20ListSubscrip\
    tions\x20method.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa4\x02\x08\x20\nK\n\
    \x04\x04\x0e\x02\0\x12\x04\xa6\x02\x02\x15\x1a=\x20The\x20name\x20of\x20\
    the\x20cloud\x20project\x20that\x20subscriptions\x20belong\x20to.\n\n\r\
    \n\x05\x04\x0e\x02\0\x05\x12\x04\xa6\x02\x02\x08\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\xa6\x02\t\x10\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xa6\x02\
    \x13\x14\n:\n\x04\x04\x0e\x02\x01\x12\x04\xa9\x02\x02\x16\x1a,\x20Maximu\
    m\x20number\x20of\x20subscriptions\x20to\x20return.\n\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\xa9\x02\x02\x07\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\xa9\x02\x08\x11\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa9\x02\x14\
    \x15\n\xce\x01\n\x04\x04\x0e\x02\x02\x12\x04\xae\x02\x02\x18\x1a\xbf\x01\
    \x20The\x20value\x20returned\x20by\x20the\x20last\x20ListSubscriptionsRe\
    sponse;\x20indicates\x20that\n\x20this\x20is\x20a\x20continuation\x20of\
    \x20a\x20prior\x20ListSubscriptions\x20call,\x20and\x20that\x20the\n\x20\
    system\x20should\x20return\x20the\x20next\x20page\x20of\x20data.\n\n\r\n\
    \x05\x04\x0e\x02\x02\x05\x12\x04\xae\x02\x02\x08\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\xae\x02\t\x13\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xae\
    \x02\x16\x17\n:\n\x02\x04\x0f\x12\x06\xb2\x02\0\xba\x02\x01\x1a,\x20Resp\
    onse\x20for\x20the\x20ListSubscriptions\x20method.\n\n\x0b\n\x03\x04\x0f\
    \x01\x12\x04\xb2\x02\x08!\n9\n\x04\x04\x0f\x02\0\x12\x04\xb4\x02\x02*\
    \x1a+\x20The\x20subscriptions\x20that\x20match\x20the\x20request.\n\n\r\
    \n\x05\x04\x0f\x02\0\x04\x12\x04\xb4\x02\x02\n\n\r\n\x05\x04\x0f\x02\0\
    \x06\x12\x04\xb4\x02\x0b\x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xb4\x02\
    \x18%\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xb4\x02()\n\xc0\x01\n\x04\x04\
    \x0f\x02\x01\x12\x04\xb9\x02\x02\x1d\x1a\xb1\x01\x20If\x20not\x20empty,\
    \x20indicates\x20that\x20there\x20may\x20be\x20more\x20subscriptions\x20\
    that\x20match\n\x20the\x20request;\x20this\x20value\x20should\x20be\x20p\
    assed\x20in\x20a\x20new\x20ListSubscriptionsRequest\n\x20to\x20get\x20mo\
    re\x20subscriptions.\n\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xb9\x02\x02\
    \x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xb9\x02\t\x18\n\r\n\x05\x04\
    \x0f\x02\x01\x03\x12\x04\xb9\x02\x1b\x1c\n:\n\x02\x04\x10\x12\x06\xbd\
    \x02\0\xc0\x02\x01\x1a,\x20Request\x20for\x20the\x20DeleteSubscription\
    \x20method.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xbd\x02\x08!\n+\n\x04\x04\
    \x10\x02\0\x12\x04\xbf\x02\x02\x1a\x1a\x1d\x20The\x20subscription\x20to\
    \x20delete.\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xbf\x02\x02\x08\n\r\n\
    \x05\x04\x10\x02\0\x01\x12\x04\xbf\x02\t\x15\n\r\n\x05\x04\x10\x02\0\x03\
    \x12\x04\xbf\x02\x18\x19\n8\n\x02\x04\x11\x12\x06\xc3\x02\0\xce\x02\x01\
    \x1a*\x20Request\x20for\x20the\x20ModifyPushConfig\x20method.\n\n\x0b\n\
    \x03\x04\x11\x01\x12\x04\xc3\x02\x08\x1f\n-\n\x04\x04\x11\x02\0\x12\x04\
    \xc5\x02\x02\x1a\x1a\x1f\x20The\x20name\x20of\x20the\x20subscription.\n\
    \n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xc5\x02\x02\x08\n\r\n\x05\x04\x11\
    \x02\0\x01\x12\x04\xc5\x02\t\x15\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xc5\
    \x02\x18\x19\n\xa1\x02\n\x04\x04\x11\x02\x01\x12\x04\xcd\x02\x02\x1d\x1a\
    \x92\x02\x20The\x20push\x20configuration\x20for\x20future\x20deliveries.\
    \n\n\x20An\x20empty\x20pushConfig\x20indicates\x20that\x20the\x20Pub/Sub\
    \x20system\x20should\n\x20stop\x20pushing\x20messages\x20from\x20the\x20\
    given\x20subscription\x20and\x20allow\n\x20messages\x20to\x20be\x20pulle\
    d\x20and\x20acknowledged\x20-\x20effectively\x20pausing\n\x20the\x20subs\
    cription\x20if\x20Pull\x20is\x20not\x20called.\n\n\r\n\x05\x04\x11\x02\
    \x01\x06\x12\x04\xcd\x02\x02\x0c\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \xcd\x02\r\x18\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xcd\x02\x1b\x1c\n,\
    \n\x02\x04\x12\x12\x06\xd1\x02\0\xdf\x02\x01\x1a\x1e\x20Request\x20for\
    \x20the\x20Pull\x20method.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xd1\x02\x08\
    \x13\nF\n\x04\x04\x12\x02\0\x12\x04\xd3\x02\x02\x1a\x1a8\x20The\x20subsc\
    ription\x20from\x20which\x20messages\x20should\x20be\x20pulled.\n\n\r\n\
    \x05\x04\x12\x02\0\x05\x12\x04\xd3\x02\x02\x08\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\xd3\x02\t\x15\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xd3\x02\
    \x18\x19\n\xe4\x02\n\x04\x04\x12\x02\x01\x12\x04\xda\x02\x02\x1e\x1a\xd5\
    \x02\x20If\x20this\x20is\x20specified\x20as\x20true\x20the\x20system\x20\
    will\x20respond\x20immediately\x20even\x20if\n\x20it\x20is\x20not\x20abl\
    e\x20to\x20return\x20a\x20message\x20in\x20the\x20Pull\x20response.\x20O\
    therwise\x20the\n\x20system\x20is\x20allowed\x20to\x20wait\x20until\x20a\
    t\x20least\x20one\x20message\x20is\x20available\x20rather\n\x20than\x20r\
    eturning\x20no\x20messages.\x20The\x20client\x20may\x20cancel\x20the\x20\
    request\x20if\x20it\x20does\n\x20not\x20wish\x20to\x20wait\x20any\x20lon\
    ger\x20for\x20the\x20response.\n\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xda\x02\x02\x06\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xda\x02\x07\x19\n\
    \r\n\x05\x04\x12\x02\x01\x03\x12\x04\xda\x02\x1c\x1d\n\x89\x01\n\x04\x04\
    \x12\x02\x02\x12\x04\xde\x02\x02\x19\x1a{\x20The\x20maximum\x20number\
    \x20of\x20messages\x20returned\x20for\x20this\x20request.\x20The\x20Pub/\
    Sub\n\x20system\x20may\x20return\x20fewer\x20than\x20the\x20number\x20sp\
    ecified.\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xde\x02\x02\x07\n\r\n\
    \x05\x04\x12\x02\x02\x01\x12\x04\xde\x02\x08\x14\n\r\n\x05\x04\x12\x02\
    \x02\x03\x12\x04\xde\x02\x17\x18\n-\n\x02\x04\x13\x12\x06\xe2\x02\0\xe8\
    \x02\x01\x1a\x1f\x20Response\x20for\x20the\x20Pull\x20method.\n\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xe2\x02\x08\x14\n\x87\x02\n\x04\x04\x13\x02\0\
    \x12\x04\xe7\x02\x021\x1a\xf8\x01\x20Received\x20Pub/Sub\x20messages.\
    \x20The\x20Pub/Sub\x20system\x20will\x20return\x20zero\x20messages\x20if\
    \n\x20there\x20are\x20no\x20more\x20available\x20in\x20the\x20backlog.\
    \x20The\x20Pub/Sub\x20system\x20may\x20return\n\x20fewer\x20than\x20the\
    \x20maxMessages\x20requested\x20even\x20if\x20there\x20are\x20more\x20me\
    ssages\n\x20available\x20in\x20the\x20backlog.\n\n\r\n\x05\x04\x13\x02\0\
    \x04\x12\x04\xe7\x02\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xe7\x02\
    \x0b\x1a\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xe7\x02\x1b,\n\r\n\x05\x04\
    \x13\x02\0\x03\x12\x04\xe7\x02/0\n9\n\x02\x04\x14\x12\x06\xeb\x02\0\xf8\
    \x02\x01\x1a+\x20Request\x20for\x20the\x20ModifyAckDeadline\x20method.\n\
    \n\x0b\n\x03\x04\x14\x01\x12\x04\xeb\x02\x08\x20\n-\n\x04\x04\x14\x02\0\
    \x12\x04\xed\x02\x02\x1a\x1a\x1f\x20The\x20name\x20of\x20the\x20subscrip\
    tion.\n\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xed\x02\x02\x08\n\r\n\x05\
    \x04\x14\x02\0\x01\x12\x04\xed\x02\t\x15\n\r\n\x05\x04\x14\x02\0\x03\x12\
    \x04\xed\x02\x18\x19\n&\n\x04\x04\x14\x02\x01\x12\x04\xf0\x02\x02\x14\
    \x1a\x18\x20The\x20acknowledgment\x20ID.\n\n\r\n\x05\x04\x14\x02\x01\x05\
    \x12\x04\xf0\x02\x02\x08\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xf0\x02\t\
    \x0f\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xf0\x02\x12\x13\n\xca\x02\n\
    \x04\x04\x14\x02\x02\x12\x04\xf7\x02\x02!\x1a\xbb\x02\x20The\x20new\x20a\
    ck\x20deadline\x20with\x20respect\x20to\x20the\x20time\x20this\x20reques\
    t\x20was\x20sent\x20to\x20the\n\x20Pub/Sub\x20system.\x20Must\x20be\x20>\
    =\x200.\x20For\x20example,\x20if\x20the\x20value\x20is\x2010,\x20the\x20\
    new\x20ack\n\x20deadline\x20will\x20expire\x2010\x20seconds\x20after\x20\
    the\x20ModifyAckDeadline\x20call\x20was\x20made.\n\x20Specifying\x20zero\
    \x20may\x20immediately\x20make\x20the\x20message\x20available\x20for\x20\
    another\x20pull\n\x20request.\n\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\
    \xf7\x02\x02\x07\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xf7\x02\x08\x1c\n\
    \r\n\x05\x04\x14\x02\x02\x03\x12\x04\xf7\x02\x1f\x20\n3\n\x02\x04\x15\
    \x12\x06\xfb\x02\0\x82\x03\x01\x1a%\x20Request\x20for\x20the\x20Acknowle\
    dge\x20method.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xfb\x02\x08\x1a\nE\n\
    \x04\x04\x15\x02\0\x12\x04\xfd\x02\x02\x1a\x1a7\x20The\x20subscription\
    \x20whose\x20message\x20is\x20being\x20acknowledged.\n\n\r\n\x05\x04\x15\
    \x02\0\x05\x12\x04\xfd\x02\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \xfd\x02\t\x15\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xfd\x02\x18\x19\n\x9c\
    \x01\n\x04\x04\x15\x02\x01\x12\x04\x81\x03\x02\x1e\x1a\x8d\x01\x20The\
    \x20acknowledgment\x20ID\x20for\x20the\x20messages\x20being\x20acknowled\
    ged\x20that\x20was\x20returned\n\x20by\x20the\x20Pub/Sub\x20system\x20in\
    \x20the\x20Pull\x20response.\x20Must\x20not\x20be\x20empty.\n\n\r\n\x05\
    \x04\x15\x02\x01\x04\x12\x04\x81\x03\x02\n\n\r\n\x05\x04\x15\x02\x01\x05\
    \x12\x04\x81\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x81\x03\
    \x12\x19\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x81\x03\x1c\x1db\x06proto\
    3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(22);
            messages.push(Topic::generated_message_descriptor_data());
            messages.push(PubsubMessage::generated_message_descriptor_data());
            messages.push(GetTopicRequest::generated_message_descriptor_data());
            messages.push(PublishRequest::generated_message_descriptor_data());
            messages.push(PublishResponse::generated_message_descriptor_data());
            messages.push(ListTopicsRequest::generated_message_descriptor_data());
            messages.push(ListTopicsResponse::generated_message_descriptor_data());
            messages.push(ListTopicSubscriptionsRequest::generated_message_descriptor_data());
            messages.push(ListTopicSubscriptionsResponse::generated_message_descriptor_data());
            messages.push(DeleteTopicRequest::generated_message_descriptor_data());
            messages.push(Subscription::generated_message_descriptor_data());
            messages.push(PushConfig::generated_message_descriptor_data());
            messages.push(ReceivedMessage::generated_message_descriptor_data());
            messages.push(GetSubscriptionRequest::generated_message_descriptor_data());
            messages.push(ListSubscriptionsRequest::generated_message_descriptor_data());
            messages.push(ListSubscriptionsResponse::generated_message_descriptor_data());
            messages.push(DeleteSubscriptionRequest::generated_message_descriptor_data());
            messages.push(ModifyPushConfigRequest::generated_message_descriptor_data());
            messages.push(PullRequest::generated_message_descriptor_data());
            messages.push(PullResponse::generated_message_descriptor_data());
            messages.push(ModifyAckDeadlineRequest::generated_message_descriptor_data());
            messages.push(AcknowledgeRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
