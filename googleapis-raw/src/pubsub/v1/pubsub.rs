// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/pubsub/v1/pubsub.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct MessageStoragePolicy {
    // message fields
    pub allowed_persistence_regions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageStoragePolicy {
    fn default() -> &'a MessageStoragePolicy {
        <MessageStoragePolicy as ::protobuf::Message>::default_instance()
    }
}

impl MessageStoragePolicy {
    pub fn new() -> MessageStoragePolicy {
        ::std::default::Default::default()
    }

    // repeated string allowed_persistence_regions = 1;


    pub fn get_allowed_persistence_regions(&self) -> &[::std::string::String] {
        &self.allowed_persistence_regions
    }
    pub fn clear_allowed_persistence_regions(&mut self) {
        self.allowed_persistence_regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_persistence_regions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_persistence_regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_persistence_regions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_persistence_regions
    }

    // Take field
    pub fn take_allowed_persistence_regions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_persistence_regions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MessageStoragePolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_persistence_regions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_persistence_regions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_persistence_regions {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageStoragePolicy {
        MessageStoragePolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allowed_persistence_regions",
                |m: &MessageStoragePolicy| { &m.allowed_persistence_regions },
                |m: &mut MessageStoragePolicy| { &mut m.allowed_persistence_regions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageStoragePolicy>(
                "MessageStoragePolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageStoragePolicy {
        static instance: ::protobuf::rt::LazyV2<MessageStoragePolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageStoragePolicy::new)
    }
}

impl ::protobuf::Clear for MessageStoragePolicy {
    fn clear(&mut self) {
        self.allowed_persistence_regions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageStoragePolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageStoragePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchemaSettings {
    // message fields
    pub schema: ::std::string::String,
    pub encoding: super::schema::Encoding,
    pub first_revision_id: ::std::string::String,
    pub last_revision_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SchemaSettings {
    fn default() -> &'a SchemaSettings {
        <SchemaSettings as ::protobuf::Message>::default_instance()
    }
}

impl SchemaSettings {
    pub fn new() -> SchemaSettings {
        ::std::default::Default::default()
    }

    // string schema = 1;


    pub fn get_schema(&self) -> &str {
        &self.schema
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::string::String) {
        self.schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ::std::string::String {
        &mut self.schema
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema, ::std::string::String::new())
    }

    // .google.pubsub.v1.Encoding encoding = 2;


    pub fn get_encoding(&self) -> super::schema::Encoding {
        self.encoding
    }
    pub fn clear_encoding(&mut self) {
        self.encoding = super::schema::Encoding::ENCODING_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: super::schema::Encoding) {
        self.encoding = v;
    }

    // string first_revision_id = 3;


    pub fn get_first_revision_id(&self) -> &str {
        &self.first_revision_id
    }
    pub fn clear_first_revision_id(&mut self) {
        self.first_revision_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_first_revision_id(&mut self, v: ::std::string::String) {
        self.first_revision_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_revision_id(&mut self) -> &mut ::std::string::String {
        &mut self.first_revision_id
    }

    // Take field
    pub fn take_first_revision_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.first_revision_id, ::std::string::String::new())
    }

    // string last_revision_id = 4;


    pub fn get_last_revision_id(&self) -> &str {
        &self.last_revision_id
    }
    pub fn clear_last_revision_id(&mut self) {
        self.last_revision_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_revision_id(&mut self, v: ::std::string::String) {
        self.last_revision_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_revision_id(&mut self) -> &mut ::std::string::String {
        &mut self.last_revision_id
    }

    // Take field
    pub fn take_last_revision_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_revision_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SchemaSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.first_revision_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_revision_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.schema.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.schema);
        }
        if self.encoding != super::schema::Encoding::ENCODING_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.encoding);
        }
        if !self.first_revision_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.first_revision_id);
        }
        if !self.last_revision_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.last_revision_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.schema.is_empty() {
            os.write_string(1, &self.schema)?;
        }
        if self.encoding != super::schema::Encoding::ENCODING_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.encoding))?;
        }
        if !self.first_revision_id.is_empty() {
            os.write_string(3, &self.first_revision_id)?;
        }
        if !self.last_revision_id.is_empty() {
            os.write_string(4, &self.last_revision_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchemaSettings {
        SchemaSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "schema",
                |m: &SchemaSettings| { &m.schema },
                |m: &mut SchemaSettings| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::schema::Encoding>>(
                "encoding",
                |m: &SchemaSettings| { &m.encoding },
                |m: &mut SchemaSettings| { &mut m.encoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "first_revision_id",
                |m: &SchemaSettings| { &m.first_revision_id },
                |m: &mut SchemaSettings| { &mut m.first_revision_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_revision_id",
                |m: &SchemaSettings| { &m.last_revision_id },
                |m: &mut SchemaSettings| { &mut m.last_revision_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SchemaSettings>(
                "SchemaSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SchemaSettings {
        static instance: ::protobuf::rt::LazyV2<SchemaSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SchemaSettings::new)
    }
}

impl ::protobuf::Clear for SchemaSettings {
    fn clear(&mut self) {
        self.schema.clear();
        self.encoding = super::schema::Encoding::ENCODING_UNSPECIFIED;
        self.first_revision_id.clear();
        self.last_revision_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchemaSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchemaSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Topic {
    // message fields
    pub name: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub message_storage_policy: ::protobuf::SingularPtrField<MessageStoragePolicy>,
    pub kms_key_name: ::std::string::String,
    pub schema_settings: ::protobuf::SingularPtrField<SchemaSettings>,
    pub satisfies_pzs: bool,
    pub message_retention_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Topic {
    fn default() -> &'a Topic {
        <Topic as ::protobuf::Message>::default_instance()
    }
}

impl Topic {
    pub fn new() -> Topic {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.Topic.LabelsEntry labels = 2;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // .google.pubsub.v1.MessageStoragePolicy message_storage_policy = 3;


    pub fn get_message_storage_policy(&self) -> &MessageStoragePolicy {
        self.message_storage_policy.as_ref().unwrap_or_else(|| <MessageStoragePolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_storage_policy(&mut self) {
        self.message_storage_policy.clear();
    }

    pub fn has_message_storage_policy(&self) -> bool {
        self.message_storage_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_storage_policy(&mut self, v: MessageStoragePolicy) {
        self.message_storage_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_storage_policy(&mut self) -> &mut MessageStoragePolicy {
        if self.message_storage_policy.is_none() {
            self.message_storage_policy.set_default();
        }
        self.message_storage_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_storage_policy(&mut self) -> MessageStoragePolicy {
        self.message_storage_policy.take().unwrap_or_else(|| MessageStoragePolicy::new())
    }

    // string kms_key_name = 5;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }

    // .google.pubsub.v1.SchemaSettings schema_settings = 6;


    pub fn get_schema_settings(&self) -> &SchemaSettings {
        self.schema_settings.as_ref().unwrap_or_else(|| <SchemaSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema_settings(&mut self) {
        self.schema_settings.clear();
    }

    pub fn has_schema_settings(&self) -> bool {
        self.schema_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_settings(&mut self, v: SchemaSettings) {
        self.schema_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_settings(&mut self) -> &mut SchemaSettings {
        if self.schema_settings.is_none() {
            self.schema_settings.set_default();
        }
        self.schema_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_settings(&mut self) -> SchemaSettings {
        self.schema_settings.take().unwrap_or_else(|| SchemaSettings::new())
    }

    // bool satisfies_pzs = 7;


    pub fn get_satisfies_pzs(&self) -> bool {
        self.satisfies_pzs
    }
    pub fn clear_satisfies_pzs(&mut self) {
        self.satisfies_pzs = false;
    }

    // Param is passed by value, moved
    pub fn set_satisfies_pzs(&mut self, v: bool) {
        self.satisfies_pzs = v;
    }

    // .google.protobuf.Duration message_retention_duration = 8;


    pub fn get_message_retention_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.message_retention_duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_retention_duration(&mut self) {
        self.message_retention_duration.clear();
    }

    pub fn has_message_retention_duration(&self) -> bool {
        self.message_retention_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_retention_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.message_retention_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_retention_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.message_retention_duration.is_none() {
            self.message_retention_duration.set_default();
        }
        self.message_retention_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_retention_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.message_retention_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for Topic {
    fn is_initialized(&self) -> bool {
        for v in &self.message_storage_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schema_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message_retention_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_storage_policy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema_settings)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.satisfies_pzs = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_retention_duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels);
        if let Some(ref v) = self.message_storage_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.kms_key_name);
        }
        if let Some(ref v) = self.schema_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.satisfies_pzs != false {
            my_size += 2;
        }
        if let Some(ref v) = self.message_retention_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels, os)?;
        if let Some(ref v) = self.message_storage_policy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(5, &self.kms_key_name)?;
        }
        if let Some(ref v) = self.schema_settings.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.satisfies_pzs != false {
            os.write_bool(7, self.satisfies_pzs)?;
        }
        if let Some(ref v) = self.message_retention_duration.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Topic {
        Topic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Topic| { &m.name },
                |m: &mut Topic| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Topic| { &m.labels },
                |m: &mut Topic| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageStoragePolicy>>(
                "message_storage_policy",
                |m: &Topic| { &m.message_storage_policy },
                |m: &mut Topic| { &mut m.message_storage_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &Topic| { &m.kms_key_name },
                |m: &mut Topic| { &mut m.kms_key_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchemaSettings>>(
                "schema_settings",
                |m: &Topic| { &m.schema_settings },
                |m: &mut Topic| { &mut m.schema_settings },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "satisfies_pzs",
                |m: &Topic| { &m.satisfies_pzs },
                |m: &mut Topic| { &mut m.satisfies_pzs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "message_retention_duration",
                |m: &Topic| { &m.message_retention_duration },
                |m: &mut Topic| { &mut m.message_retention_duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Topic>(
                "Topic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Topic {
        static instance: ::protobuf::rt::LazyV2<Topic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Topic::new)
    }
}

impl ::protobuf::Clear for Topic {
    fn clear(&mut self) {
        self.name.clear();
        self.labels.clear();
        self.message_storage_policy.clear();
        self.kms_key_name.clear();
        self.schema_settings.clear();
        self.satisfies_pzs = false;
        self.message_retention_duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Topic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Topic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PubsubMessage {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub message_id: ::std::string::String,
    pub publish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub ordering_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubsubMessage {
    fn default() -> &'a PubsubMessage {
        <PubsubMessage as ::protobuf::Message>::default_instance()
    }
}

impl PubsubMessage {
    pub fn new() -> PubsubMessage {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // repeated .google.pubsub.v1.PubsubMessage.AttributesEntry attributes = 2;


    pub fn get_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }

    // string message_id = 3;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp publish_time = 4;


    pub fn get_publish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.publish_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_publish_time(&mut self) {
        self.publish_time.clear();
    }

    pub fn has_publish_time(&self) -> bool {
        self.publish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.publish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.publish_time.is_none() {
            self.publish_time.set_default();
        }
        self.publish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_publish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.publish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string ordering_key = 5;


    pub fn get_ordering_key(&self) -> &str {
        &self.ordering_key
    }
    pub fn clear_ordering_key(&mut self) {
        self.ordering_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_ordering_key(&mut self, v: ::std::string::String) {
        self.ordering_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ordering_key(&mut self) -> &mut ::std::string::String {
        &mut self.ordering_key
    }

    // Take field
    pub fn take_ordering_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ordering_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PubsubMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.publish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.attributes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.publish_time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ordering_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes);
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message_id);
        }
        if let Some(ref v) = self.publish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.ordering_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.ordering_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes, os)?;
        if !self.message_id.is_empty() {
            os.write_string(3, &self.message_id)?;
        }
        if let Some(ref v) = self.publish_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.ordering_key.is_empty() {
            os.write_string(5, &self.ordering_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubsubMessage {
        PubsubMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &PubsubMessage| { &m.data },
                |m: &mut PubsubMessage| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "attributes",
                |m: &PubsubMessage| { &m.attributes },
                |m: &mut PubsubMessage| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &PubsubMessage| { &m.message_id },
                |m: &mut PubsubMessage| { &mut m.message_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "publish_time",
                |m: &PubsubMessage| { &m.publish_time },
                |m: &mut PubsubMessage| { &mut m.publish_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ordering_key",
                |m: &PubsubMessage| { &m.ordering_key },
                |m: &mut PubsubMessage| { &mut m.ordering_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PubsubMessage>(
                "PubsubMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PubsubMessage {
        static instance: ::protobuf::rt::LazyV2<PubsubMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PubsubMessage::new)
    }
}

impl ::protobuf::Clear for PubsubMessage {
    fn clear(&mut self) {
        self.data.clear();
        self.attributes.clear();
        self.message_id.clear();
        self.publish_time.clear();
        self.ordering_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubsubMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubsubMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTopicRequest {
    // message fields
    pub topic: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTopicRequest {
    fn default() -> &'a GetTopicRequest {
        <GetTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTopicRequest {
    pub fn new() -> GetTopicRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTopicRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTopicRequest {
        GetTopicRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &GetTopicRequest| { &m.topic },
                |m: &mut GetTopicRequest| { &mut m.topic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTopicRequest>(
                "GetTopicRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTopicRequest {
        static instance: ::protobuf::rt::LazyV2<GetTopicRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTopicRequest::new)
    }
}

impl ::protobuf::Clear for GetTopicRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTopicRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTopicRequest {
    // message fields
    pub topic: ::protobuf::SingularPtrField<Topic>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTopicRequest {
    fn default() -> &'a UpdateTopicRequest {
        <UpdateTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTopicRequest {
    pub fn new() -> UpdateTopicRequest {
        ::std::default::Default::default()
    }

    // .google.pubsub.v1.Topic topic = 1;


    pub fn get_topic(&self) -> &Topic {
        self.topic.as_ref().unwrap_or_else(|| <Topic as ::protobuf::Message>::default_instance())
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: Topic) {
        self.topic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut Topic {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> Topic {
        self.topic.take().unwrap_or_else(|| Topic::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateTopicRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.topic {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTopicRequest {
        UpdateTopicRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Topic>>(
                "topic",
                |m: &UpdateTopicRequest| { &m.topic },
                |m: &mut UpdateTopicRequest| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateTopicRequest| { &m.update_mask },
                |m: &mut UpdateTopicRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTopicRequest>(
                "UpdateTopicRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateTopicRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateTopicRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTopicRequest::new)
    }
}

impl ::protobuf::Clear for UpdateTopicRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTopicRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublishRequest {
    // message fields
    pub topic: ::std::string::String,
    pub messages: ::protobuf::RepeatedField<PubsubMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishRequest {
    fn default() -> &'a PublishRequest {
        <PublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PublishRequest {
    pub fn new() -> PublishRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.PubsubMessage messages = 2;


    pub fn get_messages(&self) -> &[PubsubMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<PubsubMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<PubsubMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<PubsubMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PublishRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        for v in &self.messages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishRequest {
        PublishRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &PublishRequest| { &m.topic },
                |m: &mut PublishRequest| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubsubMessage>>(
                "messages",
                |m: &PublishRequest| { &m.messages },
                |m: &mut PublishRequest| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PublishRequest>(
                "PublishRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PublishRequest {
        static instance: ::protobuf::rt::LazyV2<PublishRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublishRequest::new)
    }
}

impl ::protobuf::Clear for PublishRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublishResponse {
    // message fields
    pub message_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishResponse {
    fn default() -> &'a PublishResponse {
        <PublishResponse as ::protobuf::Message>::default_instance()
    }
}

impl PublishResponse {
    pub fn new() -> PublishResponse {
        ::std::default::Default::default()
    }

    // repeated string message_ids = 1;


    pub fn get_message_ids(&self) -> &[::std::string::String] {
        &self.message_ids
    }
    pub fn clear_message_ids(&mut self) {
        self.message_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.message_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.message_ids
    }

    // Take field
    pub fn take_message_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.message_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PublishResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.message_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.message_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishResponse {
        PublishResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_ids",
                |m: &PublishResponse| { &m.message_ids },
                |m: &mut PublishResponse| { &mut m.message_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PublishResponse>(
                "PublishResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PublishResponse {
        static instance: ::protobuf::rt::LazyV2<PublishResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublishResponse::new)
    }
}

impl ::protobuf::Clear for PublishResponse {
    fn clear(&mut self) {
        self.message_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicsRequest {
    // message fields
    pub project: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicsRequest {
    fn default() -> &'a ListTopicsRequest {
        <ListTopicsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsRequest {
    pub fn new() -> ListTopicsRequest {
        ::std::default::Default::default()
    }

    // string project = 1;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicsRequest {
        ListTopicsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project",
                |m: &ListTopicsRequest| { &m.project },
                |m: &mut ListTopicsRequest| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListTopicsRequest| { &m.page_size },
                |m: &mut ListTopicsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListTopicsRequest| { &m.page_token },
                |m: &mut ListTopicsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTopicsRequest>(
                "ListTopicsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTopicsRequest {
        static instance: ::protobuf::rt::LazyV2<ListTopicsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTopicsRequest::new)
    }
}

impl ::protobuf::Clear for ListTopicsRequest {
    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicsResponse {
    // message fields
    pub topics: ::protobuf::RepeatedField<Topic>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicsResponse {
    fn default() -> &'a ListTopicsResponse {
        <ListTopicsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsResponse {
    pub fn new() -> ListTopicsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.Topic topics = 1;


    pub fn get_topics(&self) -> &[Topic] {
        &self.topics
    }
    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<Topic>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<Topic> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<Topic> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.topics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.topics)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.topics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.topics {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicsResponse {
        ListTopicsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Topic>>(
                "topics",
                |m: &ListTopicsResponse| { &m.topics },
                |m: &mut ListTopicsResponse| { &mut m.topics },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListTopicsResponse| { &m.next_page_token },
                |m: &mut ListTopicsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTopicsResponse>(
                "ListTopicsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTopicsResponse {
        static instance: ::protobuf::rt::LazyV2<ListTopicsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTopicsResponse::new)
    }
}

impl ::protobuf::Clear for ListTopicsResponse {
    fn clear(&mut self) {
        self.topics.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSubscriptionsRequest {
    // message fields
    pub topic: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsRequest {
    fn default() -> &'a ListTopicSubscriptionsRequest {
        <ListTopicSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsRequest {
    pub fn new() -> ListTopicSubscriptionsRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSubscriptionsRequest {
        ListTopicSubscriptionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &ListTopicSubscriptionsRequest| { &m.topic },
                |m: &mut ListTopicSubscriptionsRequest| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListTopicSubscriptionsRequest| { &m.page_size },
                |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListTopicSubscriptionsRequest| { &m.page_token },
                |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTopicSubscriptionsRequest>(
                "ListTopicSubscriptionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTopicSubscriptionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListTopicSubscriptionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTopicSubscriptionsRequest::new)
    }
}

impl ::protobuf::Clear for ListTopicSubscriptionsRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSubscriptionsResponse {
    // message fields
    pub subscriptions: ::protobuf::RepeatedField<::std::string::String>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsResponse {
    fn default() -> &'a ListTopicSubscriptionsResponse {
        <ListTopicSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsResponse {
    pub fn new() -> ListTopicSubscriptionsResponse {
        ::std::default::Default::default()
    }

    // repeated string subscriptions = 1;


    pub fn get_subscriptions(&self) -> &[::std::string::String] {
        &self.subscriptions
    }
    pub fn clear_subscriptions(&mut self) {
        self.subscriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscriptions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subscriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscriptions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subscriptions
    }

    // Take field
    pub fn take_subscriptions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subscriptions, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subscriptions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subscriptions {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSubscriptionsResponse {
        ListTopicSubscriptionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscriptions",
                |m: &ListTopicSubscriptionsResponse| { &m.subscriptions },
                |m: &mut ListTopicSubscriptionsResponse| { &mut m.subscriptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListTopicSubscriptionsResponse| { &m.next_page_token },
                |m: &mut ListTopicSubscriptionsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTopicSubscriptionsResponse>(
                "ListTopicSubscriptionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTopicSubscriptionsResponse {
        static instance: ::protobuf::rt::LazyV2<ListTopicSubscriptionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTopicSubscriptionsResponse::new)
    }
}

impl ::protobuf::Clear for ListTopicSubscriptionsResponse {
    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSnapshotsRequest {
    // message fields
    pub topic: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSnapshotsRequest {
    fn default() -> &'a ListTopicSnapshotsRequest {
        <ListTopicSnapshotsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSnapshotsRequest {
    pub fn new() -> ListTopicSnapshotsRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSnapshotsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSnapshotsRequest {
        ListTopicSnapshotsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &ListTopicSnapshotsRequest| { &m.topic },
                |m: &mut ListTopicSnapshotsRequest| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListTopicSnapshotsRequest| { &m.page_size },
                |m: &mut ListTopicSnapshotsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListTopicSnapshotsRequest| { &m.page_token },
                |m: &mut ListTopicSnapshotsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTopicSnapshotsRequest>(
                "ListTopicSnapshotsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTopicSnapshotsRequest {
        static instance: ::protobuf::rt::LazyV2<ListTopicSnapshotsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTopicSnapshotsRequest::new)
    }
}

impl ::protobuf::Clear for ListTopicSnapshotsRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSnapshotsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSnapshotsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSnapshotsResponse {
    // message fields
    pub snapshots: ::protobuf::RepeatedField<::std::string::String>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSnapshotsResponse {
    fn default() -> &'a ListTopicSnapshotsResponse {
        <ListTopicSnapshotsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSnapshotsResponse {
    pub fn new() -> ListTopicSnapshotsResponse {
        ::std::default::Default::default()
    }

    // repeated string snapshots = 1;


    pub fn get_snapshots(&self) -> &[::std::string::String] {
        &self.snapshots
    }
    pub fn clear_snapshots(&mut self) {
        self.snapshots.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshots(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.snapshots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshots(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.snapshots
    }

    // Take field
    pub fn take_snapshots(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.snapshots, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSnapshotsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snapshots)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.snapshots {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.snapshots {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSnapshotsResponse {
        ListTopicSnapshotsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshots",
                |m: &ListTopicSnapshotsResponse| { &m.snapshots },
                |m: &mut ListTopicSnapshotsResponse| { &mut m.snapshots },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListTopicSnapshotsResponse| { &m.next_page_token },
                |m: &mut ListTopicSnapshotsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTopicSnapshotsResponse>(
                "ListTopicSnapshotsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTopicSnapshotsResponse {
        static instance: ::protobuf::rt::LazyV2<ListTopicSnapshotsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTopicSnapshotsResponse::new)
    }
}

impl ::protobuf::Clear for ListTopicSnapshotsResponse {
    fn clear(&mut self) {
        self.snapshots.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSnapshotsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSnapshotsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTopicRequest {
    // message fields
    pub topic: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTopicRequest {
    fn default() -> &'a DeleteTopicRequest {
        <DeleteTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTopicRequest {
    pub fn new() -> DeleteTopicRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteTopicRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTopicRequest {
        DeleteTopicRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &DeleteTopicRequest| { &m.topic },
                |m: &mut DeleteTopicRequest| { &mut m.topic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteTopicRequest>(
                "DeleteTopicRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteTopicRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteTopicRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteTopicRequest::new)
    }
}

impl ::protobuf::Clear for DeleteTopicRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTopicRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DetachSubscriptionRequest {
    // message fields
    pub subscription: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DetachSubscriptionRequest {
    fn default() -> &'a DetachSubscriptionRequest {
        <DetachSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DetachSubscriptionRequest {
    pub fn new() -> DetachSubscriptionRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DetachSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetachSubscriptionRequest {
        DetachSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &DetachSubscriptionRequest| { &m.subscription },
                |m: &mut DetachSubscriptionRequest| { &mut m.subscription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DetachSubscriptionRequest>(
                "DetachSubscriptionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DetachSubscriptionRequest {
        static instance: ::protobuf::rt::LazyV2<DetachSubscriptionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DetachSubscriptionRequest::new)
    }
}

impl ::protobuf::Clear for DetachSubscriptionRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetachSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetachSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DetachSubscriptionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DetachSubscriptionResponse {
    fn default() -> &'a DetachSubscriptionResponse {
        <DetachSubscriptionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DetachSubscriptionResponse {
    pub fn new() -> DetachSubscriptionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DetachSubscriptionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetachSubscriptionResponse {
        DetachSubscriptionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DetachSubscriptionResponse>(
                "DetachSubscriptionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DetachSubscriptionResponse {
        static instance: ::protobuf::rt::LazyV2<DetachSubscriptionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DetachSubscriptionResponse::new)
    }
}

impl ::protobuf::Clear for DetachSubscriptionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetachSubscriptionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetachSubscriptionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Subscription {
    // message fields
    pub name: ::std::string::String,
    pub topic: ::std::string::String,
    pub push_config: ::protobuf::SingularPtrField<PushConfig>,
    pub bigquery_config: ::protobuf::SingularPtrField<BigQueryConfig>,
    pub cloud_storage_config: ::protobuf::SingularPtrField<CloudStorageConfig>,
    pub ack_deadline_seconds: i32,
    pub retain_acked_messages: bool,
    pub message_retention_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub enable_message_ordering: bool,
    pub expiration_policy: ::protobuf::SingularPtrField<ExpirationPolicy>,
    pub filter: ::std::string::String,
    pub dead_letter_policy: ::protobuf::SingularPtrField<DeadLetterPolicy>,
    pub retry_policy: ::protobuf::SingularPtrField<RetryPolicy>,
    pub detached: bool,
    pub enable_exactly_once_delivery: bool,
    pub topic_message_retention_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub state: Subscription_State,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Subscription {
    fn default() -> &'a Subscription {
        <Subscription as ::protobuf::Message>::default_instance()
    }
}

impl Subscription {
    pub fn new() -> Subscription {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string topic = 2;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // .google.pubsub.v1.PushConfig push_config = 4;


    pub fn get_push_config(&self) -> &PushConfig {
        self.push_config.as_ref().unwrap_or_else(|| <PushConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_push_config(&mut self) {
        self.push_config.clear();
    }

    pub fn has_push_config(&self) -> bool {
        self.push_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_config(&mut self, v: PushConfig) {
        self.push_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_config(&mut self) -> &mut PushConfig {
        if self.push_config.is_none() {
            self.push_config.set_default();
        }
        self.push_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_push_config(&mut self) -> PushConfig {
        self.push_config.take().unwrap_or_else(|| PushConfig::new())
    }

    // .google.pubsub.v1.BigQueryConfig bigquery_config = 18;


    pub fn get_bigquery_config(&self) -> &BigQueryConfig {
        self.bigquery_config.as_ref().unwrap_or_else(|| <BigQueryConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bigquery_config(&mut self) {
        self.bigquery_config.clear();
    }

    pub fn has_bigquery_config(&self) -> bool {
        self.bigquery_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bigquery_config(&mut self, v: BigQueryConfig) {
        self.bigquery_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bigquery_config(&mut self) -> &mut BigQueryConfig {
        if self.bigquery_config.is_none() {
            self.bigquery_config.set_default();
        }
        self.bigquery_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_bigquery_config(&mut self) -> BigQueryConfig {
        self.bigquery_config.take().unwrap_or_else(|| BigQueryConfig::new())
    }

    // .google.pubsub.v1.CloudStorageConfig cloud_storage_config = 22;


    pub fn get_cloud_storage_config(&self) -> &CloudStorageConfig {
        self.cloud_storage_config.as_ref().unwrap_or_else(|| <CloudStorageConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cloud_storage_config(&mut self) {
        self.cloud_storage_config.clear();
    }

    pub fn has_cloud_storage_config(&self) -> bool {
        self.cloud_storage_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_storage_config(&mut self, v: CloudStorageConfig) {
        self.cloud_storage_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloud_storage_config(&mut self) -> &mut CloudStorageConfig {
        if self.cloud_storage_config.is_none() {
            self.cloud_storage_config.set_default();
        }
        self.cloud_storage_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloud_storage_config(&mut self) -> CloudStorageConfig {
        self.cloud_storage_config.take().unwrap_or_else(|| CloudStorageConfig::new())
    }

    // int32 ack_deadline_seconds = 5;


    pub fn get_ack_deadline_seconds(&self) -> i32 {
        self.ack_deadline_seconds
    }
    pub fn clear_ack_deadline_seconds(&mut self) {
        self.ack_deadline_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_ack_deadline_seconds(&mut self, v: i32) {
        self.ack_deadline_seconds = v;
    }

    // bool retain_acked_messages = 7;


    pub fn get_retain_acked_messages(&self) -> bool {
        self.retain_acked_messages
    }
    pub fn clear_retain_acked_messages(&mut self) {
        self.retain_acked_messages = false;
    }

    // Param is passed by value, moved
    pub fn set_retain_acked_messages(&mut self, v: bool) {
        self.retain_acked_messages = v;
    }

    // .google.protobuf.Duration message_retention_duration = 8;


    pub fn get_message_retention_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.message_retention_duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_retention_duration(&mut self) {
        self.message_retention_duration.clear();
    }

    pub fn has_message_retention_duration(&self) -> bool {
        self.message_retention_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_retention_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.message_retention_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_retention_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.message_retention_duration.is_none() {
            self.message_retention_duration.set_default();
        }
        self.message_retention_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_retention_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.message_retention_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // repeated .google.pubsub.v1.Subscription.LabelsEntry labels = 9;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // bool enable_message_ordering = 10;


    pub fn get_enable_message_ordering(&self) -> bool {
        self.enable_message_ordering
    }
    pub fn clear_enable_message_ordering(&mut self) {
        self.enable_message_ordering = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_message_ordering(&mut self, v: bool) {
        self.enable_message_ordering = v;
    }

    // .google.pubsub.v1.ExpirationPolicy expiration_policy = 11;


    pub fn get_expiration_policy(&self) -> &ExpirationPolicy {
        self.expiration_policy.as_ref().unwrap_or_else(|| <ExpirationPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expiration_policy(&mut self) {
        self.expiration_policy.clear();
    }

    pub fn has_expiration_policy(&self) -> bool {
        self.expiration_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_policy(&mut self, v: ExpirationPolicy) {
        self.expiration_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration_policy(&mut self) -> &mut ExpirationPolicy {
        if self.expiration_policy.is_none() {
            self.expiration_policy.set_default();
        }
        self.expiration_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration_policy(&mut self) -> ExpirationPolicy {
        self.expiration_policy.take().unwrap_or_else(|| ExpirationPolicy::new())
    }

    // string filter = 12;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // .google.pubsub.v1.DeadLetterPolicy dead_letter_policy = 13;


    pub fn get_dead_letter_policy(&self) -> &DeadLetterPolicy {
        self.dead_letter_policy.as_ref().unwrap_or_else(|| <DeadLetterPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dead_letter_policy(&mut self) {
        self.dead_letter_policy.clear();
    }

    pub fn has_dead_letter_policy(&self) -> bool {
        self.dead_letter_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dead_letter_policy(&mut self, v: DeadLetterPolicy) {
        self.dead_letter_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dead_letter_policy(&mut self) -> &mut DeadLetterPolicy {
        if self.dead_letter_policy.is_none() {
            self.dead_letter_policy.set_default();
        }
        self.dead_letter_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_dead_letter_policy(&mut self) -> DeadLetterPolicy {
        self.dead_letter_policy.take().unwrap_or_else(|| DeadLetterPolicy::new())
    }

    // .google.pubsub.v1.RetryPolicy retry_policy = 14;


    pub fn get_retry_policy(&self) -> &RetryPolicy {
        self.retry_policy.as_ref().unwrap_or_else(|| <RetryPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy(&mut self) {
        self.retry_policy.clear();
    }

    pub fn has_retry_policy(&self) -> bool {
        self.retry_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy(&mut self, v: RetryPolicy) {
        self.retry_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy(&mut self) -> &mut RetryPolicy {
        if self.retry_policy.is_none() {
            self.retry_policy.set_default();
        }
        self.retry_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy(&mut self) -> RetryPolicy {
        self.retry_policy.take().unwrap_or_else(|| RetryPolicy::new())
    }

    // bool detached = 15;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }

    // bool enable_exactly_once_delivery = 16;


    pub fn get_enable_exactly_once_delivery(&self) -> bool {
        self.enable_exactly_once_delivery
    }
    pub fn clear_enable_exactly_once_delivery(&mut self) {
        self.enable_exactly_once_delivery = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_exactly_once_delivery(&mut self, v: bool) {
        self.enable_exactly_once_delivery = v;
    }

    // .google.protobuf.Duration topic_message_retention_duration = 17;


    pub fn get_topic_message_retention_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.topic_message_retention_duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_topic_message_retention_duration(&mut self) {
        self.topic_message_retention_duration.clear();
    }

    pub fn has_topic_message_retention_duration(&self) -> bool {
        self.topic_message_retention_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic_message_retention_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.topic_message_retention_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic_message_retention_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.topic_message_retention_duration.is_none() {
            self.topic_message_retention_duration.set_default();
        }
        self.topic_message_retention_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic_message_retention_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.topic_message_retention_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.pubsub.v1.Subscription.State state = 19;


    pub fn get_state(&self) -> Subscription_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Subscription_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Subscription_State) {
        self.state = v;
    }
}

impl ::protobuf::Message for Subscription {
    fn is_initialized(&self) -> bool {
        for v in &self.push_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bigquery_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cloud_storage_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message_retention_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expiration_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dead_letter_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.topic_message_retention_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.push_config)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bigquery_config)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloud_storage_config)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ack_deadline_seconds = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retain_acked_messages = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_retention_duration)?;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_message_ordering = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiration_policy)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dead_letter_policy)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_exactly_once_delivery = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.topic_message_retention_duration)?;
                },
                19 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 19, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(ref v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bigquery_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cloud_storage_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ack_deadline_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.retain_acked_messages != false {
            my_size += 2;
        }
        if let Some(ref v) = self.message_retention_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels);
        if self.enable_message_ordering != false {
            my_size += 2;
        }
        if let Some(ref v) = self.expiration_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.filter);
        }
        if let Some(ref v) = self.dead_letter_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.detached != false {
            my_size += 2;
        }
        if self.enable_exactly_once_delivery != false {
            my_size += 3;
        }
        if let Some(ref v) = self.topic_message_retention_duration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != Subscription_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(19, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(ref v) = self.push_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bigquery_config.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cloud_storage_config.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ack_deadline_seconds != 0 {
            os.write_int32(5, self.ack_deadline_seconds)?;
        }
        if self.retain_acked_messages != false {
            os.write_bool(7, self.retain_acked_messages)?;
        }
        if let Some(ref v) = self.message_retention_duration.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels, os)?;
        if self.enable_message_ordering != false {
            os.write_bool(10, self.enable_message_ordering)?;
        }
        if let Some(ref v) = self.expiration_policy.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.filter.is_empty() {
            os.write_string(12, &self.filter)?;
        }
        if let Some(ref v) = self.dead_letter_policy.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.detached != false {
            os.write_bool(15, self.detached)?;
        }
        if self.enable_exactly_once_delivery != false {
            os.write_bool(16, self.enable_exactly_once_delivery)?;
        }
        if let Some(ref v) = self.topic_message_retention_duration.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != Subscription_State::STATE_UNSPECIFIED {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Subscription {
        Subscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Subscription| { &m.name },
                |m: &mut Subscription| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &Subscription| { &m.topic },
                |m: &mut Subscription| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PushConfig>>(
                "push_config",
                |m: &Subscription| { &m.push_config },
                |m: &mut Subscription| { &mut m.push_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BigQueryConfig>>(
                "bigquery_config",
                |m: &Subscription| { &m.bigquery_config },
                |m: &mut Subscription| { &mut m.bigquery_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CloudStorageConfig>>(
                "cloud_storage_config",
                |m: &Subscription| { &m.cloud_storage_config },
                |m: &mut Subscription| { &mut m.cloud_storage_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ack_deadline_seconds",
                |m: &Subscription| { &m.ack_deadline_seconds },
                |m: &mut Subscription| { &mut m.ack_deadline_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "retain_acked_messages",
                |m: &Subscription| { &m.retain_acked_messages },
                |m: &mut Subscription| { &mut m.retain_acked_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "message_retention_duration",
                |m: &Subscription| { &m.message_retention_duration },
                |m: &mut Subscription| { &mut m.message_retention_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Subscription| { &m.labels },
                |m: &mut Subscription| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_message_ordering",
                |m: &Subscription| { &m.enable_message_ordering },
                |m: &mut Subscription| { &mut m.enable_message_ordering },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExpirationPolicy>>(
                "expiration_policy",
                |m: &Subscription| { &m.expiration_policy },
                |m: &mut Subscription| { &mut m.expiration_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &Subscription| { &m.filter },
                |m: &mut Subscription| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeadLetterPolicy>>(
                "dead_letter_policy",
                |m: &Subscription| { &m.dead_letter_policy },
                |m: &mut Subscription| { &mut m.dead_letter_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy>>(
                "retry_policy",
                |m: &Subscription| { &m.retry_policy },
                |m: &mut Subscription| { &mut m.retry_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "detached",
                |m: &Subscription| { &m.detached },
                |m: &mut Subscription| { &mut m.detached },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_exactly_once_delivery",
                |m: &Subscription| { &m.enable_exactly_once_delivery },
                |m: &mut Subscription| { &mut m.enable_exactly_once_delivery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "topic_message_retention_duration",
                |m: &Subscription| { &m.topic_message_retention_duration },
                |m: &mut Subscription| { &mut m.topic_message_retention_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Subscription_State>>(
                "state",
                |m: &Subscription| { &m.state },
                |m: &mut Subscription| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Subscription>(
                "Subscription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Subscription {
        static instance: ::protobuf::rt::LazyV2<Subscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Subscription::new)
    }
}

impl ::protobuf::Clear for Subscription {
    fn clear(&mut self) {
        self.name.clear();
        self.topic.clear();
        self.push_config.clear();
        self.bigquery_config.clear();
        self.cloud_storage_config.clear();
        self.ack_deadline_seconds = 0;
        self.retain_acked_messages = false;
        self.message_retention_duration.clear();
        self.labels.clear();
        self.enable_message_ordering = false;
        self.expiration_policy.clear();
        self.filter.clear();
        self.dead_letter_policy.clear();
        self.retry_policy.clear();
        self.detached = false;
        self.enable_exactly_once_delivery = false;
        self.topic_message_retention_duration.clear();
        self.state = Subscription_State::STATE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Subscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Subscription_State {
    STATE_UNSPECIFIED = 0,
    ACTIVE = 1,
    RESOURCE_ERROR = 2,
}

impl ::protobuf::ProtobufEnum for Subscription_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Subscription_State> {
        match value {
            0 => ::std::option::Option::Some(Subscription_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Subscription_State::ACTIVE),
            2 => ::std::option::Option::Some(Subscription_State::RESOURCE_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Subscription_State] = &[
            Subscription_State::STATE_UNSPECIFIED,
            Subscription_State::ACTIVE,
            Subscription_State::RESOURCE_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Subscription_State>("Subscription.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Subscription_State {
}

impl ::std::default::Default for Subscription_State {
    fn default() -> Self {
        Subscription_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Subscription_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RetryPolicy {
    // message fields
    pub minimum_backoff: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub maximum_backoff: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy {
    fn default() -> &'a RetryPolicy {
        <RetryPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy {
    pub fn new() -> RetryPolicy {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration minimum_backoff = 1;


    pub fn get_minimum_backoff(&self) -> &::protobuf::well_known_types::Duration {
        self.minimum_backoff.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_minimum_backoff(&mut self) {
        self.minimum_backoff.clear();
    }

    pub fn has_minimum_backoff(&self) -> bool {
        self.minimum_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum_backoff(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.minimum_backoff = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum_backoff(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.minimum_backoff.is_none() {
            self.minimum_backoff.set_default();
        }
        self.minimum_backoff.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum_backoff(&mut self) -> ::protobuf::well_known_types::Duration {
        self.minimum_backoff.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration maximum_backoff = 2;


    pub fn get_maximum_backoff(&self) -> &::protobuf::well_known_types::Duration {
        self.maximum_backoff.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_maximum_backoff(&mut self) {
        self.maximum_backoff.clear();
    }

    pub fn has_maximum_backoff(&self) -> bool {
        self.maximum_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_backoff(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.maximum_backoff = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum_backoff(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.maximum_backoff.is_none() {
            self.maximum_backoff.set_default();
        }
        self.maximum_backoff.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum_backoff(&mut self) -> ::protobuf::well_known_types::Duration {
        self.maximum_backoff.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RetryPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.minimum_backoff {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.maximum_backoff {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minimum_backoff)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maximum_backoff)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.minimum_backoff.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.maximum_backoff.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.minimum_backoff.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.maximum_backoff.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy {
        RetryPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "minimum_backoff",
                |m: &RetryPolicy| { &m.minimum_backoff },
                |m: &mut RetryPolicy| { &mut m.minimum_backoff },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "maximum_backoff",
                |m: &RetryPolicy| { &m.maximum_backoff },
                |m: &mut RetryPolicy| { &mut m.maximum_backoff },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy>(
                "RetryPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy::new)
    }
}

impl ::protobuf::Clear for RetryPolicy {
    fn clear(&mut self) {
        self.minimum_backoff.clear();
        self.maximum_backoff.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeadLetterPolicy {
    // message fields
    pub dead_letter_topic: ::std::string::String,
    pub max_delivery_attempts: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeadLetterPolicy {
    fn default() -> &'a DeadLetterPolicy {
        <DeadLetterPolicy as ::protobuf::Message>::default_instance()
    }
}

impl DeadLetterPolicy {
    pub fn new() -> DeadLetterPolicy {
        ::std::default::Default::default()
    }

    // string dead_letter_topic = 1;


    pub fn get_dead_letter_topic(&self) -> &str {
        &self.dead_letter_topic
    }
    pub fn clear_dead_letter_topic(&mut self) {
        self.dead_letter_topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_dead_letter_topic(&mut self, v: ::std::string::String) {
        self.dead_letter_topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dead_letter_topic(&mut self) -> &mut ::std::string::String {
        &mut self.dead_letter_topic
    }

    // Take field
    pub fn take_dead_letter_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dead_letter_topic, ::std::string::String::new())
    }

    // int32 max_delivery_attempts = 2;


    pub fn get_max_delivery_attempts(&self) -> i32 {
        self.max_delivery_attempts
    }
    pub fn clear_max_delivery_attempts(&mut self) {
        self.max_delivery_attempts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_delivery_attempts(&mut self, v: i32) {
        self.max_delivery_attempts = v;
    }
}

impl ::protobuf::Message for DeadLetterPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dead_letter_topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_delivery_attempts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dead_letter_topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dead_letter_topic);
        }
        if self.max_delivery_attempts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_delivery_attempts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dead_letter_topic.is_empty() {
            os.write_string(1, &self.dead_letter_topic)?;
        }
        if self.max_delivery_attempts != 0 {
            os.write_int32(2, self.max_delivery_attempts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeadLetterPolicy {
        DeadLetterPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dead_letter_topic",
                |m: &DeadLetterPolicy| { &m.dead_letter_topic },
                |m: &mut DeadLetterPolicy| { &mut m.dead_letter_topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_delivery_attempts",
                |m: &DeadLetterPolicy| { &m.max_delivery_attempts },
                |m: &mut DeadLetterPolicy| { &mut m.max_delivery_attempts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeadLetterPolicy>(
                "DeadLetterPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeadLetterPolicy {
        static instance: ::protobuf::rt::LazyV2<DeadLetterPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeadLetterPolicy::new)
    }
}

impl ::protobuf::Clear for DeadLetterPolicy {
    fn clear(&mut self) {
        self.dead_letter_topic.clear();
        self.max_delivery_attempts = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeadLetterPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeadLetterPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExpirationPolicy {
    // message fields
    pub ttl: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpirationPolicy {
    fn default() -> &'a ExpirationPolicy {
        <ExpirationPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ExpirationPolicy {
    pub fn new() -> ExpirationPolicy {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration ttl = 1;


    pub fn get_ttl(&self) -> &::protobuf::well_known_types::Duration {
        self.ttl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ttl(&mut self) {
        self.ttl.clear();
    }

    pub fn has_ttl(&self) -> bool {
        self.ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ttl(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.ttl.is_none() {
            self.ttl.set_default();
        }
        self.ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_ttl(&mut self) -> ::protobuf::well_known_types::Duration {
        self.ttl.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for ExpirationPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ttl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ttl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpirationPolicy {
        ExpirationPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "ttl",
                |m: &ExpirationPolicy| { &m.ttl },
                |m: &mut ExpirationPolicy| { &mut m.ttl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExpirationPolicy>(
                "ExpirationPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExpirationPolicy {
        static instance: ::protobuf::rt::LazyV2<ExpirationPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExpirationPolicy::new)
    }
}

impl ::protobuf::Clear for ExpirationPolicy {
    fn clear(&mut self) {
        self.ttl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExpirationPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpirationPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushConfig {
    // message fields
    pub push_endpoint: ::std::string::String,
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub authentication_method: ::std::option::Option<PushConfig_oneof_authentication_method>,
    pub wrapper: ::std::option::Option<PushConfig_oneof_wrapper>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushConfig {
    fn default() -> &'a PushConfig {
        <PushConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PushConfig_oneof_authentication_method {
    oidc_token(PushConfig_OidcToken),
}

#[derive(Clone,PartialEq,Debug)]
pub enum PushConfig_oneof_wrapper {
    pubsub_wrapper(PushConfig_PubsubWrapper),
    no_wrapper(PushConfig_NoWrapper),
}

impl PushConfig {
    pub fn new() -> PushConfig {
        ::std::default::Default::default()
    }

    // string push_endpoint = 1;


    pub fn get_push_endpoint(&self) -> &str {
        &self.push_endpoint
    }
    pub fn clear_push_endpoint(&mut self) {
        self.push_endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_push_endpoint(&mut self, v: ::std::string::String) {
        self.push_endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.push_endpoint
    }

    // Take field
    pub fn take_push_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.push_endpoint, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.PushConfig.AttributesEntry attributes = 2;


    pub fn get_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }

    // .google.pubsub.v1.PushConfig.OidcToken oidc_token = 3;


    pub fn get_oidc_token(&self) -> &PushConfig_OidcToken {
        match self.authentication_method {
            ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(ref v)) => v,
            _ => <PushConfig_OidcToken as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_oidc_token(&mut self) {
        self.authentication_method = ::std::option::Option::None;
    }

    pub fn has_oidc_token(&self) -> bool {
        match self.authentication_method {
            ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oidc_token(&mut self, v: PushConfig_OidcToken) {
        self.authentication_method = ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oidc_token(&mut self) -> &mut PushConfig_OidcToken {
        if let ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(_)) = self.authentication_method {
        } else {
            self.authentication_method = ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(PushConfig_OidcToken::new()));
        }
        match self.authentication_method {
            ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oidc_token(&mut self) -> PushConfig_OidcToken {
        if self.has_oidc_token() {
            match self.authentication_method.take() {
                ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(v)) => v,
                _ => panic!(),
            }
        } else {
            PushConfig_OidcToken::new()
        }
    }

    // .google.pubsub.v1.PushConfig.PubsubWrapper pubsub_wrapper = 4;


    pub fn get_pubsub_wrapper(&self) -> &PushConfig_PubsubWrapper {
        match self.wrapper {
            ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(ref v)) => v,
            _ => <PushConfig_PubsubWrapper as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pubsub_wrapper(&mut self) {
        self.wrapper = ::std::option::Option::None;
    }

    pub fn has_pubsub_wrapper(&self) -> bool {
        match self.wrapper {
            ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pubsub_wrapper(&mut self, v: PushConfig_PubsubWrapper) {
        self.wrapper = ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pubsub_wrapper(&mut self) -> &mut PushConfig_PubsubWrapper {
        if let ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(_)) = self.wrapper {
        } else {
            self.wrapper = ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(PushConfig_PubsubWrapper::new()));
        }
        match self.wrapper {
            ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pubsub_wrapper(&mut self) -> PushConfig_PubsubWrapper {
        if self.has_pubsub_wrapper() {
            match self.wrapper.take() {
                ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(v)) => v,
                _ => panic!(),
            }
        } else {
            PushConfig_PubsubWrapper::new()
        }
    }

    // .google.pubsub.v1.PushConfig.NoWrapper no_wrapper = 5;


    pub fn get_no_wrapper(&self) -> &PushConfig_NoWrapper {
        match self.wrapper {
            ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(ref v)) => v,
            _ => <PushConfig_NoWrapper as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_no_wrapper(&mut self) {
        self.wrapper = ::std::option::Option::None;
    }

    pub fn has_no_wrapper(&self) -> bool {
        match self.wrapper {
            ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_no_wrapper(&mut self, v: PushConfig_NoWrapper) {
        self.wrapper = ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(v))
    }

    // Mutable pointer to the field.
    pub fn mut_no_wrapper(&mut self) -> &mut PushConfig_NoWrapper {
        if let ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(_)) = self.wrapper {
        } else {
            self.wrapper = ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(PushConfig_NoWrapper::new()));
        }
        match self.wrapper {
            ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_no_wrapper(&mut self) -> PushConfig_NoWrapper {
        if self.has_no_wrapper() {
            match self.wrapper.take() {
                ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(v)) => v,
                _ => panic!(),
            }
        } else {
            PushConfig_NoWrapper::new()
        }
    }
}

impl ::protobuf::Message for PushConfig {
    fn is_initialized(&self) -> bool {
        if let Some(PushConfig_oneof_authentication_method::oidc_token(ref v)) = self.authentication_method {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PushConfig_oneof_wrapper::pubsub_wrapper(ref v)) = self.wrapper {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PushConfig_oneof_wrapper::no_wrapper(ref v)) = self.wrapper {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.push_endpoint)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.attributes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.authentication_method = ::std::option::Option::Some(PushConfig_oneof_authentication_method::oidc_token(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.wrapper = ::std::option::Option::Some(PushConfig_oneof_wrapper::pubsub_wrapper(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.wrapper = ::std::option::Option::Some(PushConfig_oneof_wrapper::no_wrapper(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.push_endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.push_endpoint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes);
        if let ::std::option::Option::Some(ref v) = self.authentication_method {
            match v {
                &PushConfig_oneof_authentication_method::oidc_token(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.wrapper {
            match v {
                &PushConfig_oneof_wrapper::pubsub_wrapper(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PushConfig_oneof_wrapper::no_wrapper(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.push_endpoint.is_empty() {
            os.write_string(1, &self.push_endpoint)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes, os)?;
        if let ::std::option::Option::Some(ref v) = self.authentication_method {
            match v {
                &PushConfig_oneof_authentication_method::oidc_token(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.wrapper {
            match v {
                &PushConfig_oneof_wrapper::pubsub_wrapper(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PushConfig_oneof_wrapper::no_wrapper(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushConfig {
        PushConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "push_endpoint",
                |m: &PushConfig| { &m.push_endpoint },
                |m: &mut PushConfig| { &mut m.push_endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "attributes",
                |m: &PushConfig| { &m.attributes },
                |m: &mut PushConfig| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PushConfig_OidcToken>(
                "oidc_token",
                PushConfig::has_oidc_token,
                PushConfig::get_oidc_token,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PushConfig_PubsubWrapper>(
                "pubsub_wrapper",
                PushConfig::has_pubsub_wrapper,
                PushConfig::get_pubsub_wrapper,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PushConfig_NoWrapper>(
                "no_wrapper",
                PushConfig::has_no_wrapper,
                PushConfig::get_no_wrapper,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushConfig>(
                "PushConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushConfig {
        static instance: ::protobuf::rt::LazyV2<PushConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushConfig::new)
    }
}

impl ::protobuf::Clear for PushConfig {
    fn clear(&mut self) {
        self.push_endpoint.clear();
        self.attributes.clear();
        self.authentication_method = ::std::option::Option::None;
        self.wrapper = ::std::option::Option::None;
        self.wrapper = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushConfig_OidcToken {
    // message fields
    pub service_account_email: ::std::string::String,
    pub audience: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushConfig_OidcToken {
    fn default() -> &'a PushConfig_OidcToken {
        <PushConfig_OidcToken as ::protobuf::Message>::default_instance()
    }
}

impl PushConfig_OidcToken {
    pub fn new() -> PushConfig_OidcToken {
        ::std::default::Default::default()
    }

    // string service_account_email = 1;


    pub fn get_service_account_email(&self) -> &str {
        &self.service_account_email
    }
    pub fn clear_service_account_email(&mut self) {
        self.service_account_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account_email(&mut self, v: ::std::string::String) {
        self.service_account_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_account_email(&mut self) -> &mut ::std::string::String {
        &mut self.service_account_email
    }

    // Take field
    pub fn take_service_account_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_account_email, ::std::string::String::new())
    }

    // string audience = 2;


    pub fn get_audience(&self) -> &str {
        &self.audience
    }
    pub fn clear_audience(&mut self) {
        self.audience.clear();
    }

    // Param is passed by value, moved
    pub fn set_audience(&mut self, v: ::std::string::String) {
        self.audience = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audience(&mut self) -> &mut ::std::string::String {
        &mut self.audience
    }

    // Take field
    pub fn take_audience(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.audience, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PushConfig_OidcToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_account_email)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.audience)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_account_email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_account_email);
        }
        if !self.audience.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.audience);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_account_email.is_empty() {
            os.write_string(1, &self.service_account_email)?;
        }
        if !self.audience.is_empty() {
            os.write_string(2, &self.audience)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushConfig_OidcToken {
        PushConfig_OidcToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_account_email",
                |m: &PushConfig_OidcToken| { &m.service_account_email },
                |m: &mut PushConfig_OidcToken| { &mut m.service_account_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audience",
                |m: &PushConfig_OidcToken| { &m.audience },
                |m: &mut PushConfig_OidcToken| { &mut m.audience },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushConfig_OidcToken>(
                "PushConfig.OidcToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushConfig_OidcToken {
        static instance: ::protobuf::rt::LazyV2<PushConfig_OidcToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushConfig_OidcToken::new)
    }
}

impl ::protobuf::Clear for PushConfig_OidcToken {
    fn clear(&mut self) {
        self.service_account_email.clear();
        self.audience.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushConfig_OidcToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushConfig_OidcToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushConfig_PubsubWrapper {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushConfig_PubsubWrapper {
    fn default() -> &'a PushConfig_PubsubWrapper {
        <PushConfig_PubsubWrapper as ::protobuf::Message>::default_instance()
    }
}

impl PushConfig_PubsubWrapper {
    pub fn new() -> PushConfig_PubsubWrapper {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PushConfig_PubsubWrapper {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushConfig_PubsubWrapper {
        PushConfig_PubsubWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushConfig_PubsubWrapper>(
                "PushConfig.PubsubWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushConfig_PubsubWrapper {
        static instance: ::protobuf::rt::LazyV2<PushConfig_PubsubWrapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushConfig_PubsubWrapper::new)
    }
}

impl ::protobuf::Clear for PushConfig_PubsubWrapper {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushConfig_PubsubWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushConfig_PubsubWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushConfig_NoWrapper {
    // message fields
    pub write_metadata: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushConfig_NoWrapper {
    fn default() -> &'a PushConfig_NoWrapper {
        <PushConfig_NoWrapper as ::protobuf::Message>::default_instance()
    }
}

impl PushConfig_NoWrapper {
    pub fn new() -> PushConfig_NoWrapper {
        ::std::default::Default::default()
    }

    // bool write_metadata = 1;


    pub fn get_write_metadata(&self) -> bool {
        self.write_metadata
    }
    pub fn clear_write_metadata(&mut self) {
        self.write_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_write_metadata(&mut self, v: bool) {
        self.write_metadata = v;
    }
}

impl ::protobuf::Message for PushConfig_NoWrapper {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.write_metadata = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.write_metadata != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.write_metadata != false {
            os.write_bool(1, self.write_metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushConfig_NoWrapper {
        PushConfig_NoWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "write_metadata",
                |m: &PushConfig_NoWrapper| { &m.write_metadata },
                |m: &mut PushConfig_NoWrapper| { &mut m.write_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushConfig_NoWrapper>(
                "PushConfig.NoWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushConfig_NoWrapper {
        static instance: ::protobuf::rt::LazyV2<PushConfig_NoWrapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushConfig_NoWrapper::new)
    }
}

impl ::protobuf::Clear for PushConfig_NoWrapper {
    fn clear(&mut self) {
        self.write_metadata = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushConfig_NoWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushConfig_NoWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BigQueryConfig {
    // message fields
    pub table: ::std::string::String,
    pub use_topic_schema: bool,
    pub write_metadata: bool,
    pub drop_unknown_fields: bool,
    pub state: BigQueryConfig_State,
    pub use_table_schema: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BigQueryConfig {
    fn default() -> &'a BigQueryConfig {
        <BigQueryConfig as ::protobuf::Message>::default_instance()
    }
}

impl BigQueryConfig {
    pub fn new() -> BigQueryConfig {
        ::std::default::Default::default()
    }

    // string table = 1;


    pub fn get_table(&self) -> &str {
        &self.table
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }

    // bool use_topic_schema = 2;


    pub fn get_use_topic_schema(&self) -> bool {
        self.use_topic_schema
    }
    pub fn clear_use_topic_schema(&mut self) {
        self.use_topic_schema = false;
    }

    // Param is passed by value, moved
    pub fn set_use_topic_schema(&mut self, v: bool) {
        self.use_topic_schema = v;
    }

    // bool write_metadata = 3;


    pub fn get_write_metadata(&self) -> bool {
        self.write_metadata
    }
    pub fn clear_write_metadata(&mut self) {
        self.write_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_write_metadata(&mut self, v: bool) {
        self.write_metadata = v;
    }

    // bool drop_unknown_fields = 4;


    pub fn get_drop_unknown_fields(&self) -> bool {
        self.drop_unknown_fields
    }
    pub fn clear_drop_unknown_fields(&mut self) {
        self.drop_unknown_fields = false;
    }

    // Param is passed by value, moved
    pub fn set_drop_unknown_fields(&mut self, v: bool) {
        self.drop_unknown_fields = v;
    }

    // .google.pubsub.v1.BigQueryConfig.State state = 5;


    pub fn get_state(&self) -> BigQueryConfig_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = BigQueryConfig_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: BigQueryConfig_State) {
        self.state = v;
    }

    // bool use_table_schema = 6;


    pub fn get_use_table_schema(&self) -> bool {
        self.use_table_schema
    }
    pub fn clear_use_table_schema(&mut self) {
        self.use_table_schema = false;
    }

    // Param is passed by value, moved
    pub fn set_use_table_schema(&mut self, v: bool) {
        self.use_table_schema = v;
    }
}

impl ::protobuf::Message for BigQueryConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_topic_schema = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.write_metadata = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.drop_unknown_fields = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_table_schema = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.table);
        }
        if self.use_topic_schema != false {
            my_size += 2;
        }
        if self.write_metadata != false {
            my_size += 2;
        }
        if self.drop_unknown_fields != false {
            my_size += 2;
        }
        if self.state != BigQueryConfig_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.state);
        }
        if self.use_table_schema != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.table.is_empty() {
            os.write_string(1, &self.table)?;
        }
        if self.use_topic_schema != false {
            os.write_bool(2, self.use_topic_schema)?;
        }
        if self.write_metadata != false {
            os.write_bool(3, self.write_metadata)?;
        }
        if self.drop_unknown_fields != false {
            os.write_bool(4, self.drop_unknown_fields)?;
        }
        if self.state != BigQueryConfig_State::STATE_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.use_table_schema != false {
            os.write_bool(6, self.use_table_schema)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BigQueryConfig {
        BigQueryConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table",
                |m: &BigQueryConfig| { &m.table },
                |m: &mut BigQueryConfig| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_topic_schema",
                |m: &BigQueryConfig| { &m.use_topic_schema },
                |m: &mut BigQueryConfig| { &mut m.use_topic_schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "write_metadata",
                |m: &BigQueryConfig| { &m.write_metadata },
                |m: &mut BigQueryConfig| { &mut m.write_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "drop_unknown_fields",
                |m: &BigQueryConfig| { &m.drop_unknown_fields },
                |m: &mut BigQueryConfig| { &mut m.drop_unknown_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BigQueryConfig_State>>(
                "state",
                |m: &BigQueryConfig| { &m.state },
                |m: &mut BigQueryConfig| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_table_schema",
                |m: &BigQueryConfig| { &m.use_table_schema },
                |m: &mut BigQueryConfig| { &mut m.use_table_schema },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BigQueryConfig>(
                "BigQueryConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BigQueryConfig {
        static instance: ::protobuf::rt::LazyV2<BigQueryConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BigQueryConfig::new)
    }
}

impl ::protobuf::Clear for BigQueryConfig {
    fn clear(&mut self) {
        self.table.clear();
        self.use_topic_schema = false;
        self.write_metadata = false;
        self.drop_unknown_fields = false;
        self.state = BigQueryConfig_State::STATE_UNSPECIFIED;
        self.use_table_schema = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BigQueryConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BigQueryConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BigQueryConfig_State {
    STATE_UNSPECIFIED = 0,
    ACTIVE = 1,
    PERMISSION_DENIED = 2,
    NOT_FOUND = 3,
    SCHEMA_MISMATCH = 4,
}

impl ::protobuf::ProtobufEnum for BigQueryConfig_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BigQueryConfig_State> {
        match value {
            0 => ::std::option::Option::Some(BigQueryConfig_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(BigQueryConfig_State::ACTIVE),
            2 => ::std::option::Option::Some(BigQueryConfig_State::PERMISSION_DENIED),
            3 => ::std::option::Option::Some(BigQueryConfig_State::NOT_FOUND),
            4 => ::std::option::Option::Some(BigQueryConfig_State::SCHEMA_MISMATCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BigQueryConfig_State] = &[
            BigQueryConfig_State::STATE_UNSPECIFIED,
            BigQueryConfig_State::ACTIVE,
            BigQueryConfig_State::PERMISSION_DENIED,
            BigQueryConfig_State::NOT_FOUND,
            BigQueryConfig_State::SCHEMA_MISMATCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BigQueryConfig_State>("BigQueryConfig.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BigQueryConfig_State {
}

impl ::std::default::Default for BigQueryConfig_State {
    fn default() -> Self {
        BigQueryConfig_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for BigQueryConfig_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloudStorageConfig {
    // message fields
    pub bucket: ::std::string::String,
    pub filename_prefix: ::std::string::String,
    pub filename_suffix: ::std::string::String,
    pub max_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub max_bytes: i64,
    pub state: CloudStorageConfig_State,
    // message oneof groups
    pub output_format: ::std::option::Option<CloudStorageConfig_oneof_output_format>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloudStorageConfig {
    fn default() -> &'a CloudStorageConfig {
        <CloudStorageConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CloudStorageConfig_oneof_output_format {
    text_config(CloudStorageConfig_TextConfig),
    avro_config(CloudStorageConfig_AvroConfig),
}

impl CloudStorageConfig {
    pub fn new() -> CloudStorageConfig {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string filename_prefix = 2;


    pub fn get_filename_prefix(&self) -> &str {
        &self.filename_prefix
    }
    pub fn clear_filename_prefix(&mut self) {
        self.filename_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_filename_prefix(&mut self, v: ::std::string::String) {
        self.filename_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.filename_prefix
    }

    // Take field
    pub fn take_filename_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filename_prefix, ::std::string::String::new())
    }

    // string filename_suffix = 3;


    pub fn get_filename_suffix(&self) -> &str {
        &self.filename_suffix
    }
    pub fn clear_filename_suffix(&mut self) {
        self.filename_suffix.clear();
    }

    // Param is passed by value, moved
    pub fn set_filename_suffix(&mut self, v: ::std::string::String) {
        self.filename_suffix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename_suffix(&mut self) -> &mut ::std::string::String {
        &mut self.filename_suffix
    }

    // Take field
    pub fn take_filename_suffix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filename_suffix, ::std::string::String::new())
    }

    // .google.pubsub.v1.CloudStorageConfig.TextConfig text_config = 4;


    pub fn get_text_config(&self) -> &CloudStorageConfig_TextConfig {
        match self.output_format {
            ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(ref v)) => v,
            _ => <CloudStorageConfig_TextConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_text_config(&mut self) {
        self.output_format = ::std::option::Option::None;
    }

    pub fn has_text_config(&self) -> bool {
        match self.output_format {
            ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text_config(&mut self, v: CloudStorageConfig_TextConfig) {
        self.output_format = ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text_config(&mut self) -> &mut CloudStorageConfig_TextConfig {
        if let ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(_)) = self.output_format {
        } else {
            self.output_format = ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(CloudStorageConfig_TextConfig::new()));
        }
        match self.output_format {
            ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text_config(&mut self) -> CloudStorageConfig_TextConfig {
        if self.has_text_config() {
            match self.output_format.take() {
                ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(v)) => v,
                _ => panic!(),
            }
        } else {
            CloudStorageConfig_TextConfig::new()
        }
    }

    // .google.pubsub.v1.CloudStorageConfig.AvroConfig avro_config = 5;


    pub fn get_avro_config(&self) -> &CloudStorageConfig_AvroConfig {
        match self.output_format {
            ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(ref v)) => v,
            _ => <CloudStorageConfig_AvroConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_avro_config(&mut self) {
        self.output_format = ::std::option::Option::None;
    }

    pub fn has_avro_config(&self) -> bool {
        match self.output_format {
            ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_avro_config(&mut self, v: CloudStorageConfig_AvroConfig) {
        self.output_format = ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_avro_config(&mut self) -> &mut CloudStorageConfig_AvroConfig {
        if let ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(_)) = self.output_format {
        } else {
            self.output_format = ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(CloudStorageConfig_AvroConfig::new()));
        }
        match self.output_format {
            ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_avro_config(&mut self) -> CloudStorageConfig_AvroConfig {
        if self.has_avro_config() {
            match self.output_format.take() {
                ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(v)) => v,
                _ => panic!(),
            }
        } else {
            CloudStorageConfig_AvroConfig::new()
        }
    }

    // .google.protobuf.Duration max_duration = 6;


    pub fn get_max_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.max_duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_duration(&mut self) {
        self.max_duration.clear();
    }

    pub fn has_max_duration(&self) -> bool {
        self.max_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_duration.is_none() {
            self.max_duration.set_default();
        }
        self.max_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // int64 max_bytes = 7;


    pub fn get_max_bytes(&self) -> i64 {
        self.max_bytes
    }
    pub fn clear_max_bytes(&mut self) {
        self.max_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_bytes(&mut self, v: i64) {
        self.max_bytes = v;
    }

    // .google.pubsub.v1.CloudStorageConfig.State state = 9;


    pub fn get_state(&self) -> CloudStorageConfig_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = CloudStorageConfig_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CloudStorageConfig_State) {
        self.state = v;
    }
}

impl ::protobuf::Message for CloudStorageConfig {
    fn is_initialized(&self) -> bool {
        if let Some(CloudStorageConfig_oneof_output_format::text_config(ref v)) = self.output_format {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CloudStorageConfig_oneof_output_format::avro_config(ref v)) = self.output_format {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.max_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filename_prefix)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filename_suffix)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.output_format = ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::text_config(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.output_format = ::std::option::Option::Some(CloudStorageConfig_oneof_output_format::avro_config(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_duration)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_bytes = tmp;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.filename_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filename_prefix);
        }
        if !self.filename_suffix.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filename_suffix);
        }
        if let Some(ref v) = self.max_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_bytes != 0 {
            my_size += ::protobuf::rt::value_size(7, self.max_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != CloudStorageConfig_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(9, self.state);
        }
        if let ::std::option::Option::Some(ref v) = self.output_format {
            match v {
                &CloudStorageConfig_oneof_output_format::text_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CloudStorageConfig_oneof_output_format::avro_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.filename_prefix.is_empty() {
            os.write_string(2, &self.filename_prefix)?;
        }
        if !self.filename_suffix.is_empty() {
            os.write_string(3, &self.filename_suffix)?;
        }
        if let Some(ref v) = self.max_duration.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_bytes != 0 {
            os.write_int64(7, self.max_bytes)?;
        }
        if self.state != CloudStorageConfig_State::STATE_UNSPECIFIED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if let ::std::option::Option::Some(ref v) = self.output_format {
            match v {
                &CloudStorageConfig_oneof_output_format::text_config(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CloudStorageConfig_oneof_output_format::avro_config(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloudStorageConfig {
        CloudStorageConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &CloudStorageConfig| { &m.bucket },
                |m: &mut CloudStorageConfig| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename_prefix",
                |m: &CloudStorageConfig| { &m.filename_prefix },
                |m: &mut CloudStorageConfig| { &mut m.filename_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename_suffix",
                |m: &CloudStorageConfig| { &m.filename_suffix },
                |m: &mut CloudStorageConfig| { &mut m.filename_suffix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CloudStorageConfig_TextConfig>(
                "text_config",
                CloudStorageConfig::has_text_config,
                CloudStorageConfig::get_text_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CloudStorageConfig_AvroConfig>(
                "avro_config",
                CloudStorageConfig::has_avro_config,
                CloudStorageConfig::get_avro_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_duration",
                |m: &CloudStorageConfig| { &m.max_duration },
                |m: &mut CloudStorageConfig| { &mut m.max_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_bytes",
                |m: &CloudStorageConfig| { &m.max_bytes },
                |m: &mut CloudStorageConfig| { &mut m.max_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CloudStorageConfig_State>>(
                "state",
                |m: &CloudStorageConfig| { &m.state },
                |m: &mut CloudStorageConfig| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloudStorageConfig>(
                "CloudStorageConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloudStorageConfig {
        static instance: ::protobuf::rt::LazyV2<CloudStorageConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloudStorageConfig::new)
    }
}

impl ::protobuf::Clear for CloudStorageConfig {
    fn clear(&mut self) {
        self.bucket.clear();
        self.filename_prefix.clear();
        self.filename_suffix.clear();
        self.output_format = ::std::option::Option::None;
        self.output_format = ::std::option::Option::None;
        self.max_duration.clear();
        self.max_bytes = 0;
        self.state = CloudStorageConfig_State::STATE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloudStorageConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloudStorageConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloudStorageConfig_TextConfig {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloudStorageConfig_TextConfig {
    fn default() -> &'a CloudStorageConfig_TextConfig {
        <CloudStorageConfig_TextConfig as ::protobuf::Message>::default_instance()
    }
}

impl CloudStorageConfig_TextConfig {
    pub fn new() -> CloudStorageConfig_TextConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CloudStorageConfig_TextConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloudStorageConfig_TextConfig {
        CloudStorageConfig_TextConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloudStorageConfig_TextConfig>(
                "CloudStorageConfig.TextConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloudStorageConfig_TextConfig {
        static instance: ::protobuf::rt::LazyV2<CloudStorageConfig_TextConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloudStorageConfig_TextConfig::new)
    }
}

impl ::protobuf::Clear for CloudStorageConfig_TextConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloudStorageConfig_TextConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloudStorageConfig_TextConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloudStorageConfig_AvroConfig {
    // message fields
    pub write_metadata: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloudStorageConfig_AvroConfig {
    fn default() -> &'a CloudStorageConfig_AvroConfig {
        <CloudStorageConfig_AvroConfig as ::protobuf::Message>::default_instance()
    }
}

impl CloudStorageConfig_AvroConfig {
    pub fn new() -> CloudStorageConfig_AvroConfig {
        ::std::default::Default::default()
    }

    // bool write_metadata = 1;


    pub fn get_write_metadata(&self) -> bool {
        self.write_metadata
    }
    pub fn clear_write_metadata(&mut self) {
        self.write_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_write_metadata(&mut self, v: bool) {
        self.write_metadata = v;
    }
}

impl ::protobuf::Message for CloudStorageConfig_AvroConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.write_metadata = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.write_metadata != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.write_metadata != false {
            os.write_bool(1, self.write_metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloudStorageConfig_AvroConfig {
        CloudStorageConfig_AvroConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "write_metadata",
                |m: &CloudStorageConfig_AvroConfig| { &m.write_metadata },
                |m: &mut CloudStorageConfig_AvroConfig| { &mut m.write_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloudStorageConfig_AvroConfig>(
                "CloudStorageConfig.AvroConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloudStorageConfig_AvroConfig {
        static instance: ::protobuf::rt::LazyV2<CloudStorageConfig_AvroConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloudStorageConfig_AvroConfig::new)
    }
}

impl ::protobuf::Clear for CloudStorageConfig_AvroConfig {
    fn clear(&mut self) {
        self.write_metadata = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloudStorageConfig_AvroConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloudStorageConfig_AvroConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CloudStorageConfig_State {
    STATE_UNSPECIFIED = 0,
    ACTIVE = 1,
    PERMISSION_DENIED = 2,
    NOT_FOUND = 3,
}

impl ::protobuf::ProtobufEnum for CloudStorageConfig_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CloudStorageConfig_State> {
        match value {
            0 => ::std::option::Option::Some(CloudStorageConfig_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(CloudStorageConfig_State::ACTIVE),
            2 => ::std::option::Option::Some(CloudStorageConfig_State::PERMISSION_DENIED),
            3 => ::std::option::Option::Some(CloudStorageConfig_State::NOT_FOUND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CloudStorageConfig_State] = &[
            CloudStorageConfig_State::STATE_UNSPECIFIED,
            CloudStorageConfig_State::ACTIVE,
            CloudStorageConfig_State::PERMISSION_DENIED,
            CloudStorageConfig_State::NOT_FOUND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CloudStorageConfig_State>("CloudStorageConfig.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CloudStorageConfig_State {
}

impl ::std::default::Default for CloudStorageConfig_State {
    fn default() -> Self {
        CloudStorageConfig_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CloudStorageConfig_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReceivedMessage {
    // message fields
    pub ack_id: ::std::string::String,
    pub message: ::protobuf::SingularPtrField<PubsubMessage>,
    pub delivery_attempt: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceivedMessage {
    fn default() -> &'a ReceivedMessage {
        <ReceivedMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReceivedMessage {
    pub fn new() -> ReceivedMessage {
        ::std::default::Default::default()
    }

    // string ack_id = 1;


    pub fn get_ack_id(&self) -> &str {
        &self.ack_id
    }
    pub fn clear_ack_id(&mut self) {
        self.ack_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_id(&mut self, v: ::std::string::String) {
        self.ack_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ack_id(&mut self) -> &mut ::std::string::String {
        &mut self.ack_id
    }

    // Take field
    pub fn take_ack_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ack_id, ::std::string::String::new())
    }

    // .google.pubsub.v1.PubsubMessage message = 2;


    pub fn get_message(&self) -> &PubsubMessage {
        self.message.as_ref().unwrap_or_else(|| <PubsubMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: PubsubMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut PubsubMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> PubsubMessage {
        self.message.take().unwrap_or_else(|| PubsubMessage::new())
    }

    // int32 delivery_attempt = 3;


    pub fn get_delivery_attempt(&self) -> i32 {
        self.delivery_attempt
    }
    pub fn clear_delivery_attempt(&mut self) {
        self.delivery_attempt = 0;
    }

    // Param is passed by value, moved
    pub fn set_delivery_attempt(&mut self, v: i32) {
        self.delivery_attempt = v;
    }
}

impl ::protobuf::Message for ReceivedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ack_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.delivery_attempt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ack_id);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.delivery_attempt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.delivery_attempt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ack_id.is_empty() {
            os.write_string(1, &self.ack_id)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.delivery_attempt != 0 {
            os.write_int32(3, self.delivery_attempt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceivedMessage {
        ReceivedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ack_id",
                |m: &ReceivedMessage| { &m.ack_id },
                |m: &mut ReceivedMessage| { &mut m.ack_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubsubMessage>>(
                "message",
                |m: &ReceivedMessage| { &m.message },
                |m: &mut ReceivedMessage| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "delivery_attempt",
                |m: &ReceivedMessage| { &m.delivery_attempt },
                |m: &mut ReceivedMessage| { &mut m.delivery_attempt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceivedMessage>(
                "ReceivedMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReceivedMessage {
        static instance: ::protobuf::rt::LazyV2<ReceivedMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReceivedMessage::new)
    }
}

impl ::protobuf::Clear for ReceivedMessage {
    fn clear(&mut self) {
        self.ack_id.clear();
        self.message.clear();
        self.delivery_attempt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceivedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceivedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSubscriptionRequest {
    // message fields
    pub subscription: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSubscriptionRequest {
    fn default() -> &'a GetSubscriptionRequest {
        <GetSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSubscriptionRequest {
    pub fn new() -> GetSubscriptionRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubscriptionRequest {
        GetSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &GetSubscriptionRequest| { &m.subscription },
                |m: &mut GetSubscriptionRequest| { &mut m.subscription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSubscriptionRequest>(
                "GetSubscriptionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSubscriptionRequest {
        static instance: ::protobuf::rt::LazyV2<GetSubscriptionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSubscriptionRequest::new)
    }
}

impl ::protobuf::Clear for GetSubscriptionRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSubscriptionRequest {
    // message fields
    pub subscription: ::protobuf::SingularPtrField<Subscription>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSubscriptionRequest {
    fn default() -> &'a UpdateSubscriptionRequest {
        <UpdateSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSubscriptionRequest {
    pub fn new() -> UpdateSubscriptionRequest {
        ::std::default::Default::default()
    }

    // .google.pubsub.v1.Subscription subscription = 1;


    pub fn get_subscription(&self) -> &Subscription {
        self.subscription.as_ref().unwrap_or_else(|| <Subscription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    pub fn has_subscription(&self) -> bool {
        self.subscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: Subscription) {
        self.subscription = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut Subscription {
        if self.subscription.is_none() {
            self.subscription.set_default();
        }
        self.subscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription(&mut self) -> Subscription {
        self.subscription.take().unwrap_or_else(|| Subscription::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.subscription {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSubscriptionRequest {
        UpdateSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Subscription>>(
                "subscription",
                |m: &UpdateSubscriptionRequest| { &m.subscription },
                |m: &mut UpdateSubscriptionRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateSubscriptionRequest| { &m.update_mask },
                |m: &mut UpdateSubscriptionRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSubscriptionRequest>(
                "UpdateSubscriptionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSubscriptionRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateSubscriptionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSubscriptionRequest::new)
    }
}

impl ::protobuf::Clear for UpdateSubscriptionRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSubscriptionsRequest {
    // message fields
    pub project: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsRequest {
    fn default() -> &'a ListSubscriptionsRequest {
        <ListSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsRequest {
    pub fn new() -> ListSubscriptionsRequest {
        ::std::default::Default::default()
    }

    // string project = 1;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSubscriptionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSubscriptionsRequest {
        ListSubscriptionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project",
                |m: &ListSubscriptionsRequest| { &m.project },
                |m: &mut ListSubscriptionsRequest| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListSubscriptionsRequest| { &m.page_size },
                |m: &mut ListSubscriptionsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListSubscriptionsRequest| { &m.page_token },
                |m: &mut ListSubscriptionsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSubscriptionsRequest>(
                "ListSubscriptionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSubscriptionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListSubscriptionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSubscriptionsRequest::new)
    }
}

impl ::protobuf::Clear for ListSubscriptionsRequest {
    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSubscriptionsResponse {
    // message fields
    pub subscriptions: ::protobuf::RepeatedField<Subscription>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsResponse {
    fn default() -> &'a ListSubscriptionsResponse {
        <ListSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsResponse {
    pub fn new() -> ListSubscriptionsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.Subscription subscriptions = 1;


    pub fn get_subscriptions(&self) -> &[Subscription] {
        &self.subscriptions
    }
    pub fn clear_subscriptions(&mut self) {
        self.subscriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscriptions(&mut self, v: ::protobuf::RepeatedField<Subscription>) {
        self.subscriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscriptions(&mut self) -> &mut ::protobuf::RepeatedField<Subscription> {
        &mut self.subscriptions
    }

    // Take field
    pub fn take_subscriptions(&mut self) -> ::protobuf::RepeatedField<Subscription> {
        ::std::mem::replace(&mut self.subscriptions, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSubscriptionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.subscriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscriptions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subscriptions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSubscriptionsResponse {
        ListSubscriptionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Subscription>>(
                "subscriptions",
                |m: &ListSubscriptionsResponse| { &m.subscriptions },
                |m: &mut ListSubscriptionsResponse| { &mut m.subscriptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListSubscriptionsResponse| { &m.next_page_token },
                |m: &mut ListSubscriptionsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSubscriptionsResponse>(
                "ListSubscriptionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSubscriptionsResponse {
        static instance: ::protobuf::rt::LazyV2<ListSubscriptionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSubscriptionsResponse::new)
    }
}

impl ::protobuf::Clear for ListSubscriptionsResponse {
    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSubscriptionRequest {
    // message fields
    pub subscription: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSubscriptionRequest {
    fn default() -> &'a DeleteSubscriptionRequest {
        <DeleteSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSubscriptionRequest {
    pub fn new() -> DeleteSubscriptionRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSubscriptionRequest {
        DeleteSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &DeleteSubscriptionRequest| { &m.subscription },
                |m: &mut DeleteSubscriptionRequest| { &mut m.subscription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSubscriptionRequest>(
                "DeleteSubscriptionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSubscriptionRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteSubscriptionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSubscriptionRequest::new)
    }
}

impl ::protobuf::Clear for DeleteSubscriptionRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyPushConfigRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub push_config: ::protobuf::SingularPtrField<PushConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyPushConfigRequest {
    fn default() -> &'a ModifyPushConfigRequest {
        <ModifyPushConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyPushConfigRequest {
    pub fn new() -> ModifyPushConfigRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // .google.pubsub.v1.PushConfig push_config = 2;


    pub fn get_push_config(&self) -> &PushConfig {
        self.push_config.as_ref().unwrap_or_else(|| <PushConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_push_config(&mut self) {
        self.push_config.clear();
    }

    pub fn has_push_config(&self) -> bool {
        self.push_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_config(&mut self, v: PushConfig) {
        self.push_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_config(&mut self) -> &mut PushConfig {
        if self.push_config.is_none() {
            self.push_config.set_default();
        }
        self.push_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_push_config(&mut self) -> PushConfig {
        self.push_config.take().unwrap_or_else(|| PushConfig::new())
    }
}

impl ::protobuf::Message for ModifyPushConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.push_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.push_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if let Some(ref v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if let Some(ref v) = self.push_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyPushConfigRequest {
        ModifyPushConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &ModifyPushConfigRequest| { &m.subscription },
                |m: &mut ModifyPushConfigRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PushConfig>>(
                "push_config",
                |m: &ModifyPushConfigRequest| { &m.push_config },
                |m: &mut ModifyPushConfigRequest| { &mut m.push_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyPushConfigRequest>(
                "ModifyPushConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyPushConfigRequest {
        static instance: ::protobuf::rt::LazyV2<ModifyPushConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyPushConfigRequest::new)
    }
}

impl ::protobuf::Clear for ModifyPushConfigRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.push_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyPushConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyPushConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub return_immediately: bool,
    pub max_messages: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullRequest {
    fn default() -> &'a PullRequest {
        <PullRequest as ::protobuf::Message>::default_instance()
    }
}

impl PullRequest {
    pub fn new() -> PullRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // bool return_immediately = 2;


    pub fn get_return_immediately(&self) -> bool {
        self.return_immediately
    }
    pub fn clear_return_immediately(&mut self) {
        self.return_immediately = false;
    }

    // Param is passed by value, moved
    pub fn set_return_immediately(&mut self, v: bool) {
        self.return_immediately = v;
    }

    // int32 max_messages = 3;


    pub fn get_max_messages(&self) -> i32 {
        self.max_messages
    }
    pub fn clear_max_messages(&mut self) {
        self.max_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_messages(&mut self, v: i32) {
        self.max_messages = v;
    }
}

impl ::protobuf::Message for PullRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_immediately = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_messages = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if self.return_immediately != false {
            my_size += 2;
        }
        if self.max_messages != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if self.return_immediately != false {
            os.write_bool(2, self.return_immediately)?;
        }
        if self.max_messages != 0 {
            os.write_int32(3, self.max_messages)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullRequest {
        PullRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &PullRequest| { &m.subscription },
                |m: &mut PullRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "return_immediately",
                |m: &PullRequest| { &m.return_immediately },
                |m: &mut PullRequest| { &mut m.return_immediately },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_messages",
                |m: &PullRequest| { &m.max_messages },
                |m: &mut PullRequest| { &mut m.max_messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullRequest>(
                "PullRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PullRequest {
        static instance: ::protobuf::rt::LazyV2<PullRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PullRequest::new)
    }
}

impl ::protobuf::Clear for PullRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.return_immediately = false;
        self.max_messages = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullResponse {
    // message fields
    pub received_messages: ::protobuf::RepeatedField<ReceivedMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullResponse {
    fn default() -> &'a PullResponse {
        <PullResponse as ::protobuf::Message>::default_instance()
    }
}

impl PullResponse {
    pub fn new() -> PullResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.ReceivedMessage received_messages = 1;


    pub fn get_received_messages(&self) -> &[ReceivedMessage] {
        &self.received_messages
    }
    pub fn clear_received_messages(&mut self) {
        self.received_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_received_messages(&mut self, v: ::protobuf::RepeatedField<ReceivedMessage>) {
        self.received_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_received_messages(&mut self) -> &mut ::protobuf::RepeatedField<ReceivedMessage> {
        &mut self.received_messages
    }

    // Take field
    pub fn take_received_messages(&mut self) -> ::protobuf::RepeatedField<ReceivedMessage> {
        ::std::mem::replace(&mut self.received_messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PullResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.received_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.received_messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.received_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.received_messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullResponse {
        PullResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceivedMessage>>(
                "received_messages",
                |m: &PullResponse| { &m.received_messages },
                |m: &mut PullResponse| { &mut m.received_messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullResponse>(
                "PullResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PullResponse {
        static instance: ::protobuf::rt::LazyV2<PullResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PullResponse::new)
    }
}

impl ::protobuf::Clear for PullResponse {
    fn clear(&mut self) {
        self.received_messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyAckDeadlineRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub ack_deadline_seconds: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyAckDeadlineRequest {
    fn default() -> &'a ModifyAckDeadlineRequest {
        <ModifyAckDeadlineRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyAckDeadlineRequest {
    pub fn new() -> ModifyAckDeadlineRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated string ack_ids = 4;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }

    // int32 ack_deadline_seconds = 3;


    pub fn get_ack_deadline_seconds(&self) -> i32 {
        self.ack_deadline_seconds
    }
    pub fn clear_ack_deadline_seconds(&mut self) {
        self.ack_deadline_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_ack_deadline_seconds(&mut self, v: i32) {
        self.ack_deadline_seconds = v;
    }
}

impl ::protobuf::Message for ModifyAckDeadlineRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ack_deadline_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ack_deadline_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(4, &v)?;
        };
        if self.ack_deadline_seconds != 0 {
            os.write_int32(3, self.ack_deadline_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyAckDeadlineRequest {
        ModifyAckDeadlineRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &ModifyAckDeadlineRequest| { &m.subscription },
                |m: &mut ModifyAckDeadlineRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ack_ids",
                |m: &ModifyAckDeadlineRequest| { &m.ack_ids },
                |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ack_deadline_seconds",
                |m: &ModifyAckDeadlineRequest| { &m.ack_deadline_seconds },
                |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_deadline_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyAckDeadlineRequest>(
                "ModifyAckDeadlineRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyAckDeadlineRequest {
        static instance: ::protobuf::rt::LazyV2<ModifyAckDeadlineRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyAckDeadlineRequest::new)
    }
}

impl ::protobuf::Clear for ModifyAckDeadlineRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.ack_deadline_seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyAckDeadlineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyAckDeadlineRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcknowledgeRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcknowledgeRequest {
    fn default() -> &'a AcknowledgeRequest {
        <AcknowledgeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AcknowledgeRequest {
    pub fn new() -> AcknowledgeRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated string ack_ids = 2;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AcknowledgeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcknowledgeRequest {
        AcknowledgeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &AcknowledgeRequest| { &m.subscription },
                |m: &mut AcknowledgeRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ack_ids",
                |m: &AcknowledgeRequest| { &m.ack_ids },
                |m: &mut AcknowledgeRequest| { &mut m.ack_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcknowledgeRequest>(
                "AcknowledgeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcknowledgeRequest {
        static instance: ::protobuf::rt::LazyV2<AcknowledgeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcknowledgeRequest::new)
    }
}

impl ::protobuf::Clear for AcknowledgeRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcknowledgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcknowledgeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingPullRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub modify_deadline_seconds: ::std::vec::Vec<i32>,
    pub modify_deadline_ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub stream_ack_deadline_seconds: i32,
    pub client_id: ::std::string::String,
    pub max_outstanding_messages: i64,
    pub max_outstanding_bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingPullRequest {
    fn default() -> &'a StreamingPullRequest {
        <StreamingPullRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullRequest {
    pub fn new() -> StreamingPullRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated string ack_ids = 2;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }

    // repeated int32 modify_deadline_seconds = 3;


    pub fn get_modify_deadline_seconds(&self) -> &[i32] {
        &self.modify_deadline_seconds
    }
    pub fn clear_modify_deadline_seconds(&mut self) {
        self.modify_deadline_seconds.clear();
    }

    // Param is passed by value, moved
    pub fn set_modify_deadline_seconds(&mut self, v: ::std::vec::Vec<i32>) {
        self.modify_deadline_seconds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modify_deadline_seconds(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.modify_deadline_seconds
    }

    // Take field
    pub fn take_modify_deadline_seconds(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.modify_deadline_seconds, ::std::vec::Vec::new())
    }

    // repeated string modify_deadline_ack_ids = 4;


    pub fn get_modify_deadline_ack_ids(&self) -> &[::std::string::String] {
        &self.modify_deadline_ack_ids
    }
    pub fn clear_modify_deadline_ack_ids(&mut self) {
        self.modify_deadline_ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_modify_deadline_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.modify_deadline_ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modify_deadline_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.modify_deadline_ack_ids
    }

    // Take field
    pub fn take_modify_deadline_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.modify_deadline_ack_ids, ::protobuf::RepeatedField::new())
    }

    // int32 stream_ack_deadline_seconds = 5;


    pub fn get_stream_ack_deadline_seconds(&self) -> i32 {
        self.stream_ack_deadline_seconds
    }
    pub fn clear_stream_ack_deadline_seconds(&mut self) {
        self.stream_ack_deadline_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_stream_ack_deadline_seconds(&mut self, v: i32) {
        self.stream_ack_deadline_seconds = v;
    }

    // string client_id = 6;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }

    // int64 max_outstanding_messages = 7;


    pub fn get_max_outstanding_messages(&self) -> i64 {
        self.max_outstanding_messages
    }
    pub fn clear_max_outstanding_messages(&mut self) {
        self.max_outstanding_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_outstanding_messages(&mut self, v: i64) {
        self.max_outstanding_messages = v;
    }

    // int64 max_outstanding_bytes = 8;


    pub fn get_max_outstanding_bytes(&self) -> i64 {
        self.max_outstanding_bytes
    }
    pub fn clear_max_outstanding_bytes(&mut self) {
        self.max_outstanding_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_outstanding_bytes(&mut self, v: i64) {
        self.max_outstanding_bytes = v;
    }
}

impl ::protobuf::Message for StreamingPullRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.modify_deadline_seconds)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.modify_deadline_ack_ids)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stream_ack_deadline_seconds = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_outstanding_messages = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_outstanding_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.modify_deadline_seconds {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.modify_deadline_ack_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.stream_ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::value_size(5, self.stream_ack_deadline_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.client_id);
        }
        if self.max_outstanding_messages != 0 {
            my_size += ::protobuf::rt::value_size(7, self.max_outstanding_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_outstanding_bytes != 0 {
            my_size += ::protobuf::rt::value_size(8, self.max_outstanding_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.modify_deadline_seconds {
            os.write_int32(3, *v)?;
        };
        for v in &self.modify_deadline_ack_ids {
            os.write_string(4, &v)?;
        };
        if self.stream_ack_deadline_seconds != 0 {
            os.write_int32(5, self.stream_ack_deadline_seconds)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(6, &self.client_id)?;
        }
        if self.max_outstanding_messages != 0 {
            os.write_int64(7, self.max_outstanding_messages)?;
        }
        if self.max_outstanding_bytes != 0 {
            os.write_int64(8, self.max_outstanding_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingPullRequest {
        StreamingPullRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &StreamingPullRequest| { &m.subscription },
                |m: &mut StreamingPullRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ack_ids",
                |m: &StreamingPullRequest| { &m.ack_ids },
                |m: &mut StreamingPullRequest| { &mut m.ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "modify_deadline_seconds",
                |m: &StreamingPullRequest| { &m.modify_deadline_seconds },
                |m: &mut StreamingPullRequest| { &mut m.modify_deadline_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "modify_deadline_ack_ids",
                |m: &StreamingPullRequest| { &m.modify_deadline_ack_ids },
                |m: &mut StreamingPullRequest| { &mut m.modify_deadline_ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "stream_ack_deadline_seconds",
                |m: &StreamingPullRequest| { &m.stream_ack_deadline_seconds },
                |m: &mut StreamingPullRequest| { &mut m.stream_ack_deadline_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &StreamingPullRequest| { &m.client_id },
                |m: &mut StreamingPullRequest| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_outstanding_messages",
                |m: &StreamingPullRequest| { &m.max_outstanding_messages },
                |m: &mut StreamingPullRequest| { &mut m.max_outstanding_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_outstanding_bytes",
                |m: &StreamingPullRequest| { &m.max_outstanding_bytes },
                |m: &mut StreamingPullRequest| { &mut m.max_outstanding_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamingPullRequest>(
                "StreamingPullRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamingPullRequest {
        static instance: ::protobuf::rt::LazyV2<StreamingPullRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamingPullRequest::new)
    }
}

impl ::protobuf::Clear for StreamingPullRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.modify_deadline_seconds.clear();
        self.modify_deadline_ack_ids.clear();
        self.stream_ack_deadline_seconds = 0;
        self.client_id.clear();
        self.max_outstanding_messages = 0;
        self.max_outstanding_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingPullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingPullResponse {
    // message fields
    pub received_messages: ::protobuf::RepeatedField<ReceivedMessage>,
    pub acknowledge_confirmation: ::protobuf::SingularPtrField<StreamingPullResponse_AcknowledgeConfirmation>,
    pub modify_ack_deadline_confirmation: ::protobuf::SingularPtrField<StreamingPullResponse_ModifyAckDeadlineConfirmation>,
    pub subscription_properties: ::protobuf::SingularPtrField<StreamingPullResponse_SubscriptionProperties>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingPullResponse {
    fn default() -> &'a StreamingPullResponse {
        <StreamingPullResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullResponse {
    pub fn new() -> StreamingPullResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.ReceivedMessage received_messages = 1;


    pub fn get_received_messages(&self) -> &[ReceivedMessage] {
        &self.received_messages
    }
    pub fn clear_received_messages(&mut self) {
        self.received_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_received_messages(&mut self, v: ::protobuf::RepeatedField<ReceivedMessage>) {
        self.received_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_received_messages(&mut self) -> &mut ::protobuf::RepeatedField<ReceivedMessage> {
        &mut self.received_messages
    }

    // Take field
    pub fn take_received_messages(&mut self) -> ::protobuf::RepeatedField<ReceivedMessage> {
        ::std::mem::replace(&mut self.received_messages, ::protobuf::RepeatedField::new())
    }

    // .google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmation acknowledge_confirmation = 5;


    pub fn get_acknowledge_confirmation(&self) -> &StreamingPullResponse_AcknowledgeConfirmation {
        self.acknowledge_confirmation.as_ref().unwrap_or_else(|| <StreamingPullResponse_AcknowledgeConfirmation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_acknowledge_confirmation(&mut self) {
        self.acknowledge_confirmation.clear();
    }

    pub fn has_acknowledge_confirmation(&self) -> bool {
        self.acknowledge_confirmation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledge_confirmation(&mut self, v: StreamingPullResponse_AcknowledgeConfirmation) {
        self.acknowledge_confirmation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acknowledge_confirmation(&mut self) -> &mut StreamingPullResponse_AcknowledgeConfirmation {
        if self.acknowledge_confirmation.is_none() {
            self.acknowledge_confirmation.set_default();
        }
        self.acknowledge_confirmation.as_mut().unwrap()
    }

    // Take field
    pub fn take_acknowledge_confirmation(&mut self) -> StreamingPullResponse_AcknowledgeConfirmation {
        self.acknowledge_confirmation.take().unwrap_or_else(|| StreamingPullResponse_AcknowledgeConfirmation::new())
    }

    // .google.pubsub.v1.StreamingPullResponse.ModifyAckDeadlineConfirmation modify_ack_deadline_confirmation = 3;


    pub fn get_modify_ack_deadline_confirmation(&self) -> &StreamingPullResponse_ModifyAckDeadlineConfirmation {
        self.modify_ack_deadline_confirmation.as_ref().unwrap_or_else(|| <StreamingPullResponse_ModifyAckDeadlineConfirmation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modify_ack_deadline_confirmation(&mut self) {
        self.modify_ack_deadline_confirmation.clear();
    }

    pub fn has_modify_ack_deadline_confirmation(&self) -> bool {
        self.modify_ack_deadline_confirmation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modify_ack_deadline_confirmation(&mut self, v: StreamingPullResponse_ModifyAckDeadlineConfirmation) {
        self.modify_ack_deadline_confirmation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modify_ack_deadline_confirmation(&mut self) -> &mut StreamingPullResponse_ModifyAckDeadlineConfirmation {
        if self.modify_ack_deadline_confirmation.is_none() {
            self.modify_ack_deadline_confirmation.set_default();
        }
        self.modify_ack_deadline_confirmation.as_mut().unwrap()
    }

    // Take field
    pub fn take_modify_ack_deadline_confirmation(&mut self) -> StreamingPullResponse_ModifyAckDeadlineConfirmation {
        self.modify_ack_deadline_confirmation.take().unwrap_or_else(|| StreamingPullResponse_ModifyAckDeadlineConfirmation::new())
    }

    // .google.pubsub.v1.StreamingPullResponse.SubscriptionProperties subscription_properties = 4;


    pub fn get_subscription_properties(&self) -> &StreamingPullResponse_SubscriptionProperties {
        self.subscription_properties.as_ref().unwrap_or_else(|| <StreamingPullResponse_SubscriptionProperties as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subscription_properties(&mut self) {
        self.subscription_properties.clear();
    }

    pub fn has_subscription_properties(&self) -> bool {
        self.subscription_properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription_properties(&mut self, v: StreamingPullResponse_SubscriptionProperties) {
        self.subscription_properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription_properties(&mut self) -> &mut StreamingPullResponse_SubscriptionProperties {
        if self.subscription_properties.is_none() {
            self.subscription_properties.set_default();
        }
        self.subscription_properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription_properties(&mut self) -> StreamingPullResponse_SubscriptionProperties {
        self.subscription_properties.take().unwrap_or_else(|| StreamingPullResponse_SubscriptionProperties::new())
    }
}

impl ::protobuf::Message for StreamingPullResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.received_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acknowledge_confirmation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modify_ack_deadline_confirmation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscription_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.received_messages)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acknowledge_confirmation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modify_ack_deadline_confirmation)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscription_properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.received_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.acknowledge_confirmation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modify_ack_deadline_confirmation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subscription_properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.received_messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.acknowledge_confirmation.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modify_ack_deadline_confirmation.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subscription_properties.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingPullResponse {
        StreamingPullResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceivedMessage>>(
                "received_messages",
                |m: &StreamingPullResponse| { &m.received_messages },
                |m: &mut StreamingPullResponse| { &mut m.received_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamingPullResponse_AcknowledgeConfirmation>>(
                "acknowledge_confirmation",
                |m: &StreamingPullResponse| { &m.acknowledge_confirmation },
                |m: &mut StreamingPullResponse| { &mut m.acknowledge_confirmation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamingPullResponse_ModifyAckDeadlineConfirmation>>(
                "modify_ack_deadline_confirmation",
                |m: &StreamingPullResponse| { &m.modify_ack_deadline_confirmation },
                |m: &mut StreamingPullResponse| { &mut m.modify_ack_deadline_confirmation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamingPullResponse_SubscriptionProperties>>(
                "subscription_properties",
                |m: &StreamingPullResponse| { &m.subscription_properties },
                |m: &mut StreamingPullResponse| { &mut m.subscription_properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamingPullResponse>(
                "StreamingPullResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamingPullResponse {
        static instance: ::protobuf::rt::LazyV2<StreamingPullResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamingPullResponse::new)
    }
}

impl ::protobuf::Clear for StreamingPullResponse {
    fn clear(&mut self) {
        self.received_messages.clear();
        self.acknowledge_confirmation.clear();
        self.modify_ack_deadline_confirmation.clear();
        self.subscription_properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingPullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingPullResponse_AcknowledgeConfirmation {
    // message fields
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub invalid_ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub unordered_ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub temporary_failed_ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingPullResponse_AcknowledgeConfirmation {
    fn default() -> &'a StreamingPullResponse_AcknowledgeConfirmation {
        <StreamingPullResponse_AcknowledgeConfirmation as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullResponse_AcknowledgeConfirmation {
    pub fn new() -> StreamingPullResponse_AcknowledgeConfirmation {
        ::std::default::Default::default()
    }

    // repeated string ack_ids = 1;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string invalid_ack_ids = 2;


    pub fn get_invalid_ack_ids(&self) -> &[::std::string::String] {
        &self.invalid_ack_ids
    }
    pub fn clear_invalid_ack_ids(&mut self) {
        self.invalid_ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_invalid_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.invalid_ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invalid_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.invalid_ack_ids
    }

    // Take field
    pub fn take_invalid_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.invalid_ack_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string unordered_ack_ids = 3;


    pub fn get_unordered_ack_ids(&self) -> &[::std::string::String] {
        &self.unordered_ack_ids
    }
    pub fn clear_unordered_ack_ids(&mut self) {
        self.unordered_ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_unordered_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.unordered_ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unordered_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.unordered_ack_ids
    }

    // Take field
    pub fn take_unordered_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.unordered_ack_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string temporary_failed_ack_ids = 4;


    pub fn get_temporary_failed_ack_ids(&self) -> &[::std::string::String] {
        &self.temporary_failed_ack_ids
    }
    pub fn clear_temporary_failed_ack_ids(&mut self) {
        self.temporary_failed_ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_temporary_failed_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.temporary_failed_ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_temporary_failed_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.temporary_failed_ack_ids
    }

    // Take field
    pub fn take_temporary_failed_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.temporary_failed_ack_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamingPullResponse_AcknowledgeConfirmation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.invalid_ack_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.unordered_ack_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.temporary_failed_ack_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.invalid_ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.unordered_ack_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.temporary_failed_ack_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ack_ids {
            os.write_string(1, &v)?;
        };
        for v in &self.invalid_ack_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.unordered_ack_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.temporary_failed_ack_ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingPullResponse_AcknowledgeConfirmation {
        StreamingPullResponse_AcknowledgeConfirmation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ack_ids",
                |m: &StreamingPullResponse_AcknowledgeConfirmation| { &m.ack_ids },
                |m: &mut StreamingPullResponse_AcknowledgeConfirmation| { &mut m.ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invalid_ack_ids",
                |m: &StreamingPullResponse_AcknowledgeConfirmation| { &m.invalid_ack_ids },
                |m: &mut StreamingPullResponse_AcknowledgeConfirmation| { &mut m.invalid_ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unordered_ack_ids",
                |m: &StreamingPullResponse_AcknowledgeConfirmation| { &m.unordered_ack_ids },
                |m: &mut StreamingPullResponse_AcknowledgeConfirmation| { &mut m.unordered_ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "temporary_failed_ack_ids",
                |m: &StreamingPullResponse_AcknowledgeConfirmation| { &m.temporary_failed_ack_ids },
                |m: &mut StreamingPullResponse_AcknowledgeConfirmation| { &mut m.temporary_failed_ack_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamingPullResponse_AcknowledgeConfirmation>(
                "StreamingPullResponse.AcknowledgeConfirmation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamingPullResponse_AcknowledgeConfirmation {
        static instance: ::protobuf::rt::LazyV2<StreamingPullResponse_AcknowledgeConfirmation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamingPullResponse_AcknowledgeConfirmation::new)
    }
}

impl ::protobuf::Clear for StreamingPullResponse_AcknowledgeConfirmation {
    fn clear(&mut self) {
        self.ack_ids.clear();
        self.invalid_ack_ids.clear();
        self.unordered_ack_ids.clear();
        self.temporary_failed_ack_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingPullResponse_AcknowledgeConfirmation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullResponse_AcknowledgeConfirmation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingPullResponse_ModifyAckDeadlineConfirmation {
    // message fields
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub invalid_ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub temporary_failed_ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingPullResponse_ModifyAckDeadlineConfirmation {
    fn default() -> &'a StreamingPullResponse_ModifyAckDeadlineConfirmation {
        <StreamingPullResponse_ModifyAckDeadlineConfirmation as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullResponse_ModifyAckDeadlineConfirmation {
    pub fn new() -> StreamingPullResponse_ModifyAckDeadlineConfirmation {
        ::std::default::Default::default()
    }

    // repeated string ack_ids = 1;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string invalid_ack_ids = 2;


    pub fn get_invalid_ack_ids(&self) -> &[::std::string::String] {
        &self.invalid_ack_ids
    }
    pub fn clear_invalid_ack_ids(&mut self) {
        self.invalid_ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_invalid_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.invalid_ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invalid_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.invalid_ack_ids
    }

    // Take field
    pub fn take_invalid_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.invalid_ack_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string temporary_failed_ack_ids = 3;


    pub fn get_temporary_failed_ack_ids(&self) -> &[::std::string::String] {
        &self.temporary_failed_ack_ids
    }
    pub fn clear_temporary_failed_ack_ids(&mut self) {
        self.temporary_failed_ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_temporary_failed_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.temporary_failed_ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_temporary_failed_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.temporary_failed_ack_ids
    }

    // Take field
    pub fn take_temporary_failed_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.temporary_failed_ack_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamingPullResponse_ModifyAckDeadlineConfirmation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.invalid_ack_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.temporary_failed_ack_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.invalid_ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.temporary_failed_ack_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ack_ids {
            os.write_string(1, &v)?;
        };
        for v in &self.invalid_ack_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.temporary_failed_ack_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingPullResponse_ModifyAckDeadlineConfirmation {
        StreamingPullResponse_ModifyAckDeadlineConfirmation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ack_ids",
                |m: &StreamingPullResponse_ModifyAckDeadlineConfirmation| { &m.ack_ids },
                |m: &mut StreamingPullResponse_ModifyAckDeadlineConfirmation| { &mut m.ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invalid_ack_ids",
                |m: &StreamingPullResponse_ModifyAckDeadlineConfirmation| { &m.invalid_ack_ids },
                |m: &mut StreamingPullResponse_ModifyAckDeadlineConfirmation| { &mut m.invalid_ack_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "temporary_failed_ack_ids",
                |m: &StreamingPullResponse_ModifyAckDeadlineConfirmation| { &m.temporary_failed_ack_ids },
                |m: &mut StreamingPullResponse_ModifyAckDeadlineConfirmation| { &mut m.temporary_failed_ack_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamingPullResponse_ModifyAckDeadlineConfirmation>(
                "StreamingPullResponse.ModifyAckDeadlineConfirmation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamingPullResponse_ModifyAckDeadlineConfirmation {
        static instance: ::protobuf::rt::LazyV2<StreamingPullResponse_ModifyAckDeadlineConfirmation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamingPullResponse_ModifyAckDeadlineConfirmation::new)
    }
}

impl ::protobuf::Clear for StreamingPullResponse_ModifyAckDeadlineConfirmation {
    fn clear(&mut self) {
        self.ack_ids.clear();
        self.invalid_ack_ids.clear();
        self.temporary_failed_ack_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingPullResponse_ModifyAckDeadlineConfirmation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullResponse_ModifyAckDeadlineConfirmation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingPullResponse_SubscriptionProperties {
    // message fields
    pub exactly_once_delivery_enabled: bool,
    pub message_ordering_enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingPullResponse_SubscriptionProperties {
    fn default() -> &'a StreamingPullResponse_SubscriptionProperties {
        <StreamingPullResponse_SubscriptionProperties as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullResponse_SubscriptionProperties {
    pub fn new() -> StreamingPullResponse_SubscriptionProperties {
        ::std::default::Default::default()
    }

    // bool exactly_once_delivery_enabled = 1;


    pub fn get_exactly_once_delivery_enabled(&self) -> bool {
        self.exactly_once_delivery_enabled
    }
    pub fn clear_exactly_once_delivery_enabled(&mut self) {
        self.exactly_once_delivery_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_exactly_once_delivery_enabled(&mut self, v: bool) {
        self.exactly_once_delivery_enabled = v;
    }

    // bool message_ordering_enabled = 2;


    pub fn get_message_ordering_enabled(&self) -> bool {
        self.message_ordering_enabled
    }
    pub fn clear_message_ordering_enabled(&mut self) {
        self.message_ordering_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_message_ordering_enabled(&mut self, v: bool) {
        self.message_ordering_enabled = v;
    }
}

impl ::protobuf::Message for StreamingPullResponse_SubscriptionProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exactly_once_delivery_enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.message_ordering_enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.exactly_once_delivery_enabled != false {
            my_size += 2;
        }
        if self.message_ordering_enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.exactly_once_delivery_enabled != false {
            os.write_bool(1, self.exactly_once_delivery_enabled)?;
        }
        if self.message_ordering_enabled != false {
            os.write_bool(2, self.message_ordering_enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingPullResponse_SubscriptionProperties {
        StreamingPullResponse_SubscriptionProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "exactly_once_delivery_enabled",
                |m: &StreamingPullResponse_SubscriptionProperties| { &m.exactly_once_delivery_enabled },
                |m: &mut StreamingPullResponse_SubscriptionProperties| { &mut m.exactly_once_delivery_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "message_ordering_enabled",
                |m: &StreamingPullResponse_SubscriptionProperties| { &m.message_ordering_enabled },
                |m: &mut StreamingPullResponse_SubscriptionProperties| { &mut m.message_ordering_enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamingPullResponse_SubscriptionProperties>(
                "StreamingPullResponse.SubscriptionProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamingPullResponse_SubscriptionProperties {
        static instance: ::protobuf::rt::LazyV2<StreamingPullResponse_SubscriptionProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamingPullResponse_SubscriptionProperties::new)
    }
}

impl ::protobuf::Clear for StreamingPullResponse_SubscriptionProperties {
    fn clear(&mut self) {
        self.exactly_once_delivery_enabled = false;
        self.message_ordering_enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingPullResponse_SubscriptionProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullResponse_SubscriptionProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotRequest {
    // message fields
    pub name: ::std::string::String,
    pub subscription: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSnapshotRequest {
    fn default() -> &'a CreateSnapshotRequest {
        <CreateSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSnapshotRequest {
    pub fn new() -> CreateSnapshotRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string subscription = 2;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.CreateSnapshotRequest.LabelsEntry labels = 3;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for CreateSnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subscription);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.subscription.is_empty() {
            os.write_string(2, &self.subscription)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSnapshotRequest {
        CreateSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateSnapshotRequest| { &m.name },
                |m: &mut CreateSnapshotRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &CreateSnapshotRequest| { &m.subscription },
                |m: &mut CreateSnapshotRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &CreateSnapshotRequest| { &m.labels },
                |m: &mut CreateSnapshotRequest| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSnapshotRequest>(
                "CreateSnapshotRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSnapshotRequest {
        static instance: ::protobuf::rt::LazyV2<CreateSnapshotRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSnapshotRequest::new)
    }
}

impl ::protobuf::Clear for CreateSnapshotRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.subscription.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSnapshotRequest {
    // message fields
    pub snapshot: ::protobuf::SingularPtrField<Snapshot>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSnapshotRequest {
    fn default() -> &'a UpdateSnapshotRequest {
        <UpdateSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSnapshotRequest {
    pub fn new() -> UpdateSnapshotRequest {
        ::std::default::Default::default()
    }

    // .google.pubsub.v1.Snapshot snapshot = 1;


    pub fn get_snapshot(&self) -> &Snapshot {
        self.snapshot.as_ref().unwrap_or_else(|| <Snapshot as ::protobuf::Message>::default_instance())
    }
    pub fn clear_snapshot(&mut self) {
        self.snapshot.clear();
    }

    pub fn has_snapshot(&self) -> bool {
        self.snapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: Snapshot) {
        self.snapshot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshot(&mut self) -> &mut Snapshot {
        if self.snapshot.is_none() {
            self.snapshot.set_default();
        }
        self.snapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshot(&mut self) -> Snapshot {
        self.snapshot.take().unwrap_or_else(|| Snapshot::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateSnapshotRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshot.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSnapshotRequest {
        UpdateSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Snapshot>>(
                "snapshot",
                |m: &UpdateSnapshotRequest| { &m.snapshot },
                |m: &mut UpdateSnapshotRequest| { &mut m.snapshot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateSnapshotRequest| { &m.update_mask },
                |m: &mut UpdateSnapshotRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSnapshotRequest>(
                "UpdateSnapshotRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSnapshotRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateSnapshotRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSnapshotRequest::new)
    }
}

impl ::protobuf::Clear for UpdateSnapshotRequest {
    fn clear(&mut self) {
        self.snapshot.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Snapshot {
    // message fields
    pub name: ::std::string::String,
    pub topic: ::std::string::String,
    pub expire_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Snapshot {
    fn default() -> &'a Snapshot {
        <Snapshot as ::protobuf::Message>::default_instance()
    }
}

impl Snapshot {
    pub fn new() -> Snapshot {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string topic = 2;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp expire_time = 3;


    pub fn get_expire_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expire_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time.clear();
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expire_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expire_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expire_time.is_none() {
            self.expire_time.set_default();
        }
        self.expire_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_expire_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expire_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .google.pubsub.v1.Snapshot.LabelsEntry labels = 4;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Snapshot {
    fn is_initialized(&self) -> bool {
        for v in &self.expire_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expire_time)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Snapshot {
        Snapshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Snapshot| { &m.name },
                |m: &mut Snapshot| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &Snapshot| { &m.topic },
                |m: &mut Snapshot| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expire_time",
                |m: &Snapshot| { &m.expire_time },
                |m: &mut Snapshot| { &mut m.expire_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Snapshot| { &m.labels },
                |m: &mut Snapshot| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Snapshot>(
                "Snapshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Snapshot {
        static instance: ::protobuf::rt::LazyV2<Snapshot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Snapshot::new)
    }
}

impl ::protobuf::Clear for Snapshot {
    fn clear(&mut self) {
        self.name.clear();
        self.topic.clear();
        self.expire_time.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Snapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Snapshot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotRequest {
    // message fields
    pub snapshot: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotRequest {
    fn default() -> &'a GetSnapshotRequest {
        <GetSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotRequest {
    pub fn new() -> GetSnapshotRequest {
        ::std::default::Default::default()
    }

    // string snapshot = 1;


    pub fn get_snapshot(&self) -> &str {
        &self.snapshot
    }
    pub fn clear_snapshot(&mut self) {
        self.snapshot.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: ::std::string::String) {
        self.snapshot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshot(&mut self) -> &mut ::std::string::String {
        &mut self.snapshot
    }

    // Take field
    pub fn take_snapshot(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.snapshot, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.snapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.snapshot.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.snapshot.is_empty() {
            os.write_string(1, &self.snapshot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotRequest {
        GetSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshot",
                |m: &GetSnapshotRequest| { &m.snapshot },
                |m: &mut GetSnapshotRequest| { &mut m.snapshot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshotRequest>(
                "GetSnapshotRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshotRequest {
        static instance: ::protobuf::rt::LazyV2<GetSnapshotRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshotRequest::new)
    }
}

impl ::protobuf::Clear for GetSnapshotRequest {
    fn clear(&mut self) {
        self.snapshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSnapshotsRequest {
    // message fields
    pub project: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSnapshotsRequest {
    fn default() -> &'a ListSnapshotsRequest {
        <ListSnapshotsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotsRequest {
    pub fn new() -> ListSnapshotsRequest {
        ::std::default::Default::default()
    }

    // string project = 1;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSnapshotsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSnapshotsRequest {
        ListSnapshotsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project",
                |m: &ListSnapshotsRequest| { &m.project },
                |m: &mut ListSnapshotsRequest| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListSnapshotsRequest| { &m.page_size },
                |m: &mut ListSnapshotsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListSnapshotsRequest| { &m.page_token },
                |m: &mut ListSnapshotsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSnapshotsRequest>(
                "ListSnapshotsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSnapshotsRequest {
        static instance: ::protobuf::rt::LazyV2<ListSnapshotsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSnapshotsRequest::new)
    }
}

impl ::protobuf::Clear for ListSnapshotsRequest {
    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSnapshotsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSnapshotsResponse {
    // message fields
    pub snapshots: ::protobuf::RepeatedField<Snapshot>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSnapshotsResponse {
    fn default() -> &'a ListSnapshotsResponse {
        <ListSnapshotsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotsResponse {
    pub fn new() -> ListSnapshotsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.Snapshot snapshots = 1;


    pub fn get_snapshots(&self) -> &[Snapshot] {
        &self.snapshots
    }
    pub fn clear_snapshots(&mut self) {
        self.snapshots.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshots(&mut self, v: ::protobuf::RepeatedField<Snapshot>) {
        self.snapshots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshots(&mut self) -> &mut ::protobuf::RepeatedField<Snapshot> {
        &mut self.snapshots
    }

    // Take field
    pub fn take_snapshots(&mut self) -> ::protobuf::RepeatedField<Snapshot> {
        ::std::mem::replace(&mut self.snapshots, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSnapshotsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.snapshots)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.snapshots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.snapshots {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSnapshotsResponse {
        ListSnapshotsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Snapshot>>(
                "snapshots",
                |m: &ListSnapshotsResponse| { &m.snapshots },
                |m: &mut ListSnapshotsResponse| { &mut m.snapshots },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListSnapshotsResponse| { &m.next_page_token },
                |m: &mut ListSnapshotsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSnapshotsResponse>(
                "ListSnapshotsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSnapshotsResponse {
        static instance: ::protobuf::rt::LazyV2<ListSnapshotsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSnapshotsResponse::new)
    }
}

impl ::protobuf::Clear for ListSnapshotsResponse {
    fn clear(&mut self) {
        self.snapshots.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSnapshotsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotRequest {
    // message fields
    pub snapshot: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSnapshotRequest {
    fn default() -> &'a DeleteSnapshotRequest {
        <DeleteSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSnapshotRequest {
    pub fn new() -> DeleteSnapshotRequest {
        ::std::default::Default::default()
    }

    // string snapshot = 1;


    pub fn get_snapshot(&self) -> &str {
        &self.snapshot
    }
    pub fn clear_snapshot(&mut self) {
        self.snapshot.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: ::std::string::String) {
        self.snapshot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshot(&mut self) -> &mut ::std::string::String {
        &mut self.snapshot
    }

    // Take field
    pub fn take_snapshot(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.snapshot, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.snapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.snapshot.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.snapshot.is_empty() {
            os.write_string(1, &self.snapshot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSnapshotRequest {
        DeleteSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshot",
                |m: &DeleteSnapshotRequest| { &m.snapshot },
                |m: &mut DeleteSnapshotRequest| { &mut m.snapshot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSnapshotRequest>(
                "DeleteSnapshotRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSnapshotRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteSnapshotRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSnapshotRequest::new)
    }
}

impl ::protobuf::Clear for DeleteSnapshotRequest {
    fn clear(&mut self) {
        self.snapshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeekRequest {
    // message fields
    pub subscription: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<SeekRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeekRequest {
    fn default() -> &'a SeekRequest {
        <SeekRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SeekRequest_oneof_target {
    time(::protobuf::well_known_types::Timestamp),
    snapshot(::std::string::String),
}

impl SeekRequest {
    pub fn new() -> SeekRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp time = 2;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::time(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_time(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.target = ::std::option::Option::Some(SeekRequest_oneof_target::time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(SeekRequest_oneof_target::time(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(SeekRequest_oneof_target::time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_time() {
            match self.target.take() {
                ::std::option::Option::Some(SeekRequest_oneof_target::time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // string snapshot = 3;


    pub fn get_snapshot(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_snapshot(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_snapshot(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_snapshot(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_snapshot(&mut self) -> ::std::string::String {
        if self.has_snapshot() {
            match self.target.take() {
                ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for SeekRequest {
    fn is_initialized(&self) -> bool {
        if let Some(SeekRequest_oneof_target::time(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(SeekRequest_oneof_target::time(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &SeekRequest_oneof_target::time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SeekRequest_oneof_target::snapshot(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &SeekRequest_oneof_target::time(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SeekRequest_oneof_target::snapshot(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeekRequest {
        SeekRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscription",
                |m: &SeekRequest| { &m.subscription },
                |m: &mut SeekRequest| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "time",
                SeekRequest::has_time,
                SeekRequest::get_time,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "snapshot",
                SeekRequest::has_snapshot,
                SeekRequest::get_snapshot,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeekRequest>(
                "SeekRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeekRequest {
        static instance: ::protobuf::rt::LazyV2<SeekRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeekRequest::new)
    }
}

impl ::protobuf::Clear for SeekRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeekRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeekResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeekResponse {
    fn default() -> &'a SeekResponse {
        <SeekResponse as ::protobuf::Message>::default_instance()
    }
}

impl SeekResponse {
    pub fn new() -> SeekResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SeekResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeekResponse {
        SeekResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeekResponse>(
                "SeekResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeekResponse {
        static instance: ::protobuf::rt::LazyV2<SeekResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeekResponse::new)
    }
}

impl ::protobuf::Clear for SeekResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeekResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dgoogle/pubsub/v1/pubsub.proto\x12\x10google.pubsub.v1\x1a\x1cgoogl\
    e/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api\
    /field_behavior.proto\x1a\x19google/api/resource.proto\x1a\x1egoogle/pro\
    tobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x20google/pr\
    otobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1dgo\
    ogle/pubsub/v1/schema.proto\"V\n\x14MessageStoragePolicy\x12>\n\x1ballow\
    ed_persistence_regions\x18\x01\x20\x03(\tR\x19allowedPersistenceRegions\
    \"\xdc\x01\n\x0eSchemaSettings\x12<\n\x06schema\x18\x01\x20\x01(\tR\x06s\
    chemaB$\xfaA\x1e\n\x1cpubsub.googleapis.com/Schema\xe0A\x02\x126\n\x08en\
    coding\x18\x02\x20\x01(\x0e2\x1a.google.pubsub.v1.EncodingR\x08encoding\
    \x12*\n\x11first_revision_id\x18\x03\x20\x01(\tR\x0ffirstRevisionId\x12(\
    \n\x10last_revision_id\x18\x04\x20\x01(\tR\x0elastRevisionId\"\xb7\x04\n\
    \x05Topic\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x03\xe0A\x02\
    \x12;\n\x06labels\x18\x02\x20\x03(\x0b2#.google.pubsub.v1.Topic.LabelsEn\
    tryR\x06labels\x12\\\n\x16message_storage_policy\x18\x03\x20\x01(\x0b2&.\
    google.pubsub.v1.MessageStoragePolicyR\x14messageStoragePolicy\x12\x20\n\
    \x0ckms_key_name\x18\x05\x20\x01(\tR\nkmsKeyName\x12I\n\x0fschema_settin\
    gs\x18\x06\x20\x01(\x0b2\x20.google.pubsub.v1.SchemaSettingsR\x0eschemaS\
    ettings\x12#\n\rsatisfies_pzs\x18\x07\x20\x01(\x08R\x0csatisfiesPzs\x12W\
    \n\x1amessage_retention_duration\x18\x08\x20\x01(\x0b2\x19.google.protob\
    uf.DurationR\x18messageRetentionDuration\x1a9\n\x0bLabelsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01:T\xeaAQ\n\x1bpubsub.googleapis.com/Topic\x12!projec\
    ts/{project}/topics/{topic}\x12\x0f_deleted-topic_\"\xb4\x02\n\rPubsubMe\
    ssage\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12O\n\nattributes\
    \x18\x02\x20\x03(\x0b2/.google.pubsub.v1.PubsubMessage.AttributesEntryR\
    \nattributes\x12\x1d\n\nmessage_id\x18\x03\x20\x01(\tR\tmessageId\x12=\n\
    \x0cpublish_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x0bpublishTime\x12!\n\x0cordering_key\x18\x05\x20\x01(\tR\x0borderingKe\
    y\x1a=\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"L\n\x0fGetTo\
    picRequest\x129\n\x05topic\x18\x01\x20\x01(\tR\x05topicB#\xfaA\x1d\n\x1b\
    pubsub.googleapis.com/Topic\xe0A\x02\"\x8a\x01\n\x12UpdateTopicRequest\
    \x122\n\x05topic\x18\x01\x20\x01(\x0b2\x17.google.pubsub.v1.TopicR\x05to\
    picB\x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google\
    .protobuf.FieldMaskR\nupdateMaskB\x03\xe0A\x02\"\x8d\x01\n\x0ePublishReq\
    uest\x129\n\x05topic\x18\x01\x20\x01(\tR\x05topicB#\xfaA\x1d\n\x1bpubsub\
    .googleapis.com/Topic\xe0A\x02\x12@\n\x08messages\x18\x02\x20\x03(\x0b2\
    \x1f.google.pubsub.v1.PubsubMessageR\x08messagesB\x03\xe0A\x02\"2\n\x0fP\
    ublishResponse\x12\x1f\n\x0bmessage_ids\x18\x01\x20\x03(\tR\nmessageIds\
    \"\x9e\x01\n\x11ListTopicsRequest\x12M\n\x07project\x18\x01\x20\x01(\tR\
    \x07projectB3\xfaA-\n+cloudresourcemanager.googleapis.com/Project\xe0A\
    \x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\np\
    age_token\x18\x03\x20\x01(\tR\tpageToken\"m\n\x12ListTopicsResponse\x12/\
    \n\x06topics\x18\x01\x20\x03(\x0b2\x17.google.pubsub.v1.TopicR\x06topics\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\x96\x01\
    \n\x1dListTopicSubscriptionsRequest\x129\n\x05topic\x18\x01\x20\x01(\tR\
    \x05topicB#\xfaA\x1d\n\x1bpubsub.googleapis.com/Topic\xe0A\x02\x12\x1b\n\
    \tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\
    \x03\x20\x01(\tR\tpageToken\"\x97\x01\n\x1eListTopicSubscriptionsRespons\
    e\x12M\n\rsubscriptions\x18\x01\x20\x03(\tR\rsubscriptionsB'\xfaA$\n\"pu\
    bsub.googleapis.com/Subscription\x12&\n\x0fnext_page_token\x18\x02\x20\
    \x01(\tR\rnextPageToken\"\x92\x01\n\x19ListTopicSnapshotsRequest\x129\n\
    \x05topic\x18\x01\x20\x01(\tR\x05topicB#\xfaA\x1d\n\x1bpubsub.googleapis\
    .com/Topic\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSi\
    ze\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"b\n\x1aListTopi\
    cSnapshotsResponse\x12\x1c\n\tsnapshots\x18\x01\x20\x03(\tR\tsnapshots\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"O\n\x12De\
    leteTopicRequest\x129\n\x05topic\x18\x01\x20\x01(\tR\x05topicB#\xfaA\x1d\
    \n\x1bpubsub.googleapis.com/Topic\xe0A\x02\"k\n\x19DetachSubscriptionReq\
    uest\x12N\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscriptionB*\xfaA$\
    \n\"pubsub.googleapis.com/Subscription\xe0A\x02\"\x1c\n\x1aDetachSubscri\
    ptionResponse\"\xd8\n\n\x0cSubscription\x12\x17\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\x03\xe0A\x02\x129\n\x05topic\x18\x02\x20\x01(\tR\x05to\
    picB#\xfaA\x1d\n\x1bpubsub.googleapis.com/Topic\xe0A\x02\x12=\n\x0bpush_\
    config\x18\x04\x20\x01(\x0b2\x1c.google.pubsub.v1.PushConfigR\npushConfi\
    g\x12I\n\x0fbigquery_config\x18\x12\x20\x01(\x0b2\x20.google.pubsub.v1.B\
    igQueryConfigR\x0ebigqueryConfig\x12V\n\x14cloud_storage_config\x18\x16\
    \x20\x01(\x0b2$.google.pubsub.v1.CloudStorageConfigR\x12cloudStorageConf\
    ig\x120\n\x14ack_deadline_seconds\x18\x05\x20\x01(\x05R\x12ackDeadlineSe\
    conds\x122\n\x15retain_acked_messages\x18\x07\x20\x01(\x08R\x13retainAck\
    edMessages\x12W\n\x1amessage_retention_duration\x18\x08\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\x18messageRetentionDuration\x12B\n\x06lab\
    els\x18\t\x20\x03(\x0b2*.google.pubsub.v1.Subscription.LabelsEntryR\x06l\
    abels\x126\n\x17enable_message_ordering\x18\n\x20\x01(\x08R\x15enableMes\
    sageOrdering\x12O\n\x11expiration_policy\x18\x0b\x20\x01(\x0b2\".google.\
    pubsub.v1.ExpirationPolicyR\x10expirationPolicy\x12\x16\n\x06filter\x18\
    \x0c\x20\x01(\tR\x06filter\x12P\n\x12dead_letter_policy\x18\r\x20\x01(\
    \x0b2\".google.pubsub.v1.DeadLetterPolicyR\x10deadLetterPolicy\x12@\n\
    \x0cretry_policy\x18\x0e\x20\x01(\x0b2\x1d.google.pubsub.v1.RetryPolicyR\
    \x0bretryPolicy\x12\x1a\n\x08detached\x18\x0f\x20\x01(\x08R\x08detached\
    \x12?\n\x1cenable_exactly_once_delivery\x18\x10\x20\x01(\x08R\x19enableE\
    xactlyOnceDelivery\x12g\n\x20topic_message_retention_duration\x18\x11\
    \x20\x01(\x0b2\x19.google.protobuf.DurationR\x1dtopicMessageRetentionDur\
    ationB\x03\xe0A\x03\x12?\n\x05state\x18\x13\x20\x01(\x0e2$.google.pubsub\
    .v1.Subscription.StateR\x05stateB\x03\xe0A\x03\x1a9\n\x0bLabelsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\">\n\x05State\x12\x15\n\x11STATE_UNSPECIFIED\
    \x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x12\n\x0eRESOURCE_ERROR\x10\x02:X\
    \xeaAU\n\"pubsub.googleapis.com/Subscription\x12/projects/{project}/subs\
    criptions/{subscription}\"\x95\x01\n\x0bRetryPolicy\x12B\n\x0fminimum_ba\
    ckoff\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0eminimumBack\
    off\x12B\n\x0fmaximum_backoff\x18\x02\x20\x01(\x0b2\x19.google.protobuf.\
    DurationR\x0emaximumBackoff\"r\n\x10DeadLetterPolicy\x12*\n\x11dead_lett\
    er_topic\x18\x01\x20\x01(\tR\x0fdeadLetterTopic\x122\n\x15max_delivery_a\
    ttempts\x18\x02\x20\x01(\x05R\x13maxDeliveryAttempts\"?\n\x10ExpirationP\
    olicy\x12+\n\x03ttl\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\
    \x03ttl\"\xeb\x04\n\nPushConfig\x12#\n\rpush_endpoint\x18\x01\x20\x01(\t\
    R\x0cpushEndpoint\x12L\n\nattributes\x18\x02\x20\x03(\x0b2,.google.pubsu\
    b.v1.PushConfig.AttributesEntryR\nattributes\x12G\n\noidc_token\x18\x03\
    \x20\x01(\x0b2&.google.pubsub.v1.PushConfig.OidcTokenH\0R\toidcToken\x12\
    S\n\x0epubsub_wrapper\x18\x04\x20\x01(\x0b2*.google.pubsub.v1.PushConfig\
    .PubsubWrapperH\x01R\rpubsubWrapper\x12G\n\nno_wrapper\x18\x05\x20\x01(\
    \x0b2&.google.pubsub.v1.PushConfig.NoWrapperH\x01R\tnoWrapper\x1a[\n\tOi\
    dcToken\x122\n\x15service_account_email\x18\x01\x20\x01(\tR\x13serviceAc\
    countEmail\x12\x1a\n\x08audience\x18\x02\x20\x01(\tR\x08audience\x1a\x0f\
    \n\rPubsubWrapper\x1a2\n\tNoWrapper\x12%\n\x0ewrite_metadata\x18\x01\x20\
    \x01(\x08R\rwriteMetadata\x1a=\n\x0fAttributesEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01B\x17\n\x15authentication_methodB\t\n\x07wrapper\"\x85\x03\n\
    \x0eBigQueryConfig\x12\x14\n\x05table\x18\x01\x20\x01(\tR\x05table\x12-\
    \n\x10use_topic_schema\x18\x02\x20\x01(\x08R\x0euseTopicSchemaB\x03\xe0A\
    \x01\x12%\n\x0ewrite_metadata\x18\x03\x20\x01(\x08R\rwriteMetadata\x12.\
    \n\x13drop_unknown_fields\x18\x04\x20\x01(\x08R\x11dropUnknownFields\x12\
    A\n\x05state\x18\x05\x20\x01(\x0e2&.google.pubsub.v1.BigQueryConfig.Stat\
    eR\x05stateB\x03\xe0A\x03\x12-\n\x10use_table_schema\x18\x06\x20\x01(\
    \x08R\x0euseTableSchemaB\x03\xe0A\x01\"e\n\x05State\x12\x15\n\x11STATE_U\
    NSPECIFIED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x15\n\x11PERMISSION_DENIE\
    D\x10\x02\x12\r\n\tNOT_FOUND\x10\x03\x12\x13\n\x0fSCHEMA_MISMATCH\x10\
    \x04\"\xf3\x04\n\x12CloudStorageConfig\x12\x1b\n\x06bucket\x18\x01\x20\
    \x01(\tR\x06bucketB\x03\xe0A\x02\x12'\n\x0ffilename_prefix\x18\x02\x20\
    \x01(\tR\x0efilenamePrefix\x12'\n\x0ffilename_suffix\x18\x03\x20\x01(\tR\
    \x0efilenameSuffix\x12R\n\x0btext_config\x18\x04\x20\x01(\x0b2/.google.p\
    ubsub.v1.CloudStorageConfig.TextConfigH\0R\ntextConfig\x12R\n\x0bavro_co\
    nfig\x18\x05\x20\x01(\x0b2/.google.pubsub.v1.CloudStorageConfig.AvroConf\
    igH\0R\navroConfig\x12<\n\x0cmax_duration\x18\x06\x20\x01(\x0b2\x19.goog\
    le.protobuf.DurationR\x0bmaxDuration\x12\x1b\n\tmax_bytes\x18\x07\x20\
    \x01(\x03R\x08maxBytes\x12E\n\x05state\x18\t\x20\x01(\x0e2*.google.pubsu\
    b.v1.CloudStorageConfig.StateR\x05stateB\x03\xe0A\x03\x1a\x0c\n\nTextCon\
    fig\x1a3\n\nAvroConfig\x12%\n\x0ewrite_metadata\x18\x01\x20\x01(\x08R\rw\
    riteMetadata\"P\n\x05State\x12\x15\n\x11STATE_UNSPECIFIED\x10\0\x12\n\n\
    \x06ACTIVE\x10\x01\x12\x15\n\x11PERMISSION_DENIED\x10\x02\x12\r\n\tNOT_F\
    OUND\x10\x03B\x0f\n\routput_format\"\x8e\x01\n\x0fReceivedMessage\x12\
    \x15\n\x06ack_id\x18\x01\x20\x01(\tR\x05ackId\x129\n\x07message\x18\x02\
    \x20\x01(\x0b2\x1f.google.pubsub.v1.PubsubMessageR\x07message\x12)\n\x10\
    delivery_attempt\x18\x03\x20\x01(\x05R\x0fdeliveryAttempt\"h\n\x16GetSub\
    scriptionRequest\x12N\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscript\
    ionB*\xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\x02\"\xa6\x01\n\
    \x19UpdateSubscriptionRequest\x12G\n\x0csubscription\x18\x01\x20\x01(\
    \x0b2\x1e.google.pubsub.v1.SubscriptionR\x0csubscriptionB\x03\xe0A\x02\
    \x12@\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMa\
    skR\nupdateMaskB\x03\xe0A\x02\"\xa5\x01\n\x18ListSubscriptionsRequest\
    \x12M\n\x07project\x18\x01\x20\x01(\tR\x07projectB3\xfaA-\n+cloudresourc\
    emanager.googleapis.com/Project\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\
    \x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpa\
    geToken\"\x89\x01\n\x19ListSubscriptionsResponse\x12D\n\rsubscriptions\
    \x18\x01\x20\x03(\x0b2\x1e.google.pubsub.v1.SubscriptionR\rsubscriptions\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"k\n\x19De\
    leteSubscriptionRequest\x12N\n\x0csubscription\x18\x01\x20\x01(\tR\x0csu\
    bscriptionB*\xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\x02\"\xad\
    \x01\n\x17ModifyPushConfigRequest\x12N\n\x0csubscription\x18\x01\x20\x01\
    (\tR\x0csubscriptionB*\xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\
    \x02\x12B\n\x0bpush_config\x18\x02\x20\x01(\x0b2\x1c.google.pubsub.v1.Pu\
    shConfigR\npushConfigB\x03\xe0A\x02\"\xbb\x01\n\x0bPullRequest\x12N\n\
    \x0csubscription\x18\x01\x20\x01(\tR\x0csubscriptionB*\xfaA$\n\"pubsub.g\
    oogleapis.com/Subscription\xe0A\x02\x124\n\x12return_immediately\x18\x02\
    \x20\x01(\x08R\x11returnImmediatelyB\x05\x18\x01\xe0A\x01\x12&\n\x0cmax_\
    messages\x18\x03\x20\x01(\x05R\x0bmaxMessagesB\x03\xe0A\x02\"^\n\x0cPull\
    Response\x12N\n\x11received_messages\x18\x01\x20\x03(\x0b2!.google.pubsu\
    b.v1.ReceivedMessageR\x10receivedMessages\"\xbf\x01\n\x18ModifyAckDeadli\
    neRequest\x12N\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscriptionB*\
    \xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\x02\x12\x1c\n\x07ack_i\
    ds\x18\x04\x20\x03(\tR\x06ackIdsB\x03\xe0A\x02\x125\n\x14ack_deadline_se\
    conds\x18\x03\x20\x01(\x05R\x12ackDeadlineSecondsB\x03\xe0A\x02\"\x82\
    \x01\n\x12AcknowledgeRequest\x12N\n\x0csubscription\x18\x01\x20\x01(\tR\
    \x0csubscriptionB*\xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\x02\
    \x12\x1c\n\x07ack_ids\x18\x02\x20\x03(\tR\x06ackIdsB\x03\xe0A\x02\"\xbd\
    \x03\n\x14StreamingPullRequest\x12N\n\x0csubscription\x18\x01\x20\x01(\t\
    R\x0csubscriptionB*\xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\x02\
    \x12\x17\n\x07ack_ids\x18\x02\x20\x03(\tR\x06ackIds\x126\n\x17modify_dea\
    dline_seconds\x18\x03\x20\x03(\x05R\x15modifyDeadlineSeconds\x125\n\x17m\
    odify_deadline_ack_ids\x18\x04\x20\x03(\tR\x14modifyDeadlineAckIds\x12B\
    \n\x1bstream_ack_deadline_seconds\x18\x05\x20\x01(\x05R\x18streamAckDead\
    lineSecondsB\x03\xe0A\x02\x12\x1b\n\tclient_id\x18\x06\x20\x01(\tR\x08cl\
    ientId\x128\n\x18max_outstanding_messages\x18\x07\x20\x01(\x03R\x16maxOu\
    tstandingMessages\x122\n\x15max_outstanding_bytes\x18\x08\x20\x01(\x03R\
    \x13maxOutstandingBytes\"\xe3\x07\n\x15StreamingPullResponse\x12N\n\x11r\
    eceived_messages\x18\x01\x20\x03(\x0b2!.google.pubsub.v1.ReceivedMessage\
    R\x10receivedMessages\x12z\n\x18acknowledge_confirmation\x18\x05\x20\x01\
    (\x0b2?.google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmationR\
    \x17acknowledgeConfirmation\x12\x8e\x01\n\x20modify_ack_deadline_confirm\
    ation\x18\x03\x20\x01(\x0b2E.google.pubsub.v1.StreamingPullResponse.Modi\
    fyAckDeadlineConfirmationR\x1dmodifyAckDeadlineConfirmation\x12w\n\x17su\
    bscription_properties\x18\x04\x20\x01(\x0b2>.google.pubsub.v1.StreamingP\
    ullResponse.SubscriptionPropertiesR\x16subscriptionProperties\x1a\xbf\
    \x01\n\x17AcknowledgeConfirmation\x12\x17\n\x07ack_ids\x18\x01\x20\x03(\
    \tR\x06ackIds\x12&\n\x0finvalid_ack_ids\x18\x02\x20\x03(\tR\rinvalidAckI\
    ds\x12*\n\x11unordered_ack_ids\x18\x03\x20\x03(\tR\x0funorderedAckIds\
    \x127\n\x18temporary_failed_ack_ids\x18\x04\x20\x03(\tR\x15temporaryFail\
    edAckIds\x1a\x99\x01\n\x1dModifyAckDeadlineConfirmation\x12\x17\n\x07ack\
    _ids\x18\x01\x20\x03(\tR\x06ackIds\x12&\n\x0finvalid_ack_ids\x18\x02\x20\
    \x03(\tR\rinvalidAckIds\x127\n\x18temporary_failed_ack_ids\x18\x03\x20\
    \x03(\tR\x15temporaryFailedAckIds\x1a\x95\x01\n\x16SubscriptionPropertie\
    s\x12A\n\x1dexactly_once_delivery_enabled\x18\x01\x20\x01(\x08R\x1aexact\
    lyOnceDeliveryEnabled\x128\n\x18message_ordering_enabled\x18\x02\x20\x01\
    (\x08R\x16messageOrderingEnabled\"\xab\x02\n\x15CreateSnapshotRequest\
    \x12:\n\x04name\x18\x01\x20\x01(\tR\x04nameB&\xfaA\x20\n\x1epubsub.googl\
    eapis.com/Snapshot\xe0A\x02\x12N\n\x0csubscription\x18\x02\x20\x01(\tR\
    \x0csubscriptionB*\xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\x02\
    \x12K\n\x06labels\x18\x03\x20\x03(\x0b23.google.pubsub.v1.CreateSnapshot\
    Request.LabelsEntryR\x06labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\x96\x01\n\x15UpdateSnapshotRequest\x12;\n\x08snapshot\
    \x18\x01\x20\x01(\x0b2\x1a.google.pubsub.v1.SnapshotR\x08snapshotB\x03\
    \xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobu\
    f.FieldMaskR\nupdateMaskB\x03\xe0A\x02\"\xdc\x02\n\x08Snapshot\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x126\n\x05topic\x18\x02\x20\x01(\tR\
    \x05topicB\x20\xfaA\x1d\n\x1bpubsub.googleapis.com/Topic\x12;\n\x0bexpir\
    e_time\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nexpireTime\
    \x12>\n\x06labels\x18\x04\x20\x03(\x0b2&.google.pubsub.v1.Snapshot.Label\
    sEntryR\x06labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01:L\
    \xeaAI\n\x1epubsub.googleapis.com/Snapshot\x12'projects/{project}/snapsh\
    ots/{snapshot}\"X\n\x12GetSnapshotRequest\x12B\n\x08snapshot\x18\x01\x20\
    \x01(\tR\x08snapshotB&\xfaA\x20\n\x1epubsub.googleapis.com/Snapshot\xe0A\
    \x02\"\xa1\x01\n\x14ListSnapshotsRequest\x12M\n\x07project\x18\x01\x20\
    \x01(\tR\x07projectB3\xfaA-\n+cloudresourcemanager.googleapis.com/Projec\
    t\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"y\n\x15ListSnapshotsR\
    esponse\x128\n\tsnapshots\x18\x01\x20\x03(\x0b2\x1a.google.pubsub.v1.Sna\
    pshotR\tsnapshots\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPag\
    eToken\"[\n\x15DeleteSnapshotRequest\x12B\n\x08snapshot\x18\x01\x20\x01(\
    \tR\x08snapshotB&\xfaA\x20\n\x1epubsub.googleapis.com/Snapshot\xe0A\x02\
    \"\xdc\x01\n\x0bSeekRequest\x12N\n\x0csubscription\x18\x01\x20\x01(\tR\
    \x0csubscriptionB*\xfaA$\n\"pubsub.googleapis.com/Subscription\xe0A\x02\
    \x120\n\x04time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\0R\
    \x04time\x12A\n\x08snapshot\x18\x03\x20\x01(\tH\0R\x08snapshotB#\xfaA\
    \x20\n\x1epubsub.googleapis.com/SnapshotB\x08\n\x06target\"\x0e\n\x0cSee\
    kResponse2\xb8\x0b\n\tPublisher\x12q\n\x0bCreateTopic\x12\x17.google.pub\
    sub.v1.Topic\x1a\x17.google.pubsub.v1.Topic\"0\x82\xd3\xe4\x93\x02#\x1a\
    \x1e/v1/{name=projects/*/topics/*}:\x01*\xdaA\x04name\x12\x91\x01\n\x0bU\
    pdateTopic\x12$.google.pubsub.v1.UpdateTopicRequest\x1a\x17.google.pubsu\
    b.v1.Topic\"C\x82\xd3\xe4\x93\x02)2$/v1/{topic.name=projects/*/topics/*}\
    :\x01*\xdaA\x11topic,update_mask\x12\x93\x01\n\x07Publish\x12\x20.google\
    .pubsub.v1.PublishRequest\x1a!.google.pubsub.v1.PublishResponse\"C\x82\
    \xd3\xe4\x93\x02,\"'/v1/{topic=projects/*/topics/*}:publish:\x01*\xdaA\
    \x0etopic,messages\x12w\n\x08GetTopic\x12!.google.pubsub.v1.GetTopicRequ\
    est\x1a\x17.google.pubsub.v1.Topic\"/\x82\xd3\xe4\x93\x02!\x12\x1f/v1/{t\
    opic=projects/*/topics/*}\xdaA\x05topic\x12\x8a\x01\n\nListTopics\x12#.g\
    oogle.pubsub.v1.ListTopicsRequest\x1a$.google.pubsub.v1.ListTopicsRespon\
    se\"1\x82\xd3\xe4\x93\x02!\x12\x1f/v1/{project=projects/*}/topics\xdaA\
    \x07project\x12\xba\x01\n\x16ListTopicSubscriptions\x12/.google.pubsub.v\
    1.ListTopicSubscriptionsRequest\x1a0.google.pubsub.v1.ListTopicSubscript\
    ionsResponse\"=\x82\xd3\xe4\x93\x02/\x12-/v1/{topic=projects/*/topics/*}\
    /subscriptions\xdaA\x05topic\x12\xaa\x01\n\x12ListTopicSnapshots\x12+.go\
    ogle.pubsub.v1.ListTopicSnapshotsRequest\x1a,.google.pubsub.v1.ListTopic\
    SnapshotsResponse\"9\x82\xd3\xe4\x93\x02+\x12)/v1/{topic=projects/*/topi\
    cs/*}/snapshots\xdaA\x05topic\x12|\n\x0bDeleteTopic\x12$.google.pubsub.v\
    1.DeleteTopicRequest\x1a\x16.google.protobuf.Empty\"/\x82\xd3\xe4\x93\
    \x02!*\x1f/v1/{topic=projects/*/topics/*}\xdaA\x05topic\x12\xad\x01\n\
    \x12DetachSubscription\x12+.google.pubsub.v1.DetachSubscriptionRequest\
    \x1a,.google.pubsub.v1.DetachSubscriptionResponse\"<\x82\xd3\xe4\x93\x02\
    6\"4/v1/{subscription=projects/*/subscriptions/*}:detach\x1ap\xd2AUhttps\
    ://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/aut\
    h/pubsub\xcaA\x15pubsub.googleapis.com2\xd2\x15\n\nSubscriber\x12\xb4\
    \x01\n\x12CreateSubscription\x12\x1e.google.pubsub.v1.Subscription\x1a\
    \x1e.google.pubsub.v1.Subscription\"^\x82\xd3\xe4\x93\x02*\x1a%/v1/{name\
    =projects/*/subscriptions/*}:\x01*\xdaA+name,topic,push_config,ack_deadl\
    ine_seconds\x12\xa1\x01\n\x0fGetSubscription\x12(.google.pubsub.v1.GetSu\
    bscriptionRequest\x1a\x1e.google.pubsub.v1.Subscription\"D\x82\xd3\xe4\
    \x93\x02/\x12-/v1/{subscription=projects/*/subscriptions/*}\xdaA\x0csubs\
    cription\x12\xbb\x01\n\x12UpdateSubscription\x12+.google.pubsub.v1.Updat\
    eSubscriptionRequest\x1a\x1e.google.pubsub.v1.Subscription\"X\x82\xd3\
    \xe4\x93\x02722/v1/{subscription.name=projects/*/subscriptions/*}:\x01*\
    \xdaA\x18subscription,update_mask\x12\xa6\x01\n\x11ListSubscriptions\x12\
    *.google.pubsub.v1.ListSubscriptionsRequest\x1a+.google.pubsub.v1.ListSu\
    bscriptionsResponse\"8\x82\xd3\xe4\x93\x02(\x12&/v1/{project=projects/*}\
    /subscriptions\xdaA\x07project\x12\x9f\x01\n\x12DeleteSubscription\x12+.\
    google.pubsub.v1.DeleteSubscriptionRequest\x1a\x16.google.protobuf.Empty\
    \"D\x82\xd3\xe4\x93\x02/*-/v1/{subscription=projects/*/subscriptions/*}\
    \xdaA\x0csubscription\x12\xcf\x01\n\x11ModifyAckDeadline\x12*.google.pub\
    sub.v1.ModifyAckDeadlineRequest\x1a\x16.google.protobuf.Empty\"v\x82\xd3\
    \xe4\x93\x02D\"?/v1/{subscription=projects/*/subscriptions/*}:modifyAckD\
    eadline:\x01*\xdaA)subscription,ack_ids,ack_deadline_seconds\x12\xa8\x01\
    \n\x0bAcknowledge\x12$.google.pubsub.v1.AcknowledgeRequest\x1a\x16.googl\
    e.protobuf.Empty\"[\x82\xd3\xe4\x93\x02>\"9/v1/{subscription=projects/*/\
    subscriptions/*}:acknowledge:\x01*\xdaA\x14subscription,ack_ids\x12\xd0\
    \x01\n\x04Pull\x12\x1d.google.pubsub.v1.PullRequest\x1a\x1e.google.pubsu\
    b.v1.PullResponse\"\x88\x01\x82\xd3\xe4\x93\x027\"2/v1/{subscription=pro\
    jects/*/subscriptions/*}:pull:\x01*\xdaA,subscription,return_immediately\
    ,max_messages\xdaA\x19subscription,max_messages\x12f\n\rStreamingPull\
    \x12&.google.pubsub.v1.StreamingPullRequest\x1a'.google.pubsub.v1.Stream\
    ingPullResponse\"\0(\x010\x01\x12\xbb\x01\n\x10ModifyPushConfig\x12).goo\
    gle.pubsub.v1.ModifyPushConfigRequest\x1a\x16.google.protobuf.Empty\"d\
    \x82\xd3\xe4\x93\x02C\">/v1/{subscription=projects/*/subscriptions/*}:mo\
    difyPushConfig:\x01*\xdaA\x18subscription,push_config\x12\x89\x01\n\x0bG\
    etSnapshot\x12$.google.pubsub.v1.GetSnapshotRequest\x1a\x1a.google.pubsu\
    b.v1.Snapshot\"8\x82\xd3\xe4\x93\x02'\x12%/v1/{snapshot=projects/*/snaps\
    hots/*}\xdaA\x08snapshot\x12\x96\x01\n\rListSnapshots\x12&.google.pubsub\
    .v1.ListSnapshotsRequest\x1a'.google.pubsub.v1.ListSnapshotsResponse\"4\
    \x82\xd3\xe4\x93\x02$\x12\"/v1/{project=projects/*}/snapshots\xdaA\x07pr\
    oject\x12\x97\x01\n\x0eCreateSnapshot\x12'.google.pubsub.v1.CreateSnapsh\
    otRequest\x1a\x1a.google.pubsub.v1.Snapshot\"@\x82\xd3\xe4\x93\x02&\x1a!\
    /v1/{name=projects/*/snapshots/*}:\x01*\xdaA\x11name,subscription\x12\
    \xa3\x01\n\x0eUpdateSnapshot\x12'.google.pubsub.v1.UpdateSnapshotRequest\
    \x1a\x1a.google.pubsub.v1.Snapshot\"L\x82\xd3\xe4\x93\x02/2*/v1/{snapsho\
    t.name=projects/*/snapshots/*}:\x01*\xdaA\x14snapshot,update_mask\x12\
    \x8b\x01\n\x0eDeleteSnapshot\x12'.google.pubsub.v1.DeleteSnapshotRequest\
    \x1a\x16.google.protobuf.Empty\"8\x82\xd3\xe4\x93\x02'*%/v1/{snapshot=pr\
    ojects/*/snapshots/*}\xdaA\x08snapshot\x12\x84\x01\n\x04Seek\x12\x1d.goo\
    gle.pubsub.v1.SeekRequest\x1a\x1e.google.pubsub.v1.SeekResponse\"=\x82\
    \xd3\xe4\x93\x027\"2/v1/{subscription=projects/*/subscriptions/*}:seek:\
    \x01*\x1ap\xd2AUhttps://www.googleapis.com/auth/cloud-platform,https://w\
    ww.googleapis.com/auth/pubsub\xcaA\x15pubsub.googleapis.comB\xaa\x01\n\
    \x14com.google.pubsub.v1B\x0bPubsubProtoP\x01Z2cloud.google.com/go/pubsu\
    b/apiv1/pubsubpb;pubsubpb\xf8\x01\x01\xaa\x02\x16Google.Cloud.PubSub.V1\
    \xca\x02\x16Google\\Cloud\\PubSub\\V1\xea\x02\x19Google::Cloud::PubSub::\
    V1J\xce\xf6\x03\n\x07\x12\x05\x0e\0\xbd\x0c\x17\n\xbc\x04\n\x01\x0c\x12\
    \x03\x0e\0\x122\xb1\x04\x20Copyright\x202023\x20Google\x20LLC\n\n\x20Lic\
    ensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\
    \x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20excep\
    t\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obta\
    in\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20htt\
    p://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\
    \x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20softwar\
    e\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\x08\n\x01\x02\x12\x03\x10\0\x19\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\
    \n\x02\x03\x01\x12\x03\x13\0!\n\t\n\x02\x03\x02\x12\x03\x14\0)\n\t\n\x02\
    \x03\x03\x12\x03\x15\0#\n\t\n\x02\x03\x04\x12\x03\x16\0(\n\t\n\x02\x03\
    \x05\x12\x03\x17\0%\n\t\n\x02\x03\x06\x12\x03\x18\0*\n\t\n\x02\x03\x07\
    \x12\x03\x19\0)\n\t\n\x02\x03\x08\x12\x03\x1a\0'\n\x08\n\x01\x08\x12\x03\
    \x1c\0\x1f\n\t\n\x02\x08\x1f\x12\x03\x1c\0\x1f\n\x08\n\x01\x08\x12\x03\
    \x1d\03\n\t\n\x02\x08%\x12\x03\x1d\03\n\x08\n\x01\x08\x12\x03\x1e\0I\n\t\
    \n\x02\x08\x0b\x12\x03\x1e\0I\n\x08\n\x01\x08\x12\x03\x1f\0\"\n\t\n\x02\
    \x08\n\x12\x03\x1f\0\"\n\x08\n\x01\x08\x12\x03\x20\0,\n\t\n\x02\x08\x08\
    \x12\x03\x20\0,\n\x08\n\x01\x08\x12\x03!\0-\n\t\n\x02\x08\x01\x12\x03!\0\
    -\n\x08\n\x01\x08\x12\x03\"\03\n\t\n\x02\x08)\x12\x03\"\03\n\x08\n\x01\
    \x08\x12\x03#\02\n\t\n\x02\x08-\x12\x03#\02\nk\n\x02\x06\0\x12\x05'\0\
    \x87\x01\x01\x1a^\x20The\x20service\x20that\x20an\x20application\x20uses\
    \x20to\x20manipulate\x20topics,\x20and\x20to\x20send\n\x20messages\x20to\
    \x20a\x20topic.\n\n\n\n\x03\x06\0\x01\x12\x03'\x08\x11\n\n\n\x03\x06\0\
    \x03\x12\x03(\x02=\n\x0c\n\x05\x06\0\x03\x99\x08\x12\x03(\x02=\n\x0b\n\
    \x03\x06\0\x03\x12\x04)\x02+/\n\r\n\x05\x06\0\x03\x9a\x08\x12\x04)\x02+/\
    \n\xa1\x01\n\x04\x06\0\x02\0\x12\x04/\x025\x03\x1a\x92\x01\x20Creates\
    \x20the\x20given\x20topic\x20with\x20the\x20given\x20name.\x20See\x20the\
    \x20[resource\x20name\x20rules]\n\x20(https://cloud.google.com/pubsub/do\
    cs/pubsub-basics#resource_names).\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03/\
    \x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03/\x12\x17\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x03/\"'\n\r\n\x05\x06\0\x02\0\x04\x12\x040\x043\x06\n\x11\
    \n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x040\x043\x06\n\x0c\n\x05\x06\0\
    \x02\0\x04\x12\x034\x042\n\x0f\n\x08\x06\0\x02\0\x04\x9b\x08\0\x12\x034\
    \x042\ng\n\x04\x06\0\x02\x01\x12\x049\x02?\x03\x1aY\x20Updates\x20an\x20\
    existing\x20topic.\x20Note\x20that\x20certain\x20properties\x20of\x20a\n\
    \x20topic\x20are\x20not\x20modifiable.\n\n\x0c\n\x05\x06\0\x02\x01\x01\
    \x12\x039\x06\x11\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x039\x12$\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x039/4\n\r\n\x05\x06\0\x02\x01\x04\x12\x04:\
    \x04=\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04:\x04=\x06\n\
    \x0c\n\x05\x06\0\x02\x01\x04\x12\x03>\x04?\n\x0f\n\x08\x06\0\x02\x01\x04\
    \x9b\x08\0\x12\x03>\x04?\ni\n\x04\x06\0\x02\x02\x12\x04C\x02I\x03\x1a[\
    \x20Adds\x20one\x20or\x20more\x20messages\x20to\x20the\x20topic.\x20Retu\
    rns\x20`NOT_FOUND`\x20if\x20the\x20topic\n\x20does\x20not\x20exist.\n\n\
    \x0c\n\x05\x06\0\x02\x02\x01\x12\x03C\x06\r\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x03C\x0e\x1c\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03C'6\n\r\n\x05\
    \x06\0\x02\x02\x04\x12\x04D\x04G\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\
    \xbc\"\x12\x04D\x04G\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03H\x04<\n\
    \x0f\n\x08\x06\0\x02\x02\x04\x9b\x08\0\x12\x03H\x04<\n2\n\x04\x06\0\x02\
    \x03\x12\x04L\x02Q\x03\x1a$\x20Gets\x20the\x20configuration\x20of\x20a\
    \x20topic.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03L\x06\x0e\n\x0c\n\x05\
    \x06\0\x02\x03\x02\x12\x03L\x0f\x1e\n\x0c\n\x05\x06\0\x02\x03\x03\x12\
    \x03L).\n\r\n\x05\x06\0\x02\x03\x04\x12\x04M\x04O\x06\n\x11\n\t\x06\0\
    \x02\x03\x04\xb0\xca\xbc\"\x12\x04M\x04O\x06\n\x0c\n\x05\x06\0\x02\x03\
    \x04\x12\x03P\x043\n\x0f\n\x08\x06\0\x02\x03\x04\x9b\x08\0\x12\x03P\x043\
    \n&\n\x04\x06\0\x02\x04\x12\x04T\x02Y\x03\x1a\x18\x20Lists\x20matching\
    \x20topics.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03T\x06\x10\n\x0c\n\x05\
    \x06\0\x02\x04\x02\x12\x03T\x11\"\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03T\
    -?\n\r\n\x05\x06\0\x02\x04\x04\x12\x04U\x04W\x06\n\x11\n\t\x06\0\x02\x04\
    \x04\xb0\xca\xbc\"\x12\x04U\x04W\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\
    \x03X\x045\n\x0f\n\x08\x06\0\x02\x04\x04\x9b\x08\0\x12\x03X\x045\nL\n\
    \x04\x06\0\x02\x05\x12\x04\\\x02b\x03\x1a>\x20Lists\x20the\x20names\x20o\
    f\x20the\x20attached\x20subscriptions\x20on\x20this\x20topic.\n\n\x0c\n\
    \x05\x06\0\x02\x05\x01\x12\x03\\\x06\x1c\n\x0c\n\x05\x06\0\x02\x05\x02\
    \x12\x03\\\x1d:\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03]\x0f-\n\r\n\x05\
    \x06\0\x02\x05\x04\x12\x04^\x04`\x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\
    \xbc\"\x12\x04^\x04`\x06\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03a\x043\n\
    \x0f\n\x08\x06\0\x02\x05\x04\x9b\x08\0\x12\x03a\x043\n\xd9\x02\n\x04\x06\
    \0\x02\x06\x12\x04i\x02o\x03\x1a\xca\x02\x20Lists\x20the\x20names\x20of\
    \x20the\x20snapshots\x20on\x20this\x20topic.\x20Snapshots\x20are\x20used\
    \x20in\n\x20[Seek](https://cloud.google.com/pubsub/docs/replay-overview)\
    \x20operations,\n\x20which\x20allow\x20you\x20to\x20manage\x20message\
    \x20acknowledgments\x20in\x20bulk.\x20That\x20is,\x20you\x20can\n\x20set\
    \x20the\x20acknowledgment\x20state\x20of\x20messages\x20in\x20an\x20exis\
    ting\x20subscription\x20to\x20the\n\x20state\x20captured\x20by\x20a\x20s\
    napshot.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03i\x06\x18\n\x0c\n\x05\
    \x06\0\x02\x06\x02\x12\x03i\x192\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03j\
    \x0f)\n\r\n\x05\x06\0\x02\x06\x04\x12\x04k\x04m\x06\n\x11\n\t\x06\0\x02\
    \x06\x04\xb0\xca\xbc\"\x12\x04k\x04m\x06\n\x0c\n\x05\x06\0\x02\x06\x04\
    \x12\x03n\x043\n\x0f\n\x08\x06\0\x02\x06\x04\x9b\x08\0\x12\x03n\x043\n\
    \xf3\x02\n\x04\x06\0\x02\x07\x12\x04v\x02{\x03\x1a\xe4\x02\x20Deletes\
    \x20the\x20topic\x20with\x20the\x20given\x20name.\x20Returns\x20`NOT_FOU\
    ND`\x20if\x20the\x20topic\n\x20does\x20not\x20exist.\x20After\x20a\x20to\
    pic\x20is\x20deleted,\x20a\x20new\x20topic\x20may\x20be\x20created\x20wi\
    th\n\x20the\x20same\x20name;\x20this\x20is\x20an\x20entirely\x20new\x20t\
    opic\x20with\x20none\x20of\x20the\x20old\n\x20configuration\x20or\x20sub\
    scriptions.\x20Existing\x20subscriptions\x20to\x20this\x20topic\x20are\n\
    \x20not\x20deleted,\x20but\x20their\x20`topic`\x20field\x20is\x20set\x20\
    to\x20`_deleted-topic_`.\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03v\x06\
    \x11\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03v\x12$\n\x0c\n\x05\x06\0\x02\
    \x07\x03\x12\x03v/D\n\r\n\x05\x06\0\x02\x07\x04\x12\x04w\x04y\x06\n\x11\
    \n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x04w\x04y\x06\n\x0c\n\x05\x06\0\
    \x02\x07\x04\x12\x03z\x043\n\x0f\n\x08\x06\0\x02\x07\x04\x9b\x08\0\x12\
    \x03z\x043\n\x93\x02\n\x04\x06\0\x02\x08\x12\x06\x81\x01\x02\x86\x01\x03\
    \x1a\x82\x02\x20Detaches\x20a\x20subscription\x20from\x20this\x20topic.\
    \x20All\x20messages\x20retained\x20in\x20the\n\x20subscription\x20are\
    \x20dropped.\x20Subsequent\x20`Pull`\x20and\x20`StreamingPull`\x20reques\
    ts\n\x20will\x20return\x20FAILED_PRECONDITION.\x20If\x20the\x20subscript\
    ion\x20is\x20a\x20push\n\x20subscription,\x20pushes\x20to\x20the\x20endp\
    oint\x20will\x20stop.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\x81\x01\x06\
    \x18\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\x81\x01\x192\n\r\n\x05\x06\0\
    \x02\x08\x03\x12\x04\x82\x01\x0f)\n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\
    \x83\x01\x04\x85\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\
    \x06\x83\x01\x04\x85\x01\x06\nU\n\x02\x04\0\x12\x06\x8a\x01\0\x92\x01\
    \x01\x1aG\x20A\x20policy\x20constraining\x20the\x20storage\x20of\x20mess\
    ages\x20published\x20to\x20the\x20topic.\n\n\x0b\n\x03\x04\0\x01\x12\x04\
    \x8a\x01\x08\x1c\n\x8d\x03\n\x04\x04\0\x02\0\x12\x04\x91\x01\x022\x1a\
    \xfe\x02\x20A\x20list\x20of\x20IDs\x20of\x20Google\x20Cloud\x20regions\
    \x20where\x20messages\x20that\x20are\x20published\n\x20to\x20the\x20topi\
    c\x20may\x20be\x20persisted\x20in\x20storage.\x20Messages\x20published\
    \x20by\x20publishers\n\x20running\x20in\x20non-allowed\x20Google\x20Clou\
    d\x20regions\x20(or\x20running\x20outside\x20of\x20Google\n\x20Cloud\x20\
    altogether)\x20are\x20routed\x20for\x20storage\x20in\x20one\x20of\x20the\
    \x20allowed\x20regions.\n\x20An\x20empty\x20list\x20means\x20that\x20no\
    \x20regions\x20are\x20allowed,\x20and\x20is\x20not\x20a\x20valid\n\x20co\
    nfiguration.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x91\x01\x02\n\n\r\n\x05\
    \x04\0\x02\0\x05\x12\x04\x91\x01\x0b\x11\n\r\n\x05\x04\0\x02\0\x01\x12\
    \x04\x91\x01\x12-\n\r\n\x05\x04\0\x02\0\x03\x12\x04\x91\x0101\nL\n\x02\
    \x04\x01\x12\x06\x95\x01\0\xab\x01\x01\x1a>\x20Settings\x20for\x20valida\
    ting\x20messages\x20published\x20against\x20a\x20schema.\n\n\x0b\n\x03\
    \x04\x01\x01\x12\x04\x95\x01\x08\x16\n\xef\x01\n\x04\x04\x01\x02\0\x12\
    \x06\x9a\x01\x02\x9d\x01\x04\x1a\xde\x01\x20Required.\x20The\x20name\x20\
    of\x20the\x20schema\x20that\x20messages\x20published\x20should\x20be\n\
    \x20validated\x20against.\x20Format\x20is\x20`projects/{project}/schemas\
    /{schema}`.\x20The\n\x20value\x20of\x20this\x20field\x20will\x20be\x20`_\
    deleted-schema_`\x20if\x20the\x20schema\x20has\x20been\n\x20deleted.\n\n\
    \r\n\x05\x04\x01\x02\0\x05\x12\x04\x9a\x01\x02\x08\n\r\n\x05\x04\x01\x02\
    \0\x01\x12\x04\x9a\x01\t\x0f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x9a\x01\
    \x12\x13\n\x0f\n\x05\x04\x01\x02\0\x08\x12\x06\x9a\x01\x14\x9d\x01\x03\n\
    \x10\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\x04\x9b\x01\x04*\n\x0f\n\x07\
    \x04\x01\x02\0\x08\x9f\x08\x12\x04\x9c\x01\x04N\nD\n\x04\x04\x01\x02\x01\
    \x12\x04\xa0\x01\x02\x18\x1a6\x20The\x20encoding\x20of\x20messages\x20va\
    lidated\x20against\x20`schema`.\n\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\
    \xa0\x01\x02\n\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xa0\x01\x0b\x13\n\r\
    \n\x05\x04\x01\x02\x01\x03\x12\x04\xa0\x01\x16\x17\n\xc6\x01\n\x04\x04\
    \x01\x02\x02\x12\x04\xa5\x01\x02\x1f\x1a\xb7\x01\x20The\x20minimum\x20(i\
    nclusive)\x20revision\x20allowed\x20for\x20validating\x20messages.\x20If\
    \x20empty\n\x20or\x20not\x20present,\x20allow\x20any\x20revision\x20to\
    \x20be\x20validated\x20against\x20last_revision\x20or\n\x20any\x20revisi\
    on\x20created\x20before.\n\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xa5\x01\
    \x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xa5\x01\t\x1a\n\r\n\x05\
    \x04\x01\x02\x02\x03\x12\x04\xa5\x01\x1d\x1e\n\xc6\x01\n\x04\x04\x01\x02\
    \x03\x12\x04\xaa\x01\x02\x1e\x1a\xb7\x01\x20The\x20maximum\x20(inclusive\
    )\x20revision\x20allowed\x20for\x20validating\x20messages.\x20If\x20empt\
    y\n\x20or\x20not\x20present,\x20allow\x20any\x20revision\x20to\x20be\x20\
    validated\x20against\x20first_revision\n\x20or\x20any\x20revision\x20cre\
    ated\x20after.\n\n\r\n\x05\x04\x01\x02\x03\x05\x12\x04\xaa\x01\x02\x08\n\
    \r\n\x05\x04\x01\x02\x03\x01\x12\x04\xaa\x01\t\x19\n\r\n\x05\x04\x01\x02\
    \x03\x03\x12\x04\xaa\x01\x1c\x1d\n!\n\x02\x04\x02\x12\x06\xae\x01\0\xdc\
    \x01\x01\x1a\x13\x20A\x20topic\x20resource.\n\n\x0b\n\x03\x04\x02\x01\
    \x12\x04\xae\x01\x08\r\n\r\n\x03\x04\x02\x07\x12\x06\xaf\x01\x02\xb3\x01\
    \x04\n\x0f\n\x05\x04\x02\x07\x9d\x08\x12\x06\xaf\x01\x02\xb3\x01\x04\n\
    \x8c\x03\n\x04\x04\x02\x02\0\x12\x04\xbb\x01\x02;\x1a\xfd\x02\x20Require\
    d.\x20The\x20name\x20of\x20the\x20topic.\x20It\x20must\x20have\x20the\
    \x20format\n\x20`\"projects/{project}/topics/{topic}\"`.\x20`{topic}`\
    \x20must\x20start\x20with\x20a\x20letter,\n\x20and\x20contain\x20only\
    \x20letters\x20(`[A-Za-z]`),\x20numbers\x20(`[0-9]`),\x20dashes\x20(`-`)\
    ,\n\x20underscores\x20(`_`),\x20periods\x20(`.`),\x20tildes\x20(`~`),\
    \x20plus\x20(`+`)\x20or\x20percent\n\x20signs\x20(`%`).\x20It\x20must\
    \x20be\x20between\x203\x20and\x20255\x20characters\x20in\x20length,\x20a\
    nd\x20it\n\x20must\x20not\x20start\x20with\x20`\"goog\"`.\n\n\r\n\x05\
    \x04\x02\x02\0\x05\x12\x04\xbb\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\
    \x12\x04\xbb\x01\t\r\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xbb\x01\x10\x11\
    \n\r\n\x05\x04\x02\x02\0\x08\x12\x04\xbb\x01\x12:\n\x10\n\x08\x04\x02\
    \x02\0\x08\x9c\x08\0\x12\x04\xbb\x01\x139\nb\n\x04\x04\x02\x02\x01\x12\
    \x04\xbf\x01\x02!\x1aT\x20See\x20[Creating\x20and\x20managing\x20labels]\
    \n\x20(https://cloud.google.com/pubsub/docs/labels).\n\n\r\n\x05\x04\x02\
    \x02\x01\x06\x12\x04\xbf\x01\x02\x15\n\r\n\x05\x04\x02\x02\x01\x01\x12\
    \x04\xbf\x01\x16\x1c\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xbf\x01\x1f\
    \x20\n\xb7\x01\n\x04\x04\x02\x02\x02\x12\x04\xc4\x01\x022\x1a\xa8\x01\
    \x20Policy\x20constraining\x20the\x20set\x20of\x20Google\x20Cloud\x20Pla\
    tform\x20regions\x20where\x20messages\n\x20published\x20to\x20the\x20top\
    ic\x20may\x20be\x20stored.\x20If\x20not\x20present,\x20then\x20no\x20con\
    straints\n\x20are\x20in\x20effect.\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\
    \x04\xc4\x01\x02\x16\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xc4\x01\x17-\
    \n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xc4\x0101\n\xcb\x01\n\x04\x04\x02\
    \x02\x03\x12\x04\xca\x01\x02\x1a\x1a\xbc\x01\x20The\x20resource\x20name\
    \x20of\x20the\x20Cloud\x20KMS\x20CryptoKey\x20to\x20be\x20used\x20to\x20\
    protect\x20access\n\x20to\x20messages\x20published\x20on\x20this\x20topi\
    c.\n\n\x20The\x20expected\x20format\x20is\x20`projects/*/locations/*/key\
    Rings/*/cryptoKeys/*`.\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\xca\x01\
    \x02\x08\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xca\x01\t\x15\n\r\n\x05\
    \x04\x02\x02\x03\x03\x12\x04\xca\x01\x18\x19\nL\n\x04\x04\x02\x02\x04\
    \x12\x04\xcd\x01\x02%\x1a>\x20Settings\x20for\x20validating\x20messages\
    \x20published\x20against\x20a\x20schema.\n\n\r\n\x05\x04\x02\x02\x04\x06\
    \x12\x04\xcd\x01\x02\x10\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xcd\x01\
    \x11\x20\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xcd\x01#$\n\x8a\x01\n\x04\
    \x04\x02\x02\x05\x12\x04\xd1\x01\x02\x19\x1a|\x20Reserved\x20for\x20futu\
    re\x20use.\x20This\x20field\x20is\x20set\x20only\x20in\x20responses\x20f\
    rom\x20the\n\x20server;\x20it\x20is\x20ignored\x20if\x20it\x20is\x20set\
    \x20in\x20any\x20requests.\n\n\r\n\x05\x04\x02\x02\x05\x05\x12\x04\xd1\
    \x01\x02\x06\n\r\n\x05\x04\x02\x02\x05\x01\x12\x04\xd1\x01\x07\x14\n\r\n\
    \x05\x04\x02\x02\x05\x03\x12\x04\xd1\x01\x17\x18\n\xd2\x04\n\x04\x04\x02\
    \x02\x06\x12\x04\xdb\x01\x02:\x1a\xc3\x04\x20Indicates\x20the\x20minimum\
    \x20duration\x20to\x20retain\x20a\x20message\x20after\x20it\x20is\x20pub\
    lished\x20to\n\x20the\x20topic.\x20If\x20this\x20field\x20is\x20set,\x20\
    messages\x20published\x20to\x20the\x20topic\x20in\x20the\n\x20last\x20`m\
    essage_retention_duration`\x20are\x20always\x20available\x20to\x20subscr\
    ibers.\x20For\n\x20instance,\x20it\x20allows\x20any\x20attached\x20subsc\
    ription\x20to\x20[seek\x20to\x20a\n\x20timestamp](https://cloud.google.c\
    om/pubsub/docs/replay-overview#seek_to_a_time)\n\x20that\x20is\x20up\x20\
    to\x20`message_retention_duration`\x20in\x20the\x20past.\x20If\x20this\
    \x20field\x20is\n\x20not\x20set,\x20message\x20retention\x20is\x20contro\
    lled\x20by\x20settings\x20on\x20individual\n\x20subscriptions.\x20Cannot\
    \x20be\x20more\x20than\x2031\x20days\x20or\x20less\x20than\x2010\x20minu\
    tes.\n\n\r\n\x05\x04\x02\x02\x06\x06\x12\x04\xdb\x01\x02\x1a\n\r\n\x05\
    \x04\x02\x02\x06\x01\x12\x04\xdb\x01\x1b5\n\r\n\x05\x04\x02\x02\x06\x03\
    \x12\x04\xdb\x0189\n\xf9\x03\n\x02\x04\x03\x12\x06\xe6\x01\0\x84\x02\x01\
    \x1a\xea\x03\x20A\x20message\x20that\x20is\x20published\x20by\x20publish\
    ers\x20and\x20consumed\x20by\x20subscribers.\x20The\n\x20message\x20must\
    \x20contain\x20either\x20a\x20non-empty\x20data\x20field\x20or\x20at\x20\
    least\x20one\x20attribute.\n\x20Note\x20that\x20client\x20libraries\x20r\
    epresent\x20this\x20object\x20differently\n\x20depending\x20on\x20the\
    \x20language.\x20See\x20the\x20corresponding\x20[client\x20library\n\x20\
    documentation](https://cloud.google.com/pubsub/docs/reference/libraries)\
    \x20for\n\x20more\x20information.\x20See\x20[quotas\x20and\x20limits]\n\
    \x20(https://cloud.google.com/pubsub/quotas)\x20for\x20more\x20informati\
    on\x20about\x20message\n\x20limits.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\
    \xe6\x01\x08\x15\nq\n\x04\x04\x03\x02\0\x12\x04\xe9\x01\x02\x11\x1ac\x20\
    The\x20message\x20data\x20field.\x20If\x20this\x20field\x20is\x20empty,\
    \x20the\x20message\x20must\x20contain\n\x20at\x20least\x20one\x20attribu\
    te.\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xe9\x01\x02\x07\n\r\n\x05\x04\
    \x03\x02\0\x01\x12\x04\xe9\x01\x08\x0c\n\r\n\x05\x04\x03\x02\0\x03\x12\
    \x04\xe9\x01\x0f\x10\n\xa9\x01\n\x04\x04\x03\x02\x01\x12\x04\xee\x01\x02\
    %\x1a\x9a\x01\x20Attributes\x20for\x20this\x20message.\x20If\x20this\x20\
    field\x20is\x20empty,\x20the\x20message\x20must\n\x20contain\x20non-empt\
    y\x20data.\x20This\x20can\x20be\x20used\x20to\x20filter\x20messages\x20o\
    n\x20the\n\x20subscription.\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xee\
    \x01\x02\x15\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xee\x01\x16\x20\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\xee\x01#$\n\xb3\x02\n\x04\x04\x03\x02\
    \x02\x12\x04\xf4\x01\x02\x18\x1a\xa4\x02\x20ID\x20of\x20this\x20message,\
    \x20assigned\x20by\x20the\x20server\x20when\x20the\x20message\x20is\x20p\
    ublished.\n\x20Guaranteed\x20to\x20be\x20unique\x20within\x20the\x20topi\
    c.\x20This\x20value\x20may\x20be\x20read\x20by\x20a\n\x20subscriber\x20t\
    hat\x20receives\x20a\x20`PubsubMessage`\x20via\x20a\x20`Pull`\x20call\
    \x20or\x20a\x20push\n\x20delivery.\x20It\x20must\x20not\x20be\x20populat\
    ed\x20by\x20the\x20publisher\x20in\x20a\x20`Publish`\x20call.\n\n\r\n\
    \x05\x04\x03\x02\x02\x05\x12\x04\xf4\x01\x02\x08\n\r\n\x05\x04\x03\x02\
    \x02\x01\x12\x04\xf4\x01\t\x13\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xf4\
    \x01\x16\x17\n\xbb\x01\n\x04\x04\x03\x02\x03\x12\x04\xf9\x01\x02-\x1a\
    \xac\x01\x20The\x20time\x20at\x20which\x20the\x20message\x20was\x20publi\
    shed,\x20populated\x20by\x20the\x20server\x20when\n\x20it\x20receives\
    \x20the\x20`Publish`\x20call.\x20It\x20must\x20not\x20be\x20populated\
    \x20by\x20the\n\x20publisher\x20in\x20a\x20`Publish`\x20call.\n\n\r\n\
    \x05\x04\x03\x02\x03\x06\x12\x04\xf9\x01\x02\x1b\n\r\n\x05\x04\x03\x02\
    \x03\x01\x12\x04\xf9\x01\x1c(\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xf9\
    \x01+,\n\x94\x04\n\x04\x04\x03\x02\x04\x12\x04\x83\x02\x02\x1a\x1a\x85\
    \x04\x20If\x20non-empty,\x20identifies\x20related\x20messages\x20for\x20\
    which\x20publish\x20order\x20should\x20be\n\x20respected.\x20If\x20a\x20\
    `Subscription`\x20has\x20`enable_message_ordering`\x20set\x20to\x20`true\
    `,\n\x20messages\x20published\x20with\x20the\x20same\x20non-empty\x20`or\
    dering_key`\x20value\x20will\x20be\n\x20delivered\x20to\x20subscribers\
    \x20in\x20the\x20order\x20in\x20which\x20they\x20are\x20received\x20by\
    \x20the\n\x20Pub/Sub\x20system.\x20All\x20`PubsubMessage`s\x20published\
    \x20in\x20a\x20given\x20`PublishRequest`\n\x20must\x20specify\x20the\x20\
    same\x20`ordering_key`\x20value.\n\x20For\x20more\x20information,\x20see\
    \x20[ordering\n\x20messages](https://cloud.google.com/pubsub/docs/orderi\
    ng).\n\n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\x83\x02\x02\x08\n\r\n\x05\
    \x04\x03\x02\x04\x01\x12\x04\x83\x02\t\x15\n\r\n\x05\x04\x03\x02\x04\x03\
    \x12\x04\x83\x02\x18\x19\n0\n\x02\x04\x04\x12\x06\x87\x02\0\x8e\x02\x01\
    \x1a\"\x20Request\x20for\x20the\x20GetTopic\x20method.\n\n\x0b\n\x03\x04\
    \x04\x01\x12\x04\x87\x02\x08\x17\ni\n\x04\x04\x04\x02\0\x12\x06\x8a\x02\
    \x02\x8d\x02\x04\x1aY\x20Required.\x20The\x20name\x20of\x20the\x20topic\
    \x20to\x20get.\n\x20Format\x20is\x20`projects/{project}/topics/{topic}`.\
    \n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x8a\x02\x02\x08\n\r\n\x05\x04\x04\
    \x02\0\x01\x12\x04\x8a\x02\t\x0e\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x8a\
    \x02\x11\x12\n\x0f\n\x05\x04\x04\x02\0\x08\x12\x06\x8a\x02\x13\x8d\x02\
    \x03\n\x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\x8b\x02\x04*\n\x0f\
    \n\x07\x04\x04\x02\0\x08\x9f\x08\x12\x04\x8c\x02\x04M\n3\n\x02\x04\x05\
    \x12\x06\x91\x02\0\x9c\x02\x01\x1a%\x20Request\x20for\x20the\x20UpdateTo\
    pic\x20method.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x91\x02\x08\x1a\n3\n\
    \x04\x04\x05\x02\0\x12\x04\x93\x02\x02;\x1a%\x20Required.\x20The\x20upda\
    ted\x20topic\x20object.\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x93\x02\
    \x02\x07\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x93\x02\x08\r\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\x93\x02\x10\x11\n\r\n\x05\x04\x05\x02\0\x08\x12\
    \x04\x93\x02\x12:\n\x10\n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\x93\
    \x02\x139\n\xe5\x02\n\x04\x04\x05\x02\x01\x12\x06\x9a\x02\x02\x9b\x02/\
    \x1a\xd4\x02\x20Required.\x20Indicates\x20which\x20fields\x20in\x20the\
    \x20provided\x20topic\x20to\x20update.\x20Must\x20be\n\x20specified\x20a\
    nd\x20non-empty.\x20Note\x20that\x20if\x20`update_mask`\x20contains\n\
    \x20\"message_storage_policy\"\x20but\x20the\x20`message_storage_policy`\
    \x20is\x20not\x20set\x20in\n\x20the\x20`topic`\x20provided\x20above,\x20\
    then\x20the\x20updated\x20value\x20is\x20determined\x20by\x20the\n\x20po\
    licy\x20configured\x20at\x20the\x20project\x20or\x20organization\x20leve\
    l.\n\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\x9a\x02\x02\x1b\n\r\n\x05\x04\
    \x05\x02\x01\x01\x12\x04\x9a\x02\x1c'\n\r\n\x05\x04\x05\x02\x01\x03\x12\
    \x04\x9a\x02*+\n\r\n\x05\x04\x05\x02\x01\x08\x12\x04\x9b\x02\x06.\n\x10\
    \n\x08\x04\x05\x02\x01\x08\x9c\x08\0\x12\x04\x9b\x02\x07-\n/\n\x02\x04\
    \x06\x12\x06\x9f\x02\0\xa9\x02\x01\x1a!\x20Request\x20for\x20the\x20Publ\
    ish\x20method.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\x9f\x02\x08\x16\n\x88\
    \x01\n\x04\x04\x06\x02\0\x12\x06\xa2\x02\x02\xa5\x02\x04\x1ax\x20Require\
    d.\x20The\x20messages\x20in\x20the\x20request\x20will\x20be\x20published\
    \x20on\x20this\x20topic.\n\x20Format\x20is\x20`projects/{project}/topics\
    /{topic}`.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xa2\x02\x02\x08\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\xa2\x02\t\x0e\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\xa2\x02\x11\x12\n\x0f\n\x05\x04\x06\x02\0\x08\x12\x06\xa2\x02\
    \x13\xa5\x02\x03\n\x10\n\x08\x04\x06\x02\0\x08\x9c\x08\0\x12\x04\xa3\x02\
    \x04*\n\x0f\n\x07\x04\x06\x02\0\x08\x9f\x08\x12\x04\xa4\x02\x04M\n2\n\
    \x04\x04\x06\x02\x01\x12\x04\xa8\x02\x02O\x1a$\x20Required.\x20The\x20me\
    ssages\x20to\x20publish.\n\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xa8\x02\
    \x02\n\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xa8\x02\x0b\x18\n\r\n\x05\
    \x04\x06\x02\x01\x01\x12\x04\xa8\x02\x19!\n\r\n\x05\x04\x06\x02\x01\x03\
    \x12\x04\xa8\x02$%\n\r\n\x05\x04\x06\x02\x01\x08\x12\x04\xa8\x02&N\n\x10\
    \n\x08\x04\x06\x02\x01\x08\x9c\x08\0\x12\x04\xa8\x02'M\n2\n\x02\x04\x07\
    \x12\x06\xac\x02\0\xb1\x02\x01\x1a$\x20Response\x20for\x20the\x20`Publis\
    h`\x20method.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xac\x02\x08\x17\n\xa8\
    \x01\n\x04\x04\x07\x02\0\x12\x04\xb0\x02\x02\"\x1a\x99\x01\x20The\x20ser\
    ver-assigned\x20ID\x20of\x20each\x20published\x20message,\x20in\x20the\
    \x20same\x20order\x20as\n\x20the\x20messages\x20in\x20the\x20request.\
    \x20IDs\x20are\x20guaranteed\x20to\x20be\x20unique\x20within\n\x20the\
    \x20topic.\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xb0\x02\x02\n\n\r\n\x05\
    \x04\x07\x02\0\x05\x12\x04\xb0\x02\x0b\x11\n\r\n\x05\x04\x07\x02\0\x01\
    \x12\x04\xb0\x02\x12\x1d\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xb0\x02\x20\
    !\n4\n\x02\x04\x08\x12\x06\xb4\x02\0\xc5\x02\x01\x1a&\x20Request\x20for\
    \x20the\x20`ListTopics`\x20method.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xb4\
    \x02\x08\x19\np\n\x04\x04\x08\x02\0\x12\x06\xb7\x02\x02\xbc\x02\x04\x1a`\
    \x20Required.\x20The\x20name\x20of\x20the\x20project\x20in\x20which\x20t\
    o\x20list\x20topics.\n\x20Format\x20is\x20`projects/{project-id}`.\n\n\r\
    \n\x05\x04\x08\x02\0\x05\x12\x04\xb7\x02\x02\x08\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\xb7\x02\t\x10\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xb7\x02\
    \x13\x14\n\x0f\n\x05\x04\x08\x02\0\x08\x12\x06\xb7\x02\x15\xbc\x02\x03\n\
    \x10\n\x08\x04\x08\x02\0\x08\x9c\x08\0\x12\x04\xb8\x02\x04*\n\x11\n\x07\
    \x04\x08\x02\0\x08\x9f\x08\x12\x06\xb9\x02\x04\xbb\x02\x05\n3\n\x04\x04\
    \x08\x02\x01\x12\x04\xbf\x02\x02\x16\x1a%\x20Maximum\x20number\x20of\x20\
    topics\x20to\x20return.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xbf\x02\
    \x02\x07\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xbf\x02\x08\x11\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\xbf\x02\x14\x15\n\xc4\x01\n\x04\x04\x08\x02\
    \x02\x12\x04\xc4\x02\x02\x18\x1a\xb5\x01\x20The\x20value\x20returned\x20\
    by\x20the\x20last\x20`ListTopicsResponse`;\x20indicates\x20that\x20this\
    \x20is\n\x20a\x20continuation\x20of\x20a\x20prior\x20`ListTopics`\x20cal\
    l,\x20and\x20that\x20the\x20system\x20should\n\x20return\x20the\x20next\
    \x20page\x20of\x20data.\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xc4\x02\
    \x02\x08\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xc4\x02\t\x13\n\r\n\x05\
    \x04\x08\x02\x02\x03\x12\x04\xc4\x02\x16\x17\n5\n\x02\x04\t\x12\x06\xc8\
    \x02\0\xcf\x02\x01\x1a'\x20Response\x20for\x20the\x20`ListTopics`\x20met\
    hod.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xc8\x02\x08\x1a\n%\n\x04\x04\t\x02\
    \0\x12\x04\xca\x02\x02\x1c\x1a\x17\x20The\x20resulting\x20topics.\n\n\r\
    \n\x05\x04\t\x02\0\x04\x12\x04\xca\x02\x02\n\n\r\n\x05\x04\t\x02\0\x06\
    \x12\x04\xca\x02\x0b\x10\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xca\x02\x11\
    \x17\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xca\x02\x1a\x1b\n\x99\x01\n\x04\
    \x04\t\x02\x01\x12\x04\xce\x02\x02\x1d\x1a\x8a\x01\x20If\x20not\x20empty\
    ,\x20indicates\x20that\x20there\x20may\x20be\x20more\x20topics\x20that\
    \x20match\x20the\n\x20request;\x20this\x20value\x20should\x20be\x20passe\
    d\x20in\x20a\x20new\x20`ListTopicsRequest`.\n\n\r\n\x05\x04\t\x02\x01\
    \x05\x12\x04\xce\x02\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xce\x02\
    \t\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xce\x02\x1b\x1c\n@\n\x02\x04\
    \n\x12\x06\xd2\x02\0\xe1\x02\x01\x1a2\x20Request\x20for\x20the\x20`ListT\
    opicSubscriptions`\x20method.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xd2\x02\
    \x08%\n\x85\x01\n\x04\x04\n\x02\0\x12\x06\xd5\x02\x02\xd8\x02\x04\x1au\
    \x20Required.\x20The\x20name\x20of\x20the\x20topic\x20that\x20subscripti\
    ons\x20are\x20attached\x20to.\n\x20Format\x20is\x20`projects/{project}/t\
    opics/{topic}`.\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xd5\x02\x02\x08\n\r\
    \n\x05\x04\n\x02\0\x01\x12\x04\xd5\x02\t\x0e\n\r\n\x05\x04\n\x02\0\x03\
    \x12\x04\xd5\x02\x11\x12\n\x0f\n\x05\x04\n\x02\0\x08\x12\x06\xd5\x02\x13\
    \xd8\x02\x03\n\x10\n\x08\x04\n\x02\0\x08\x9c\x08\0\x12\x04\xd6\x02\x04*\
    \n\x0f\n\x07\x04\n\x02\0\x08\x9f\x08\x12\x04\xd7\x02\x04M\n?\n\x04\x04\n\
    \x02\x01\x12\x04\xdb\x02\x02\x16\x1a1\x20Maximum\x20number\x20of\x20subs\
    cription\x20names\x20to\x20return.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\
    \xdb\x02\x02\x07\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xdb\x02\x08\x11\n\r\
    \n\x05\x04\n\x02\x01\x03\x12\x04\xdb\x02\x14\x15\n\xdc\x01\n\x04\x04\n\
    \x02\x02\x12\x04\xe0\x02\x02\x18\x1a\xcd\x01\x20The\x20value\x20returned\
    \x20by\x20the\x20last\x20`ListTopicSubscriptionsResponse`;\x20indicates\
    \n\x20that\x20this\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20`Li\
    stTopicSubscriptions`\x20call,\x20and\n\x20that\x20the\x20system\x20shou\
    ld\x20return\x20the\x20next\x20page\x20of\x20data.\n\n\r\n\x05\x04\n\x02\
    \x02\x05\x12\x04\xe0\x02\x02\x08\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xe0\
    \x02\t\x13\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xe0\x02\x16\x17\nA\n\x02\
    \x04\x0b\x12\x06\xe4\x02\0\xee\x02\x01\x1a3\x20Response\x20for\x20the\
    \x20`ListTopicSubscriptions`\x20method.\n\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\xe4\x02\x08&\n\\\n\x04\x04\x0b\x02\0\x12\x06\xe6\x02\x02\xe8\x02\
    \x05\x1aL\x20The\x20names\x20of\x20subscriptions\x20attached\x20to\x20th\
    e\x20topic\x20specified\x20in\x20the\x20request.\n\n\r\n\x05\x04\x0b\x02\
    \0\x04\x12\x04\xe6\x02\x02\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xe6\x02\
    \x0b\x11\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xe6\x02\x12\x1f\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xe6\x02\"#\n\x0f\n\x05\x04\x0b\x02\0\x08\x12\
    \x06\xe6\x02$\xe8\x02\x04\n\x11\n\x07\x04\x0b\x02\0\x08\x9f\x08\x12\x06\
    \xe6\x02%\xe8\x02\x03\n\xc7\x01\n\x04\x04\x0b\x02\x01\x12\x04\xed\x02\
    \x02\x1d\x1a\xb8\x01\x20If\x20not\x20empty,\x20indicates\x20that\x20ther\
    e\x20may\x20be\x20more\x20subscriptions\x20that\x20match\n\x20the\x20req\
    uest;\x20this\x20value\x20should\x20be\x20passed\x20in\x20a\x20new\n\x20\
    `ListTopicSubscriptionsRequest`\x20to\x20get\x20more\x20subscriptions.\n\
    \n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xed\x02\x02\x08\n\r\n\x05\x04\x0b\
    \x02\x01\x01\x12\x04\xed\x02\t\x18\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xed\x02\x1b\x1c\n<\n\x02\x04\x0c\x12\x06\xf1\x02\0\x80\x03\x01\x1a.\x20\
    Request\x20for\x20the\x20`ListTopicSnapshots`\x20method.\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\xf1\x02\x08!\n\x81\x01\n\x04\x04\x0c\x02\0\x12\x06\
    \xf4\x02\x02\xf7\x02\x04\x1aq\x20Required.\x20The\x20name\x20of\x20the\
    \x20topic\x20that\x20snapshots\x20are\x20attached\x20to.\n\x20Format\x20\
    is\x20`projects/{project}/topics/{topic}`.\n\n\r\n\x05\x04\x0c\x02\0\x05\
    \x12\x04\xf4\x02\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xf4\x02\t\
    \x0e\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xf4\x02\x11\x12\n\x0f\n\x05\x04\
    \x0c\x02\0\x08\x12\x06\xf4\x02\x13\xf7\x02\x03\n\x10\n\x08\x04\x0c\x02\0\
    \x08\x9c\x08\0\x12\x04\xf5\x02\x04*\n\x0f\n\x07\x04\x0c\x02\0\x08\x9f\
    \x08\x12\x04\xf6\x02\x04M\n;\n\x04\x04\x0c\x02\x01\x12\x04\xfa\x02\x02\
    \x16\x1a-\x20Maximum\x20number\x20of\x20snapshot\x20names\x20to\x20retur\
    n.\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xfa\x02\x02\x07\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\xfa\x02\x08\x11\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\xfa\x02\x14\x15\n\xd4\x01\n\x04\x04\x0c\x02\x02\x12\x04\xff\x02\
    \x02\x18\x1a\xc5\x01\x20The\x20value\x20returned\x20by\x20the\x20last\
    \x20`ListTopicSnapshotsResponse`;\x20indicates\n\x20that\x20this\x20is\
    \x20a\x20continuation\x20of\x20a\x20prior\x20`ListTopicSnapshots`\x20cal\
    l,\x20and\n\x20that\x20the\x20system\x20should\x20return\x20the\x20next\
    \x20page\x20of\x20data.\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xff\x02\
    \x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xff\x02\t\x13\n\r\n\x05\
    \x04\x0c\x02\x02\x03\x12\x04\xff\x02\x16\x17\n=\n\x02\x04\r\x12\x06\x83\
    \x03\0\x8b\x03\x01\x1a/\x20Response\x20for\x20the\x20`ListTopicSnapshots\
    `\x20method.\n\n\x0b\n\x03\x04\r\x01\x12\x04\x83\x03\x08\"\nB\n\x04\x04\
    \r\x02\0\x12\x04\x85\x03\x02\x20\x1a4\x20The\x20names\x20of\x20the\x20sn\
    apshots\x20that\x20match\x20the\x20request.\n\n\r\n\x05\x04\r\x02\0\x04\
    \x12\x04\x85\x03\x02\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x85\x03\x0b\x11\
    \n\r\n\x05\x04\r\x02\0\x01\x12\x04\x85\x03\x12\x1b\n\r\n\x05\x04\r\x02\0\
    \x03\x12\x04\x85\x03\x1e\x1f\n\xbb\x01\n\x04\x04\r\x02\x01\x12\x04\x8a\
    \x03\x02\x1d\x1a\xac\x01\x20If\x20not\x20empty,\x20indicates\x20that\x20\
    there\x20may\x20be\x20more\x20snapshots\x20that\x20match\n\x20the\x20req\
    uest;\x20this\x20value\x20should\x20be\x20passed\x20in\x20a\x20new\n\x20\
    `ListTopicSnapshotsRequest`\x20to\x20get\x20more\x20snapshots.\n\n\r\n\
    \x05\x04\r\x02\x01\x05\x12\x04\x8a\x03\x02\x08\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\x8a\x03\t\x18\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x8a\x03\
    \x1b\x1c\n5\n\x02\x04\x0e\x12\x06\x8e\x03\0\x95\x03\x01\x1a'\x20Request\
    \x20for\x20the\x20`DeleteTopic`\x20method.\n\n\x0b\n\x03\x04\x0e\x01\x12\
    \x04\x8e\x03\x08\x1a\nh\n\x04\x04\x0e\x02\0\x12\x06\x91\x03\x02\x94\x03\
    \x04\x1aX\x20Required.\x20Name\x20of\x20the\x20topic\x20to\x20delete.\n\
    \x20Format\x20is\x20`projects/{project}/topics/{topic}`.\n\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\x91\x03\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x91\x03\t\x0e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x91\x03\x11\x12\n\
    \x0f\n\x05\x04\x0e\x02\0\x08\x12\x06\x91\x03\x13\x94\x03\x03\n\x10\n\x08\
    \x04\x0e\x02\0\x08\x9c\x08\0\x12\x04\x92\x03\x04*\n\x0f\n\x07\x04\x0e\
    \x02\0\x08\x9f\x08\x12\x04\x93\x03\x04M\n:\n\x02\x04\x0f\x12\x06\x98\x03\
    \0\xa1\x03\x01\x1a,\x20Request\x20for\x20the\x20DetachSubscription\x20me\
    thod.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x98\x03\x08!\nu\n\x04\x04\x0f\
    \x02\0\x12\x06\x9b\x03\x02\xa0\x03\x04\x1ae\x20Required.\x20The\x20subsc\
    ription\x20to\x20detach.\n\x20Format\x20is\x20`projects/{project}/subscr\
    iptions/{subscription}`.\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x9b\x03\
    \x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x9b\x03\t\x15\n\r\n\x05\x04\
    \x0f\x02\0\x03\x12\x04\x9b\x03\x18\x19\n\x0f\n\x05\x04\x0f\x02\0\x08\x12\
    \x06\x9b\x03\x1a\xa0\x03\x03\n\x10\n\x08\x04\x0f\x02\0\x08\x9c\x08\0\x12\
    \x04\x9c\x03\x04*\n\x11\n\x07\x04\x0f\x02\0\x08\x9f\x08\x12\x06\x9d\x03\
    \x04\x9f\x03\x05\nS\n\x02\x04\x10\x12\x04\xa5\x03\0%\x1aG\x20Response\
    \x20for\x20the\x20DetachSubscription\x20method.\n\x20Reserved\x20for\x20\
    future\x20use.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xa5\x03\x08\"\n\xe2\x01\
    \n\x02\x06\x01\x12\x06\xaa\x03\0\x88\x05\x01\x1a\xd3\x01\x20The\x20servi\
    ce\x20that\x20an\x20application\x20uses\x20to\x20manipulate\x20subscript\
    ions\x20and\x20to\n\x20consume\x20messages\x20from\x20a\x20subscription\
    \x20via\x20the\x20`Pull`\x20method\x20or\x20by\n\x20establishing\x20a\
    \x20bi-directional\x20stream\x20using\x20the\x20`StreamingPull`\x20metho\
    d.\n\n\x0b\n\x03\x06\x01\x01\x12\x04\xaa\x03\x08\x12\n\x0b\n\x03\x06\x01\
    \x03\x12\x04\xab\x03\x02=\n\r\n\x05\x06\x01\x03\x99\x08\x12\x04\xab\x03\
    \x02=\n\r\n\x03\x06\x01\x03\x12\x06\xac\x03\x02\xae\x03/\n\x0f\n\x05\x06\
    \x01\x03\x9a\x08\x12\x06\xac\x03\x02\xae\x03/\n\xaa\x05\n\x04\x06\x01\
    \x02\0\x12\x06\xbb\x03\x02\xc2\x03\x03\x1a\x99\x05\x20Creates\x20a\x20su\
    bscription\x20to\x20a\x20given\x20topic.\x20See\x20the\x20[resource\x20n\
    ame\x20rules]\n\x20(https://cloud.google.com/pubsub/docs/pubsub-basics#r\
    esource_names).\n\x20If\x20the\x20subscription\x20already\x20exists,\x20\
    returns\x20`ALREADY_EXISTS`.\n\x20If\x20the\x20corresponding\x20topic\
    \x20doesn't\x20exist,\x20returns\x20`NOT_FOUND`.\n\n\x20If\x20the\x20nam\
    e\x20is\x20not\x20provided\x20in\x20the\x20request,\x20the\x20server\x20\
    will\x20assign\x20a\x20random\n\x20name\x20for\x20this\x20subscription\
    \x20on\x20the\x20same\x20project\x20as\x20the\x20topic,\x20conforming\n\
    \x20to\x20the\x20[resource\x20name\x20format]\n\x20(https://cloud.google\
    .com/pubsub/docs/pubsub-basics#resource_names).\x20The\n\x20generated\
    \x20name\x20is\x20populated\x20in\x20the\x20returned\x20Subscription\x20\
    object.\x20Note\x20that\n\x20for\x20REST\x20API\x20requests,\x20you\x20m\
    ust\x20specify\x20a\x20name\x20in\x20the\x20request.\n\n\r\n\x05\x06\x01\
    \x02\0\x01\x12\x04\xbb\x03\x06\x18\n\r\n\x05\x06\x01\x02\0\x02\x12\x04\
    \xbb\x03\x19%\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\xbb\x030<\n\x0f\n\x05\
    \x06\x01\x02\0\x04\x12\x06\xbc\x03\x04\xbf\x03\x06\n\x13\n\t\x06\x01\x02\
    \0\x04\xb0\xca\xbc\"\x12\x06\xbc\x03\x04\xbf\x03\x06\n\x0f\n\x05\x06\x01\
    \x02\0\x04\x12\x06\xc0\x03\x04\xc1\x036\n\x12\n\x08\x06\x01\x02\0\x04\
    \x9b\x08\0\x12\x06\xc0\x03\x04\xc1\x036\nC\n\x04\x06\x01\x02\x01\x12\x06\
    \xc5\x03\x02\xca\x03\x03\x1a3\x20Gets\x20the\x20configuration\x20details\
    \x20of\x20a\x20subscription.\n\n\r\n\x05\x06\x01\x02\x01\x01\x12\x04\xc5\
    \x03\x06\x15\n\r\n\x05\x06\x01\x02\x01\x02\x12\x04\xc5\x03\x16,\n\r\n\
    \x05\x06\x01\x02\x01\x03\x12\x04\xc5\x037C\n\x0f\n\x05\x06\x01\x02\x01\
    \x04\x12\x06\xc6\x03\x04\xc8\x03\x06\n\x13\n\t\x06\x01\x02\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xc6\x03\x04\xc8\x03\x06\n\r\n\x05\x06\x01\x02\x01\x04\
    \x12\x04\xc9\x03\x04:\n\x10\n\x08\x06\x01\x02\x01\x04\x9b\x08\0\x12\x04\
    \xc9\x03\x04:\n\x8b\x01\n\x04\x06\x01\x02\x02\x12\x06\xce\x03\x02\xd4\
    \x03\x03\x1a{\x20Updates\x20an\x20existing\x20subscription.\x20Note\x20t\
    hat\x20certain\x20properties\x20of\x20a\n\x20subscription,\x20such\x20as\
    \x20its\x20topic,\x20are\x20not\x20modifiable.\n\n\r\n\x05\x06\x01\x02\
    \x02\x01\x12\x04\xce\x03\x06\x18\n\r\n\x05\x06\x01\x02\x02\x02\x12\x04\
    \xce\x03\x192\n\r\n\x05\x06\x01\x02\x02\x03\x12\x04\xce\x03=I\n\x0f\n\
    \x05\x06\x01\x02\x02\x04\x12\x06\xcf\x03\x04\xd2\x03\x06\n\x13\n\t\x06\
    \x01\x02\x02\x04\xb0\xca\xbc\"\x12\x06\xcf\x03\x04\xd2\x03\x06\n\r\n\x05\
    \x06\x01\x02\x02\x04\x12\x04\xd3\x03\x04F\n\x10\n\x08\x06\x01\x02\x02\
    \x04\x9b\x08\0\x12\x04\xd3\x03\x04F\n/\n\x04\x06\x01\x02\x03\x12\x06\xd7\
    \x03\x02\xdd\x03\x03\x1a\x1f\x20Lists\x20matching\x20subscriptions.\n\n\
    \r\n\x05\x06\x01\x02\x03\x01\x12\x04\xd7\x03\x06\x17\n\r\n\x05\x06\x01\
    \x02\x03\x02\x12\x04\xd7\x03\x180\n\r\n\x05\x06\x01\x02\x03\x03\x12\x04\
    \xd8\x03\x0f(\n\x0f\n\x05\x06\x01\x02\x03\x04\x12\x06\xd9\x03\x04\xdb\
    \x03\x06\n\x13\n\t\x06\x01\x02\x03\x04\xb0\xca\xbc\"\x12\x06\xd9\x03\x04\
    \xdb\x03\x06\n\r\n\x05\x06\x01\x02\x03\x04\x12\x04\xdc\x03\x045\n\x10\n\
    \x08\x06\x01\x02\x03\x04\x9b\x08\0\x12\x04\xdc\x03\x045\n\xef\x02\n\x04\
    \x06\x01\x02\x04\x12\x06\xe4\x03\x02\xea\x03\x03\x1a\xde\x02\x20Deletes\
    \x20an\x20existing\x20subscription.\x20All\x20messages\x20retained\x20in\
    \x20the\x20subscription\n\x20are\x20immediately\x20dropped.\x20Calls\x20\
    to\x20`Pull`\x20after\x20deletion\x20will\x20return\n\x20`NOT_FOUND`.\
    \x20After\x20a\x20subscription\x20is\x20deleted,\x20a\x20new\x20one\x20m\
    ay\x20be\x20created\x20with\n\x20the\x20same\x20name,\x20but\x20the\x20n\
    ew\x20one\x20has\x20no\x20association\x20with\x20the\x20old\n\x20subscri\
    ption\x20or\x20its\x20topic\x20unless\x20the\x20same\x20topic\x20is\x20s\
    pecified.\n\n\r\n\x05\x06\x01\x02\x04\x01\x12\x04\xe4\x03\x06\x18\n\r\n\
    \x05\x06\x01\x02\x04\x02\x12\x04\xe4\x03\x192\n\r\n\x05\x06\x01\x02\x04\
    \x03\x12\x04\xe5\x03\x0f$\n\x0f\n\x05\x06\x01\x02\x04\x04\x12\x06\xe6\
    \x03\x04\xe8\x03\x06\n\x13\n\t\x06\x01\x02\x04\x04\xb0\xca\xbc\"\x12\x06\
    \xe6\x03\x04\xe8\x03\x06\n\r\n\x05\x06\x01\x02\x04\x04\x12\x04\xe9\x03\
    \x04:\n\x10\n\x08\x06\x01\x02\x04\x04\x9b\x08\0\x12\x04\xe9\x03\x04:\n\
    \xe7\x02\n\x04\x06\x01\x02\x05\x12\x06\xf1\x03\x02\xf9\x03\x03\x1a\xd6\
    \x02\x20Modifies\x20the\x20ack\x20deadline\x20for\x20a\x20specific\x20me\
    ssage.\x20This\x20method\x20is\x20useful\n\x20to\x20indicate\x20that\x20\
    more\x20time\x20is\x20needed\x20to\x20process\x20a\x20message\x20by\x20t\
    he\n\x20subscriber,\x20or\x20to\x20make\x20the\x20message\x20available\
    \x20for\x20redelivery\x20if\x20the\n\x20processing\x20was\x20interrupted\
    .\x20Note\x20that\x20this\x20does\x20not\x20modify\x20the\n\x20subscript\
    ion-level\x20`ackDeadlineSeconds`\x20used\x20for\x20subsequent\x20messag\
    es.\n\n\r\n\x05\x06\x01\x02\x05\x01\x12\x04\xf1\x03\x06\x17\n\r\n\x05\
    \x06\x01\x02\x05\x02\x12\x04\xf1\x03\x180\n\r\n\x05\x06\x01\x02\x05\x03\
    \x12\x04\xf2\x03\x0f$\n\x0f\n\x05\x06\x01\x02\x05\x04\x12\x06\xf3\x03\
    \x04\xf6\x03\x06\n\x13\n\t\x06\x01\x02\x05\x04\xb0\xca\xbc\"\x12\x06\xf3\
    \x03\x04\xf6\x03\x06\n\x0f\n\x05\x06\x01\x02\x05\x04\x12\x06\xf7\x03\x04\
    \xf8\x034\n\x12\n\x08\x06\x01\x02\x05\x04\x9b\x08\0\x12\x06\xf7\x03\x04\
    \xf8\x034\n\xed\x02\n\x04\x06\x01\x02\x06\x12\x06\x82\x04\x02\x88\x04\
    \x03\x1a\xdc\x02\x20Acknowledges\x20the\x20messages\x20associated\x20wit\
    h\x20the\x20`ack_ids`\x20in\x20the\n\x20`AcknowledgeRequest`.\x20The\x20\
    Pub/Sub\x20system\x20can\x20remove\x20the\x20relevant\x20messages\n\x20f\
    rom\x20the\x20subscription.\n\n\x20Acknowledging\x20a\x20message\x20whos\
    e\x20ack\x20deadline\x20has\x20expired\x20may\x20succeed,\n\x20but\x20su\
    ch\x20a\x20message\x20may\x20be\x20redelivered\x20later.\x20Acknowledgin\
    g\x20a\x20message\x20more\n\x20than\x20once\x20will\x20not\x20result\x20\
    in\x20an\x20error.\n\n\r\n\x05\x06\x01\x02\x06\x01\x12\x04\x82\x04\x06\
    \x11\n\r\n\x05\x06\x01\x02\x06\x02\x12\x04\x82\x04\x12$\n\r\n\x05\x06\
    \x01\x02\x06\x03\x12\x04\x82\x04/D\n\x0f\n\x05\x06\x01\x02\x06\x04\x12\
    \x06\x83\x04\x04\x86\x04\x06\n\x13\n\t\x06\x01\x02\x06\x04\xb0\xca\xbc\"\
    \x12\x06\x83\x04\x04\x86\x04\x06\n\r\n\x05\x06\x01\x02\x06\x04\x12\x04\
    \x87\x04\x04B\n\x10\n\x08\x06\x01\x02\x06\x04\x9b\x08\0\x12\x04\x87\x04\
    \x04B\n1\n\x04\x06\x01\x02\x07\x12\x06\x8b\x04\x02\x93\x04\x03\x1a!\x20P\
    ulls\x20messages\x20from\x20the\x20server.\n\n\r\n\x05\x06\x01\x02\x07\
    \x01\x12\x04\x8b\x04\x06\n\n\r\n\x05\x06\x01\x02\x07\x02\x12\x04\x8b\x04\
    \x0b\x16\n\r\n\x05\x06\x01\x02\x07\x03\x12\x04\x8b\x04!-\n\x0f\n\x05\x06\
    \x01\x02\x07\x04\x12\x06\x8c\x04\x04\x8f\x04\x06\n\x13\n\t\x06\x01\x02\
    \x07\x04\xb0\xca\xbc\"\x12\x06\x8c\x04\x04\x8f\x04\x06\n\x0f\n\x05\x06\
    \x01\x02\x07\x04\x12\x06\x90\x04\x04\x91\x047\n\x12\n\x08\x06\x01\x02\
    \x07\x04\x9b\x08\0\x12\x06\x90\x04\x04\x91\x047\n\r\n\x05\x06\x01\x02\
    \x07\x04\x12\x04\x92\x04\x04G\n\x10\n\x08\x06\x01\x02\x07\x04\x9b\x08\
    \x01\x12\x04\x92\x04\x04G\n\xe2\x03\n\x04\x06\x01\x02\x08\x12\x06\x9c\
    \x04\x02\x9d\x04/\x1a\xd1\x03\x20Establishes\x20a\x20stream\x20with\x20t\
    he\x20server,\x20which\x20sends\x20messages\x20down\x20to\x20the\n\x20cl\
    ient.\x20The\x20client\x20streams\x20acknowledgements\x20and\x20ack\x20d\
    eadline\x20modifications\n\x20back\x20to\x20the\x20server.\x20The\x20ser\
    ver\x20will\x20close\x20the\x20stream\x20and\x20return\x20the\x20status\
    \n\x20on\x20any\x20error.\x20The\x20server\x20may\x20close\x20the\x20str\
    eam\x20with\x20status\x20`UNAVAILABLE`\x20to\n\x20reassign\x20server-sid\
    e\x20resources,\x20in\x20which\x20case,\x20the\x20client\x20should\n\x20\
    re-establish\x20the\x20stream.\x20Flow\x20control\x20can\x20be\x20achiev\
    ed\x20by\x20configuring\x20the\n\x20underlying\x20RPC\x20channel.\n\n\r\
    \n\x05\x06\x01\x02\x08\x01\x12\x04\x9c\x04\x06\x13\n\r\n\x05\x06\x01\x02\
    \x08\x05\x12\x04\x9c\x04\x14\x1a\n\r\n\x05\x06\x01\x02\x08\x02\x12\x04\
    \x9c\x04\x1b/\n\r\n\x05\x06\x01\x02\x08\x06\x12\x04\x9d\x04\x0f\x15\n\r\
    \n\x05\x06\x01\x02\x08\x03\x12\x04\x9d\x04\x16+\n\xf7\x02\n\x04\x06\x01\
    \x02\t\x12\x06\xa5\x04\x02\xac\x04\x03\x1a\xe6\x02\x20Modifies\x20the\
    \x20`PushConfig`\x20for\x20a\x20specified\x20subscription.\n\n\x20This\
    \x20may\x20be\x20used\x20to\x20change\x20a\x20push\x20subscription\x20to\
    \x20a\x20pull\x20one\x20(signified\x20by\n\x20an\x20empty\x20`PushConfig\
    `)\x20or\x20vice\x20versa,\x20or\x20change\x20the\x20endpoint\x20URL\x20\
    and\x20other\n\x20attributes\x20of\x20a\x20push\x20subscription.\x20Mess\
    ages\x20will\x20accumulate\x20for\x20delivery\n\x20continuously\x20throu\
    gh\x20the\x20call\x20regardless\x20of\x20changes\x20to\x20the\x20`PushCo\
    nfig`.\n\n\r\n\x05\x06\x01\x02\t\x01\x12\x04\xa5\x04\x06\x16\n\r\n\x05\
    \x06\x01\x02\t\x02\x12\x04\xa5\x04\x17.\n\r\n\x05\x06\x01\x02\t\x03\x12\
    \x04\xa6\x04\x0f$\n\x0f\n\x05\x06\x01\x02\t\x04\x12\x06\xa7\x04\x04\xaa\
    \x04\x06\n\x13\n\t\x06\x01\x02\t\x04\xb0\xca\xbc\"\x12\x06\xa7\x04\x04\
    \xaa\x04\x06\n\r\n\x05\x06\x01\x02\t\x04\x12\x04\xab\x04\x04F\n\x10\n\
    \x08\x06\x01\x02\t\x04\x9b\x08\0\x12\x04\xab\x04\x04F\n\xd9\x02\n\x04\
    \x06\x01\x02\n\x12\x06\xb3\x04\x02\xb8\x04\x03\x1a\xc8\x02\x20Gets\x20th\
    e\x20configuration\x20details\x20of\x20a\x20snapshot.\x20Snapshots\x20ar\
    e\x20used\x20in\n\x20[Seek](https://cloud.google.com/pubsub/docs/replay-\
    overview)\x20operations,\n\x20which\x20allow\x20you\x20to\x20manage\x20m\
    essage\x20acknowledgments\x20in\x20bulk.\x20That\x20is,\x20you\x20can\n\
    \x20set\x20the\x20acknowledgment\x20state\x20of\x20messages\x20in\x20an\
    \x20existing\x20subscription\x20to\x20the\n\x20state\x20captured\x20by\
    \x20a\x20snapshot.\n\n\r\n\x05\x06\x01\x02\n\x01\x12\x04\xb3\x04\x06\x11\
    \n\r\n\x05\x06\x01\x02\n\x02\x12\x04\xb3\x04\x12$\n\r\n\x05\x06\x01\x02\
    \n\x03\x12\x04\xb3\x04/7\n\x0f\n\x05\x06\x01\x02\n\x04\x12\x06\xb4\x04\
    \x04\xb6\x04\x06\n\x13\n\t\x06\x01\x02\n\x04\xb0\xca\xbc\"\x12\x06\xb4\
    \x04\x04\xb6\x04\x06\n\r\n\x05\x06\x01\x02\n\x04\x12\x04\xb7\x04\x046\n\
    \x10\n\x08\x06\x01\x02\n\x04\x9b\x08\0\x12\x04\xb7\x04\x046\n\xca\x02\n\
    \x04\x06\x01\x02\x0b\x12\x06\xbf\x04\x02\xc4\x04\x03\x1a\xb9\x02\x20List\
    s\x20the\x20existing\x20snapshots.\x20Snapshots\x20are\x20used\x20in\x20\
    [Seek](\n\x20https://cloud.google.com/pubsub/docs/replay-overview)\x20op\
    erations,\x20which\n\x20allow\x20you\x20to\x20manage\x20message\x20ackno\
    wledgments\x20in\x20bulk.\x20That\x20is,\x20you\x20can\x20set\n\x20the\
    \x20acknowledgment\x20state\x20of\x20messages\x20in\x20an\x20existing\
    \x20subscription\x20to\x20the\n\x20state\x20captured\x20by\x20a\x20snaps\
    hot.\n\n\r\n\x05\x06\x01\x02\x0b\x01\x12\x04\xbf\x04\x06\x13\n\r\n\x05\
    \x06\x01\x02\x0b\x02\x12\x04\xbf\x04\x14(\n\r\n\x05\x06\x01\x02\x0b\x03\
    \x12\x04\xbf\x043H\n\x0f\n\x05\x06\x01\x02\x0b\x04\x12\x06\xc0\x04\x04\
    \xc2\x04\x06\n\x13\n\t\x06\x01\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xc0\x04\
    \x04\xc2\x04\x06\n\r\n\x05\x06\x01\x02\x0b\x04\x12\x04\xc3\x04\x045\n\
    \x10\n\x08\x06\x01\x02\x0b\x04\x9b\x08\0\x12\x04\xc3\x04\x045\n\xad\x08\
    \n\x04\x06\x01\x02\x0c\x12\x06\xd6\x04\x02\xdc\x04\x03\x1a\x9c\x08\x20Cr\
    eates\x20a\x20snapshot\x20from\x20the\x20requested\x20subscription.\x20S\
    napshots\x20are\x20used\x20in\n\x20[Seek](https://cloud.google.com/pubsu\
    b/docs/replay-overview)\x20operations,\n\x20which\x20allow\x20you\x20to\
    \x20manage\x20message\x20acknowledgments\x20in\x20bulk.\x20That\x20is,\
    \x20you\x20can\n\x20set\x20the\x20acknowledgment\x20state\x20of\x20messa\
    ges\x20in\x20an\x20existing\x20subscription\x20to\x20the\n\x20state\x20c\
    aptured\x20by\x20a\x20snapshot.\n\x20If\x20the\x20snapshot\x20already\
    \x20exists,\x20returns\x20`ALREADY_EXISTS`.\n\x20If\x20the\x20requested\
    \x20subscription\x20doesn't\x20exist,\x20returns\x20`NOT_FOUND`.\n\x20If\
    \x20the\x20backlog\x20in\x20the\x20subscription\x20is\x20too\x20old\x20-\
    -\x20and\x20the\x20resulting\x20snapshot\n\x20would\x20expire\x20in\x20l\
    ess\x20than\x201\x20hour\x20--\x20then\x20`FAILED_PRECONDITION`\x20is\
    \x20returned.\n\x20See\x20also\x20the\x20`Snapshot.expire_time`\x20field\
    .\x20If\x20the\x20name\x20is\x20not\x20provided\x20in\n\x20the\x20reques\
    t,\x20the\x20server\x20will\x20assign\x20a\x20random\n\x20name\x20for\
    \x20this\x20snapshot\x20on\x20the\x20same\x20project\x20as\x20the\x20sub\
    scription,\x20conforming\n\x20to\x20the\x20[resource\x20name\x20format]\
    \n\x20(https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names\
    ).\x20The\n\x20generated\x20name\x20is\x20populated\x20in\x20the\x20retu\
    rned\x20Snapshot\x20object.\x20Note\x20that\x20for\n\x20REST\x20API\x20r\
    equests,\x20you\x20must\x20specify\x20a\x20name\x20in\x20the\x20request.\
    \n\n\r\n\x05\x06\x01\x02\x0c\x01\x12\x04\xd6\x04\x06\x14\n\r\n\x05\x06\
    \x01\x02\x0c\x02\x12\x04\xd6\x04\x15*\n\r\n\x05\x06\x01\x02\x0c\x03\x12\
    \x04\xd6\x045=\n\x0f\n\x05\x06\x01\x02\x0c\x04\x12\x06\xd7\x04\x04\xda\
    \x04\x06\n\x13\n\t\x06\x01\x02\x0c\x04\xb0\xca\xbc\"\x12\x06\xd7\x04\x04\
    \xda\x04\x06\n\r\n\x05\x06\x01\x02\x0c\x04\x12\x04\xdb\x04\x04?\n\x10\n\
    \x08\x06\x01\x02\x0c\x04\x9b\x08\0\x12\x04\xdb\x04\x04?\n\xc9\x02\n\x04\
    \x06\x01\x02\r\x12\x06\xe3\x04\x02\xe9\x04\x03\x1a\xb8\x02\x20Updates\
    \x20an\x20existing\x20snapshot.\x20Snapshots\x20are\x20used\x20in\n\x20[\
    Seek](https://cloud.google.com/pubsub/docs/replay-overview)\x20operation\
    s,\n\x20which\x20allow\x20you\x20to\x20manage\x20message\x20acknowledgme\
    nts\x20in\x20bulk.\x20That\x20is,\x20you\x20can\n\x20set\x20the\x20ackno\
    wledgment\x20state\x20of\x20messages\x20in\x20an\x20existing\x20subscrip\
    tion\x20to\x20the\n\x20state\x20captured\x20by\x20a\x20snapshot.\n\n\r\n\
    \x05\x06\x01\x02\r\x01\x12\x04\xe3\x04\x06\x14\n\r\n\x05\x06\x01\x02\r\
    \x02\x12\x04\xe3\x04\x15*\n\r\n\x05\x06\x01\x02\r\x03\x12\x04\xe3\x045=\
    \n\x0f\n\x05\x06\x01\x02\r\x04\x12\x06\xe4\x04\x04\xe7\x04\x06\n\x13\n\t\
    \x06\x01\x02\r\x04\xb0\xca\xbc\"\x12\x06\xe4\x04\x04\xe7\x04\x06\n\r\n\
    \x05\x06\x01\x02\r\x04\x12\x04\xe8\x04\x04B\n\x10\n\x08\x06\x01\x02\r\
    \x04\x9b\x08\0\x12\x04\xe8\x04\x04B\n\xee\x04\n\x04\x06\x01\x02\x0e\x12\
    \x06\xf4\x04\x02\xf9\x04\x03\x1a\xdd\x04\x20Removes\x20an\x20existing\
    \x20snapshot.\x20Snapshots\x20are\x20used\x20in\x20[Seek]\n\x20(https://\
    cloud.google.com/pubsub/docs/replay-overview)\x20operations,\x20which\n\
    \x20allow\x20you\x20to\x20manage\x20message\x20acknowledgments\x20in\x20\
    bulk.\x20That\x20is,\x20you\x20can\x20set\n\x20the\x20acknowledgment\x20\
    state\x20of\x20messages\x20in\x20an\x20existing\x20subscription\x20to\
    \x20the\n\x20state\x20captured\x20by\x20a\x20snapshot.\n\x20When\x20the\
    \x20snapshot\x20is\x20deleted,\x20all\x20messages\x20retained\x20in\x20t\
    he\x20snapshot\n\x20are\x20immediately\x20dropped.\x20After\x20a\x20snap\
    shot\x20is\x20deleted,\x20a\x20new\x20one\x20may\x20be\n\x20created\x20w\
    ith\x20the\x20same\x20name,\x20but\x20the\x20new\x20one\x20has\x20no\x20\
    association\x20with\x20the\x20old\n\x20snapshot\x20or\x20its\x20subscrip\
    tion,\x20unless\x20the\x20same\x20subscription\x20is\x20specified.\n\n\r\
    \n\x05\x06\x01\x02\x0e\x01\x12\x04\xf4\x04\x06\x14\n\r\n\x05\x06\x01\x02\
    \x0e\x02\x12\x04\xf4\x04\x15*\n\r\n\x05\x06\x01\x02\x0e\x03\x12\x04\xf4\
    \x045J\n\x0f\n\x05\x06\x01\x02\x0e\x04\x12\x06\xf5\x04\x04\xf7\x04\x06\n\
    \x13\n\t\x06\x01\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\xf5\x04\x04\xf7\x04\
    \x06\n\r\n\x05\x06\x01\x02\x0e\x04\x12\x04\xf8\x04\x046\n\x10\n\x08\x06\
    \x01\x02\x0e\x04\x9b\x08\0\x12\x04\xf8\x04\x046\n\xea\x03\n\x04\x06\x01\
    \x02\x0f\x12\x06\x82\x05\x02\x87\x05\x03\x1a\xd9\x03\x20Seeks\x20an\x20e\
    xisting\x20subscription\x20to\x20a\x20point\x20in\x20time\x20or\x20to\
    \x20a\x20given\x20snapshot,\n\x20whichever\x20is\x20provided\x20in\x20th\
    e\x20request.\x20Snapshots\x20are\x20used\x20in\x20[Seek]\n\x20(https://\
    cloud.google.com/pubsub/docs/replay-overview)\x20operations,\x20which\n\
    \x20allow\x20you\x20to\x20manage\x20message\x20acknowledgments\x20in\x20\
    bulk.\x20That\x20is,\x20you\x20can\x20set\n\x20the\x20acknowledgment\x20\
    state\x20of\x20messages\x20in\x20an\x20existing\x20subscription\x20to\
    \x20the\n\x20state\x20captured\x20by\x20a\x20snapshot.\x20Note\x20that\
    \x20both\x20the\x20subscription\x20and\x20the\n\x20snapshot\x20must\x20b\
    e\x20on\x20the\x20same\x20topic.\n\n\r\n\x05\x06\x01\x02\x0f\x01\x12\x04\
    \x82\x05\x06\n\n\r\n\x05\x06\x01\x02\x0f\x02\x12\x04\x82\x05\x0b\x16\n\r\
    \n\x05\x06\x01\x02\x0f\x03\x12\x04\x82\x05!-\n\x0f\n\x05\x06\x01\x02\x0f\
    \x04\x12\x06\x83\x05\x04\x86\x05\x06\n\x13\n\t\x06\x01\x02\x0f\x04\xb0\
    \xca\xbc\"\x12\x06\x83\x05\x04\x86\x05\x06\n\xe4\x01\n\x02\x04\x11\x12\
    \x06\x8d\x05\0\xb0\x06\x01\x1a\xd5\x01\x20A\x20subscription\x20resource.\
    \x20If\x20none\x20of\x20`push_config`,\x20`bigquery_config`,\x20or\n\x20\
    `cloud_storage_config`\x20is\x20set,\x20then\x20the\x20subscriber\x20wil\
    l\x20pull\x20and\x20ack\x20messages\n\x20using\x20API\x20methods.\x20At\
    \x20most\x20one\x20of\x20these\x20fields\x20may\x20be\x20set.\n\n\x0b\n\
    \x03\x04\x11\x01\x12\x04\x8d\x05\x08\x14\n\r\n\x03\x04\x11\x07\x12\x06\
    \x8e\x05\x02\x91\x05\x04\n\x0f\n\x05\x04\x11\x07\x9d\x08\x12\x06\x8e\x05\
    \x02\x91\x05\x04\n5\n\x04\x04\x11\x04\0\x12\x06\x94\x05\x02\x9f\x05\x03\
    \x1a%\x20Possible\x20states\x20for\x20a\x20subscription.\n\n\r\n\x05\x04\
    \x11\x04\0\x01\x12\x04\x94\x05\x07\x0c\n6\n\x06\x04\x11\x04\0\x02\0\x12\
    \x04\x96\x05\x04\x1a\x1a&\x20Default\x20value.\x20This\x20value\x20is\
    \x20unused.\n\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\x04\x96\x05\x04\
    \x15\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\x96\x05\x18\x19\n@\n\
    \x06\x04\x11\x04\0\x02\x01\x12\x04\x99\x05\x04\x0f\x1a0\x20The\x20subscr\
    iption\x20can\x20actively\x20receive\x20messages\n\n\x0f\n\x07\x04\x11\
    \x04\0\x02\x01\x01\x12\x04\x99\x05\x04\n\n\x0f\n\x07\x04\x11\x04\0\x02\
    \x01\x02\x12\x04\x99\x05\r\x0e\n\xc6\x01\n\x06\x04\x11\x04\0\x02\x02\x12\
    \x04\x9e\x05\x04\x17\x1a\xb5\x01\x20The\x20subscription\x20cannot\x20rec\
    eive\x20messages\x20because\x20of\x20an\x20error\x20with\x20the\n\x20res\
    ource\x20to\x20which\x20it\x20pushes\x20messages.\x20See\x20the\x20more\
    \x20detailed\x20error\x20state\n\x20in\x20the\x20corresponding\x20config\
    uration.\n\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x01\x12\x04\x9e\x05\x04\x12\
    \n\x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\x04\x9e\x05\x15\x16\n\xa8\x03\
    \n\x04\x04\x11\x02\0\x12\x04\xa7\x05\x02;\x1a\x99\x03\x20Required.\x20Th\
    e\x20name\x20of\x20the\x20subscription.\x20It\x20must\x20have\x20the\x20\
    format\n\x20`\"projects/{project}/subscriptions/{subscription}\"`.\x20`{\
    subscription}`\x20must\n\x20start\x20with\x20a\x20letter,\x20and\x20cont\
    ain\x20only\x20letters\x20(`[A-Za-z]`),\x20numbers\n\x20(`[0-9]`),\x20da\
    shes\x20(`-`),\x20underscores\x20(`_`),\x20periods\x20(`.`),\x20tildes\
    \x20(`~`),\n\x20plus\x20(`+`)\x20or\x20percent\x20signs\x20(`%`).\x20It\
    \x20must\x20be\x20between\x203\x20and\x20255\x20characters\n\x20in\x20le\
    ngth,\x20and\x20it\x20must\x20not\x20start\x20with\x20`\"goog\"`.\n\n\r\
    \n\x05\x04\x11\x02\0\x05\x12\x04\xa7\x05\x02\x08\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xa7\x05\t\r\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xa7\x05\x10\
    \x11\n\r\n\x05\x04\x11\x02\0\x08\x12\x04\xa7\x05\x12:\n\x10\n\x08\x04\
    \x11\x02\0\x08\x9c\x08\0\x12\x04\xa7\x05\x139\n\xe8\x01\n\x04\x04\x11\
    \x02\x01\x12\x06\xac\x05\x02\xaf\x05\x04\x1a\xd7\x01\x20Required.\x20The\
    \x20name\x20of\x20the\x20topic\x20from\x20which\x20this\x20subscription\
    \x20is\x20receiving\n\x20messages.\x20Format\x20is\x20`projects/{project\
    }/topics/{topic}`.\x20The\x20value\x20of\x20this\n\x20field\x20will\x20b\
    e\x20`_deleted-topic_`\x20if\x20the\x20topic\x20has\x20been\x20deleted.\
    \n\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xac\x05\x02\x08\n\r\n\x05\x04\
    \x11\x02\x01\x01\x12\x04\xac\x05\t\x0e\n\r\n\x05\x04\x11\x02\x01\x03\x12\
    \x04\xac\x05\x11\x12\n\x0f\n\x05\x04\x11\x02\x01\x08\x12\x06\xac\x05\x13\
    \xaf\x05\x03\n\x10\n\x08\x04\x11\x02\x01\x08\x9c\x08\0\x12\x04\xad\x05\
    \x04*\n\x0f\n\x07\x04\x11\x02\x01\x08\x9f\x08\x12\x04\xae\x05\x04M\ne\n\
    \x04\x04\x11\x02\x02\x12\x04\xb3\x05\x02\x1d\x1aW\x20If\x20push\x20deliv\
    ery\x20is\x20used\x20with\x20this\x20subscription,\x20this\x20field\x20i\
    s\n\x20used\x20to\x20configure\x20it.\n\n\r\n\x05\x04\x11\x02\x02\x06\
    \x12\x04\xb3\x05\x02\x0c\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xb3\x05\r\
    \x18\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xb3\x05\x1b\x1c\nl\n\x04\x04\
    \x11\x02\x03\x12\x04\xb7\x05\x02&\x1a^\x20If\x20delivery\x20to\x20BigQue\
    ry\x20is\x20used\x20with\x20this\x20subscription,\x20this\x20field\x20is\
    \n\x20used\x20to\x20configure\x20it.\n\n\r\n\x05\x04\x11\x02\x03\x06\x12\
    \x04\xb7\x05\x02\x10\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xb7\x05\x11\
    \x20\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xb7\x05#%\nx\n\x04\x04\x11\
    \x02\x04\x12\x04\xbb\x05\x02/\x1aj\x20If\x20delivery\x20to\x20Google\x20\
    Cloud\x20Storage\x20is\x20used\x20with\x20this\x20subscription,\x20this\
    \n\x20field\x20is\x20used\x20to\x20configure\x20it.\n\n\r\n\x05\x04\x11\
    \x02\x04\x06\x12\x04\xbb\x05\x02\x14\n\r\n\x05\x04\x11\x02\x04\x01\x12\
    \x04\xbb\x05\x15)\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xbb\x05,.\n\xc2\
    \x08\n\x04\x04\x11\x02\x05\x12\x04\xd1\x05\x02!\x1a\xb3\x08\x20The\x20ap\
    proximate\x20amount\x20of\x20time\x20(on\x20a\x20best-effort\x20basis)\
    \x20Pub/Sub\x20waits\x20for\n\x20the\x20subscriber\x20to\x20acknowledge\
    \x20receipt\x20before\x20resending\x20the\x20message.\x20In\x20the\n\x20\
    interval\x20after\x20the\x20message\x20is\x20delivered\x20and\x20before\
    \x20it\x20is\x20acknowledged,\x20it\n\x20is\x20considered\x20to\x20be\
    \x20_outstanding_.\x20During\x20that\x20time\x20period,\x20the\n\x20mess\
    age\x20will\x20not\x20be\x20redelivered\x20(on\x20a\x20best-effort\x20ba\
    sis).\n\n\x20For\x20pull\x20subscriptions,\x20this\x20value\x20is\x20use\
    d\x20as\x20the\x20initial\x20value\x20for\x20the\x20ack\n\x20deadline.\
    \x20To\x20override\x20this\x20value\x20for\x20a\x20given\x20message,\x20\
    call\n\x20`ModifyAckDeadline`\x20with\x20the\x20corresponding\x20`ack_id\
    `\x20if\x20using\n\x20non-streaming\x20pull\x20or\x20send\x20the\x20`ack\
    _id`\x20in\x20a\n\x20`StreamingModifyAckDeadlineRequest`\x20if\x20using\
    \x20streaming\x20pull.\n\x20The\x20minimum\x20custom\x20deadline\x20you\
    \x20can\x20specify\x20is\x2010\x20seconds.\n\x20The\x20maximum\x20custom\
    \x20deadline\x20you\x20can\x20specify\x20is\x20600\x20seconds\x20(10\x20\
    minutes).\n\x20If\x20this\x20parameter\x20is\x200,\x20a\x20default\x20va\
    lue\x20of\x2010\x20seconds\x20is\x20used.\n\n\x20For\x20push\x20delivery\
    ,\x20this\x20value\x20is\x20also\x20used\x20to\x20set\x20the\x20request\
    \x20timeout\x20for\n\x20the\x20call\x20to\x20the\x20push\x20endpoint.\n\
    \n\x20If\x20the\x20subscriber\x20never\x20acknowledges\x20the\x20message\
    ,\x20the\x20Pub/Sub\n\x20system\x20will\x20eventually\x20redeliver\x20th\
    e\x20message.\n\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\xd1\x05\x02\x07\n\
    \r\n\x05\x04\x11\x02\x05\x01\x12\x04\xd1\x05\x08\x1c\n\r\n\x05\x04\x11\
    \x02\x05\x03\x12\x04\xd1\x05\x1f\x20\n\xad\x03\n\x04\x04\x11\x02\x06\x12\
    \x04\xd9\x05\x02!\x1a\x9e\x03\x20Indicates\x20whether\x20to\x20retain\
    \x20acknowledged\x20messages.\x20If\x20true,\x20then\n\x20messages\x20ar\
    e\x20not\x20expunged\x20from\x20the\x20subscription's\x20backlog,\x20eve\
    n\x20if\x20they\x20are\n\x20acknowledged,\x20until\x20they\x20fall\x20ou\
    t\x20of\x20the\x20`message_retention_duration`\n\x20window.\x20This\x20m\
    ust\x20be\x20true\x20if\x20you\x20would\x20like\x20to\x20[`Seek`\x20to\
    \x20a\x20timestamp]\n\x20(https://cloud.google.com/pubsub/docs/replay-ov\
    erview#seek_to_a_time)\x20in\n\x20the\x20past\x20to\x20replay\x20previou\
    sly-acknowledged\x20messages.\n\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\
    \xd9\x05\x02\x06\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xd9\x05\x07\x1c\n\
    \r\n\x05\x04\x11\x02\x06\x03\x12\x04\xd9\x05\x1f\x20\n\xf4\x02\n\x04\x04\
    \x11\x02\x07\x12\x04\xe1\x05\x02:\x1a\xe5\x02\x20How\x20long\x20to\x20re\
    tain\x20unacknowledged\x20messages\x20in\x20the\x20subscription's\x20bac\
    klog,\n\x20from\x20the\x20moment\x20a\x20message\x20is\x20published.\n\
    \x20If\x20`retain_acked_messages`\x20is\x20true,\x20then\x20this\x20also\
    \x20configures\x20the\x20retention\n\x20of\x20acknowledged\x20messages,\
    \x20and\x20thus\x20configures\x20how\x20far\x20back\x20in\x20time\x20a\
    \x20`Seek`\n\x20can\x20be\x20done.\x20Defaults\x20to\x207\x20days.\x20Ca\
    nnot\x20be\x20more\x20than\x207\x20days\x20or\x20less\x20than\x2010\n\
    \x20minutes.\n\n\r\n\x05\x04\x11\x02\x07\x06\x12\x04\xe1\x05\x02\x1a\n\r\
    \n\x05\x04\x11\x02\x07\x01\x12\x04\xe1\x05\x1b5\n\r\n\x05\x04\x11\x02\
    \x07\x03\x12\x04\xe1\x0589\na\n\x04\x04\x11\x02\x08\x12\x04\xe5\x05\x02!\
    \x1aS\x20See\x20[Creating\x20and\x20managing\n\x20labels](https://cloud.\
    google.com/pubsub/docs/labels).\n\n\r\n\x05\x04\x11\x02\x08\x06\x12\x04\
    \xe5\x05\x02\x15\n\r\n\x05\x04\x11\x02\x08\x01\x12\x04\xe5\x05\x16\x1c\n\
    \r\n\x05\x04\x11\x02\x08\x03\x12\x04\xe5\x05\x1f\x20\n\xf2\x01\n\x04\x04\
    \x11\x02\t\x12\x04\xeb\x05\x02$\x1a\xe3\x01\x20If\x20true,\x20messages\
    \x20published\x20with\x20the\x20same\x20`ordering_key`\x20in\x20`PubsubM\
    essage`\n\x20will\x20be\x20delivered\x20to\x20the\x20subscribers\x20in\
    \x20the\x20order\x20in\x20which\x20they\n\x20are\x20received\x20by\x20th\
    e\x20Pub/Sub\x20system.\x20Otherwise,\x20they\x20may\x20be\x20delivered\
    \x20in\n\x20any\x20order.\n\n\r\n\x05\x04\x11\x02\t\x05\x12\x04\xeb\x05\
    \x02\x06\n\r\n\x05\x04\x11\x02\t\x01\x12\x04\xeb\x05\x07\x1e\n\r\n\x05\
    \x04\x11\x02\t\x03\x12\x04\xeb\x05!#\n\x91\x04\n\x04\x04\x11\x02\n\x12\
    \x04\xf4\x05\x02*\x1a\x82\x04\x20A\x20policy\x20that\x20specifies\x20the\
    \x20conditions\x20for\x20this\x20subscription's\x20expiration.\n\x20A\
    \x20subscription\x20is\x20considered\x20active\x20as\x20long\x20as\x20an\
    y\x20connected\x20subscriber\x20is\n\x20successfully\x20consuming\x20mes\
    sages\x20from\x20the\x20subscription\x20or\x20is\x20issuing\n\x20operati\
    ons\x20on\x20the\x20subscription.\x20If\x20`expiration_policy`\x20is\x20\
    not\x20set,\x20a\n\x20*default\x20policy*\x20with\x20`ttl`\x20of\x2031\
    \x20days\x20will\x20be\x20used.\x20The\x20minimum\x20allowed\n\x20value\
    \x20for\x20`expiration_policy.ttl`\x20is\x201\x20day.\x20If\x20`expirati\
    on_policy`\x20is\x20set,\n\x20but\x20`expiration_policy.ttl`\x20is\x20no\
    t\x20set,\x20the\x20subscription\x20never\x20expires.\n\n\r\n\x05\x04\
    \x11\x02\n\x06\x12\x04\xf4\x05\x02\x12\n\r\n\x05\x04\x11\x02\n\x01\x12\
    \x04\xf4\x05\x13$\n\r\n\x05\x04\x11\x02\n\x03\x12\x04\xf4\x05')\n\xa2\
    \x02\n\x04\x04\x11\x02\x0b\x12\x04\xfb\x05\x02\x15\x1a\x93\x02\x20An\x20\
    expression\x20written\x20in\x20the\x20Pub/Sub\x20[filter\n\x20language](\
    https://cloud.google.com/pubsub/docs/filtering).\x20If\x20non-empty,\n\
    \x20then\x20only\x20`PubsubMessage`s\x20whose\x20`attributes`\x20field\
    \x20matches\x20the\x20filter\x20are\n\x20delivered\x20on\x20this\x20subs\
    cription.\x20If\x20empty,\x20then\x20no\x20messages\x20are\x20filtered\n\
    \x20out.\n\n\r\n\x05\x04\x11\x02\x0b\x05\x12\x04\xfb\x05\x02\x08\n\r\n\
    \x05\x04\x11\x02\x0b\x01\x12\x04\xfb\x05\t\x0f\n\r\n\x05\x04\x11\x02\x0b\
    \x03\x12\x04\xfb\x05\x12\x14\n\x90\x03\n\x04\x04\x11\x02\x0c\x12\x04\x85\
    \x06\x02+\x1a\x81\x03\x20A\x20policy\x20that\x20specifies\x20the\x20cond\
    itions\x20for\x20dead\x20lettering\x20messages\x20in\n\x20this\x20subscr\
    iption.\x20If\x20dead_letter_policy\x20is\x20not\x20set,\x20dead\x20lett\
    ering\n\x20is\x20disabled.\n\n\x20The\x20Cloud\x20Pub/Sub\x20service\x20\
    account\x20associated\x20with\x20this\x20subscriptions's\n\x20parent\x20\
    project\x20(i.e.,\n\x20service-{project_number}@gcp-sa-pubsub.iam.gservi\
    ceaccount.com)\x20must\x20have\n\x20permission\x20to\x20Acknowledge()\
    \x20messages\x20on\x20this\x20subscription.\n\n\r\n\x05\x04\x11\x02\x0c\
    \x06\x12\x04\x85\x06\x02\x12\n\r\n\x05\x04\x11\x02\x0c\x01\x12\x04\x85\
    \x06\x13%\n\r\n\x05\x04\x11\x02\x0c\x03\x12\x04\x85\x06(*\n\xe5\x02\n\
    \x04\x04\x11\x02\r\x12\x04\x8e\x06\x02\x20\x1a\xd6\x02\x20A\x20policy\
    \x20that\x20specifies\x20how\x20Pub/Sub\x20retries\x20message\x20deliver\
    y\x20for\x20this\n\x20subscription.\n\n\x20If\x20not\x20set,\x20the\x20d\
    efault\x20retry\x20policy\x20is\x20applied.\x20This\x20generally\x20impl\
    ies\n\x20that\x20messages\x20will\x20be\x20retried\x20as\x20soon\x20as\
    \x20possible\x20for\x20healthy\x20subscribers.\n\x20RetryPolicy\x20will\
    \x20be\x20triggered\x20on\x20NACKs\x20or\x20acknowledgement\x20deadline\
    \n\x20exceeded\x20events\x20for\x20a\x20given\x20message.\n\n\r\n\x05\
    \x04\x11\x02\r\x06\x12\x04\x8e\x06\x02\r\n\r\n\x05\x04\x11\x02\r\x01\x12\
    \x04\x8e\x06\x0e\x1a\n\r\n\x05\x04\x11\x02\r\x03\x12\x04\x8e\x06\x1d\x1f\
    \n\xca\x02\n\x04\x04\x11\x02\x0e\x12\x04\x95\x06\x02\x15\x1a\xbb\x02\x20\
    Indicates\x20whether\x20the\x20subscription\x20is\x20detached\x20from\
    \x20its\x20topic.\x20Detached\n\x20subscriptions\x20don't\x20receive\x20\
    messages\x20from\x20their\x20topic\x20and\x20don't\x20retain\x20any\n\
    \x20backlog.\x20`Pull`\x20and\x20`StreamingPull`\x20requests\x20will\x20\
    return\n\x20FAILED_PRECONDITION.\x20If\x20the\x20subscription\x20is\x20a\
    \x20push\x20subscription,\x20pushes\x20to\n\x20the\x20endpoint\x20will\
    \x20not\x20be\x20made.\n\n\r\n\x05\x04\x11\x02\x0e\x05\x12\x04\x95\x06\
    \x02\x06\n\r\n\x05\x04\x11\x02\x0e\x01\x12\x04\x95\x06\x07\x0f\n\r\n\x05\
    \x04\x11\x02\x0e\x03\x12\x04\x95\x06\x12\x14\n\xe7\x04\n\x04\x04\x11\x02\
    \x0f\x12\x04\xa2\x06\x02)\x1a\xd8\x04\x20If\x20true,\x20Pub/Sub\x20provi\
    des\x20the\x20following\x20guarantees\x20for\x20the\x20delivery\x20of\n\
    \x20a\x20message\x20with\x20a\x20given\x20value\x20of\x20`message_id`\
    \x20on\x20this\x20subscription:\n\n\x20*\x20The\x20message\x20sent\x20to\
    \x20a\x20subscriber\x20is\x20guaranteed\x20not\x20to\x20be\x20resent\n\
    \x20before\x20the\x20message's\x20acknowledgement\x20deadline\x20expires\
    .\n\x20*\x20An\x20acknowledged\x20message\x20will\x20not\x20be\x20resent\
    \x20to\x20a\x20subscriber.\n\n\x20Note\x20that\x20subscribers\x20may\x20\
    still\x20receive\x20multiple\x20copies\x20of\x20a\x20message\n\x20when\
    \x20`enable_exactly_once_delivery`\x20is\x20true\x20if\x20the\x20message\
    \x20was\x20published\n\x20multiple\x20times\x20by\x20a\x20publisher\x20c\
    lient.\x20These\x20copies\x20are\x20\x20considered\x20distinct\n\x20by\
    \x20Pub/Sub\x20and\x20have\x20distinct\x20`message_id`\x20values.\n\n\r\
    \n\x05\x04\x11\x02\x0f\x05\x12\x04\xa2\x06\x02\x06\n\r\n\x05\x04\x11\x02\
    \x0f\x01\x12\x04\xa2\x06\x07#\n\r\n\x05\x04\x11\x02\x0f\x03\x12\x04\xa2\
    \x06&(\n\xc7\x03\n\x04\x04\x11\x02\x10\x12\x06\xaa\x06\x02\xab\x062\x1a\
    \xb6\x03\x20Output\x20only.\x20Indicates\x20the\x20minimum\x20duration\
    \x20for\x20which\x20a\x20message\x20is\x20retained\n\x20after\x20it\x20i\
    s\x20published\x20to\x20the\x20subscription's\x20topic.\x20If\x20this\
    \x20field\x20is\x20set,\n\x20messages\x20published\x20to\x20the\x20subsc\
    ription's\x20topic\x20in\x20the\x20last\n\x20`topic_message_retention_du\
    ration`\x20are\x20always\x20available\x20to\x20subscribers.\x20See\n\x20\
    the\x20`message_retention_duration`\x20field\x20in\x20`Topic`.\x20This\
    \x20field\x20is\x20set\x20only\n\x20in\x20responses\x20from\x20the\x20se\
    rver;\x20it\x20is\x20ignored\x20if\x20it\x20is\x20set\x20in\x20any\x20re\
    quests.\n\n\r\n\x05\x04\x11\x02\x10\x06\x12\x04\xaa\x06\x02\x1a\n\r\n\
    \x05\x04\x11\x02\x10\x01\x12\x04\xaa\x06\x1b;\n\r\n\x05\x04\x11\x02\x10\
    \x03\x12\x04\xaa\x06>@\n\r\n\x05\x04\x11\x02\x10\x08\x12\x04\xab\x06\x06\
    1\n\x10\n\x08\x04\x11\x02\x10\x08\x9c\x08\0\x12\x04\xab\x06\x070\ns\n\
    \x04\x04\x11\x02\x11\x12\x04\xaf\x06\x02?\x1ae\x20Output\x20only.\x20An\
    \x20output-only\x20field\x20indicating\x20whether\x20or\x20not\x20the\n\
    \x20subscription\x20can\x20receive\x20messages.\n\n\r\n\x05\x04\x11\x02\
    \x11\x06\x12\x04\xaf\x06\x02\x07\n\r\n\x05\x04\x11\x02\x11\x01\x12\x04\
    \xaf\x06\x08\r\n\r\n\x05\x04\x11\x02\x11\x03\x12\x04\xaf\x06\x10\x12\n\r\
    \n\x05\x04\x11\x02\x11\x08\x12\x04\xaf\x06\x13>\n\x10\n\x08\x04\x11\x02\
    \x11\x08\x9c\x08\0\x12\x04\xaf\x06\x14=\n\x8d\x04\n\x02\x04\x12\x12\x06\
    \xbd\x06\0\xc5\x06\x01\x1a\xfe\x03\x20A\x20policy\x20that\x20specifies\
    \x20how\x20Cloud\x20Pub/Sub\x20retries\x20message\x20delivery.\n\n\x20Re\
    try\x20delay\x20will\x20be\x20exponential\x20based\x20on\x20provided\x20\
    minimum\x20and\x20maximum\n\x20backoffs.\x20https://en.wikipedia.org/wik\
    i/Exponential_backoff.\n\n\x20RetryPolicy\x20will\x20be\x20triggered\x20\
    on\x20NACKs\x20or\x20acknowledgement\x20deadline\x20exceeded\n\x20events\
    \x20for\x20a\x20given\x20message.\n\n\x20Retry\x20Policy\x20is\x20implem\
    ented\x20on\x20a\x20best\x20effort\x20basis.\x20At\x20times,\x20the\x20d\
    elay\n\x20between\x20consecutive\x20deliveries\x20may\x20not\x20match\
    \x20the\x20configuration.\x20That\x20is,\n\x20delay\x20can\x20be\x20more\
    \x20or\x20less\x20than\x20configured\x20backoff.\n\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\xbd\x06\x08\x13\n\x99\x01\n\x04\x04\x12\x02\0\x12\x04\xc0\
    \x06\x02/\x1a\x8a\x01\x20The\x20minimum\x20delay\x20between\x20consecuti\
    ve\x20deliveries\x20of\x20a\x20given\x20message.\n\x20Value\x20should\
    \x20be\x20between\x200\x20and\x20600\x20seconds.\x20Defaults\x20to\x2010\
    \x20seconds.\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xc0\x06\x02\x1a\n\r\n\
    \x05\x04\x12\x02\0\x01\x12\x04\xc0\x06\x1b*\n\r\n\x05\x04\x12\x02\0\x03\
    \x12\x04\xc0\x06-.\n\x9a\x01\n\x04\x04\x12\x02\x01\x12\x04\xc4\x06\x02/\
    \x1a\x8b\x01\x20The\x20maximum\x20delay\x20between\x20consecutive\x20del\
    iveries\x20of\x20a\x20given\x20message.\n\x20Value\x20should\x20be\x20be\
    tween\x200\x20and\x20600\x20seconds.\x20Defaults\x20to\x20600\x20seconds\
    .\n\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xc4\x06\x02\x1a\n\r\n\x05\x04\
    \x12\x02\x01\x01\x12\x04\xc4\x06\x1b*\n\r\n\x05\x04\x12\x02\x01\x03\x12\
    \x04\xc4\x06-.\n\xf9\x01\n\x02\x04\x13\x12\x06\xcc\x06\0\xe6\x06\x01\x1a\
    \xea\x01\x20Dead\x20lettering\x20is\x20done\x20on\x20a\x20best\x20effort\
    \x20basis.\x20The\x20same\x20message\x20might\x20be\n\x20dead\x20lettere\
    d\x20multiple\x20times.\n\n\x20If\x20validation\x20on\x20any\x20of\x20th\
    e\x20fields\x20fails\x20at\x20subscription\x20creation/updation,\n\x20th\
    e\x20create/update\x20subscription\x20request\x20will\x20fail.\n\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xcc\x06\x08\x18\n\xa6\x04\n\x04\x04\x13\x02\0\
    \x12\x04\xd6\x06\x02\x1f\x1a\x97\x04\x20The\x20name\x20of\x20the\x20topi\
    c\x20to\x20which\x20dead\x20letter\x20messages\x20should\x20be\x20publis\
    hed.\n\x20Format\x20is\x20`projects/{project}/topics/{topic}`.The\x20Clo\
    ud\x20Pub/Sub\x20service\n\x20account\x20associated\x20with\x20the\x20en\
    closing\x20subscription's\x20parent\x20project\x20(i.e.,\n\x20service-{p\
    roject_number}@gcp-sa-pubsub.iam.gserviceaccount.com)\x20must\x20have\n\
    \x20permission\x20to\x20Publish()\x20to\x20this\x20topic.\n\n\x20The\x20\
    operation\x20will\x20fail\x20if\x20the\x20topic\x20does\x20not\x20exist.\
    \n\x20Users\x20should\x20ensure\x20that\x20there\x20is\x20a\x20subscript\
    ion\x20attached\x20to\x20this\x20topic\n\x20since\x20messages\x20publish\
    ed\x20to\x20a\x20topic\x20with\x20no\x20subscriptions\x20are\x20lost.\n\
    \n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xd6\x06\x02\x08\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xd6\x06\t\x1a\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xd6\
    \x06\x1d\x1e\n\x84\x04\n\x04\x04\x13\x02\x01\x12\x04\xe5\x06\x02\"\x1a\
    \xf5\x03\x20The\x20maximum\x20number\x20of\x20delivery\x20attempts\x20fo\
    r\x20any\x20message.\x20The\x20value\x20must\x20be\n\x20between\x205\x20\
    and\x20100.\n\n\x20The\x20number\x20of\x20delivery\x20attempts\x20is\x20\
    defined\x20as\x201\x20+\x20(the\x20sum\x20of\x20number\x20of\n\x20NACKs\
    \x20and\x20number\x20of\x20times\x20the\x20acknowledgement\x20deadline\
    \x20has\x20been\x20exceeded\n\x20for\x20the\x20message).\n\n\x20A\x20NAC\
    K\x20is\x20any\x20call\x20to\x20ModifyAckDeadline\x20with\x20a\x200\x20d\
    eadline.\x20Note\x20that\n\x20client\x20libraries\x20may\x20automaticall\
    y\x20extend\x20ack_deadlines.\n\n\x20This\x20field\x20will\x20be\x20hono\
    red\x20on\x20a\x20best\x20effort\x20basis.\n\n\x20If\x20this\x20paramete\
    r\x20is\x200,\x20a\x20default\x20value\x20of\x205\x20is\x20used.\n\n\r\n\
    \x05\x04\x13\x02\x01\x05\x12\x04\xe5\x06\x02\x07\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\xe5\x06\x08\x1d\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\
    \xe5\x06\x20!\nt\n\x02\x04\x14\x12\x06\xea\x06\0\xf2\x06\x01\x1af\x20A\
    \x20policy\x20that\x20specifies\x20the\x20conditions\x20for\x20resource\
    \x20expiration\x20(i.e.,\n\x20automatic\x20resource\x20deletion).\n\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xea\x06\x08\x18\n\x89\x03\n\x04\x04\x14\
    \x02\0\x12\x04\xf1\x06\x02#\x1a\xfa\x02\x20Specifies\x20the\x20\"time-to\
    -live\"\x20duration\x20for\x20an\x20associated\x20resource.\x20The\n\x20\
    resource\x20expires\x20if\x20it\x20is\x20not\x20active\x20for\x20a\x20pe\
    riod\x20of\x20`ttl`.\x20The\x20definition\n\x20of\x20\"activity\"\x20dep\
    ends\x20on\x20the\x20type\x20of\x20the\x20associated\x20resource.\x20The\
    \x20minimum\n\x20and\x20maximum\x20allowed\x20values\x20for\x20`ttl`\x20\
    depend\x20on\x20the\x20type\x20of\x20the\x20associated\n\x20resource,\
    \x20as\x20well.\x20If\x20`ttl`\x20is\x20not\x20set,\x20the\x20associated\
    \x20resource\x20never\n\x20expires.\n\n\r\n\x05\x04\x14\x02\0\x06\x12\
    \x04\xf1\x06\x02\x1a\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xf1\x06\x1b\x1e\
    \n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xf1\x06!\"\n;\n\x02\x04\x15\x12\x06\
    \xf5\x06\0\xc8\x07\x01\x1a-\x20Configuration\x20for\x20a\x20push\x20deli\
    very\x20endpoint.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xf5\x06\x08\x12\n\
    \x9a\x01\n\x04\x04\x15\x03\0\x12\x06\xf9\x06\x02\x88\x07\x03\x1a\x89\x01\
    \x20Contains\x20information\x20needed\x20for\x20generating\x20an\n\x20[O\
    penID\x20Connect\n\x20token](https://developers.google.com/identity/prot\
    ocols/OpenIDConnect).\n\n\r\n\x05\x04\x15\x03\0\x01\x12\x04\xf9\x06\n\
    \x13\n\xfe\x01\n\x06\x04\x15\x03\0\x02\0\x12\x04\xff\x06\x04%\x1a\xed\
    \x01\x20[Service\x20account\n\x20email](https://cloud.google.com/iam/doc\
    s/service-accounts)\n\x20used\x20for\x20generating\x20the\x20OIDC\x20tok\
    en.\x20For\x20more\x20information\n\x20on\x20setting\x20up\x20authentica\
    tion,\x20see\n\x20[Push\x20subscriptions](https://cloud.google.com/pubsu\
    b/docs/push).\n\n\x0f\n\x07\x04\x15\x03\0\x02\0\x05\x12\x04\xff\x06\x04\
    \n\n\x0f\n\x07\x04\x15\x03\0\x02\0\x01\x12\x04\xff\x06\x0b\x20\n\x0f\n\
    \x07\x04\x15\x03\0\x02\0\x03\x12\x04\xff\x06#$\n\xb0\x03\n\x06\x04\x15\
    \x03\0\x02\x01\x12\x04\x87\x07\x04\x18\x1a\x9f\x03\x20Audience\x20to\x20\
    be\x20used\x20when\x20generating\x20OIDC\x20token.\x20The\x20audience\
    \x20claim\n\x20identifies\x20the\x20recipients\x20that\x20the\x20JWT\x20\
    is\x20intended\x20for.\x20The\x20audience\n\x20value\x20is\x20a\x20singl\
    e\x20case-sensitive\x20string.\x20Having\x20multiple\x20values\x20(array\
    )\n\x20for\x20the\x20audience\x20field\x20is\x20not\x20supported.\x20Mor\
    e\x20info\x20about\x20the\x20OIDC\x20JWT\n\x20token\x20audience\x20here:\
    \x20https://tools.ietf.org/html/rfc7519#section-4.1.3\n\x20Note:\x20if\
    \x20not\x20specified,\x20the\x20Push\x20endpoint\x20URL\x20will\x20be\
    \x20used.\n\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x05\x12\x04\x87\x07\x04\n\
    \n\x0f\n\x07\x04\x15\x03\0\x02\x01\x01\x12\x04\x87\x07\x0b\x13\n\x0f\n\
    \x07\x04\x15\x03\0\x02\x01\x03\x12\x04\x87\x07\x16\x17\n\xc5\x01\n\x04\
    \x04\x15\x03\x01\x12\x04\x8d\x07\x02\x1a\x1a\xb6\x01\x20The\x20payload\
    \x20to\x20the\x20push\x20endpoint\x20is\x20in\x20the\x20form\x20of\x20th\
    e\x20JSON\x20representation\n\x20of\x20a\x20PubsubMessage\n\x20(https://\
    cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessag\
    e).\n\n\r\n\x05\x04\x15\x03\x01\x01\x12\x04\x8d\x07\n\x17\nF\n\x04\x04\
    \x15\x03\x02\x12\x06\x90\x07\x02\x95\x07\x03\x1a6\x20Sets\x20the\x20`dat\
    a`\x20field\x20as\x20the\x20HTTP\x20body\x20for\x20delivery.\n\n\r\n\x05\
    \x04\x15\x03\x02\x01\x12\x04\x90\x07\n\x13\n\xd3\x01\n\x06\x04\x15\x03\
    \x02\x02\0\x12\x04\x94\x07\x04\x1c\x1a\xc2\x01\x20When\x20true,\x20write\
    s\x20the\x20Pub/Sub\x20message\x20metadata\x20to\n\x20`x-goog-pubsub-<KE\
    Y>:<VAL>`\x20headers\x20of\x20the\x20HTTP\x20request.\x20Writes\x20the\n\
    \x20Pub/Sub\x20message\x20attributes\x20to\x20`<KEY>:<VAL>`\x20headers\
    \x20of\x20the\x20HTTP\x20request.\n\n\x0f\n\x07\x04\x15\x03\x02\x02\0\
    \x05\x12\x04\x94\x07\x04\x08\n\x0f\n\x07\x04\x15\x03\x02\x02\0\x01\x12\
    \x04\x94\x07\t\x17\n\x0f\n\x07\x04\x15\x03\x02\x02\0\x03\x12\x04\x94\x07\
    \x1a\x1b\n\x97\x01\n\x04\x04\x15\x02\0\x12\x04\x99\x07\x02\x1b\x1a\x88\
    \x01\x20A\x20URL\x20locating\x20the\x20endpoint\x20to\x20which\x20messag\
    es\x20should\x20be\x20pushed.\n\x20For\x20example,\x20a\x20Webhook\x20en\
    dpoint\x20might\x20use\x20`https://example.com/push`.\n\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\x99\x07\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\x99\x07\t\x16\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x99\x07\x19\x1a\n\
    \xeb\x07\n\x04\x04\x15\x02\x01\x12\x04\xb0\x07\x02%\x1a\xdc\x07\x20Endpo\
    int\x20configuration\x20attributes\x20that\x20can\x20be\x20used\x20to\
    \x20control\x20different\n\x20aspects\x20of\x20the\x20message\x20deliver\
    y.\n\n\x20The\x20only\x20currently\x20supported\x20attribute\x20is\x20`x\
    -goog-version`,\x20which\x20you\x20can\n\x20use\x20to\x20change\x20the\
    \x20format\x20of\x20the\x20pushed\x20message.\x20This\x20attribute\n\x20\
    indicates\x20the\x20version\x20of\x20the\x20data\x20expected\x20by\x20th\
    e\x20endpoint.\x20This\n\x20controls\x20the\x20shape\x20of\x20the\x20pus\
    hed\x20message\x20(i.e.,\x20its\x20fields\x20and\x20metadata).\n\n\x20If\
    \x20not\x20present\x20during\x20the\x20`CreateSubscription`\x20call,\x20\
    it\x20will\x20default\x20to\n\x20the\x20version\x20of\x20the\x20Pub/Sub\
    \x20API\x20used\x20to\x20make\x20such\x20call.\x20If\x20not\x20present\
    \x20in\x20a\n\x20`ModifyPushConfig`\x20call,\x20its\x20value\x20will\x20\
    not\x20be\x20changed.\x20`GetSubscription`\n\x20calls\x20will\x20always\
    \x20return\x20a\x20valid\x20version,\x20even\x20if\x20the\x20subscriptio\
    n\x20was\n\x20created\x20without\x20this\x20attribute.\n\n\x20The\x20onl\
    y\x20supported\x20values\x20for\x20the\x20`x-goog-version`\x20attribute\
    \x20are:\n\n\x20*\x20`v1beta1`:\x20uses\x20the\x20push\x20format\x20defi\
    ned\x20in\x20the\x20v1beta1\x20Pub/Sub\x20API.\n\x20*\x20`v1`\x20or\x20`\
    v1beta2`:\x20uses\x20the\x20push\x20format\x20defined\x20in\x20the\x20v1\
    \x20Pub/Sub\x20API.\n\n\x20For\x20example:\n\x20`attributes\x20{\x20\"x-\
    goog-version\":\x20\"v1\"\x20}`\n\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\
    \xb0\x07\x02\x15\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xb0\x07\x16\x20\n\
    \r\n\x05\x04\x15\x02\x01\x03\x12\x04\xb0\x07#$\n\xca\x02\n\x04\x04\x15\
    \x08\0\x12\x06\xb7\x07\x02\xbb\x07\x03\x1a\xb9\x02\x20An\x20authenticati\
    on\x20method\x20used\x20by\x20push\x20endpoints\x20to\x20verify\x20the\
    \x20source\x20of\n\x20push\x20requests.\x20This\x20can\x20be\x20used\x20\
    with\x20push\x20endpoints\x20that\x20are\x20private\x20by\n\x20default\
    \x20to\x20allow\x20requests\x20only\x20from\x20the\x20Cloud\x20Pub/Sub\
    \x20system,\x20for\x20example.\n\x20This\x20field\x20is\x20optional\x20a\
    nd\x20should\x20be\x20set\x20only\x20by\x20users\x20interested\x20in\n\
    \x20authenticated\x20push.\n\n\r\n\x05\x04\x15\x08\0\x01\x12\x04\xb7\x07\
    \x08\x1d\n\x9d\x01\n\x04\x04\x15\x02\x02\x12\x04\xba\x07\x04\x1d\x1a\x8e\
    \x01\x20If\x20specified,\x20Pub/Sub\x20will\x20generate\x20and\x20attach\
    \x20an\x20OIDC\x20JWT\x20token\x20as\x20an\n\x20`Authorization`\x20heade\
    r\x20in\x20the\x20HTTP\x20request\x20for\x20every\x20pushed\x20message.\
    \n\n\r\n\x05\x04\x15\x02\x02\x06\x12\x04\xba\x07\x04\r\n\r\n\x05\x04\x15\
    \x02\x02\x01\x12\x04\xba\x07\x0e\x18\n\r\n\x05\x04\x15\x02\x02\x03\x12\
    \x04\xba\x07\x1b\x1c\n\x93\x01\n\x04\x04\x15\x08\x01\x12\x06\xbf\x07\x02\
    \xc7\x07\x03\x1a\x82\x01\x20The\x20format\x20of\x20the\x20delivered\x20m\
    essage\x20to\x20the\x20push\x20endpoint\x20is\x20defined\x20by\n\x20the\
    \x20chosen\x20wrapper.\x20When\x20unset,\x20`PubsubWrapper`\x20is\x20use\
    d.\n\n\r\n\x05\x04\x15\x08\x01\x01\x12\x04\xbf\x07\x08\x0f\n\xcf\x01\n\
    \x04\x04\x15\x02\x03\x12\x04\xc3\x07\x04%\x1a\xc0\x01\x20When\x20set,\
    \x20the\x20payload\x20to\x20the\x20push\x20endpoint\x20is\x20in\x20the\
    \x20form\x20of\x20the\x20JSON\n\x20representation\x20of\x20a\x20PubsubMe\
    ssage\n\x20(https://cloud.google.com/pubsub/docs/reference/rpc/google.pu\
    bsub.v1#pubsubmessage).\n\n\r\n\x05\x04\x15\x02\x03\x06\x12\x04\xc3\x07\
    \x04\x11\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xc3\x07\x12\x20\n\r\n\x05\
    \x04\x15\x02\x03\x03\x12\x04\xc3\x07#$\nJ\n\x04\x04\x15\x02\x04\x12\x04\
    \xc6\x07\x04\x1d\x1a<\x20When\x20set,\x20the\x20payload\x20to\x20the\x20\
    push\x20endpoint\x20is\x20not\x20wrapped.\n\n\r\n\x05\x04\x15\x02\x04\
    \x06\x12\x04\xc6\x07\x04\r\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xc6\x07\
    \x0e\x18\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xc6\x07\x1b\x1c\n:\n\x02\
    \x04\x16\x12\x06\xcb\x07\0\x82\x08\x01\x1a,\x20Configuration\x20for\x20a\
    \x20BigQuery\x20subscription.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xcb\x07\
    \x08\x16\n>\n\x04\x04\x16\x04\0\x12\x06\xcd\x07\x02\xe1\x07\x03\x1a.\x20\
    Possible\x20states\x20for\x20a\x20BigQuery\x20subscription.\n\n\r\n\x05\
    \x04\x16\x04\0\x01\x12\x04\xcd\x07\x07\x0c\n6\n\x06\x04\x16\x04\0\x02\0\
    \x12\x04\xcf\x07\x04\x1a\x1a&\x20Default\x20value.\x20This\x20value\x20i\
    s\x20unused.\n\n\x0f\n\x07\x04\x16\x04\0\x02\0\x01\x12\x04\xcf\x07\x04\
    \x15\n\x0f\n\x07\x04\x16\x04\0\x02\0\x02\x12\x04\xcf\x07\x18\x19\nI\n\
    \x06\x04\x16\x04\0\x02\x01\x12\x04\xd2\x07\x04\x0f\x1a9\x20The\x20subscr\
    iption\x20can\x20actively\x20send\x20messages\x20to\x20BigQuery\n\n\x0f\
    \n\x07\x04\x16\x04\0\x02\x01\x01\x12\x04\xd2\x07\x04\n\n\x0f\n\x07\x04\
    \x16\x04\0\x02\x01\x02\x12\x04\xd2\x07\r\x0e\n\xa3\x03\n\x06\x04\x16\x04\
    \0\x02\x02\x12\x04\xda\x07\x04\x1a\x1a\x92\x03\x20Cannot\x20write\x20to\
    \x20the\x20BigQuery\x20table\x20because\x20of\x20permission\x20denied\
    \x20errors.\n\x20This\x20can\x20happen\x20if\n\x20-\x20Pub/Sub\x20SA\x20\
    has\x20not\x20been\x20granted\x20the\x20[appropriate\x20BigQuery\x20IAM\
    \n\x20permissions](https://cloud.google.com/pubsub/docs/create-subscript\
    ion#assign_bigquery_service_account)\n\x20-\x20bigquery.googleapis.com\
    \x20API\x20is\x20not\x20enabled\x20for\x20the\x20project\n\x20([instruct\
    ions](https://cloud.google.com/service-usage/docs/enable-disable))\n\n\
    \x0f\n\x07\x04\x16\x04\0\x02\x02\x01\x12\x04\xda\x07\x04\x15\n\x0f\n\x07\
    \x04\x16\x04\0\x02\x02\x02\x12\x04\xda\x07\x18\x19\nO\n\x06\x04\x16\x04\
    \0\x02\x03\x12\x04\xdd\x07\x04\x12\x1a?\x20Cannot\x20write\x20to\x20the\
    \x20BigQuery\x20table\x20because\x20it\x20does\x20not\x20exist.\n\n\x0f\
    \n\x07\x04\x16\x04\0\x02\x03\x01\x12\x04\xdd\x07\x04\r\n\x0f\n\x07\x04\
    \x16\x04\0\x02\x03\x02\x12\x04\xdd\x07\x10\x11\nN\n\x06\x04\x16\x04\0\
    \x02\x04\x12\x04\xe0\x07\x04\x18\x1a>\x20Cannot\x20write\x20to\x20the\
    \x20BigQuery\x20table\x20due\x20to\x20a\x20schema\x20mismatch.\n\n\x0f\n\
    \x07\x04\x16\x04\0\x02\x04\x01\x12\x04\xe0\x07\x04\x13\n\x0f\n\x07\x04\
    \x16\x04\0\x02\x04\x02\x12\x04\xe0\x07\x16\x17\nl\n\x04\x04\x16\x02\0\
    \x12\x04\xe5\x07\x02\x13\x1a^\x20The\x20name\x20of\x20the\x20table\x20to\
    \x20which\x20to\x20write\x20data,\x20of\x20the\x20form\n\x20{projectId}.\
    {datasetId}.{tableId}\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xe5\x07\x02\
    \x08\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xe5\x07\t\x0e\n\r\n\x05\x04\x16\
    \x02\0\x03\x12\x04\xe5\x07\x11\x12\n\xc2\x01\n\x04\x04\x16\x02\x01\x12\
    \x04\xea\x07\x02E\x1a\xb3\x01\x20Optional.\x20When\x20true,\x20use\x20th\
    e\x20topic's\x20schema\x20as\x20the\x20columns\x20to\x20write\x20to\x20i\
    n\n\x20BigQuery,\x20if\x20it\x20exists.\x20`use_topic_schema`\x20and\x20\
    `use_table_schema`\x20cannot\x20be\n\x20enabled\x20at\x20the\x20same\x20\
    time.\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xea\x07\x02\x06\n\r\n\x05\
    \x04\x16\x02\x01\x01\x12\x04\xea\x07\x07\x17\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\xea\x07\x1a\x1b\n\r\n\x05\x04\x16\x02\x01\x08\x12\x04\xea\
    \x07\x1cD\n\x10\n\x08\x04\x16\x02\x01\x08\x9c\x08\0\x12\x04\xea\x07\x1dC\
    \n\xdb\x02\n\x04\x04\x16\x02\x02\x12\x04\xf1\x07\x02\x1a\x1a\xcc\x02\x20\
    When\x20true,\x20write\x20the\x20subscription\x20name,\x20message_id,\
    \x20publish_time,\n\x20attributes,\x20and\x20ordering_key\x20to\x20addit\
    ional\x20columns\x20in\x20the\x20table.\x20The\n\x20subscription\x20name\
    ,\x20message_id,\x20and\x20publish_time\x20fields\x20are\x20put\x20in\
    \x20their\x20own\n\x20columns\x20while\x20all\x20other\x20message\x20pro\
    perties\x20(other\x20than\x20data)\x20are\x20written\x20to\n\x20a\x20JSO\
    N\x20object\x20in\x20the\x20attributes\x20column.\n\n\r\n\x05\x04\x16\
    \x02\x02\x05\x12\x04\xf1\x07\x02\x06\n\r\n\x05\x04\x16\x02\x02\x01\x12\
    \x04\xf1\x07\x07\x15\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xf1\x07\x18\
    \x19\n\xc9\x02\n\x04\x04\x16\x02\x03\x12\x04\xf8\x07\x02\x1f\x1a\xba\x02\
    \x20When\x20true\x20and\x20use_topic_schema\x20is\x20true,\x20any\x20fie\
    lds\x20that\x20are\x20a\x20part\x20of\x20the\n\x20topic\x20schema\x20tha\
    t\x20are\x20not\x20part\x20of\x20the\x20BigQuery\x20table\x20schema\x20a\
    re\x20dropped\n\x20when\x20writing\x20to\x20BigQuery.\x20Otherwise,\x20t\
    he\x20schemas\x20must\x20be\x20kept\x20in\x20sync\x20and\n\x20any\x20mes\
    sages\x20with\x20extra\x20fields\x20are\x20not\x20written\x20and\x20rema\
    in\x20in\x20the\n\x20subscription's\x20backlog.\n\n\r\n\x05\x04\x16\x02\
    \x03\x05\x12\x04\xf8\x07\x02\x06\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\
    \xf8\x07\x07\x1a\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xf8\x07\x1d\x1e\n\
    w\n\x04\x04\x16\x02\x04\x12\x04\xfc\x07\x02>\x1ai\x20Output\x20only.\x20\
    An\x20output-only\x20field\x20that\x20indicates\x20whether\x20or\x20not\
    \x20the\n\x20subscription\x20can\x20receive\x20messages.\n\n\r\n\x05\x04\
    \x16\x02\x04\x06\x12\x04\xfc\x07\x02\x07\n\r\n\x05\x04\x16\x02\x04\x01\
    \x12\x04\xfc\x07\x08\r\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\xfc\x07\x10\
    \x11\n\r\n\x05\x04\x16\x02\x04\x08\x12\x04\xfc\x07\x12=\n\x10\n\x08\x04\
    \x16\x02\x04\x08\x9c\x08\0\x12\x04\xfc\x07\x13<\n\xbd\x01\n\x04\x04\x16\
    \x02\x05\x12\x04\x81\x08\x02E\x1a\xae\x01\x20Optional.\x20When\x20true,\
    \x20use\x20the\x20BigQuery\x20table's\x20schema\x20as\x20the\x20columns\
    \x20to\n\x20write\x20to\x20in\x20BigQuery.\x20`use_table_schema`\x20and\
    \x20`use_topic_schema`\x20cannot\x20be\n\x20enabled\x20at\x20the\x20same\
    \x20time.\n\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\x81\x08\x02\x06\n\r\n\
    \x05\x04\x16\x02\x05\x01\x12\x04\x81\x08\x07\x17\n\r\n\x05\x04\x16\x02\
    \x05\x03\x12\x04\x81\x08\x1a\x1b\n\r\n\x05\x04\x16\x02\x05\x08\x12\x04\
    \x81\x08\x1cD\n\x10\n\x08\x04\x16\x02\x05\x08\x9c\x08\0\x12\x04\x81\x08\
    \x1dC\n?\n\x02\x04\x17\x12\x06\x85\x08\0\xcc\x08\x01\x1a1\x20Configurati\
    on\x20for\x20a\x20Cloud\x20Storage\x20subscription.\n\n\x0b\n\x03\x04\
    \x17\x01\x12\x04\x85\x08\x08\x1a\n\x98\x01\n\x04\x04\x17\x03\0\x12\x04\
    \x89\x08\x02\x17\x1a\x89\x01\x20Configuration\x20for\x20writing\x20messa\
    ge\x20data\x20in\x20text\x20format.\n\x20Message\x20payloads\x20will\x20\
    be\x20written\x20to\x20files\x20as\x20raw\x20text,\x20separated\x20by\
    \x20a\n\x20newline.\n\n\r\n\x05\x04\x17\x03\0\x01\x12\x04\x89\x08\n\x14\
    \n\x94\x01\n\x04\x04\x17\x03\x01\x12\x06\x8d\x08\x02\x95\x08\x03\x1a\x83\
    \x01\x20Configuration\x20for\x20writing\x20message\x20data\x20in\x20Avro\
    \x20format.\n\x20Message\x20payloads\x20and\x20metadata\x20will\x20be\
    \x20written\x20to\x20files\x20as\x20an\x20Avro\x20binary.\n\n\r\n\x05\
    \x04\x17\x03\x01\x01\x12\x04\x8d\x08\n\x14\n\xfb\x02\n\x06\x04\x17\x03\
    \x01\x02\0\x12\x04\x94\x08\x04\x1c\x1a\xea\x02\x20When\x20true,\x20write\
    \x20the\x20subscription\x20name,\x20message_id,\x20publish_time,\n\x20at\
    tributes,\x20and\x20ordering_key\x20as\x20additional\x20fields\x20in\x20\
    the\x20output.\x20The\n\x20subscription\x20name,\x20message_id,\x20and\
    \x20publish_time\x20fields\x20are\x20put\x20in\x20their\n\x20own\x20fiel\
    ds\x20while\x20all\x20other\x20message\x20properties\x20other\x20than\
    \x20data\x20(for\n\x20example,\x20an\x20ordering_key,\x20if\x20present)\
    \x20are\x20added\x20as\x20entries\x20in\x20the\n\x20attributes\x20map.\n\
    \n\x0f\n\x07\x04\x17\x03\x01\x02\0\x05\x12\x04\x94\x08\x04\x08\n\x0f\n\
    \x07\x04\x17\x03\x01\x02\0\x01\x12\x04\x94\x08\t\x17\n\x0f\n\x07\x04\x17\
    \x03\x01\x02\0\x03\x12\x04\x94\x08\x1a\x1b\nC\n\x04\x04\x17\x04\0\x12\
    \x06\x98\x08\x02\xa5\x08\x03\x1a3\x20Possible\x20states\x20for\x20a\x20C\
    loud\x20Storage\x20subscription.\n\n\r\n\x05\x04\x17\x04\0\x01\x12\x04\
    \x98\x08\x07\x0c\n6\n\x06\x04\x17\x04\0\x02\0\x12\x04\x9a\x08\x04\x1a\
    \x1a&\x20Default\x20value.\x20This\x20value\x20is\x20unused.\n\n\x0f\n\
    \x07\x04\x17\x04\0\x02\0\x01\x12\x04\x9a\x08\x04\x15\n\x0f\n\x07\x04\x17\
    \x04\0\x02\0\x02\x12\x04\x9a\x08\x18\x19\nO\n\x06\x04\x17\x04\0\x02\x01\
    \x12\x04\x9d\x08\x04\x0f\x1a?\x20The\x20subscription\x20can\x20actively\
    \x20send\x20messages\x20to\x20Cloud\x20Storage.\n\n\x0f\n\x07\x04\x17\
    \x04\0\x02\x01\x01\x12\x04\x9d\x08\x04\n\n\x0f\n\x07\x04\x17\x04\0\x02\
    \x01\x02\x12\x04\x9d\x08\r\x0e\n`\n\x06\x04\x17\x04\0\x02\x02\x12\x04\
    \xa1\x08\x04\x1a\x1aP\x20Cannot\x20write\x20to\x20the\x20Cloud\x20Storag\
    e\x20bucket\x20because\x20of\x20permission\x20denied\n\x20errors.\n\n\
    \x0f\n\x07\x04\x17\x04\0\x02\x02\x01\x12\x04\xa1\x08\x04\x15\n\x0f\n\x07\
    \x04\x17\x04\0\x02\x02\x02\x12\x04\xa1\x08\x18\x19\nU\n\x06\x04\x17\x04\
    \0\x02\x03\x12\x04\xa4\x08\x04\x12\x1aE\x20Cannot\x20write\x20to\x20the\
    \x20Cloud\x20Storage\x20bucket\x20because\x20it\x20does\x20not\x20exist.\
    \n\n\x0f\n\x07\x04\x17\x04\0\x02\x03\x01\x12\x04\xa4\x08\x04\r\n\x0f\n\
    \x07\x04\x17\x04\0\x02\x03\x02\x12\x04\xa4\x08\x10\x11\n\x8c\x02\n\x04\
    \x04\x17\x02\0\x12\x04\xab\x08\x02=\x1a\xfd\x01\x20Required.\x20User-pro\
    vided\x20name\x20for\x20the\x20Cloud\x20Storage\x20bucket.\n\x20The\x20b\
    ucket\x20must\x20be\x20created\x20by\x20the\x20user.\x20The\x20bucket\
    \x20name\x20must\x20be\x20without\n\x20any\x20prefix\x20like\x20\"gs://\
    \".\x20See\x20the\x20[bucket\x20naming\n\x20requirements]\x20(https://cl\
    oud.google.com/storage/docs/buckets#naming).\n\n\r\n\x05\x04\x17\x02\0\
    \x05\x12\x04\xab\x08\x02\x08\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xab\x08\
    \t\x0f\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xab\x08\x12\x13\n\r\n\x05\x04\
    \x17\x02\0\x08\x12\x04\xab\x08\x14<\n\x10\n\x08\x04\x17\x02\0\x08\x9c\
    \x08\0\x12\x04\xab\x08\x15;\n\x9e\x01\n\x04\x04\x17\x02\x01\x12\x04\xaf\
    \x08\x02\x1d\x1a\x8f\x01\x20User-provided\x20prefix\x20for\x20Cloud\x20S\
    torage\x20filename.\x20See\x20the\x20[object\x20naming\n\x20requirements\
    ](https://cloud.google.com/storage/docs/objects#naming).\n\n\r\n\x05\x04\
    \x17\x02\x01\x05\x12\x04\xaf\x08\x02\x08\n\r\n\x05\x04\x17\x02\x01\x01\
    \x12\x04\xaf\x08\t\x18\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xaf\x08\x1b\
    \x1c\n\xb4\x01\n\x04\x04\x17\x02\x02\x12\x04\xb4\x08\x02\x1d\x1a\xa5\x01\
    \x20User-provided\x20suffix\x20for\x20Cloud\x20Storage\x20filename.\x20S\
    ee\x20the\x20[object\x20naming\n\x20requirements](https://cloud.google.c\
    om/storage/docs/objects#naming).\x20Must\n\x20not\x20end\x20in\x20\"/\".\
    \n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xb4\x08\x02\x08\n\r\n\x05\x04\
    \x17\x02\x02\x01\x12\x04\xb4\x08\t\x18\n\r\n\x05\x04\x17\x02\x02\x03\x12\
    \x04\xb4\x08\x1b\x1c\n*\n\x04\x04\x17\x08\0\x12\x06\xb7\x08\x02\xbd\x08\
    \x03\x1a\x1a\x20Defaults\x20to\x20text\x20format.\n\n\r\n\x05\x04\x17\
    \x08\0\x01\x12\x04\xb7\x08\x08\x15\nU\n\x04\x04\x17\x02\x03\x12\x04\xb9\
    \x08\x04\x1f\x1aG\x20If\x20set,\x20message\x20data\x20will\x20be\x20writ\
    ten\x20to\x20Cloud\x20Storage\x20in\x20text\x20format.\n\n\r\n\x05\x04\
    \x17\x02\x03\x06\x12\x04\xb9\x08\x04\x0e\n\r\n\x05\x04\x17\x02\x03\x01\
    \x12\x04\xb9\x08\x0f\x1a\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xb9\x08\
    \x1d\x1e\nU\n\x04\x04\x17\x02\x04\x12\x04\xbc\x08\x04\x1f\x1aG\x20If\x20\
    set,\x20message\x20data\x20will\x20be\x20written\x20to\x20Cloud\x20Stora\
    ge\x20in\x20Avro\x20format.\n\n\r\n\x05\x04\x17\x02\x04\x06\x12\x04\xbc\
    \x08\x04\x0e\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\xbc\x08\x0f\x1a\n\r\n\
    \x05\x04\x17\x02\x04\x03\x12\x04\xbc\x08\x1d\x1e\n\xd0\x01\n\x04\x04\x17\
    \x02\x05\x12\x04\xc2\x08\x02,\x1a\xc1\x01\x20The\x20maximum\x20duration\
    \x20that\x20can\x20elapse\x20before\x20a\x20new\x20Cloud\x20Storage\x20f\
    ile\x20is\n\x20created.\x20Min\x201\x20minute,\x20max\x2010\x20minutes,\
    \x20default\x205\x20minutes.\x20May\x20not\x20exceed\n\x20the\x20subscri\
    ption's\x20acknowledgement\x20deadline.\n\n\r\n\x05\x04\x17\x02\x05\x06\
    \x12\x04\xc2\x08\x02\x1a\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\xc2\x08\
    \x1b'\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\xc2\x08*+\n\xdb\x01\n\x04\
    \x04\x17\x02\x06\x12\x04\xc7\x08\x02\x16\x1a\xcc\x01\x20The\x20maximum\
    \x20bytes\x20that\x20can\x20be\x20written\x20to\x20a\x20Cloud\x20Storage\
    \x20file\x20before\x20a\x20new\n\x20file\x20is\x20created.\x20Min\x201\
    \x20KB,\x20max\x2010\x20GiB.\x20The\x20max_bytes\x20limit\x20may\x20be\
    \x20exceeded\n\x20in\x20cases\x20where\x20messages\x20are\x20larger\x20t\
    han\x20the\x20limit.\n\n\r\n\x05\x04\x17\x02\x06\x05\x12\x04\xc7\x08\x02\
    \x07\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\xc7\x08\x08\x11\n\r\n\x05\x04\
    \x17\x02\x06\x03\x12\x04\xc7\x08\x14\x15\nw\n\x04\x04\x17\x02\x07\x12\
    \x04\xcb\x08\x02>\x1ai\x20Output\x20only.\x20An\x20output-only\x20field\
    \x20that\x20indicates\x20whether\x20or\x20not\x20the\n\x20subscription\
    \x20can\x20receive\x20messages.\n\n\r\n\x05\x04\x17\x02\x07\x06\x12\x04\
    \xcb\x08\x02\x07\n\r\n\x05\x04\x17\x02\x07\x01\x12\x04\xcb\x08\x08\r\n\r\
    \n\x05\x04\x17\x02\x07\x03\x12\x04\xcb\x08\x10\x11\n\r\n\x05\x04\x17\x02\
    \x07\x08\x12\x04\xcb\x08\x12=\n\x10\n\x08\x04\x17\x02\x07\x08\x9c\x08\0\
    \x12\x04\xcb\x08\x13<\nB\n\x02\x04\x18\x12\x06\xcf\x08\0\xe7\x08\x01\x1a\
    4\x20A\x20message\x20and\x20its\x20corresponding\x20acknowledgment\x20ID\
    .\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xcf\x08\x08\x17\nH\n\x04\x04\x18\x02\
    \0\x12\x04\xd1\x08\x02\x14\x1a:\x20This\x20ID\x20can\x20be\x20used\x20to\
    \x20acknowledge\x20the\x20received\x20message.\n\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xd1\x08\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xd1\x08\
    \t\x0f\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xd1\x08\x12\x13\n\x1c\n\x04\
    \x04\x18\x02\x01\x12\x04\xd4\x08\x02\x1c\x1a\x0e\x20The\x20message.\n\n\
    \r\n\x05\x04\x18\x02\x01\x06\x12\x04\xd4\x08\x02\x0f\n\r\n\x05\x04\x18\
    \x02\x01\x01\x12\x04\xd4\x08\x10\x17\n\r\n\x05\x04\x18\x02\x01\x03\x12\
    \x04\xd4\x08\x1a\x1b\n\xe5\x05\n\x04\x04\x18\x02\x02\x12\x04\xe6\x08\x02\
    \x1d\x1a\xd6\x05\x20The\x20approximate\x20number\x20of\x20times\x20that\
    \x20Cloud\x20Pub/Sub\x20has\x20attempted\x20to\x20deliver\n\x20the\x20as\
    sociated\x20message\x20to\x20a\x20subscriber.\n\n\x20More\x20precisely,\
    \x20this\x20is\x201\x20+\x20(number\x20of\x20NACKs)\x20+\n\x20(number\
    \x20of\x20ack_deadline\x20exceeds)\x20for\x20this\x20message.\n\n\x20A\
    \x20NACK\x20is\x20any\x20call\x20to\x20ModifyAckDeadline\x20with\x20a\
    \x200\x20deadline.\x20An\x20ack_deadline\n\x20exceeds\x20event\x20is\x20\
    whenever\x20a\x20message\x20is\x20not\x20acknowledged\x20within\n\x20ack\
    _deadline.\x20Note\x20that\x20ack_deadline\x20is\x20initially\n\x20Subsc\
    ription.ackDeadlineSeconds,\x20but\x20may\x20get\x20extended\x20automati\
    cally\x20by\n\x20the\x20client\x20library.\n\n\x20Upon\x20the\x20first\
    \x20delivery\x20of\x20a\x20given\x20message,\x20`delivery_attempt`\x20wi\
    ll\x20have\x20a\n\x20value\x20of\x201.\x20The\x20value\x20is\x20calculat\
    ed\x20at\x20best\x20effort\x20and\x20is\x20approximate.\n\n\x20If\x20a\
    \x20DeadLetterPolicy\x20is\x20not\x20set\x20on\x20the\x20subscription,\
    \x20this\x20will\x20be\x200.\n\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xe6\
    \x08\x02\x07\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xe6\x08\x08\x18\n\r\n\
    \x05\x04\x18\x02\x02\x03\x12\x04\xe6\x08\x1b\x1c\n7\n\x02\x04\x19\x12\
    \x06\xea\x08\0\xf3\x08\x01\x1a)\x20Request\x20for\x20the\x20GetSubscript\
    ion\x20method.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xea\x08\x08\x1e\nu\n\
    \x04\x04\x19\x02\0\x12\x06\xed\x08\x02\xf2\x08\x04\x1ae\x20Required.\x20\
    The\x20name\x20of\x20the\x20subscription\x20to\x20get.\n\x20Format\x20is\
    \x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\x05\x04\x19\x02\0\
    \x05\x12\x04\xed\x08\x02\x08\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xed\x08\
    \t\x15\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xed\x08\x18\x19\n\x0f\n\x05\
    \x04\x19\x02\0\x08\x12\x06\xed\x08\x1a\xf2\x08\x03\n\x10\n\x08\x04\x19\
    \x02\0\x08\x9c\x08\0\x12\x04\xee\x08\x04*\n\x11\n\x07\x04\x19\x02\0\x08\
    \x9f\x08\x12\x06\xef\x08\x04\xf1\x08\x05\n:\n\x02\x04\x1a\x12\x06\xf6\
    \x08\0\xfe\x08\x01\x1a,\x20Request\x20for\x20the\x20UpdateSubscription\
    \x20method.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xf6\x08\x08!\n:\n\x04\x04\
    \x1a\x02\0\x12\x04\xf8\x08\x02I\x1a,\x20Required.\x20The\x20updated\x20s\
    ubscription\x20object.\n\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xf8\x08\x02\
    \x0e\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xf8\x08\x0f\x1b\n\r\n\x05\x04\
    \x1a\x02\0\x03\x12\x04\xf8\x08\x1e\x1f\n\r\n\x05\x04\x1a\x02\0\x08\x12\
    \x04\xf8\x08\x20H\n\x10\n\x08\x04\x1a\x02\0\x08\x9c\x08\0\x12\x04\xf8\
    \x08!G\n|\n\x04\x04\x1a\x02\x01\x12\x06\xfc\x08\x02\xfd\x08/\x1al\x20Req\
    uired.\x20Indicates\x20which\x20fields\x20in\x20the\x20provided\x20subsc\
    ription\x20to\x20update.\n\x20Must\x20be\x20specified\x20and\x20non-empt\
    y.\n\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xfc\x08\x02\x1b\n\r\n\x05\x04\
    \x1a\x02\x01\x01\x12\x04\xfc\x08\x1c'\n\r\n\x05\x04\x1a\x02\x01\x03\x12\
    \x04\xfc\x08*+\n\r\n\x05\x04\x1a\x02\x01\x08\x12\x04\xfd\x08\x06.\n\x10\
    \n\x08\x04\x1a\x02\x01\x08\x9c\x08\0\x12\x04\xfd\x08\x07-\n;\n\x02\x04\
    \x1b\x12\x06\x81\t\0\x92\t\x01\x1a-\x20Request\x20for\x20the\x20`ListSub\
    scriptions`\x20method.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\x81\t\x08\x20\n\
    w\n\x04\x04\x1b\x02\0\x12\x06\x84\t\x02\x89\t\x04\x1ag\x20Required.\x20T\
    he\x20name\x20of\x20the\x20project\x20in\x20which\x20to\x20list\x20subsc\
    riptions.\n\x20Format\x20is\x20`projects/{project-id}`.\n\n\r\n\x05\x04\
    \x1b\x02\0\x05\x12\x04\x84\t\x02\x08\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\
    \x84\t\t\x10\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x84\t\x13\x14\n\x0f\n\
    \x05\x04\x1b\x02\0\x08\x12\x06\x84\t\x15\x89\t\x03\n\x10\n\x08\x04\x1b\
    \x02\0\x08\x9c\x08\0\x12\x04\x85\t\x04*\n\x11\n\x07\x04\x1b\x02\0\x08\
    \x9f\x08\x12\x06\x86\t\x04\x88\t\x05\n:\n\x04\x04\x1b\x02\x01\x12\x04\
    \x8c\t\x02\x16\x1a,\x20Maximum\x20number\x20of\x20subscriptions\x20to\
    \x20return.\n\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\x8c\t\x02\x07\n\r\n\
    \x05\x04\x1b\x02\x01\x01\x12\x04\x8c\t\x08\x11\n\r\n\x05\x04\x1b\x02\x01\
    \x03\x12\x04\x8c\t\x14\x15\n\xd2\x01\n\x04\x04\x1b\x02\x02\x12\x04\x91\t\
    \x02\x18\x1a\xc3\x01\x20The\x20value\x20returned\x20by\x20the\x20last\
    \x20`ListSubscriptionsResponse`;\x20indicates\x20that\n\x20this\x20is\
    \x20a\x20continuation\x20of\x20a\x20prior\x20`ListSubscriptions`\x20call\
    ,\x20and\x20that\x20the\n\x20system\x20should\x20return\x20the\x20next\
    \x20page\x20of\x20data.\n\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\x91\t\
    \x02\x08\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\x91\t\t\x13\n\r\n\x05\x04\
    \x1b\x02\x02\x03\x12\x04\x91\t\x16\x17\n<\n\x02\x04\x1c\x12\x06\x95\t\0\
    \x9d\t\x01\x1a.\x20Response\x20for\x20the\x20`ListSubscriptions`\x20meth\
    od.\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\x95\t\x08!\n9\n\x04\x04\x1c\x02\0\
    \x12\x04\x97\t\x02*\x1a+\x20The\x20subscriptions\x20that\x20match\x20the\
    \x20request.\n\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\x97\t\x02\n\n\r\n\x05\
    \x04\x1c\x02\0\x06\x12\x04\x97\t\x0b\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\
    \x04\x97\t\x18%\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\x97\t()\n\xc2\x01\n\
    \x04\x04\x1c\x02\x01\x12\x04\x9c\t\x02\x1d\x1a\xb3\x01\x20If\x20not\x20e\
    mpty,\x20indicates\x20that\x20there\x20may\x20be\x20more\x20subscription\
    s\x20that\x20match\n\x20the\x20request;\x20this\x20value\x20should\x20be\
    \x20passed\x20in\x20a\x20new\n\x20`ListSubscriptionsRequest`\x20to\x20ge\
    t\x20more\x20subscriptions.\n\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\x9c\
    \t\x02\x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\x9c\t\t\x18\n\r\n\x05\
    \x04\x1c\x02\x01\x03\x12\x04\x9c\t\x1b\x1c\n:\n\x02\x04\x1d\x12\x06\xa0\
    \t\0\xa9\t\x01\x1a,\x20Request\x20for\x20the\x20DeleteSubscription\x20me\
    thod.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xa0\t\x08!\nl\n\x04\x04\x1d\x02\
    \0\x12\x06\xa3\t\x02\xa8\t\x04\x1a\\\x20Required.\x20The\x20subscription\
    \x20to\x20delete.\n\x20Format\x20is\x20`projects/{project}/subscriptions\
    /{sub}`.\n\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xa3\t\x02\x08\n\r\n\x05\
    \x04\x1d\x02\0\x01\x12\x04\xa3\t\t\x15\n\r\n\x05\x04\x1d\x02\0\x03\x12\
    \x04\xa3\t\x18\x19\n\x0f\n\x05\x04\x1d\x02\0\x08\x12\x06\xa3\t\x1a\xa8\t\
    \x03\n\x10\n\x08\x04\x1d\x02\0\x08\x9c\x08\0\x12\x04\xa4\t\x04*\n\x11\n\
    \x07\x04\x1d\x02\0\x08\x9f\x08\x12\x06\xa5\t\x04\xa7\t\x05\n8\n\x02\x04\
    \x1e\x12\x06\xac\t\0\xbd\t\x01\x1a*\x20Request\x20for\x20the\x20ModifyPu\
    shConfig\x20method.\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xac\t\x08\x1f\nn\n\
    \x04\x04\x1e\x02\0\x12\x06\xaf\t\x02\xb4\t\x04\x1a^\x20Required.\x20The\
    \x20name\x20of\x20the\x20subscription.\n\x20Format\x20is\x20`projects/{p\
    roject}/subscriptions/{sub}`.\n\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xaf\
    \t\x02\x08\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xaf\t\t\x15\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\xaf\t\x18\x19\n\x0f\n\x05\x04\x1e\x02\0\x08\x12\
    \x06\xaf\t\x1a\xb4\t\x03\n\x10\n\x08\x04\x1e\x02\0\x08\x9c\x08\0\x12\x04\
    \xb0\t\x04*\n\x11\n\x07\x04\x1e\x02\0\x08\x9f\x08\x12\x06\xb1\t\x04\xb3\
    \t\x05\n\xc2\x02\n\x04\x04\x1e\x02\x01\x12\x04\xbc\t\x02F\x1a\xb3\x02\
    \x20Required.\x20The\x20push\x20configuration\x20for\x20future\x20delive\
    ries.\n\n\x20An\x20empty\x20`pushConfig`\x20indicates\x20that\x20the\x20\
    Pub/Sub\x20system\x20should\n\x20stop\x20pushing\x20messages\x20from\x20\
    the\x20given\x20subscription\x20and\x20allow\n\x20messages\x20to\x20be\
    \x20pulled\x20and\x20acknowledged\x20-\x20effectively\x20pausing\n\x20th\
    e\x20subscription\x20if\x20`Pull`\x20or\x20`StreamingPull`\x20is\x20not\
    \x20called.\n\n\r\n\x05\x04\x1e\x02\x01\x06\x12\x04\xbc\t\x02\x0c\n\r\n\
    \x05\x04\x1e\x02\x01\x01\x12\x04\xbc\t\r\x18\n\r\n\x05\x04\x1e\x02\x01\
    \x03\x12\x04\xbc\t\x1b\x1c\n\r\n\x05\x04\x1e\x02\x01\x08\x12\x04\xbc\t\
    \x1dE\n\x10\n\x08\x04\x1e\x02\x01\x08\x9c\x08\0\x12\x04\xbc\t\x1eD\n.\n\
    \x02\x04\x1f\x12\x06\xc0\t\0\xd8\t\x01\x1a\x20\x20Request\x20for\x20the\
    \x20`Pull`\x20method.\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xc0\t\x08\x13\n\
    \x87\x01\n\x04\x04\x1f\x02\0\x12\x06\xc3\t\x02\xc8\t\x04\x1aw\x20Require\
    d.\x20The\x20subscription\x20from\x20which\x20messages\x20should\x20be\
    \x20pulled.\n\x20Format\x20is\x20`projects/{project}/subscriptions/{sub}\
    `.\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xc3\t\x02\x08\n\r\n\x05\x04\x1f\
    \x02\0\x01\x12\x04\xc3\t\t\x15\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xc3\t\
    \x18\x19\n\x0f\n\x05\x04\x1f\x02\0\x08\x12\x06\xc3\t\x1a\xc8\t\x03\n\x10\
    \n\x08\x04\x1f\x02\0\x08\x9c\x08\0\x12\x04\xc4\t\x04*\n\x11\n\x07\x04\
    \x1f\x02\0\x08\x9f\x08\x12\x06\xc5\t\x04\xc7\t\x05\n\xdf\x03\n\x04\x04\
    \x1f\x02\x01\x12\x06\xd1\t\x02\xd2\tB\x1a\xce\x03\x20Optional.\x20If\x20\
    this\x20field\x20set\x20to\x20true,\x20the\x20system\x20will\x20respond\
    \x20immediately\n\x20even\x20if\x20it\x20there\x20are\x20no\x20messages\
    \x20available\x20to\x20return\x20in\x20the\x20`Pull`\n\x20response.\x20O\
    therwise,\x20the\x20system\x20may\x20wait\x20(for\x20a\x20bounded\x20amo\
    unt\x20of\x20time)\n\x20until\x20at\x20least\x20one\x20message\x20is\x20\
    available,\x20rather\x20than\x20returning\x20no\x20messages.\n\x20Warnin\
    g:\x20setting\x20this\x20field\x20to\x20`true`\x20is\x20discouraged\x20b\
    ecause\x20it\x20adversely\n\x20impacts\x20the\x20performance\x20of\x20`P\
    ull`\x20operations.\x20We\x20recommend\x20that\x20users\x20do\n\x20not\
    \x20set\x20this\x20field.\n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xd1\t\
    \x02\x06\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xd1\t\x07\x19\n\r\n\x05\
    \x04\x1f\x02\x01\x03\x12\x04\xd1\t\x1c\x1d\n\r\n\x05\x04\x1f\x02\x01\x08\
    \x12\x04\xd2\t\x06A\n\x0e\n\x06\x04\x1f\x02\x01\x08\x03\x12\x04\xd2\t\
    \x07\x18\n\x10\n\x08\x04\x1f\x02\x01\x08\x9c\x08\0\x12\x04\xd2\t\x1a@\n\
    \xb2\x01\n\x04\x04\x1f\x02\x02\x12\x04\xd7\t\x02B\x1a\xa3\x01\x20Require\
    d.\x20The\x20maximum\x20number\x20of\x20messages\x20to\x20return\x20for\
    \x20this\x20request.\x20Must\n\x20be\x20a\x20positive\x20integer.\x20The\
    \x20Pub/Sub\x20system\x20may\x20return\x20fewer\x20than\x20the\x20number\
    \n\x20specified.\n\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xd7\t\x02\x07\n\
    \r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xd7\t\x08\x14\n\r\n\x05\x04\x1f\x02\
    \x02\x03\x12\x04\xd7\t\x17\x18\n\r\n\x05\x04\x1f\x02\x02\x08\x12\x04\xd7\
    \t\x19A\n\x10\n\x08\x04\x1f\x02\x02\x08\x9c\x08\0\x12\x04\xd7\t\x1a@\n/\
    \n\x02\x04\x20\x12\x06\xdb\t\0\xe2\t\x01\x1a!\x20Response\x20for\x20the\
    \x20`Pull`\x20method.\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xdb\t\x08\x14\n\
    \xeb\x02\n\x04\x04\x20\x02\0\x12\x04\xe1\t\x021\x1a\xdc\x02\x20Received\
    \x20Pub/Sub\x20messages.\x20The\x20list\x20will\x20be\x20empty\x20if\x20\
    there\x20are\x20no\x20more\n\x20messages\x20available\x20in\x20the\x20ba\
    cklog,\x20or\x20if\x20no\x20messages\x20could\x20be\x20returned\n\x20bef\
    ore\x20the\x20request\x20timeout.\x20For\x20JSON,\x20the\x20response\x20\
    can\x20be\x20entirely\n\x20empty.\x20The\x20Pub/Sub\x20system\x20may\x20\
    return\x20fewer\x20than\x20the\x20`maxMessages`\x20requested\n\x20even\
    \x20if\x20there\x20are\x20more\x20messages\x20available\x20in\x20the\x20\
    backlog.\n\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xe1\t\x02\n\n\r\n\x05\x04\
    \x20\x02\0\x06\x12\x04\xe1\t\x0b\x1a\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\
    \xe1\t\x1b,\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xe1\t/0\n9\n\x02\x04!\
    \x12\x06\xe5\t\0\xfb\t\x01\x1a+\x20Request\x20for\x20the\x20ModifyAckDea\
    dline\x20method.\n\n\x0b\n\x03\x04!\x01\x12\x04\xe5\t\x08\x20\nn\n\x04\
    \x04!\x02\0\x12\x06\xe8\t\x02\xed\t\x04\x1a^\x20Required.\x20The\x20name\
    \x20of\x20the\x20subscription.\n\x20Format\x20is\x20`projects/{project}/\
    subscriptions/{sub}`.\n\n\r\n\x05\x04!\x02\0\x05\x12\x04\xe8\t\x02\x08\n\
    \r\n\x05\x04!\x02\0\x01\x12\x04\xe8\t\t\x15\n\r\n\x05\x04!\x02\0\x03\x12\
    \x04\xe8\t\x18\x19\n\x0f\n\x05\x04!\x02\0\x08\x12\x06\xe8\t\x1a\xed\t\
    \x03\n\x10\n\x08\x04!\x02\0\x08\x9c\x08\0\x12\x04\xe9\t\x04*\n\x11\n\x07\
    \x04!\x02\0\x08\x9f\x08\x12\x06\xea\t\x04\xec\t\x05\n5\n\x04\x04!\x02\
    \x01\x12\x04\xf0\t\x02G\x1a'\x20Required.\x20List\x20of\x20acknowledgmen\
    t\x20IDs.\n\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xf0\t\x02\n\n\r\n\x05\x04\
    !\x02\x01\x05\x12\x04\xf0\t\x0b\x11\n\r\n\x05\x04!\x02\x01\x01\x12\x04\
    \xf0\t\x12\x19\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xf0\t\x1c\x1d\n\r\n\
    \x05\x04!\x02\x01\x08\x12\x04\xf0\t\x1eF\n\x10\n\x08\x04!\x02\x01\x08\
    \x9c\x08\0\x12\x04\xf0\t\x1fE\n\xb4\x04\n\x04\x04!\x02\x02\x12\x04\xfa\t\
    \x02J\x1a\xa5\x04\x20Required.\x20The\x20new\x20ack\x20deadline\x20with\
    \x20respect\x20to\x20the\x20time\x20this\x20request\x20was\n\x20sent\x20\
    to\x20the\x20Pub/Sub\x20system.\x20For\x20example,\x20if\x20the\x20value\
    \x20is\x2010,\x20the\x20new\x20ack\n\x20deadline\x20will\x20expire\x2010\
    \x20seconds\x20after\x20the\x20`ModifyAckDeadline`\x20call\x20was\n\x20m\
    ade.\x20Specifying\x20zero\x20might\x20immediately\x20make\x20the\x20mes\
    sage\x20available\x20for\n\x20delivery\x20to\x20another\x20subscriber\
    \x20client.\x20This\x20typically\x20results\x20in\x20an\n\x20increase\
    \x20in\x20the\x20rate\x20of\x20message\x20redeliveries\x20(that\x20is,\
    \x20duplicates).\n\x20The\x20minimum\x20deadline\x20you\x20can\x20specif\
    y\x20is\x200\x20seconds.\n\x20The\x20maximum\x20deadline\x20you\x20can\
    \x20specify\x20is\x20600\x20seconds\x20(10\x20minutes).\n\n\r\n\x05\x04!\
    \x02\x02\x05\x12\x04\xfa\t\x02\x07\n\r\n\x05\x04!\x02\x02\x01\x12\x04\
    \xfa\t\x08\x1c\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xfa\t\x1f\x20\n\r\n\
    \x05\x04!\x02\x02\x08\x12\x04\xfa\t!I\n\x10\n\x08\x04!\x02\x02\x08\x9c\
    \x08\0\x12\x04\xfa\t\"H\n3\n\x02\x04\"\x12\x06\xfe\t\0\x8c\n\x01\x1a%\
    \x20Request\x20for\x20the\x20Acknowledge\x20method.\n\n\x0b\n\x03\x04\"\
    \x01\x12\x04\xfe\t\x08\x1a\n\x86\x01\n\x04\x04\"\x02\0\x12\x06\x81\n\x02\
    \x86\n\x04\x1av\x20Required.\x20The\x20subscription\x20whose\x20message\
    \x20is\x20being\x20acknowledged.\n\x20Format\x20is\x20`projects/{project\
    }/subscriptions/{sub}`.\n\n\r\n\x05\x04\"\x02\0\x05\x12\x04\x81\n\x02\
    \x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x81\n\t\x15\n\r\n\x05\x04\"\x02\0\
    \x03\x12\x04\x81\n\x18\x19\n\x0f\n\x05\x04\"\x02\0\x08\x12\x06\x81\n\x1a\
    \x86\n\x03\n\x10\n\x08\x04\"\x02\0\x08\x9c\x08\0\x12\x04\x82\n\x04*\n\
    \x11\n\x07\x04\"\x02\0\x08\x9f\x08\x12\x06\x83\n\x04\x85\n\x05\n\xa9\x01\
    \n\x04\x04\"\x02\x01\x12\x04\x8b\n\x02G\x1a\x9a\x01\x20Required.\x20The\
    \x20acknowledgment\x20ID\x20for\x20the\x20messages\x20being\x20acknowled\
    ged\x20that\n\x20was\x20returned\x20by\x20the\x20Pub/Sub\x20system\x20in\
    \x20the\x20`Pull`\x20response.\x20Must\x20not\x20be\n\x20empty.\n\n\r\n\
    \x05\x04\"\x02\x01\x04\x12\x04\x8b\n\x02\n\n\r\n\x05\x04\"\x02\x01\x05\
    \x12\x04\x8b\n\x0b\x11\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x8b\n\x12\x19\
    \n\r\n\x05\x04\"\x02\x01\x03\x12\x04\x8b\n\x1c\x1d\n\r\n\x05\x04\"\x02\
    \x01\x08\x12\x04\x8b\n\x1eF\n\x10\n\x08\x04\"\x02\x01\x08\x9c\x08\0\x12\
    \x04\x8b\n\x1fE\n\xe1\x01\n\x02\x04#\x12\x06\x91\n\0\xdc\n\x01\x1a\xd2\
    \x01\x20Request\x20for\x20the\x20`StreamingPull`\x20streaming\x20RPC\x20\
    method.\x20This\x20request\x20is\x20used\x20to\n\x20establish\x20the\x20\
    initial\x20stream\x20as\x20well\x20as\x20to\x20stream\x20acknowledgement\
    s\x20and\x20ack\n\x20deadline\x20modifications\x20from\x20the\x20client\
    \x20to\x20the\x20server.\n\n\x0b\n\x03\x04#\x01\x12\x04\x91\n\x08\x1c\n\
    \x88\x02\n\x04\x04#\x02\0\x12\x06\x96\n\x02\x9b\n\x04\x1a\xf7\x01\x20Req\
    uired.\x20The\x20subscription\x20for\x20which\x20to\x20initialize\x20the\
    \x20new\x20stream.\x20This\n\x20must\x20be\x20provided\x20in\x20the\x20f\
    irst\x20request\x20on\x20the\x20stream,\x20and\x20must\x20not\x20be\x20s\
    et\x20in\n\x20subsequent\x20requests\x20from\x20client\x20to\x20server.\
    \n\x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\
    \x05\x04#\x02\0\x05\x12\x04\x96\n\x02\x08\n\r\n\x05\x04#\x02\0\x01\x12\
    \x04\x96\n\t\x15\n\r\n\x05\x04#\x02\0\x03\x12\x04\x96\n\x18\x19\n\x0f\n\
    \x05\x04#\x02\0\x08\x12\x06\x96\n\x1a\x9b\n\x03\n\x10\n\x08\x04#\x02\0\
    \x08\x9c\x08\0\x12\x04\x97\n\x04*\n\x11\n\x07\x04#\x02\0\x08\x9f\x08\x12\
    \x06\x98\n\x04\x9a\n\x05\n\x85\x03\n\x04\x04#\x02\x01\x12\x04\xa2\n\x02\
    \x1e\x1a\xf6\x02\x20List\x20of\x20acknowledgement\x20IDs\x20for\x20ackno\
    wledging\x20previously\x20received\x20messages\n\x20(received\x20on\x20t\
    his\x20stream\x20or\x20a\x20different\x20stream).\x20If\x20an\x20ack\x20\
    ID\x20has\x20expired,\n\x20the\x20corresponding\x20message\x20may\x20be\
    \x20redelivered\x20later.\x20Acknowledging\x20a\x20message\n\x20more\x20\
    than\x20once\x20will\x20not\x20result\x20in\x20an\x20error.\x20If\x20the\
    \x20acknowledgement\x20ID\x20is\n\x20malformed,\x20the\x20stream\x20will\
    \x20be\x20aborted\x20with\x20status\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\
    \x04#\x02\x01\x04\x12\x04\xa2\n\x02\n\n\r\n\x05\x04#\x02\x01\x05\x12\x04\
    \xa2\n\x0b\x11\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xa2\n\x12\x19\n\r\n\
    \x05\x04#\x02\x01\x03\x12\x04\xa2\n\x1c\x1d\n\x89\x06\n\x04\x04#\x02\x02\
    \x12\x04\xaf\n\x02-\x1a\xfa\x05\x20The\x20list\x20of\x20new\x20ack\x20de\
    adlines\x20for\x20the\x20IDs\x20listed\x20in\n\x20`modify_deadline_ack_i\
    ds`.\x20The\x20size\x20of\x20this\x20list\x20must\x20be\x20the\x20same\
    \x20as\x20the\n\x20size\x20of\x20`modify_deadline_ack_ids`.\x20If\x20it\
    \x20differs\x20the\x20stream\x20will\x20be\x20aborted\n\x20with\x20`INVA\
    LID_ARGUMENT`.\x20Each\x20element\x20in\x20this\x20list\x20is\x20applied\
    \x20to\x20the\n\x20element\x20in\x20the\x20same\x20position\x20in\x20`mo\
    dify_deadline_ack_ids`.\x20The\x20new\x20ack\n\x20deadline\x20is\x20with\
    \x20respect\x20to\x20the\x20time\x20this\x20request\x20was\x20sent\x20to\
    \x20the\x20Pub/Sub\n\x20system.\x20Must\x20be\x20>=\x200.\x20For\x20exam\
    ple,\x20if\x20the\x20value\x20is\x2010,\x20the\x20new\x20ack\x20deadline\
    \n\x20will\x20expire\x2010\x20seconds\x20after\x20this\x20request\x20is\
    \x20received.\x20If\x20the\x20value\x20is\x200,\n\x20the\x20message\x20i\
    s\x20immediately\x20made\x20available\x20for\x20another\x20streaming\x20\
    or\n\x20non-streaming\x20pull\x20request.\x20If\x20the\x20value\x20is\
    \x20<\x200\x20(an\x20error),\x20the\x20stream\x20will\n\x20be\x20aborted\
    \x20with\x20status\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\x04#\x02\x02\x04\
    \x12\x04\xaf\n\x02\n\n\r\n\x05\x04#\x02\x02\x05\x12\x04\xaf\n\x0b\x10\n\
    \r\n\x05\x04#\x02\x02\x01\x12\x04\xaf\n\x11(\n\r\n\x05\x04#\x02\x02\x03\
    \x12\x04\xaf\n+,\n\xc8\x02\n\x04\x04#\x02\x03\x12\x04\xb6\n\x02.\x1a\xb9\
    \x02\x20List\x20of\x20acknowledgement\x20IDs\x20whose\x20deadline\x20wil\
    l\x20be\x20modified\x20based\x20on\x20the\n\x20corresponding\x20element\
    \x20in\x20`modify_deadline_seconds`.\x20This\x20field\x20can\x20be\x20us\
    ed\n\x20to\x20indicate\x20that\x20more\x20time\x20is\x20needed\x20to\x20\
    process\x20a\x20message\x20by\x20the\n\x20subscriber,\x20or\x20to\x20mak\
    e\x20the\x20message\x20available\x20for\x20redelivery\x20if\x20the\n\x20\
    processing\x20was\x20interrupted.\n\n\r\n\x05\x04#\x02\x03\x04\x12\x04\
    \xb6\n\x02\n\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xb6\n\x0b\x11\n\r\n\x05\
    \x04#\x02\x03\x01\x12\x04\xb6\n\x12)\n\r\n\x05\x04#\x02\x03\x03\x12\x04\
    \xb6\n,-\n\xc0\x02\n\x04\x04#\x02\x04\x12\x06\xbc\n\x02\xbd\n/\x1a\xaf\
    \x02\x20Required.\x20The\x20ack\x20deadline\x20to\x20use\x20for\x20the\
    \x20stream.\x20This\x20must\x20be\x20provided\x20in\n\x20the\x20first\
    \x20request\x20on\x20the\x20stream,\x20but\x20it\x20can\x20also\x20be\
    \x20updated\x20on\x20subsequent\n\x20requests\x20from\x20client\x20to\
    \x20server.\x20The\x20minimum\x20deadline\x20you\x20can\x20specify\x20is\
    \x2010\n\x20seconds.\x20The\x20maximum\x20deadline\x20you\x20can\x20spec\
    ify\x20is\x20600\x20seconds\x20(10\x20minutes).\n\n\r\n\x05\x04#\x02\x04\
    \x05\x12\x04\xbc\n\x02\x07\n\r\n\x05\x04#\x02\x04\x01\x12\x04\xbc\n\x08#\
    \n\r\n\x05\x04#\x02\x04\x03\x12\x04\xbc\n&'\n\r\n\x05\x04#\x02\x04\x08\
    \x12\x04\xbd\n\x06.\n\x10\n\x08\x04#\x02\x04\x08\x9c\x08\0\x12\x04\xbd\n\
    \x07-\n\x9e\x03\n\x04\x04#\x02\x05\x12\x04\xc5\n\x02\x17\x1a\x8f\x03\x20\
    A\x20unique\x20identifier\x20that\x20is\x20used\x20to\x20distinguish\x20\
    client\x20instances\x20from\x20each\n\x20other.\x20Only\x20needs\x20to\
    \x20be\x20provided\x20on\x20the\x20initial\x20request.\x20When\x20a\x20s\
    tream\n\x20disconnects\x20and\x20reconnects\x20for\x20the\x20same\x20str\
    eam,\x20the\x20client_id\x20should\x20be\x20set\n\x20to\x20the\x20same\
    \x20value\x20so\x20that\x20state\x20associated\x20with\x20the\x20old\x20\
    stream\x20can\x20be\n\x20transferred\x20to\x20the\x20new\x20stream.\x20T\
    he\x20same\x20client_id\x20should\x20not\x20be\x20used\x20for\n\x20diffe\
    rent\x20client\x20instances.\n\n\r\n\x05\x04#\x02\x05\x05\x12\x04\xc5\n\
    \x02\x08\n\r\n\x05\x04#\x02\x05\x01\x12\x04\xc5\n\t\x12\n\r\n\x05\x04#\
    \x02\x05\x03\x12\x04\xc5\n\x15\x16\n\xe0\x04\n\x04\x04#\x02\x06\x12\x04\
    \xd0\n\x02%\x1a\xd1\x04\x20Flow\x20control\x20settings\x20for\x20the\x20\
    maximum\x20number\x20of\x20outstanding\x20messages.\x20When\n\x20there\
    \x20are\x20`max_outstanding_messages`\x20or\x20more\x20currently\x20sent\
    \x20to\x20the\n\x20streaming\x20pull\x20client\x20that\x20have\x20not\
    \x20yet\x20been\x20acked\x20or\x20nacked,\x20the\x20server\n\x20stops\
    \x20sending\x20more\x20messages.\x20The\x20sending\x20of\x20messages\x20\
    resumes\x20once\x20the\n\x20number\x20of\x20outstanding\x20messages\x20i\
    s\x20less\x20than\x20this\x20value.\x20If\x20the\x20value\x20is\n\x20<=\
    \x200,\x20there\x20is\x20no\x20limit\x20to\x20the\x20number\x20of\x20out\
    standing\x20messages.\x20This\n\x20property\x20can\x20only\x20be\x20set\
    \x20on\x20the\x20initial\x20StreamingPullRequest.\x20If\x20it\x20is\x20s\
    et\n\x20on\x20a\x20subsequent\x20request,\x20the\x20stream\x20will\x20be\
    \x20aborted\x20with\x20status\n\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\x04#\
    \x02\x06\x05\x12\x04\xd0\n\x02\x07\n\r\n\x05\x04#\x02\x06\x01\x12\x04\
    \xd0\n\x08\x20\n\r\n\x05\x04#\x02\x06\x03\x12\x04\xd0\n#$\n\xea\x04\n\
    \x04\x04#\x02\x07\x12\x04\xdb\n\x02\"\x1a\xdb\x04\x20Flow\x20control\x20\
    settings\x20for\x20the\x20maximum\x20number\x20of\x20outstanding\x20byte\
    s.\x20When\n\x20there\x20are\x20`max_outstanding_bytes`\x20or\x20more\
    \x20worth\x20of\x20messages\x20currently\x20sent\n\x20to\x20the\x20strea\
    ming\x20pull\x20client\x20that\x20have\x20not\x20yet\x20been\x20acked\
    \x20or\x20nacked,\x20the\n\x20server\x20will\x20stop\x20sending\x20more\
    \x20messages.\x20The\x20sending\x20of\x20messages\x20resumes\n\x20once\
    \x20the\x20number\x20of\x20outstanding\x20bytes\x20is\x20less\x20than\
    \x20this\x20value.\x20If\x20the\x20value\n\x20is\x20<=\x200,\x20there\
    \x20is\x20no\x20limit\x20to\x20the\x20number\x20of\x20outstanding\x20byt\
    es.\x20This\n\x20property\x20can\x20only\x20be\x20set\x20on\x20the\x20in\
    itial\x20StreamingPullRequest.\x20If\x20it\x20is\x20set\n\x20on\x20a\x20\
    subsequent\x20request,\x20the\x20stream\x20will\x20be\x20aborted\x20with\
    \x20status\n\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\x04#\x02\x07\x05\x12\x04\
    \xdb\n\x02\x07\n\r\n\x05\x04#\x02\x07\x01\x12\x04\xdb\n\x08\x1d\n\r\n\
    \x05\x04#\x02\x07\x03\x12\x04\xdb\n\x20!\n\x81\x01\n\x02\x04$\x12\x06\
    \xe0\n\0\x96\x0b\x01\x1as\x20Response\x20for\x20the\x20`StreamingPull`\
    \x20method.\x20This\x20response\x20is\x20used\x20to\x20stream\n\x20messa\
    ges\x20from\x20the\x20server\x20to\x20the\x20client.\n\n\x0b\n\x03\x04$\
    \x01\x12\x04\xe0\n\x08\x1d\nz\n\x04\x04$\x03\0\x12\x06\xe3\n\x02\xf0\n\
    \x03\x1aj\x20Acknowledgement\x20IDs\x20sent\x20in\x20one\x20or\x20more\
    \x20previous\x20requests\x20to\x20acknowledge\x20a\n\x20previously\x20re\
    ceived\x20message.\n\n\r\n\x05\x04$\x03\0\x01\x12\x04\xe3\n\n!\n=\n\x06\
    \x04$\x03\0\x02\0\x12\x04\xe5\n\x04\x20\x1a-\x20Successfully\x20processe\
    d\x20acknowledgement\x20IDs.\n\n\x0f\n\x07\x04$\x03\0\x02\0\x04\x12\x04\
    \xe5\n\x04\x0c\n\x0f\n\x07\x04$\x03\0\x02\0\x05\x12\x04\xe5\n\r\x13\n\
    \x0f\n\x07\x04$\x03\0\x02\0\x01\x12\x04\xe5\n\x14\x1b\n\x0f\n\x07\x04$\
    \x03\0\x02\0\x03\x12\x04\xe5\n\x1e\x1f\nq\n\x06\x04$\x03\0\x02\x01\x12\
    \x04\xe9\n\x04(\x1aa\x20List\x20of\x20acknowledgement\x20IDs\x20that\x20\
    were\x20malformed\x20or\x20whose\x20acknowledgement\n\x20deadline\x20has\
    \x20expired.\n\n\x0f\n\x07\x04$\x03\0\x02\x01\x04\x12\x04\xe9\n\x04\x0c\
    \n\x0f\n\x07\x04$\x03\0\x02\x01\x05\x12\x04\xe9\n\r\x13\n\x0f\n\x07\x04$\
    \x03\0\x02\x01\x01\x12\x04\xe9\n\x14#\n\x0f\n\x07\x04$\x03\0\x02\x01\x03\
    \x12\x04\xe9\n&'\nE\n\x06\x04$\x03\0\x02\x02\x12\x04\xec\n\x04*\x1a5\x20\
    List\x20of\x20acknowledgement\x20IDs\x20that\x20were\x20out\x20of\x20ord\
    er.\n\n\x0f\n\x07\x04$\x03\0\x02\x02\x04\x12\x04\xec\n\x04\x0c\n\x0f\n\
    \x07\x04$\x03\0\x02\x02\x05\x12\x04\xec\n\r\x13\n\x0f\n\x07\x04$\x03\0\
    \x02\x02\x01\x12\x04\xec\n\x14%\n\x0f\n\x07\x04$\x03\0\x02\x02\x03\x12\
    \x04\xec\n()\n[\n\x06\x04$\x03\0\x02\x03\x12\x04\xef\n\x041\x1aK\x20List\
    \x20of\x20acknowledgement\x20IDs\x20that\x20failed\x20processing\x20with\
    \x20temporary\x20issues.\n\n\x0f\n\x07\x04$\x03\0\x02\x03\x04\x12\x04\
    \xef\n\x04\x0c\n\x0f\n\x07\x04$\x03\0\x02\x03\x05\x12\x04\xef\n\r\x13\n\
    \x0f\n\x07\x04$\x03\0\x02\x03\x01\x12\x04\xef\n\x14,\n\x0f\n\x07\x04$\
    \x03\0\x02\x03\x03\x12\x04\xef\n/0\n{\n\x04\x04$\x03\x01\x12\x06\xf4\n\
    \x02\xfe\n\x03\x1ak\x20Acknowledgement\x20IDs\x20sent\x20in\x20one\x20or\
    \x20more\x20previous\x20requests\x20to\x20modify\x20the\n\x20deadline\
    \x20for\x20a\x20specific\x20message.\n\n\r\n\x05\x04$\x03\x01\x01\x12\
    \x04\xf4\n\n'\n=\n\x06\x04$\x03\x01\x02\0\x12\x04\xf6\n\x04\x20\x1a-\x20\
    Successfully\x20processed\x20acknowledgement\x20IDs.\n\n\x0f\n\x07\x04$\
    \x03\x01\x02\0\x04\x12\x04\xf6\n\x04\x0c\n\x0f\n\x07\x04$\x03\x01\x02\0\
    \x05\x12\x04\xf6\n\r\x13\n\x0f\n\x07\x04$\x03\x01\x02\0\x01\x12\x04\xf6\
    \n\x14\x1b\n\x0f\n\x07\x04$\x03\x01\x02\0\x03\x12\x04\xf6\n\x1e\x1f\nq\n\
    \x06\x04$\x03\x01\x02\x01\x12\x04\xfa\n\x04(\x1aa\x20List\x20of\x20ackno\
    wledgement\x20IDs\x20that\x20were\x20malformed\x20or\x20whose\x20acknowl\
    edgement\n\x20deadline\x20has\x20expired.\n\n\x0f\n\x07\x04$\x03\x01\x02\
    \x01\x04\x12\x04\xfa\n\x04\x0c\n\x0f\n\x07\x04$\x03\x01\x02\x01\x05\x12\
    \x04\xfa\n\r\x13\n\x0f\n\x07\x04$\x03\x01\x02\x01\x01\x12\x04\xfa\n\x14#\
    \n\x0f\n\x07\x04$\x03\x01\x02\x01\x03\x12\x04\xfa\n&'\n[\n\x06\x04$\x03\
    \x01\x02\x02\x12\x04\xfd\n\x041\x1aK\x20List\x20of\x20acknowledgement\
    \x20IDs\x20that\x20failed\x20processing\x20with\x20temporary\x20issues.\
    \n\n\x0f\n\x07\x04$\x03\x01\x02\x02\x04\x12\x04\xfd\n\x04\x0c\n\x0f\n\
    \x07\x04$\x03\x01\x02\x02\x05\x12\x04\xfd\n\r\x13\n\x0f\n\x07\x04$\x03\
    \x01\x02\x02\x01\x12\x04\xfd\n\x14,\n\x0f\n\x07\x04$\x03\x01\x02\x02\x03\
    \x12\x04\xfd\n/0\nG\n\x04\x04$\x03\x02\x12\x06\x81\x0b\x02\x87\x0b\x03\
    \x1a7\x20Subscription\x20properties\x20sent\x20as\x20part\x20of\x20the\
    \x20response.\n\n\r\n\x05\x04$\x03\x02\x01\x12\x04\x81\x0b\n\x20\nR\n\
    \x06\x04$\x03\x02\x02\0\x12\x04\x83\x0b\x04+\x1aB\x20True\x20iff\x20exac\
    tly\x20once\x20delivery\x20is\x20enabled\x20for\x20this\x20subscription.\
    \n\n\x0f\n\x07\x04$\x03\x02\x02\0\x05\x12\x04\x83\x0b\x04\x08\n\x0f\n\
    \x07\x04$\x03\x02\x02\0\x01\x12\x04\x83\x0b\t&\n\x0f\n\x07\x04$\x03\x02\
    \x02\0\x03\x12\x04\x83\x0b)*\nM\n\x06\x04$\x03\x02\x02\x01\x12\x04\x86\
    \x0b\x04&\x1a=\x20True\x20iff\x20message\x20ordering\x20is\x20enabled\
    \x20for\x20this\x20subscription.\n\n\x0f\n\x07\x04$\x03\x02\x02\x01\x05\
    \x12\x04\x86\x0b\x04\x08\n\x0f\n\x07\x04$\x03\x02\x02\x01\x01\x12\x04\
    \x86\x0b\t!\n\x0f\n\x07\x04$\x03\x02\x02\x01\x03\x12\x04\x86\x0b$%\nB\n\
    \x04\x04$\x02\0\x12\x04\x8a\x0b\x021\x1a4\x20Received\x20Pub/Sub\x20mess\
    ages.\x20This\x20will\x20not\x20be\x20empty.\n\n\r\n\x05\x04$\x02\0\x04\
    \x12\x04\x8a\x0b\x02\n\n\r\n\x05\x04$\x02\0\x06\x12\x04\x8a\x0b\x0b\x1a\
    \n\r\n\x05\x04$\x02\0\x01\x12\x04\x8a\x0b\x1b,\n\r\n\x05\x04$\x02\0\x03\
    \x12\x04\x8a\x0b/0\n`\n\x04\x04$\x02\x01\x12\x04\x8e\x0b\x027\x1aR\x20Th\
    is\x20field\x20will\x20only\x20be\x20set\x20if\x20`enable_exactly_once_d\
    elivery`\x20is\x20set\x20to\n\x20`true`.\n\n\r\n\x05\x04$\x02\x01\x06\
    \x12\x04\x8e\x0b\x02\x19\n\r\n\x05\x04$\x02\x01\x01\x12\x04\x8e\x0b\x1a2\
    \n\r\n\x05\x04$\x02\x01\x03\x12\x04\x8e\x0b56\n`\n\x04\x04$\x02\x02\x12\
    \x04\x92\x0b\x02E\x1aR\x20This\x20field\x20will\x20only\x20be\x20set\x20\
    if\x20`enable_exactly_once_delivery`\x20is\x20set\x20to\n\x20`true`.\n\n\
    \r\n\x05\x04$\x02\x02\x06\x12\x04\x92\x0b\x02\x1f\n\r\n\x05\x04$\x02\x02\
    \x01\x12\x04\x92\x0b\x20@\n\r\n\x05\x04$\x02\x02\x03\x12\x04\x92\x0bCD\n\
    =\n\x04\x04$\x02\x03\x12\x04\x95\x0b\x025\x1a/\x20Properties\x20associat\
    ed\x20with\x20this\x20subscription.\n\n\r\n\x05\x04$\x02\x03\x06\x12\x04\
    \x95\x0b\x02\x18\n\r\n\x05\x04$\x02\x03\x01\x12\x04\x95\x0b\x190\n\r\n\
    \x05\x04$\x02\x03\x03\x12\x04\x95\x0b34\n8\n\x02\x04%\x12\x06\x99\x0b\0\
    \xb8\x0b\x01\x1a*\x20Request\x20for\x20the\x20`CreateSnapshot`\x20method\
    .\n\n\x0b\n\x03\x04%\x01\x12\x04\x99\x0b\x08\x1d\n\xa1\x03\n\x04\x04%\
    \x02\0\x12\x06\xa0\x0b\x02\xa3\x0b\x04\x1a\x90\x03\x20Required.\x20User-\
    provided\x20name\x20for\x20this\x20snapshot.\x20If\x20the\x20name\x20is\
    \x20not\x20provided\n\x20in\x20the\x20request,\x20the\x20server\x20will\
    \x20assign\x20a\x20random\x20name\x20for\x20this\x20snapshot\x20on\n\x20\
    the\x20same\x20project\x20as\x20the\x20subscription.\x20Note\x20that\x20\
    for\x20REST\x20API\x20requests,\x20you\n\x20must\x20specify\x20a\x20name\
    .\x20\x20See\x20the\x20[resource\x20name\n\x20rules](https://cloud.googl\
    e.com/pubsub/docs/pubsub-basics#resource_names).\n\x20Format\x20is\x20`p\
    rojects/{project}/snapshots/{snap}`.\n\n\r\n\x05\x04%\x02\0\x05\x12\x04\
    \xa0\x0b\x02\x08\n\r\n\x05\x04%\x02\0\x01\x12\x04\xa0\x0b\t\r\n\r\n\x05\
    \x04%\x02\0\x03\x12\x04\xa0\x0b\x10\x11\n\x0f\n\x05\x04%\x02\0\x08\x12\
    \x06\xa0\x0b\x12\xa3\x0b\x03\n\x10\n\x08\x04%\x02\0\x08\x9c\x08\0\x12\
    \x04\xa1\x0b\x04*\n\x0f\n\x07\x04%\x02\0\x08\x9f\x08\x12\x04\xa2\x0b\x04\
    P\n\xb9\x04\n\x04\x04%\x02\x01\x12\x06\xae\x0b\x02\xb3\x0b\x04\x1a\xa8\
    \x04\x20Required.\x20The\x20subscription\x20whose\x20backlog\x20the\x20s\
    napshot\x20retains.\n\x20Specifically,\x20the\x20created\x20snapshot\x20\
    is\x20guaranteed\x20to\x20retain:\n\x20\x20(a)\x20The\x20existing\x20bac\
    klog\x20on\x20the\x20subscription.\x20More\x20precisely,\x20this\x20is\n\
    \x20\x20\x20\x20\x20\x20defined\x20as\x20the\x20messages\x20in\x20the\
    \x20subscription's\x20backlog\x20that\x20are\n\x20\x20\x20\x20\x20\x20un\
    acknowledged\x20upon\x20the\x20successful\x20completion\x20of\x20the\n\
    \x20\x20\x20\x20\x20\x20`CreateSnapshot`\x20request;\x20as\x20well\x20as\
    :\n\x20\x20(b)\x20Any\x20messages\x20published\x20to\x20the\x20subscript\
    ion's\x20topic\x20following\x20the\n\x20\x20\x20\x20\x20\x20successful\
    \x20completion\x20of\x20the\x20CreateSnapshot\x20request.\n\x20Format\
    \x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\x05\x04%\x02\
    \x01\x05\x12\x04\xae\x0b\x02\x08\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xae\
    \x0b\t\x15\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xae\x0b\x18\x19\n\x0f\n\
    \x05\x04%\x02\x01\x08\x12\x06\xae\x0b\x1a\xb3\x0b\x03\n\x10\n\x08\x04%\
    \x02\x01\x08\x9c\x08\0\x12\x04\xaf\x0b\x04*\n\x11\n\x07\x04%\x02\x01\x08\
    \x9f\x08\x12\x06\xb0\x0b\x04\xb2\x0b\x05\na\n\x04\x04%\x02\x02\x12\x04\
    \xb7\x0b\x02!\x1aS\x20See\x20[Creating\x20and\x20managing\n\x20labels](h\
    ttps://cloud.google.com/pubsub/docs/labels).\n\n\r\n\x05\x04%\x02\x02\
    \x06\x12\x04\xb7\x0b\x02\x15\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xb7\x0b\
    \x16\x1c\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xb7\x0b\x1f\x20\n6\n\x02\x04\
    &\x12\x06\xbb\x0b\0\xc3\x0b\x01\x1a(\x20Request\x20for\x20the\x20UpdateS\
    napshot\x20method.\n\n\x0b\n\x03\x04&\x01\x12\x04\xbb\x0b\x08\x1d\n6\n\
    \x04\x04&\x02\0\x12\x04\xbd\x0b\x02A\x1a(\x20Required.\x20The\x20updated\
    \x20snapshot\x20object.\n\n\r\n\x05\x04&\x02\0\x06\x12\x04\xbd\x0b\x02\n\
    \n\r\n\x05\x04&\x02\0\x01\x12\x04\xbd\x0b\x0b\x13\n\r\n\x05\x04&\x02\0\
    \x03\x12\x04\xbd\x0b\x16\x17\n\r\n\x05\x04&\x02\0\x08\x12\x04\xbd\x0b\
    \x18@\n\x10\n\x08\x04&\x02\0\x08\x9c\x08\0\x12\x04\xbd\x0b\x19?\nx\n\x04\
    \x04&\x02\x01\x12\x06\xc1\x0b\x02\xc2\x0b/\x1ah\x20Required.\x20Indicate\
    s\x20which\x20fields\x20in\x20the\x20provided\x20snapshot\x20to\x20updat\
    e.\n\x20Must\x20be\x20specified\x20and\x20non-empty.\n\n\r\n\x05\x04&\
    \x02\x01\x06\x12\x04\xc1\x0b\x02\x1b\n\r\n\x05\x04&\x02\x01\x01\x12\x04\
    \xc1\x0b\x1c'\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xc1\x0b*+\n\r\n\x05\x04\
    &\x02\x01\x08\x12\x04\xc2\x0b\x06.\n\x10\n\x08\x04&\x02\x01\x08\x9c\x08\
    \0\x12\x04\xc2\x0b\x07-\n\xbe\x02\n\x02\x04'\x12\x06\xca\x0b\0\xe7\x0b\
    \x01\x1a\xaf\x02\x20A\x20snapshot\x20resource.\x20Snapshots\x20are\x20us\
    ed\x20in\n\x20[Seek](https://cloud.google.com/pubsub/docs/replay-overvie\
    w)\n\x20operations,\x20which\x20allow\x20you\x20to\x20manage\x20message\
    \x20acknowledgments\x20in\x20bulk.\x20That\n\x20is,\x20you\x20can\x20set\
    \x20the\x20acknowledgment\x20state\x20of\x20messages\x20in\x20an\x20exis\
    ting\n\x20subscription\x20to\x20the\x20state\x20captured\x20by\x20a\x20s\
    napshot.\n\n\x0b\n\x03\x04'\x01\x12\x04\xca\x0b\x08\x10\n\r\n\x03\x04'\
    \x07\x12\x06\xcb\x0b\x02\xce\x0b\x04\n\x0f\n\x05\x04'\x07\x9d\x08\x12\
    \x06\xcb\x0b\x02\xce\x0b\x04\n)\n\x04\x04'\x02\0\x12\x04\xd1\x0b\x02\x12\
    \x1a\x1b\x20The\x20name\x20of\x20the\x20snapshot.\n\n\r\n\x05\x04'\x02\0\
    \x05\x12\x04\xd1\x0b\x02\x08\n\r\n\x05\x04'\x02\0\x01\x12\x04\xd1\x0b\t\
    \r\n\r\n\x05\x04'\x02\0\x03\x12\x04\xd1\x0b\x10\x11\nW\n\x04\x04'\x02\
    \x01\x12\x06\xd4\x0b\x02\xd6\x0b\x04\x1aG\x20The\x20name\x20of\x20the\
    \x20topic\x20from\x20which\x20this\x20snapshot\x20is\x20retaining\x20mes\
    sages.\n\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xd4\x0b\x02\x08\n\r\n\x05\
    \x04'\x02\x01\x01\x12\x04\xd4\x0b\t\x0e\n\r\n\x05\x04'\x02\x01\x03\x12\
    \x04\xd4\x0b\x11\x12\n\x0f\n\x05\x04'\x02\x01\x08\x12\x06\xd4\x0b\x13\
    \xd6\x0b\x03\n\x0f\n\x07\x04'\x02\x01\x08\x9f\x08\x12\x04\xd5\x0b\x04M\n\
    \xd4\x05\n\x04\x04'\x02\x02\x12\x04\xe2\x0b\x02,\x1a\xc5\x05\x20The\x20s\
    napshot\x20is\x20guaranteed\x20to\x20exist\x20up\x20until\x20this\x20tim\
    e.\n\x20A\x20newly-created\x20snapshot\x20expires\x20no\x20later\x20than\
    \x207\x20days\x20from\x20the\x20time\x20of\x20its\n\x20creation.\x20Its\
    \x20exact\x20lifetime\x20is\x20determined\x20at\x20creation\x20by\x20the\
    \x20existing\n\x20backlog\x20in\x20the\x20source\x20subscription.\x20Spe\
    cifically,\x20the\x20lifetime\x20of\x20the\n\x20snapshot\x20is\x20`7\x20\
    days\x20-\x20(age\x20of\x20oldest\x20unacked\x20message\x20in\x20the\x20\
    subscription)`.\n\x20For\x20example,\x20consider\x20a\x20subscription\
    \x20whose\x20oldest\x20unacked\x20message\x20is\x203\x20days\n\x20old.\
    \x20If\x20a\x20snapshot\x20is\x20created\x20from\x20this\x20subscription\
    ,\x20the\x20snapshot\x20--\x20which\n\x20will\x20always\x20capture\x20th\
    is\x203-day-old\x20backlog\x20as\x20long\x20as\x20the\x20snapshot\n\x20e\
    xists\x20--\x20will\x20expire\x20in\x204\x20days.\x20The\x20service\x20w\
    ill\x20refuse\x20to\x20create\x20a\n\x20snapshot\x20that\x20would\x20exp\
    ire\x20in\x20less\x20than\x201\x20hour\x20after\x20creation.\n\n\r\n\x05\
    \x04'\x02\x02\x06\x12\x04\xe2\x0b\x02\x1b\n\r\n\x05\x04'\x02\x02\x01\x12\
    \x04\xe2\x0b\x1c'\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xe2\x0b*+\nb\n\x04\
    \x04'\x02\x03\x12\x04\xe6\x0b\x02!\x1aT\x20See\x20[Creating\x20and\x20ma\
    naging\x20labels]\n\x20(https://cloud.google.com/pubsub/docs/labels).\n\
    \n\r\n\x05\x04'\x02\x03\x06\x12\x04\xe6\x0b\x02\x15\n\r\n\x05\x04'\x02\
    \x03\x01\x12\x04\xe6\x0b\x16\x1c\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xe6\
    \x0b\x1f\x20\n3\n\x02\x04(\x12\x06\xea\x0b\0\xf1\x0b\x01\x1a%\x20Request\
    \x20for\x20the\x20GetSnapshot\x20method.\n\n\x0b\n\x03\x04(\x01\x12\x04\
    \xea\x0b\x08\x1a\nn\n\x04\x04(\x02\0\x12\x06\xed\x0b\x02\xf0\x0b\x04\x1a\
    ^\x20Required.\x20The\x20name\x20of\x20the\x20snapshot\x20to\x20get.\n\
    \x20Format\x20is\x20`projects/{project}/snapshots/{snap}`.\n\n\r\n\x05\
    \x04(\x02\0\x05\x12\x04\xed\x0b\x02\x08\n\r\n\x05\x04(\x02\0\x01\x12\x04\
    \xed\x0b\t\x11\n\r\n\x05\x04(\x02\0\x03\x12\x04\xed\x0b\x14\x15\n\x0f\n\
    \x05\x04(\x02\0\x08\x12\x06\xed\x0b\x16\xf0\x0b\x03\n\x10\n\x08\x04(\x02\
    \0\x08\x9c\x08\0\x12\x04\xee\x0b\x04*\n\x0f\n\x07\x04(\x02\0\x08\x9f\x08\
    \x12\x04\xef\x0b\x04P\n7\n\x02\x04)\x12\x06\xf4\x0b\0\x85\x0c\x01\x1a)\
    \x20Request\x20for\x20the\x20`ListSnapshots`\x20method.\n\n\x0b\n\x03\
    \x04)\x01\x12\x04\xf4\x0b\x08\x1c\ns\n\x04\x04)\x02\0\x12\x06\xf7\x0b\
    \x02\xfc\x0b\x04\x1ac\x20Required.\x20The\x20name\x20of\x20the\x20projec\
    t\x20in\x20which\x20to\x20list\x20snapshots.\n\x20Format\x20is\x20`proje\
    cts/{project-id}`.\n\n\r\n\x05\x04)\x02\0\x05\x12\x04\xf7\x0b\x02\x08\n\
    \r\n\x05\x04)\x02\0\x01\x12\x04\xf7\x0b\t\x10\n\r\n\x05\x04)\x02\0\x03\
    \x12\x04\xf7\x0b\x13\x14\n\x0f\n\x05\x04)\x02\0\x08\x12\x06\xf7\x0b\x15\
    \xfc\x0b\x03\n\x10\n\x08\x04)\x02\0\x08\x9c\x08\0\x12\x04\xf8\x0b\x04*\n\
    \x11\n\x07\x04)\x02\0\x08\x9f\x08\x12\x06\xf9\x0b\x04\xfb\x0b\x05\n6\n\
    \x04\x04)\x02\x01\x12\x04\xff\x0b\x02\x16\x1a(\x20Maximum\x20number\x20o\
    f\x20snapshots\x20to\x20return.\n\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xff\
    \x0b\x02\x07\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xff\x0b\x08\x11\n\r\n\
    \x05\x04)\x02\x01\x03\x12\x04\xff\x0b\x14\x15\n\xca\x01\n\x04\x04)\x02\
    \x02\x12\x04\x84\x0c\x02\x18\x1a\xbb\x01\x20The\x20value\x20returned\x20\
    by\x20the\x20last\x20`ListSnapshotsResponse`;\x20indicates\x20that\x20th\
    is\n\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20`ListSnapshots`\
    \x20call,\x20and\x20that\x20the\x20system\n\x20should\x20return\x20the\
    \x20next\x20page\x20of\x20data.\n\n\r\n\x05\x04)\x02\x02\x05\x12\x04\x84\
    \x0c\x02\x08\n\r\n\x05\x04)\x02\x02\x01\x12\x04\x84\x0c\t\x13\n\r\n\x05\
    \x04)\x02\x02\x03\x12\x04\x84\x0c\x16\x17\n8\n\x02\x04*\x12\x06\x88\x0c\
    \0\x8f\x0c\x01\x1a*\x20Response\x20for\x20the\x20`ListSnapshots`\x20meth\
    od.\n\n\x0b\n\x03\x04*\x01\x12\x04\x88\x0c\x08\x1d\n(\n\x04\x04*\x02\0\
    \x12\x04\x8a\x0c\x02\"\x1a\x1a\x20The\x20resulting\x20snapshots.\n\n\r\n\
    \x05\x04*\x02\0\x04\x12\x04\x8a\x0c\x02\n\n\r\n\x05\x04*\x02\0\x06\x12\
    \x04\x8a\x0c\x0b\x13\n\r\n\x05\x04*\x02\0\x01\x12\x04\x8a\x0c\x14\x1d\n\
    \r\n\x05\x04*\x02\0\x03\x12\x04\x8a\x0c\x20!\n\x9e\x01\n\x04\x04*\x02\
    \x01\x12\x04\x8e\x0c\x02\x1d\x1a\x8f\x01\x20If\x20not\x20empty,\x20indic\
    ates\x20that\x20there\x20may\x20be\x20more\x20snapshot\x20that\x20match\
    \x20the\n\x20request;\x20this\x20value\x20should\x20be\x20passed\x20in\
    \x20a\x20new\x20`ListSnapshotsRequest`.\n\n\r\n\x05\x04*\x02\x01\x05\x12\
    \x04\x8e\x0c\x02\x08\n\r\n\x05\x04*\x02\x01\x01\x12\x04\x8e\x0c\t\x18\n\
    \r\n\x05\x04*\x02\x01\x03\x12\x04\x8e\x0c\x1b\x1c\n8\n\x02\x04+\x12\x06\
    \x92\x0c\0\x99\x0c\x01\x1a*\x20Request\x20for\x20the\x20`DeleteSnapshot`\
    \x20method.\n\n\x0b\n\x03\x04+\x01\x12\x04\x92\x0c\x08\x1d\nq\n\x04\x04+\
    \x02\0\x12\x06\x95\x0c\x02\x98\x0c\x04\x1aa\x20Required.\x20The\x20name\
    \x20of\x20the\x20snapshot\x20to\x20delete.\n\x20Format\x20is\x20`project\
    s/{project}/snapshots/{snap}`.\n\n\r\n\x05\x04+\x02\0\x05\x12\x04\x95\
    \x0c\x02\x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\x95\x0c\t\x11\n\r\n\x05\
    \x04+\x02\0\x03\x12\x04\x95\x0c\x14\x15\n\x0f\n\x05\x04+\x02\0\x08\x12\
    \x06\x95\x0c\x16\x98\x0c\x03\n\x10\n\x08\x04+\x02\0\x08\x9c\x08\0\x12\
    \x04\x96\x0c\x04*\n\x0f\n\x07\x04+\x02\0\x08\x9f\x08\x12\x04\x97\x0c\x04\
    P\n.\n\x02\x04,\x12\x06\x9c\x0c\0\xba\x0c\x01\x1a\x20\x20Request\x20for\
    \x20the\x20`Seek`\x20method.\n\n\x0b\n\x03\x04,\x01\x12\x04\x9c\x0c\x08\
    \x13\n7\n\x04\x04,\x02\0\x12\x06\x9e\x0c\x02\xa3\x0c\x04\x1a'\x20Require\
    d.\x20The\x20subscription\x20to\x20affect.\n\n\r\n\x05\x04,\x02\0\x05\
    \x12\x04\x9e\x0c\x02\x08\n\r\n\x05\x04,\x02\0\x01\x12\x04\x9e\x0c\t\x15\
    \n\r\n\x05\x04,\x02\0\x03\x12\x04\x9e\x0c\x18\x19\n\x0f\n\x05\x04,\x02\0\
    \x08\x12\x06\x9e\x0c\x1a\xa3\x0c\x03\n\x10\n\x08\x04,\x02\0\x08\x9c\x08\
    \0\x12\x04\x9f\x0c\x04*\n\x11\n\x07\x04,\x02\0\x08\x9f\x08\x12\x06\xa0\
    \x0c\x04\xa2\x0c\x05\n\x0e\n\x04\x04,\x08\0\x12\x06\xa5\x0c\x02\xb9\x0c\
    \x03\n\r\n\x05\x04,\x08\0\x01\x12\x04\xa5\x0c\x08\x0e\n\xbe\x05\n\x04\
    \x04,\x02\x01\x12\x04\xb1\x0c\x04'\x1a\xaf\x05\x20The\x20time\x20to\x20s\
    eek\x20to.\n\x20Messages\x20retained\x20in\x20the\x20subscription\x20tha\
    t\x20were\x20published\x20before\x20this\n\x20time\x20are\x20marked\x20a\
    s\x20acknowledged,\x20and\x20messages\x20retained\x20in\x20the\n\x20subs\
    cription\x20that\x20were\x20published\x20after\x20this\x20time\x20are\
    \x20marked\x20as\n\x20unacknowledged.\x20Note\x20that\x20this\x20operati\
    on\x20affects\x20only\x20those\x20messages\n\x20retained\x20in\x20the\
    \x20subscription\x20(configured\x20by\x20the\x20combination\x20of\n\x20`\
    message_retention_duration`\x20and\x20`retain_acked_messages`).\x20For\
    \x20example,\n\x20if\x20`time`\x20corresponds\x20to\x20a\x20point\x20bef\
    ore\x20the\x20message\x20retention\n\x20window\x20(or\x20to\x20a\x20poin\
    t\x20before\x20the\x20system's\x20notion\x20of\x20the\x20subscription\n\
    \x20creation\x20time),\x20only\x20retained\x20messages\x20will\x20be\x20\
    marked\x20as\x20unacknowledged,\n\x20and\x20already-expunged\x20messages\
    \x20will\x20not\x20be\x20restored.\n\n\r\n\x05\x04,\x02\x01\x06\x12\x04\
    \xb1\x0c\x04\x1d\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xb1\x0c\x1e\"\n\r\n\
    \x05\x04,\x02\x01\x03\x12\x04\xb1\x0c%&\n\xaa\x01\n\x04\x04,\x02\x02\x12\
    \x06\xb6\x0c\x04\xb8\x0c\x07\x1a\x99\x01\x20The\x20snapshot\x20to\x20see\
    k\x20to.\x20The\x20snapshot's\x20topic\x20must\x20be\x20the\x20same\x20a\
    s\x20that\x20of\n\x20the\x20provided\x20subscription.\n\x20Format\x20is\
    \x20`projects/{project}/snapshots/{snap}`.\n\n\r\n\x05\x04,\x02\x02\x05\
    \x12\x04\xb6\x0c\x04\n\n\r\n\x05\x04,\x02\x02\x01\x12\x04\xb6\x0c\x0b\
    \x13\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xb6\x0c\x16\x17\n\x0f\n\x05\x04,\
    \x02\x02\x08\x12\x06\xb6\x0c\x18\xb8\x0c\x06\n\x11\n\x07\x04,\x02\x02\
    \x08\x9f\x08\x12\x06\xb6\x0c\x19\xb8\x0c\x05\nF\n\x02\x04-\x12\x04\xbd\
    \x0c\0\x17\x1a:\x20Response\x20for\x20the\x20`Seek`\x20method\x20(this\
    \x20response\x20is\x20empty).\n\n\x0b\n\x03\x04-\x01\x12\x04\xbd\x0c\x08\
    \x14b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
