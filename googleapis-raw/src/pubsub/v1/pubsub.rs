// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/pubsub/v1/pubsub.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:google.pubsub.v1.MessageStoragePolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageStoragePolicy {
    // message fields
    ///  A list of IDs of GCP regions where messages that are published to the topic
    ///  may be persisted in storage. Messages published by publishers running in
    ///  non-allowed GCP regions (or running outside of GCP altogether) will be
    ///  routed for storage in one of the allowed regions. An empty list means that
    ///  no regions are allowed, and is not a valid configuration.
    // @@protoc_insertion_point(field:google.pubsub.v1.MessageStoragePolicy.allowed_persistence_regions)
    pub allowed_persistence_regions: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.MessageStoragePolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageStoragePolicy {
    fn default() -> &'a MessageStoragePolicy {
        <MessageStoragePolicy as ::protobuf::Message>::default_instance()
    }
}

impl MessageStoragePolicy {
    pub fn new() -> MessageStoragePolicy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allowed_persistence_regions",
            |m: &MessageStoragePolicy| { &m.allowed_persistence_regions },
            |m: &mut MessageStoragePolicy| { &mut m.allowed_persistence_regions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageStoragePolicy>(
            "MessageStoragePolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageStoragePolicy {
    const NAME: &'static str = "MessageStoragePolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.allowed_persistence_regions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.allowed_persistence_regions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.allowed_persistence_regions {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageStoragePolicy {
        MessageStoragePolicy::new()
    }

    fn clear(&mut self) {
        self.allowed_persistence_regions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageStoragePolicy {
        static instance: MessageStoragePolicy = MessageStoragePolicy {
            allowed_persistence_regions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageStoragePolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageStoragePolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageStoragePolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageStoragePolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A topic resource.
// @@protoc_insertion_point(message:google.pubsub.v1.Topic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Topic {
    // message fields
    ///  The name of the topic. It must have the format
    ///  `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
    ///  and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
    ///  underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
    ///  signs (`%`). It must be between 3 and 255 characters in length, and it
    ///  must not start with `"goog"`.
    // @@protoc_insertion_point(field:google.pubsub.v1.Topic.name)
    pub name: ::std::string::String,
    ///  See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
    ///  managing labels</a>.
    // @@protoc_insertion_point(field:google.pubsub.v1.Topic.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  Policy constraining the set of Google Cloud Platform regions where messages
    ///  published to the topic may be stored. If not present, then no constraints
    ///  are in effect.
    // @@protoc_insertion_point(field:google.pubsub.v1.Topic.message_storage_policy)
    pub message_storage_policy: ::protobuf::MessageField<MessageStoragePolicy>,
    ///  The resource name of the Cloud KMS CryptoKey to be used to protect access
    ///  to messages published on this topic.
    ///
    ///  The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    // @@protoc_insertion_point(field:google.pubsub.v1.Topic.kms_key_name)
    pub kms_key_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.Topic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Topic {
    fn default() -> &'a Topic {
        <Topic as ::protobuf::Message>::default_instance()
    }
}

impl Topic {
    pub fn new() -> Topic {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Topic| { &m.name },
            |m: &mut Topic| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &Topic| { &m.labels },
            |m: &mut Topic| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageStoragePolicy>(
            "message_storage_policy",
            |m: &Topic| { &m.message_storage_policy },
            |m: &mut Topic| { &mut m.message_storage_policy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kms_key_name",
            |m: &Topic| { &m.kms_key_name },
            |m: &mut Topic| { &mut m.kms_key_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Topic>(
            "Topic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Topic {
    const NAME: &'static str = "Topic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message_storage_policy)?;
                },
                42 => {
                    self.kms_key_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.message_storage_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.message_storage_policy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(5, &self.kms_key_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Topic {
        Topic::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.labels.clear();
        self.message_storage_policy.clear();
        self.kms_key_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Topic {
        static instance: ::protobuf::rt::Lazy<Topic> = ::protobuf::rt::Lazy::new();
        instance.get(Topic::new)
    }
}

impl ::protobuf::MessageFull for Topic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Topic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Topic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Topic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A message that is published by publishers and consumed by subscribers. The
///  message must contain either a non-empty data field or at least one attribute.
///  Note that client libraries represent this object differently
///  depending on the language. See the corresponding
///  <a href="https://cloud.google.com/pubsub/docs/reference/libraries">client
///  library documentation</a> for more information. See
///  <a href="https://cloud.google.com/pubsub/quotas">Quotas and limits</a>
///  for more information about message limits.
// @@protoc_insertion_point(message:google.pubsub.v1.PubsubMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PubsubMessage {
    // message fields
    ///  The message data field. If this field is empty, the message must contain
    ///  at least one attribute.
    // @@protoc_insertion_point(field:google.pubsub.v1.PubsubMessage.data)
    pub data: ::std::vec::Vec<u8>,
    ///  Optional attributes for this message.
    // @@protoc_insertion_point(field:google.pubsub.v1.PubsubMessage.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  ID of this message, assigned by the server when the message is published.
    ///  Guaranteed to be unique within the topic. This value may be read by a
    ///  subscriber that receives a `PubsubMessage` via a `Pull` call or a push
    ///  delivery. It must not be populated by the publisher in a `Publish` call.
    // @@protoc_insertion_point(field:google.pubsub.v1.PubsubMessage.message_id)
    pub message_id: ::std::string::String,
    ///  The time at which the message was published, populated by the server when
    ///  it receives the `Publish` call. It must not be populated by the
    ///  publisher in a `Publish` call.
    // @@protoc_insertion_point(field:google.pubsub.v1.PubsubMessage.publish_time)
    pub publish_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Identifies related messages for which publish order should be respected.
    ///  If a `Subscription` has `enable_message_ordering` set to `true`, messages
    ///  published with the same `ordering_key` value will be delivered to
    ///  subscribers in the order in which they are received by the Pub/Sub system.
    ///  <b>EXPERIMENTAL:</b> This feature is part of a closed alpha release. This
    ///  API might be changed in backward-incompatible ways and is not recommended
    ///  for production use. It is not subject to any SLA or deprecation policy.
    // @@protoc_insertion_point(field:google.pubsub.v1.PubsubMessage.ordering_key)
    pub ordering_key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.PubsubMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubsubMessage {
    fn default() -> &'a PubsubMessage {
        <PubsubMessage as ::protobuf::Message>::default_instance()
    }
}

impl PubsubMessage {
    pub fn new() -> PubsubMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &PubsubMessage| { &m.data },
            |m: &mut PubsubMessage| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &PubsubMessage| { &m.attributes },
            |m: &mut PubsubMessage| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &PubsubMessage| { &m.message_id },
            |m: &mut PubsubMessage| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "publish_time",
            |m: &PubsubMessage| { &m.publish_time },
            |m: &mut PubsubMessage| { &mut m.publish_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordering_key",
            |m: &PubsubMessage| { &m.ordering_key },
            |m: &mut PubsubMessage| { &mut m.ordering_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubsubMessage>(
            "PubsubMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubsubMessage {
    const NAME: &'static str = "PubsubMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                26 => {
                    self.message_id = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.publish_time)?;
                },
                42 => {
                    self.ordering_key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message_id);
        }
        if let Some(v) = self.publish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.ordering_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.ordering_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.message_id.is_empty() {
            os.write_string(3, &self.message_id)?;
        }
        if let Some(v) = self.publish_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.ordering_key.is_empty() {
            os.write_string(5, &self.ordering_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubsubMessage {
        PubsubMessage::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.attributes.clear();
        self.message_id.clear();
        self.publish_time.clear();
        self.ordering_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubsubMessage {
        static instance: ::protobuf::rt::Lazy<PubsubMessage> = ::protobuf::rt::Lazy::new();
        instance.get(PubsubMessage::new)
    }
}

impl ::protobuf::MessageFull for PubsubMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubsubMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubsubMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubsubMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the GetTopic method.
// @@protoc_insertion_point(message:google.pubsub.v1.GetTopicRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTopicRequest {
    // message fields
    ///  The name of the topic to get.
    ///  Format is `projects/{project}/topics/{topic}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.GetTopicRequest.topic)
    pub topic: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.GetTopicRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTopicRequest {
    fn default() -> &'a GetTopicRequest {
        <GetTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTopicRequest {
    pub fn new() -> GetTopicRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &GetTopicRequest| { &m.topic },
            |m: &mut GetTopicRequest| { &mut m.topic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTopicRequest>(
            "GetTopicRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTopicRequest {
    const NAME: &'static str = "GetTopicRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTopicRequest {
        GetTopicRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTopicRequest {
        static instance: GetTopicRequest = GetTopicRequest {
            topic: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTopicRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTopicRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTopicRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the UpdateTopic method.
// @@protoc_insertion_point(message:google.pubsub.v1.UpdateTopicRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateTopicRequest {
    // message fields
    ///  The updated topic object.
    // @@protoc_insertion_point(field:google.pubsub.v1.UpdateTopicRequest.topic)
    pub topic: ::protobuf::MessageField<Topic>,
    ///  Indicates which fields in the provided topic to update. Must be specified
    ///  and non-empty. Note that if `update_mask` contains
    ///  "message_storage_policy" then the new value will be determined based on the
    ///  policy configured at the project or organization level. The
    ///  `message_storage_policy` must not be set in the `topic` provided above.
    // @@protoc_insertion_point(field:google.pubsub.v1.UpdateTopicRequest.update_mask)
    pub update_mask: ::protobuf::MessageField<::protobuf::well_known_types::field_mask::FieldMask>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.UpdateTopicRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateTopicRequest {
    fn default() -> &'a UpdateTopicRequest {
        <UpdateTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTopicRequest {
    pub fn new() -> UpdateTopicRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Topic>(
            "topic",
            |m: &UpdateTopicRequest| { &m.topic },
            |m: &mut UpdateTopicRequest| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::field_mask::FieldMask>(
            "update_mask",
            |m: &UpdateTopicRequest| { &m.update_mask },
            |m: &mut UpdateTopicRequest| { &mut m.update_mask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateTopicRequest>(
            "UpdateTopicRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateTopicRequest {
    const NAME: &'static str = "UpdateTopicRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.topic)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_mask)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.topic.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.topic.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.update_mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateTopicRequest {
        UpdateTopicRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.update_mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateTopicRequest {
        static instance: UpdateTopicRequest = UpdateTopicRequest {
            topic: ::protobuf::MessageField::none(),
            update_mask: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateTopicRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateTopicRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTopicRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the Publish method.
// @@protoc_insertion_point(message:google.pubsub.v1.PublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublishRequest {
    // message fields
    ///  The messages in the request will be published on this topic.
    ///  Format is `projects/{project}/topics/{topic}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.PublishRequest.topic)
    pub topic: ::std::string::String,
    ///  The messages to publish.
    // @@protoc_insertion_point(field:google.pubsub.v1.PublishRequest.messages)
    pub messages: ::std::vec::Vec<PubsubMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.PublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublishRequest {
    fn default() -> &'a PublishRequest {
        <PublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PublishRequest {
    pub fn new() -> PublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &PublishRequest| { &m.topic },
            |m: &mut PublishRequest| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &PublishRequest| { &m.messages },
            |m: &mut PublishRequest| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishRequest>(
            "PublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PublishRequest {
    const NAME: &'static str = "PublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                18 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublishRequest {
        PublishRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublishRequest {
        static instance: PublishRequest = PublishRequest {
            topic: ::std::string::String::new(),
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `Publish` method.
// @@protoc_insertion_point(message:google.pubsub.v1.PublishResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublishResponse {
    // message fields
    ///  The server-assigned ID of each published message, in the same order as
    ///  the messages in the request. IDs are guaranteed to be unique within
    ///  the topic.
    // @@protoc_insertion_point(field:google.pubsub.v1.PublishResponse.message_ids)
    pub message_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.PublishResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublishResponse {
    fn default() -> &'a PublishResponse {
        <PublishResponse as ::protobuf::Message>::default_instance()
    }
}

impl PublishResponse {
    pub fn new() -> PublishResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_ids",
            |m: &PublishResponse| { &m.message_ids },
            |m: &mut PublishResponse| { &mut m.message_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublishResponse>(
            "PublishResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PublishResponse {
    const NAME: &'static str = "PublishResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.message_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.message_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublishResponse {
        PublishResponse::new()
    }

    fn clear(&mut self) {
        self.message_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublishResponse {
        static instance: PublishResponse = PublishResponse {
            message_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PublishResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PublishResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PublishResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `ListTopics` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListTopicsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicsRequest {
    // message fields
    ///  The name of the project in which to list topics.
    ///  Format is `projects/{project-id}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicsRequest.project)
    pub project: ::std::string::String,
    ///  Maximum number of topics to return.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last `ListTopicsResponse`; indicates that this is
    ///  a continuation of a prior `ListTopics` call, and that the system should
    ///  return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListTopicsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicsRequest {
    fn default() -> &'a ListTopicsRequest {
        <ListTopicsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsRequest {
    pub fn new() -> ListTopicsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &ListTopicsRequest| { &m.project },
            |m: &mut ListTopicsRequest| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListTopicsRequest| { &m.page_size },
            |m: &mut ListTopicsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListTopicsRequest| { &m.page_token },
            |m: &mut ListTopicsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicsRequest>(
            "ListTopicsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicsRequest {
    const NAME: &'static str = "ListTopicsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.project = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicsRequest {
        ListTopicsRequest::new()
    }

    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicsRequest {
        static instance: ListTopicsRequest = ListTopicsRequest {
            project: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `ListTopics` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListTopicsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicsResponse {
    // message fields
    ///  The resulting topics.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicsResponse.topics)
    pub topics: ::std::vec::Vec<Topic>,
    ///  If not empty, indicates that there may be more topics that match the
    ///  request; this value should be passed in a new `ListTopicsRequest`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListTopicsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicsResponse {
    fn default() -> &'a ListTopicsResponse {
        <ListTopicsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsResponse {
    pub fn new() -> ListTopicsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "topics",
            |m: &ListTopicsResponse| { &m.topics },
            |m: &mut ListTopicsResponse| { &mut m.topics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListTopicsResponse| { &m.next_page_token },
            |m: &mut ListTopicsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicsResponse>(
            "ListTopicsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicsResponse {
    const NAME: &'static str = "ListTopicsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topics.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.topics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.topics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicsResponse {
        ListTopicsResponse::new()
    }

    fn clear(&mut self) {
        self.topics.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicsResponse {
        static instance: ListTopicsResponse = ListTopicsResponse {
            topics: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `ListTopicSubscriptions` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListTopicSubscriptionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicSubscriptionsRequest {
    // message fields
    ///  The name of the topic that subscriptions are attached to.
    ///  Format is `projects/{project}/topics/{topic}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSubscriptionsRequest.topic)
    pub topic: ::std::string::String,
    ///  Maximum number of subscription names to return.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSubscriptionsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last `ListTopicSubscriptionsResponse`; indicates
    ///  that this is a continuation of a prior `ListTopicSubscriptions` call, and
    ///  that the system should return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSubscriptionsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListTopicSubscriptionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsRequest {
    fn default() -> &'a ListTopicSubscriptionsRequest {
        <ListTopicSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsRequest {
    pub fn new() -> ListTopicSubscriptionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &ListTopicSubscriptionsRequest| { &m.topic },
            |m: &mut ListTopicSubscriptionsRequest| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListTopicSubscriptionsRequest| { &m.page_size },
            |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListTopicSubscriptionsRequest| { &m.page_token },
            |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicSubscriptionsRequest>(
            "ListTopicSubscriptionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsRequest {
    const NAME: &'static str = "ListTopicSubscriptionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicSubscriptionsRequest {
        ListTopicSubscriptionsRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicSubscriptionsRequest {
        static instance: ListTopicSubscriptionsRequest = ListTopicSubscriptionsRequest {
            topic: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicSubscriptionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicSubscriptionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `ListTopicSubscriptions` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListTopicSubscriptionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicSubscriptionsResponse {
    // message fields
    ///  The names of the subscriptions that match the request.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSubscriptionsResponse.subscriptions)
    pub subscriptions: ::std::vec::Vec<::std::string::String>,
    ///  If not empty, indicates that there may be more subscriptions that match
    ///  the request; this value should be passed in a new
    ///  `ListTopicSubscriptionsRequest` to get more subscriptions.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSubscriptionsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListTopicSubscriptionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsResponse {
    fn default() -> &'a ListTopicSubscriptionsResponse {
        <ListTopicSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsResponse {
    pub fn new() -> ListTopicSubscriptionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscriptions",
            |m: &ListTopicSubscriptionsResponse| { &m.subscriptions },
            |m: &mut ListTopicSubscriptionsResponse| { &mut m.subscriptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListTopicSubscriptionsResponse| { &m.next_page_token },
            |m: &mut ListTopicSubscriptionsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicSubscriptionsResponse>(
            "ListTopicSubscriptionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsResponse {
    const NAME: &'static str = "ListTopicSubscriptionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscriptions.push(is.read_string()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.subscriptions {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicSubscriptionsResponse {
        ListTopicSubscriptionsResponse::new()
    }

    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicSubscriptionsResponse {
        static instance: ListTopicSubscriptionsResponse = ListTopicSubscriptionsResponse {
            subscriptions: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicSubscriptionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicSubscriptionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `ListTopicSnapshots` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListTopicSnapshotsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicSnapshotsRequest {
    // message fields
    ///  The name of the topic that snapshots are attached to.
    ///  Format is `projects/{project}/topics/{topic}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSnapshotsRequest.topic)
    pub topic: ::std::string::String,
    ///  Maximum number of snapshot names to return.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSnapshotsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last `ListTopicSnapshotsResponse`; indicates
    ///  that this is a continuation of a prior `ListTopicSnapshots` call, and
    ///  that the system should return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSnapshotsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListTopicSnapshotsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicSnapshotsRequest {
    fn default() -> &'a ListTopicSnapshotsRequest {
        <ListTopicSnapshotsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSnapshotsRequest {
    pub fn new() -> ListTopicSnapshotsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &ListTopicSnapshotsRequest| { &m.topic },
            |m: &mut ListTopicSnapshotsRequest| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListTopicSnapshotsRequest| { &m.page_size },
            |m: &mut ListTopicSnapshotsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListTopicSnapshotsRequest| { &m.page_token },
            |m: &mut ListTopicSnapshotsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicSnapshotsRequest>(
            "ListTopicSnapshotsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicSnapshotsRequest {
    const NAME: &'static str = "ListTopicSnapshotsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicSnapshotsRequest {
        ListTopicSnapshotsRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicSnapshotsRequest {
        static instance: ListTopicSnapshotsRequest = ListTopicSnapshotsRequest {
            topic: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicSnapshotsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicSnapshotsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicSnapshotsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSnapshotsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `ListTopicSnapshots` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListTopicSnapshotsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTopicSnapshotsResponse {
    // message fields
    ///  The names of the snapshots that match the request.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSnapshotsResponse.snapshots)
    pub snapshots: ::std::vec::Vec<::std::string::String>,
    ///  If not empty, indicates that there may be more snapshots that match
    ///  the request; this value should be passed in a new
    ///  `ListTopicSnapshotsRequest` to get more snapshots.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListTopicSnapshotsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListTopicSnapshotsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTopicSnapshotsResponse {
    fn default() -> &'a ListTopicSnapshotsResponse {
        <ListTopicSnapshotsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSnapshotsResponse {
    pub fn new() -> ListTopicSnapshotsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshots",
            |m: &ListTopicSnapshotsResponse| { &m.snapshots },
            |m: &mut ListTopicSnapshotsResponse| { &mut m.snapshots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListTopicSnapshotsResponse| { &m.next_page_token },
            |m: &mut ListTopicSnapshotsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTopicSnapshotsResponse>(
            "ListTopicSnapshotsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTopicSnapshotsResponse {
    const NAME: &'static str = "ListTopicSnapshotsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshots.push(is.read_string()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.snapshots {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.snapshots {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTopicSnapshotsResponse {
        ListTopicSnapshotsResponse::new()
    }

    fn clear(&mut self) {
        self.snapshots.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTopicSnapshotsResponse {
        static instance: ListTopicSnapshotsResponse = ListTopicSnapshotsResponse {
            snapshots: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTopicSnapshotsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTopicSnapshotsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTopicSnapshotsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSnapshotsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `DeleteTopic` method.
// @@protoc_insertion_point(message:google.pubsub.v1.DeleteTopicRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteTopicRequest {
    // message fields
    ///  Name of the topic to delete.
    ///  Format is `projects/{project}/topics/{topic}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.DeleteTopicRequest.topic)
    pub topic: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.DeleteTopicRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTopicRequest {
    fn default() -> &'a DeleteTopicRequest {
        <DeleteTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTopicRequest {
    pub fn new() -> DeleteTopicRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &DeleteTopicRequest| { &m.topic },
            |m: &mut DeleteTopicRequest| { &mut m.topic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTopicRequest>(
            "DeleteTopicRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTopicRequest {
    const NAME: &'static str = "DeleteTopicRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTopicRequest {
        DeleteTopicRequest::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTopicRequest {
        static instance: DeleteTopicRequest = DeleteTopicRequest {
            topic: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTopicRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTopicRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTopicRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A subscription resource.
// @@protoc_insertion_point(message:google.pubsub.v1.Subscription)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subscription {
    // message fields
    ///  The name of the subscription. It must have the format
    ///  `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
    ///  start with a letter, and contain only letters (`[A-Za-z]`), numbers
    ///  (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
    ///  plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
    ///  in length, and it must not start with `"goog"`.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.name)
    pub name: ::std::string::String,
    ///  The name of the topic from which this subscription is receiving messages.
    ///  Format is `projects/{project}/topics/{topic}`.
    ///  The value of this field will be `_deleted-topic_` if the topic has been
    ///  deleted.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.topic)
    pub topic: ::std::string::String,
    ///  If push delivery is used with this subscription, this field is
    ///  used to configure it. An empty `pushConfig` signifies that the subscriber
    ///  will pull and ack messages using API methods.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.push_config)
    pub push_config: ::protobuf::MessageField<PushConfig>,
    ///  The approximate amount of time (on a best-effort basis) Pub/Sub waits for
    ///  the subscriber to acknowledge receipt before resending the message. In the
    ///  interval after the message is delivered and before it is acknowledged, it
    ///  is considered to be <i>outstanding</i>. During that time period, the
    ///  message will not be redelivered (on a best-effort basis).
    ///
    ///  For pull subscriptions, this value is used as the initial value for the ack
    ///  deadline. To override this value for a given message, call
    ///  `ModifyAckDeadline` with the corresponding `ack_id` if using
    ///  non-streaming pull or send the `ack_id` in a
    ///  `StreamingModifyAckDeadlineRequest` if using streaming pull.
    ///  The minimum custom deadline you can specify is 10 seconds.
    ///  The maximum custom deadline you can specify is 600 seconds (10 minutes).
    ///  If this parameter is 0, a default value of 10 seconds is used.
    ///
    ///  For push delivery, this value is also used to set the request timeout for
    ///  the call to the push endpoint.
    ///
    ///  If the subscriber never acknowledges the message, the Pub/Sub
    ///  system will eventually redeliver the message.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.ack_deadline_seconds)
    pub ack_deadline_seconds: i32,
    ///  Indicates whether to retain acknowledged messages. If true, then
    ///  messages are not expunged from the subscription's backlog, even if they are
    ///  acknowledged, until they fall out of the `message_retention_duration`
    ///  window. This must be true if you would like to
    ///  <a
    ///  href="https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time">
    ///  Seek to a timestamp</a>.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.retain_acked_messages)
    pub retain_acked_messages: bool,
    ///  How long to retain unacknowledged messages in the subscription's backlog,
    ///  from the moment a message is published.
    ///  If `retain_acked_messages` is true, then this also configures the retention
    ///  of acknowledged messages, and thus configures how far back in time a `Seek`
    ///  can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10
    ///  minutes.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.message_retention_duration)
    pub message_retention_duration: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    ///  See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
    ///  managing labels</a>.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  If true, messages published with the same `ordering_key` in `PubsubMessage`
    ///  will be delivered to the subscribers in the order in which they
    ///  are received by the Pub/Sub system. Otherwise, they may be delivered in
    ///  any order.
    ///  <b>EXPERIMENTAL:</b> This feature is part of a closed alpha release. This
    ///  API might be changed in backward-incompatible ways and is not recommended
    ///  for production use. It is not subject to any SLA or deprecation policy.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.enable_message_ordering)
    pub enable_message_ordering: bool,
    ///  A policy that specifies the conditions for this subscription's expiration.
    ///  A subscription is considered active as long as any connected subscriber is
    ///  successfully consuming messages from the subscription or is issuing
    ///  operations on the subscription. If `expiration_policy` is not set, a
    ///  *default policy* with `ttl` of 31 days will be used. The minimum allowed
    ///  value for `expiration_policy.ttl` is 1 day.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.expiration_policy)
    pub expiration_policy: ::protobuf::MessageField<ExpirationPolicy>,
    ///  A policy that specifies the conditions for dead lettering messages in
    ///  this subscription. If dead_letter_policy is not set, dead lettering
    ///  is disabled.
    ///
    ///  The Cloud Pub/Sub service account associated with this subscriptions's
    ///  parent project (i.e.,
    ///  service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    ///  permission to Acknowledge() messages on this subscription.
    ///  <b>EXPERIMENTAL:</b> This feature is part of a closed alpha release. This
    ///  API might be changed in backward-incompatible ways and is not recommended
    ///  for production use. It is not subject to any SLA or deprecation policy.
    // @@protoc_insertion_point(field:google.pubsub.v1.Subscription.dead_letter_policy)
    pub dead_letter_policy: ::protobuf::MessageField<DeadLetterPolicy>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.Subscription.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Subscription {
    fn default() -> &'a Subscription {
        <Subscription as ::protobuf::Message>::default_instance()
    }
}

impl Subscription {
    pub fn new() -> Subscription {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Subscription| { &m.name },
            |m: &mut Subscription| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &Subscription| { &m.topic },
            |m: &mut Subscription| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PushConfig>(
            "push_config",
            |m: &Subscription| { &m.push_config },
            |m: &mut Subscription| { &mut m.push_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_deadline_seconds",
            |m: &Subscription| { &m.ack_deadline_seconds },
            |m: &mut Subscription| { &mut m.ack_deadline_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "retain_acked_messages",
            |m: &Subscription| { &m.retain_acked_messages },
            |m: &mut Subscription| { &mut m.retain_acked_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "message_retention_duration",
            |m: &Subscription| { &m.message_retention_duration },
            |m: &mut Subscription| { &mut m.message_retention_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &Subscription| { &m.labels },
            |m: &mut Subscription| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enable_message_ordering",
            |m: &Subscription| { &m.enable_message_ordering },
            |m: &mut Subscription| { &mut m.enable_message_ordering },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExpirationPolicy>(
            "expiration_policy",
            |m: &Subscription| { &m.expiration_policy },
            |m: &mut Subscription| { &mut m.expiration_policy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeadLetterPolicy>(
            "dead_letter_policy",
            |m: &Subscription| { &m.dead_letter_policy },
            |m: &mut Subscription| { &mut m.dead_letter_policy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscription>(
            "Subscription",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Subscription {
    const NAME: &'static str = "Subscription";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.topic = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.push_config)?;
                },
                40 => {
                    self.ack_deadline_seconds = is.read_int32()?;
                },
                56 => {
                    self.retain_acked_messages = is.read_bool()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message_retention_duration)?;
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                80 => {
                    self.enable_message_ordering = is.read_bool()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.expiration_policy)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dead_letter_policy)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.ack_deadline_seconds);
        }
        if self.retain_acked_messages != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message_retention_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.enable_message_ordering != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.expiration_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dead_letter_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(v) = self.push_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.ack_deadline_seconds != 0 {
            os.write_int32(5, self.ack_deadline_seconds)?;
        }
        if self.retain_acked_messages != false {
            os.write_bool(7, self.retain_acked_messages)?;
        }
        if let Some(v) = self.message_retention_duration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.enable_message_ordering != false {
            os.write_bool(10, self.enable_message_ordering)?;
        }
        if let Some(v) = self.expiration_policy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.dead_letter_policy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Subscription {
        Subscription::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.topic.clear();
        self.push_config.clear();
        self.ack_deadline_seconds = 0;
        self.retain_acked_messages = false;
        self.message_retention_duration.clear();
        self.labels.clear();
        self.enable_message_ordering = false;
        self.expiration_policy.clear();
        self.dead_letter_policy.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Subscription {
        static instance: ::protobuf::rt::Lazy<Subscription> = ::protobuf::rt::Lazy::new();
        instance.get(Subscription::new)
    }
}

impl ::protobuf::MessageFull for Subscription {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Subscription").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Subscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subscription {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Dead lettering is done on a best effort basis. The same message might be
///  dead lettered multiple times.
///
///  If validation on any of the fields fails at subscription creation/updation,
///  the create/update subscription request will fail.
// @@protoc_insertion_point(message:google.pubsub.v1.DeadLetterPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeadLetterPolicy {
    // message fields
    ///  The name of the topic to which dead letter messages should be published.
    ///  Format is `projects/{project}/topics/{topic}`.The Cloud Pub/Sub service
    ///  account associated with the enclosing subscription's parent project (i.e.,
    ///  service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    ///  permission to Publish() to this topic.
    ///
    ///  The operation will fail if the topic does not exist.
    ///  Users should ensure that there is a subscription attached to this topic
    ///  since messages published to a topic with no subscriptions are lost.
    // @@protoc_insertion_point(field:google.pubsub.v1.DeadLetterPolicy.dead_letter_topic)
    pub dead_letter_topic: ::std::string::String,
    ///  The maximum number of delivery attempts for any message. The value must be
    ///  between 5 and 100.
    ///
    ///  The number of delivery attempts is defined as 1 + (the sum of number of
    ///  NACKs and number of times the acknowledgement deadline has been exceeded
    ///  for the message).
    ///
    ///  A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
    ///  client libraries may automatically extend ack_deadlines.
    ///
    ///  This field will be honored on a best effort basis.
    ///
    ///  If this parameter is 0, a default value of 5 is used.
    // @@protoc_insertion_point(field:google.pubsub.v1.DeadLetterPolicy.max_delivery_attempts)
    pub max_delivery_attempts: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.DeadLetterPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeadLetterPolicy {
    fn default() -> &'a DeadLetterPolicy {
        <DeadLetterPolicy as ::protobuf::Message>::default_instance()
    }
}

impl DeadLetterPolicy {
    pub fn new() -> DeadLetterPolicy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dead_letter_topic",
            |m: &DeadLetterPolicy| { &m.dead_letter_topic },
            |m: &mut DeadLetterPolicy| { &mut m.dead_letter_topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_delivery_attempts",
            |m: &DeadLetterPolicy| { &m.max_delivery_attempts },
            |m: &mut DeadLetterPolicy| { &mut m.max_delivery_attempts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeadLetterPolicy>(
            "DeadLetterPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeadLetterPolicy {
    const NAME: &'static str = "DeadLetterPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dead_letter_topic = is.read_string()?;
                },
                16 => {
                    self.max_delivery_attempts = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dead_letter_topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dead_letter_topic);
        }
        if self.max_delivery_attempts != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.max_delivery_attempts);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dead_letter_topic.is_empty() {
            os.write_string(1, &self.dead_letter_topic)?;
        }
        if self.max_delivery_attempts != 0 {
            os.write_int32(2, self.max_delivery_attempts)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeadLetterPolicy {
        DeadLetterPolicy::new()
    }

    fn clear(&mut self) {
        self.dead_letter_topic.clear();
        self.max_delivery_attempts = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeadLetterPolicy {
        static instance: DeadLetterPolicy = DeadLetterPolicy {
            dead_letter_topic: ::std::string::String::new(),
            max_delivery_attempts: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeadLetterPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeadLetterPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeadLetterPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeadLetterPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A policy that specifies the conditions for resource expiration (i.e.,
///  automatic resource deletion).
// @@protoc_insertion_point(message:google.pubsub.v1.ExpirationPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpirationPolicy {
    // message fields
    ///  Specifies the "time-to-live" duration for an associated resource. The
    ///  resource expires if it is not active for a period of `ttl`. The definition
    ///  of "activity" depends on the type of the associated resource. The minimum
    ///  and maximum allowed values for `ttl` depend on the type of the associated
    ///  resource, as well. If `ttl` is not set, the associated resource never
    ///  expires.
    // @@protoc_insertion_point(field:google.pubsub.v1.ExpirationPolicy.ttl)
    pub ttl: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ExpirationPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExpirationPolicy {
    fn default() -> &'a ExpirationPolicy {
        <ExpirationPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ExpirationPolicy {
    pub fn new() -> ExpirationPolicy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "ttl",
            |m: &ExpirationPolicy| { &m.ttl },
            |m: &mut ExpirationPolicy| { &mut m.ttl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExpirationPolicy>(
            "ExpirationPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExpirationPolicy {
    const NAME: &'static str = "ExpirationPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ttl)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ttl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExpirationPolicy {
        ExpirationPolicy::new()
    }

    fn clear(&mut self) {
        self.ttl.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExpirationPolicy {
        static instance: ExpirationPolicy = ExpirationPolicy {
            ttl: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExpirationPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExpirationPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExpirationPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpirationPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Configuration for a push delivery endpoint.
// @@protoc_insertion_point(message:google.pubsub.v1.PushConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PushConfig {
    // message fields
    ///  A URL locating the endpoint to which messages should be pushed.
    ///  For example, a Webhook endpoint might use "https://example.com/push".
    // @@protoc_insertion_point(field:google.pubsub.v1.PushConfig.push_endpoint)
    pub push_endpoint: ::std::string::String,
    ///  Endpoint configuration attributes that can be used to control different
    ///  aspects of the message delivery.
    ///
    ///  The only currently supported attribute is `x-goog-version`, which you can
    ///  use to change the format of the pushed message. This attribute
    ///  indicates the version of the data expected by the endpoint. This
    ///  controls the shape of the pushed message (i.e., its fields and metadata).
    ///
    ///  If not present during the `CreateSubscription` call, it will default to
    ///  the version of the Pub/Sub API used to make such call. If not present in a
    ///  `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
    ///  calls will always return a valid version, even if the subscription was
    ///  created without this attribute.
    ///
    ///  The only supported values for the `x-goog-version` attribute are:
    ///
    ///  * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
    ///  * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.
    ///
    ///  For example:
    ///  <pre><code>attributes { "x-goog-version": "v1" } </code></pre>
    // @@protoc_insertion_point(field:google.pubsub.v1.PushConfig.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub authentication_method: ::std::option::Option<push_config::Authentication_method>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.PushConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PushConfig {
    fn default() -> &'a PushConfig {
        <PushConfig as ::protobuf::Message>::default_instance()
    }
}

impl PushConfig {
    pub fn new() -> PushConfig {
        ::std::default::Default::default()
    }

    // .google.pubsub.v1.PushConfig.OidcToken oidc_token = 3;

    pub fn oidc_token(&self) -> &push_config::OidcToken {
        match self.authentication_method {
            ::std::option::Option::Some(push_config::Authentication_method::OidcToken(ref v)) => v,
            _ => <push_config::OidcToken as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_oidc_token(&mut self) {
        self.authentication_method = ::std::option::Option::None;
    }

    pub fn has_oidc_token(&self) -> bool {
        match self.authentication_method {
            ::std::option::Option::Some(push_config::Authentication_method::OidcToken(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oidc_token(&mut self, v: push_config::OidcToken) {
        self.authentication_method = ::std::option::Option::Some(push_config::Authentication_method::OidcToken(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oidc_token(&mut self) -> &mut push_config::OidcToken {
        if let ::std::option::Option::Some(push_config::Authentication_method::OidcToken(_)) = self.authentication_method {
        } else {
            self.authentication_method = ::std::option::Option::Some(push_config::Authentication_method::OidcToken(push_config::OidcToken::new()));
        }
        match self.authentication_method {
            ::std::option::Option::Some(push_config::Authentication_method::OidcToken(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oidc_token(&mut self) -> push_config::OidcToken {
        if self.has_oidc_token() {
            match self.authentication_method.take() {
                ::std::option::Option::Some(push_config::Authentication_method::OidcToken(v)) => v,
                _ => panic!(),
            }
        } else {
            push_config::OidcToken::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "push_endpoint",
            |m: &PushConfig| { &m.push_endpoint },
            |m: &mut PushConfig| { &mut m.push_endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &PushConfig| { &m.attributes },
            |m: &mut PushConfig| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, push_config::OidcToken>(
            "oidc_token",
            PushConfig::has_oidc_token,
            PushConfig::oidc_token,
            PushConfig::mut_oidc_token,
            PushConfig::set_oidc_token,
        ));
        oneofs.push(push_config::Authentication_method::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PushConfig>(
            "PushConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PushConfig {
    const NAME: &'static str = "PushConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.push_endpoint = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                26 => {
                    self.authentication_method = ::std::option::Option::Some(push_config::Authentication_method::OidcToken(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.push_endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.push_endpoint);
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let ::std::option::Option::Some(ref v) = self.authentication_method {
            match v {
                &push_config::Authentication_method::OidcToken(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.push_endpoint.is_empty() {
            os.write_string(1, &self.push_endpoint)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.authentication_method {
            match v {
                &push_config::Authentication_method::OidcToken(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PushConfig {
        PushConfig::new()
    }

    fn clear(&mut self) {
        self.push_endpoint.clear();
        self.attributes.clear();
        self.authentication_method = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PushConfig {
        static instance: ::protobuf::rt::Lazy<PushConfig> = ::protobuf::rt::Lazy::new();
        instance.get(PushConfig::new)
    }
}

impl ::protobuf::MessageFull for PushConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PushConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PushConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PushConfig`
pub mod push_config {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.pubsub.v1.PushConfig.authentication_method)
    pub enum Authentication_method {
        // @@protoc_insertion_point(oneof_field:google.pubsub.v1.PushConfig.oidc_token)
        OidcToken(OidcToken),
    }

    impl ::protobuf::Oneof for Authentication_method {
    }

    impl ::protobuf::OneofFull for Authentication_method {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PushConfig as ::protobuf::MessageFull>::descriptor().oneof_by_name("authentication_method").unwrap()).clone()
        }
    }

    impl Authentication_method {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Authentication_method>("authentication_method")
        }
    }
    ///  Contains information needed for generating an
    ///  [OpenID Connect
    ///  token](https://developers.google.com/identity/protocols/OpenIDConnect).
    // @@protoc_insertion_point(message:google.pubsub.v1.PushConfig.OidcToken)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OidcToken {
        // message fields
        ///  [Service account
        ///  email](https://cloud.google.com/iam/docs/service-accounts)
        ///  to be used for generating the OIDC token. The caller (for
        ///  CreateSubscription, UpdateSubscription, and ModifyPushConfig RPCs) must
        ///  have the iam.serviceAccounts.actAs permission for the service account.
        // @@protoc_insertion_point(field:google.pubsub.v1.PushConfig.OidcToken.service_account_email)
        pub service_account_email: ::std::string::String,
        ///  Audience to be used when generating OIDC token. The audience claim
        ///  identifies the recipients that the JWT is intended for. The audience
        ///  value is a single case-sensitive string. Having multiple values (array)
        ///  for the audience field is not supported. More info about the OIDC JWT
        ///  token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
        ///  Note: if not specified, the Push endpoint URL will be used.
        // @@protoc_insertion_point(field:google.pubsub.v1.PushConfig.OidcToken.audience)
        pub audience: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:google.pubsub.v1.PushConfig.OidcToken.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OidcToken {
        fn default() -> &'a OidcToken {
            <OidcToken as ::protobuf::Message>::default_instance()
        }
    }

    impl OidcToken {
        pub fn new() -> OidcToken {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "service_account_email",
                |m: &OidcToken| { &m.service_account_email },
                |m: &mut OidcToken| { &mut m.service_account_email },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "audience",
                |m: &OidcToken| { &m.audience },
                |m: &mut OidcToken| { &mut m.audience },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OidcToken>(
                "PushConfig.OidcToken",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OidcToken {
        const NAME: &'static str = "OidcToken";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.service_account_email = is.read_string()?;
                    },
                    18 => {
                        self.audience = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.service_account_email.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.service_account_email);
            }
            if !self.audience.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.audience);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.service_account_email.is_empty() {
                os.write_string(1, &self.service_account_email)?;
            }
            if !self.audience.is_empty() {
                os.write_string(2, &self.audience)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OidcToken {
            OidcToken::new()
        }

        fn clear(&mut self) {
            self.service_account_email.clear();
            self.audience.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OidcToken {
            static instance: OidcToken = OidcToken {
                service_account_email: ::std::string::String::new(),
                audience: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OidcToken {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PushConfig.OidcToken").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OidcToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OidcToken {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  A message and its corresponding acknowledgment ID.
// @@protoc_insertion_point(message:google.pubsub.v1.ReceivedMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReceivedMessage {
    // message fields
    ///  This ID can be used to acknowledge the received message.
    // @@protoc_insertion_point(field:google.pubsub.v1.ReceivedMessage.ack_id)
    pub ack_id: ::std::string::String,
    ///  The message.
    // @@protoc_insertion_point(field:google.pubsub.v1.ReceivedMessage.message)
    pub message: ::protobuf::MessageField<PubsubMessage>,
    ///  Delivery attempt counter is 1 + (the sum of number of NACKs and number of
    ///  ack_deadline exceeds) for this message.
    ///
    ///  A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline
    ///  exceeds event is whenever a message is not acknowledged within
    ///  ack_deadline. Note that ack_deadline is initially
    ///  Subscription.ackDeadlineSeconds, but may get extended automatically by
    ///  the client library.
    ///
    ///  The first delivery of a given message will have this value as 1. The value
    ///  is calculated at best effort and is approximate.
    ///
    ///  If a DeadLetterPolicy is not set on the subscription, this will be 0.
    ///  <b>EXPERIMENTAL:</b> This feature is part of a closed alpha release. This
    ///  API might be changed in backward-incompatible ways and is not recommended
    ///  for production use. It is not subject to any SLA or deprecation policy.
    // @@protoc_insertion_point(field:google.pubsub.v1.ReceivedMessage.delivery_attempt)
    pub delivery_attempt: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ReceivedMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReceivedMessage {
    fn default() -> &'a ReceivedMessage {
        <ReceivedMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReceivedMessage {
    pub fn new() -> ReceivedMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_id",
            |m: &ReceivedMessage| { &m.ack_id },
            |m: &mut ReceivedMessage| { &mut m.ack_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubsubMessage>(
            "message",
            |m: &ReceivedMessage| { &m.message },
            |m: &mut ReceivedMessage| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delivery_attempt",
            |m: &ReceivedMessage| { &m.delivery_attempt },
            |m: &mut ReceivedMessage| { &mut m.delivery_attempt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReceivedMessage>(
            "ReceivedMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReceivedMessage {
    const NAME: &'static str = "ReceivedMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ack_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                24 => {
                    self.delivery_attempt = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ack_id);
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.delivery_attempt != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.delivery_attempt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ack_id.is_empty() {
            os.write_string(1, &self.ack_id)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.delivery_attempt != 0 {
            os.write_int32(3, self.delivery_attempt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReceivedMessage {
        ReceivedMessage::new()
    }

    fn clear(&mut self) {
        self.ack_id.clear();
        self.message.clear();
        self.delivery_attempt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReceivedMessage {
        static instance: ReceivedMessage = ReceivedMessage {
            ack_id: ::std::string::String::new(),
            message: ::protobuf::MessageField::none(),
            delivery_attempt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReceivedMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReceivedMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReceivedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceivedMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the GetSubscription method.
// @@protoc_insertion_point(message:google.pubsub.v1.GetSubscriptionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSubscriptionRequest {
    // message fields
    ///  The name of the subscription to get.
    ///  Format is `projects/{project}/subscriptions/{sub}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.GetSubscriptionRequest.subscription)
    pub subscription: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.GetSubscriptionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSubscriptionRequest {
    fn default() -> &'a GetSubscriptionRequest {
        <GetSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSubscriptionRequest {
    pub fn new() -> GetSubscriptionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &GetSubscriptionRequest| { &m.subscription },
            |m: &mut GetSubscriptionRequest| { &mut m.subscription },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSubscriptionRequest>(
            "GetSubscriptionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSubscriptionRequest {
    const NAME: &'static str = "GetSubscriptionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSubscriptionRequest {
        GetSubscriptionRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSubscriptionRequest {
        static instance: GetSubscriptionRequest = GetSubscriptionRequest {
            subscription: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSubscriptionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSubscriptionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubscriptionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the UpdateSubscription method.
// @@protoc_insertion_point(message:google.pubsub.v1.UpdateSubscriptionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateSubscriptionRequest {
    // message fields
    ///  The updated subscription object.
    // @@protoc_insertion_point(field:google.pubsub.v1.UpdateSubscriptionRequest.subscription)
    pub subscription: ::protobuf::MessageField<Subscription>,
    ///  Indicates which fields in the provided subscription to update.
    ///  Must be specified and non-empty.
    // @@protoc_insertion_point(field:google.pubsub.v1.UpdateSubscriptionRequest.update_mask)
    pub update_mask: ::protobuf::MessageField<::protobuf::well_known_types::field_mask::FieldMask>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.UpdateSubscriptionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateSubscriptionRequest {
    fn default() -> &'a UpdateSubscriptionRequest {
        <UpdateSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSubscriptionRequest {
    pub fn new() -> UpdateSubscriptionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Subscription>(
            "subscription",
            |m: &UpdateSubscriptionRequest| { &m.subscription },
            |m: &mut UpdateSubscriptionRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::field_mask::FieldMask>(
            "update_mask",
            |m: &UpdateSubscriptionRequest| { &m.update_mask },
            |m: &mut UpdateSubscriptionRequest| { &mut m.update_mask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateSubscriptionRequest>(
            "UpdateSubscriptionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateSubscriptionRequest {
    const NAME: &'static str = "UpdateSubscriptionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subscription)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_mask)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subscription.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.update_mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateSubscriptionRequest {
        UpdateSubscriptionRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.update_mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateSubscriptionRequest {
        static instance: UpdateSubscriptionRequest = UpdateSubscriptionRequest {
            subscription: ::protobuf::MessageField::none(),
            update_mask: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateSubscriptionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateSubscriptionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSubscriptionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `ListSubscriptions` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListSubscriptionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSubscriptionsRequest {
    // message fields
    ///  The name of the project in which to list subscriptions.
    ///  Format is `projects/{project-id}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSubscriptionsRequest.project)
    pub project: ::std::string::String,
    ///  Maximum number of subscriptions to return.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSubscriptionsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last `ListSubscriptionsResponse`; indicates that
    ///  this is a continuation of a prior `ListSubscriptions` call, and that the
    ///  system should return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSubscriptionsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListSubscriptionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsRequest {
    fn default() -> &'a ListSubscriptionsRequest {
        <ListSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsRequest {
    pub fn new() -> ListSubscriptionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &ListSubscriptionsRequest| { &m.project },
            |m: &mut ListSubscriptionsRequest| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListSubscriptionsRequest| { &m.page_size },
            |m: &mut ListSubscriptionsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListSubscriptionsRequest| { &m.page_token },
            |m: &mut ListSubscriptionsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSubscriptionsRequest>(
            "ListSubscriptionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSubscriptionsRequest {
    const NAME: &'static str = "ListSubscriptionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.project = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSubscriptionsRequest {
        ListSubscriptionsRequest::new()
    }

    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSubscriptionsRequest {
        static instance: ListSubscriptionsRequest = ListSubscriptionsRequest {
            project: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSubscriptionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSubscriptionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `ListSubscriptions` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListSubscriptionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSubscriptionsResponse {
    // message fields
    ///  The subscriptions that match the request.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSubscriptionsResponse.subscriptions)
    pub subscriptions: ::std::vec::Vec<Subscription>,
    ///  If not empty, indicates that there may be more subscriptions that match
    ///  the request; this value should be passed in a new
    ///  `ListSubscriptionsRequest` to get more subscriptions.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSubscriptionsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListSubscriptionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsResponse {
    fn default() -> &'a ListSubscriptionsResponse {
        <ListSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsResponse {
    pub fn new() -> ListSubscriptionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscriptions",
            |m: &ListSubscriptionsResponse| { &m.subscriptions },
            |m: &mut ListSubscriptionsResponse| { &mut m.subscriptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListSubscriptionsResponse| { &m.next_page_token },
            |m: &mut ListSubscriptionsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSubscriptionsResponse>(
            "ListSubscriptionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSubscriptionsResponse {
    const NAME: &'static str = "ListSubscriptionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscriptions.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.subscriptions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSubscriptionsResponse {
        ListSubscriptionsResponse::new()
    }

    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSubscriptionsResponse {
        static instance: ListSubscriptionsResponse = ListSubscriptionsResponse {
            subscriptions: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSubscriptionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSubscriptionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the DeleteSubscription method.
// @@protoc_insertion_point(message:google.pubsub.v1.DeleteSubscriptionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSubscriptionRequest {
    // message fields
    ///  The subscription to delete.
    ///  Format is `projects/{project}/subscriptions/{sub}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.DeleteSubscriptionRequest.subscription)
    pub subscription: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.DeleteSubscriptionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSubscriptionRequest {
    fn default() -> &'a DeleteSubscriptionRequest {
        <DeleteSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSubscriptionRequest {
    pub fn new() -> DeleteSubscriptionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &DeleteSubscriptionRequest| { &m.subscription },
            |m: &mut DeleteSubscriptionRequest| { &mut m.subscription },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSubscriptionRequest>(
            "DeleteSubscriptionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSubscriptionRequest {
    const NAME: &'static str = "DeleteSubscriptionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSubscriptionRequest {
        DeleteSubscriptionRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSubscriptionRequest {
        static instance: DeleteSubscriptionRequest = DeleteSubscriptionRequest {
            subscription: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSubscriptionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSubscriptionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSubscriptionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the ModifyPushConfig method.
// @@protoc_insertion_point(message:google.pubsub.v1.ModifyPushConfigRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModifyPushConfigRequest {
    // message fields
    ///  The name of the subscription.
    ///  Format is `projects/{project}/subscriptions/{sub}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ModifyPushConfigRequest.subscription)
    pub subscription: ::std::string::String,
    ///  The push configuration for future deliveries.
    ///
    ///  An empty `pushConfig` indicates that the Pub/Sub system should
    ///  stop pushing messages from the given subscription and allow
    ///  messages to be pulled and acknowledged - effectively pausing
    ///  the subscription if `Pull` or `StreamingPull` is not called.
    // @@protoc_insertion_point(field:google.pubsub.v1.ModifyPushConfigRequest.push_config)
    pub push_config: ::protobuf::MessageField<PushConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ModifyPushConfigRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModifyPushConfigRequest {
    fn default() -> &'a ModifyPushConfigRequest {
        <ModifyPushConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyPushConfigRequest {
    pub fn new() -> ModifyPushConfigRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &ModifyPushConfigRequest| { &m.subscription },
            |m: &mut ModifyPushConfigRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PushConfig>(
            "push_config",
            |m: &ModifyPushConfigRequest| { &m.push_config },
            |m: &mut ModifyPushConfigRequest| { &mut m.push_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModifyPushConfigRequest>(
            "ModifyPushConfigRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModifyPushConfigRequest {
    const NAME: &'static str = "ModifyPushConfigRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.push_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if let Some(v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if let Some(v) = self.push_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModifyPushConfigRequest {
        ModifyPushConfigRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.push_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModifyPushConfigRequest {
        static instance: ModifyPushConfigRequest = ModifyPushConfigRequest {
            subscription: ::std::string::String::new(),
            push_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModifyPushConfigRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModifyPushConfigRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModifyPushConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyPushConfigRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `Pull` method.
// @@protoc_insertion_point(message:google.pubsub.v1.PullRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PullRequest {
    // message fields
    ///  The subscription from which messages should be pulled.
    ///  Format is `projects/{project}/subscriptions/{sub}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.PullRequest.subscription)
    pub subscription: ::std::string::String,
    ///  If this field set to true, the system will respond immediately even if
    ///  it there are no messages available to return in the `Pull` response.
    ///  Otherwise, the system may wait (for a bounded amount of time) until at
    ///  least one message is available, rather than returning no messages.
    // @@protoc_insertion_point(field:google.pubsub.v1.PullRequest.return_immediately)
    pub return_immediately: bool,
    ///  The maximum number of messages to return for this request. Must be a
    ///  positive integer. The Pub/Sub system may return fewer than the number
    ///  specified.
    // @@protoc_insertion_point(field:google.pubsub.v1.PullRequest.max_messages)
    pub max_messages: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.PullRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PullRequest {
    fn default() -> &'a PullRequest {
        <PullRequest as ::protobuf::Message>::default_instance()
    }
}

impl PullRequest {
    pub fn new() -> PullRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &PullRequest| { &m.subscription },
            |m: &mut PullRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_immediately",
            |m: &PullRequest| { &m.return_immediately },
            |m: &mut PullRequest| { &mut m.return_immediately },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_messages",
            |m: &PullRequest| { &m.max_messages },
            |m: &mut PullRequest| { &mut m.max_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PullRequest>(
            "PullRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PullRequest {
    const NAME: &'static str = "PullRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                16 => {
                    self.return_immediately = is.read_bool()?;
                },
                24 => {
                    self.max_messages = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if self.return_immediately != false {
            my_size += 1 + 1;
        }
        if self.max_messages != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.max_messages);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if self.return_immediately != false {
            os.write_bool(2, self.return_immediately)?;
        }
        if self.max_messages != 0 {
            os.write_int32(3, self.max_messages)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PullRequest {
        PullRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.return_immediately = false;
        self.max_messages = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PullRequest {
        static instance: PullRequest = PullRequest {
            subscription: ::std::string::String::new(),
            return_immediately: false,
            max_messages: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PullRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PullRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `Pull` method.
// @@protoc_insertion_point(message:google.pubsub.v1.PullResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PullResponse {
    // message fields
    ///  Received Pub/Sub messages. The list will be empty if there are no more
    ///  messages available in the backlog. For JSON, the response can be entirely
    ///  empty. The Pub/Sub system may return fewer than the `maxMessages` requested
    ///  even if there are more messages available in the backlog.
    // @@protoc_insertion_point(field:google.pubsub.v1.PullResponse.received_messages)
    pub received_messages: ::std::vec::Vec<ReceivedMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.PullResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PullResponse {
    fn default() -> &'a PullResponse {
        <PullResponse as ::protobuf::Message>::default_instance()
    }
}

impl PullResponse {
    pub fn new() -> PullResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "received_messages",
            |m: &PullResponse| { &m.received_messages },
            |m: &mut PullResponse| { &mut m.received_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PullResponse>(
            "PullResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PullResponse {
    const NAME: &'static str = "PullResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.received_messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.received_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.received_messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PullResponse {
        PullResponse::new()
    }

    fn clear(&mut self) {
        self.received_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PullResponse {
        static instance: PullResponse = PullResponse {
            received_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PullResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PullResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the ModifyAckDeadline method.
// @@protoc_insertion_point(message:google.pubsub.v1.ModifyAckDeadlineRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModifyAckDeadlineRequest {
    // message fields
    ///  The name of the subscription.
    ///  Format is `projects/{project}/subscriptions/{sub}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ModifyAckDeadlineRequest.subscription)
    pub subscription: ::std::string::String,
    ///  List of acknowledgment IDs.
    // @@protoc_insertion_point(field:google.pubsub.v1.ModifyAckDeadlineRequest.ack_ids)
    pub ack_ids: ::std::vec::Vec<::std::string::String>,
    ///  The new ack deadline with respect to the time this request was sent to
    ///  the Pub/Sub system. For example, if the value is 10, the new
    ///  ack deadline will expire 10 seconds after the `ModifyAckDeadline` call
    ///  was made. Specifying zero might immediately make the message available for
    ///  delivery to another subscriber client. This typically results in an
    ///  increase in the rate of message redeliveries (that is, duplicates).
    ///  The minimum deadline you can specify is 0 seconds.
    ///  The maximum deadline you can specify is 600 seconds (10 minutes).
    // @@protoc_insertion_point(field:google.pubsub.v1.ModifyAckDeadlineRequest.ack_deadline_seconds)
    pub ack_deadline_seconds: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ModifyAckDeadlineRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModifyAckDeadlineRequest {
    fn default() -> &'a ModifyAckDeadlineRequest {
        <ModifyAckDeadlineRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyAckDeadlineRequest {
    pub fn new() -> ModifyAckDeadlineRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &ModifyAckDeadlineRequest| { &m.subscription },
            |m: &mut ModifyAckDeadlineRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_ids",
            |m: &ModifyAckDeadlineRequest| { &m.ack_ids },
            |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_deadline_seconds",
            |m: &ModifyAckDeadlineRequest| { &m.ack_deadline_seconds },
            |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_deadline_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModifyAckDeadlineRequest>(
            "ModifyAckDeadlineRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModifyAckDeadlineRequest {
    const NAME: &'static str = "ModifyAckDeadlineRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                34 => {
                    self.ack_ids.push(is.read_string()?);
                },
                24 => {
                    self.ack_deadline_seconds = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.ack_deadline_seconds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(4, &v)?;
        };
        if self.ack_deadline_seconds != 0 {
            os.write_int32(3, self.ack_deadline_seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModifyAckDeadlineRequest {
        ModifyAckDeadlineRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.ack_deadline_seconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModifyAckDeadlineRequest {
        static instance: ModifyAckDeadlineRequest = ModifyAckDeadlineRequest {
            subscription: ::std::string::String::new(),
            ack_ids: ::std::vec::Vec::new(),
            ack_deadline_seconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModifyAckDeadlineRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModifyAckDeadlineRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModifyAckDeadlineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyAckDeadlineRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the Acknowledge method.
// @@protoc_insertion_point(message:google.pubsub.v1.AcknowledgeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AcknowledgeRequest {
    // message fields
    ///  The subscription whose message is being acknowledged.
    ///  Format is `projects/{project}/subscriptions/{sub}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.AcknowledgeRequest.subscription)
    pub subscription: ::std::string::String,
    ///  The acknowledgment ID for the messages being acknowledged that was returned
    ///  by the Pub/Sub system in the `Pull` response. Must not be empty.
    // @@protoc_insertion_point(field:google.pubsub.v1.AcknowledgeRequest.ack_ids)
    pub ack_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.AcknowledgeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AcknowledgeRequest {
    fn default() -> &'a AcknowledgeRequest {
        <AcknowledgeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AcknowledgeRequest {
    pub fn new() -> AcknowledgeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &AcknowledgeRequest| { &m.subscription },
            |m: &mut AcknowledgeRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_ids",
            |m: &AcknowledgeRequest| { &m.ack_ids },
            |m: &mut AcknowledgeRequest| { &mut m.ack_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AcknowledgeRequest>(
            "AcknowledgeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AcknowledgeRequest {
    const NAME: &'static str = "AcknowledgeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                18 => {
                    self.ack_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AcknowledgeRequest {
        AcknowledgeRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AcknowledgeRequest {
        static instance: AcknowledgeRequest = AcknowledgeRequest {
            subscription: ::std::string::String::new(),
            ack_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AcknowledgeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AcknowledgeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AcknowledgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcknowledgeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `StreamingPull` streaming RPC method. This request is used to
///  establish the initial stream as well as to stream acknowledgements and ack
///  deadline modifications from the client to the server.
// @@protoc_insertion_point(message:google.pubsub.v1.StreamingPullRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamingPullRequest {
    // message fields
    ///  The subscription for which to initialize the new stream. This must be
    ///  provided in the first request on the stream, and must not be set in
    ///  subsequent requests from client to server.
    ///  Format is `projects/{project}/subscriptions/{sub}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.StreamingPullRequest.subscription)
    pub subscription: ::std::string::String,
    ///  List of acknowledgement IDs for acknowledging previously received messages
    ///  (received on this stream or a different stream). If an ack ID has expired,
    ///  the corresponding message may be redelivered later. Acknowledging a message
    ///  more than once will not result in an error. If the acknowledgement ID is
    ///  malformed, the stream will be aborted with status `INVALID_ARGUMENT`.
    // @@protoc_insertion_point(field:google.pubsub.v1.StreamingPullRequest.ack_ids)
    pub ack_ids: ::std::vec::Vec<::std::string::String>,
    ///  The list of new ack deadlines for the IDs listed in
    ///  `modify_deadline_ack_ids`. The size of this list must be the same as the
    ///  size of `modify_deadline_ack_ids`. If it differs the stream will be aborted
    ///  with `INVALID_ARGUMENT`. Each element in this list is applied to the
    ///  element in the same position in `modify_deadline_ack_ids`. The new ack
    ///  deadline is with respect to the time this request was sent to the Pub/Sub
    ///  system. Must be >= 0. For example, if the value is 10, the new ack deadline
    ///  will expire 10 seconds after this request is received. If the value is 0,
    ///  the message is immediately made available for another streaming or
    ///  non-streaming pull request. If the value is < 0 (an error), the stream will
    ///  be aborted with status `INVALID_ARGUMENT`.
    // @@protoc_insertion_point(field:google.pubsub.v1.StreamingPullRequest.modify_deadline_seconds)
    pub modify_deadline_seconds: ::std::vec::Vec<i32>,
    ///  List of acknowledgement IDs whose deadline will be modified based on the
    ///  corresponding element in `modify_deadline_seconds`. This field can be used
    ///  to indicate that more time is needed to process a message by the
    ///  subscriber, or to make the message available for redelivery if the
    ///  processing was interrupted.
    // @@protoc_insertion_point(field:google.pubsub.v1.StreamingPullRequest.modify_deadline_ack_ids)
    pub modify_deadline_ack_ids: ::std::vec::Vec<::std::string::String>,
    ///  The ack deadline to use for the stream. This must be provided in the
    ///  first request on the stream, but it can also be updated on subsequent
    ///  requests from client to server. The minimum deadline you can specify is 10
    ///  seconds. The maximum deadline you can specify is 600 seconds (10 minutes).
    // @@protoc_insertion_point(field:google.pubsub.v1.StreamingPullRequest.stream_ack_deadline_seconds)
    pub stream_ack_deadline_seconds: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.StreamingPullRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamingPullRequest {
    fn default() -> &'a StreamingPullRequest {
        <StreamingPullRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullRequest {
    pub fn new() -> StreamingPullRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &StreamingPullRequest| { &m.subscription },
            |m: &mut StreamingPullRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ack_ids",
            |m: &StreamingPullRequest| { &m.ack_ids },
            |m: &mut StreamingPullRequest| { &mut m.ack_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modify_deadline_seconds",
            |m: &StreamingPullRequest| { &m.modify_deadline_seconds },
            |m: &mut StreamingPullRequest| { &mut m.modify_deadline_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modify_deadline_ack_ids",
            |m: &StreamingPullRequest| { &m.modify_deadline_ack_ids },
            |m: &mut StreamingPullRequest| { &mut m.modify_deadline_ack_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream_ack_deadline_seconds",
            |m: &StreamingPullRequest| { &m.stream_ack_deadline_seconds },
            |m: &mut StreamingPullRequest| { &mut m.stream_ack_deadline_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamingPullRequest>(
            "StreamingPullRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamingPullRequest {
    const NAME: &'static str = "StreamingPullRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                18 => {
                    self.ack_ids.push(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.modify_deadline_seconds)?;
                },
                24 => {
                    self.modify_deadline_seconds.push(is.read_int32()?);
                },
                34 => {
                    self.modify_deadline_ack_ids.push(is.read_string()?);
                },
                40 => {
                    self.stream_ack_deadline_seconds = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.modify_deadline_seconds {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        for value in &self.modify_deadline_ack_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.stream_ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.stream_ack_deadline_seconds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.modify_deadline_seconds {
            os.write_int32(3, *v)?;
        };
        for v in &self.modify_deadline_ack_ids {
            os.write_string(4, &v)?;
        };
        if self.stream_ack_deadline_seconds != 0 {
            os.write_int32(5, self.stream_ack_deadline_seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamingPullRequest {
        StreamingPullRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.modify_deadline_seconds.clear();
        self.modify_deadline_ack_ids.clear();
        self.stream_ack_deadline_seconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamingPullRequest {
        static instance: StreamingPullRequest = StreamingPullRequest {
            subscription: ::std::string::String::new(),
            ack_ids: ::std::vec::Vec::new(),
            modify_deadline_seconds: ::std::vec::Vec::new(),
            modify_deadline_ack_ids: ::std::vec::Vec::new(),
            stream_ack_deadline_seconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamingPullRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamingPullRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamingPullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `StreamingPull` method. This response is used to stream
///  messages from the server to the client.
// @@protoc_insertion_point(message:google.pubsub.v1.StreamingPullResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamingPullResponse {
    // message fields
    ///  Received Pub/Sub messages. This will not be empty.
    // @@protoc_insertion_point(field:google.pubsub.v1.StreamingPullResponse.received_messages)
    pub received_messages: ::std::vec::Vec<ReceivedMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.StreamingPullResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamingPullResponse {
    fn default() -> &'a StreamingPullResponse {
        <StreamingPullResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullResponse {
    pub fn new() -> StreamingPullResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "received_messages",
            |m: &StreamingPullResponse| { &m.received_messages },
            |m: &mut StreamingPullResponse| { &mut m.received_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamingPullResponse>(
            "StreamingPullResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamingPullResponse {
    const NAME: &'static str = "StreamingPullResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.received_messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.received_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.received_messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamingPullResponse {
        StreamingPullResponse::new()
    }

    fn clear(&mut self) {
        self.received_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamingPullResponse {
        static instance: StreamingPullResponse = StreamingPullResponse {
            received_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamingPullResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamingPullResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamingPullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `CreateSnapshot` method.
// @@protoc_insertion_point(message:google.pubsub.v1.CreateSnapshotRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateSnapshotRequest {
    // message fields
    ///  Optional user-provided name for this snapshot.
    ///  If the name is not provided in the request, the server will assign a random
    ///  name for this snapshot on the same project as the subscription.
    ///  Note that for REST API requests, you must specify a name.  See the
    ///  <a href="https://cloud.google.com/pubsub/docs/admin#resource_names">
    ///  resource name rules</a>.
    ///  Format is `projects/{project}/snapshots/{snap}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.CreateSnapshotRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:google.pubsub.v1.CreateSnapshotRequest.subscription)
    pub subscription: ::std::string::String,
    ///  See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
    ///  managing labels</a>.
    // @@protoc_insertion_point(field:google.pubsub.v1.CreateSnapshotRequest.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.CreateSnapshotRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSnapshotRequest {
    fn default() -> &'a CreateSnapshotRequest {
        <CreateSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSnapshotRequest {
    pub fn new() -> CreateSnapshotRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CreateSnapshotRequest| { &m.name },
            |m: &mut CreateSnapshotRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &CreateSnapshotRequest| { &m.subscription },
            |m: &mut CreateSnapshotRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &CreateSnapshotRequest| { &m.labels },
            |m: &mut CreateSnapshotRequest| { &mut m.labels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSnapshotRequest>(
            "CreateSnapshotRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSnapshotRequest {
    const NAME: &'static str = "CreateSnapshotRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.subscription = is.read_string()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subscription);
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.subscription.is_empty() {
            os.write_string(2, &self.subscription)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSnapshotRequest {
        CreateSnapshotRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.subscription.clear();
        self.labels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSnapshotRequest {
        static instance: ::protobuf::rt::Lazy<CreateSnapshotRequest> = ::protobuf::rt::Lazy::new();
        instance.get(CreateSnapshotRequest::new)
    }
}

impl ::protobuf::MessageFull for CreateSnapshotRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSnapshotRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the UpdateSnapshot method.
// @@protoc_insertion_point(message:google.pubsub.v1.UpdateSnapshotRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateSnapshotRequest {
    // message fields
    ///  The updated snapshot object.
    // @@protoc_insertion_point(field:google.pubsub.v1.UpdateSnapshotRequest.snapshot)
    pub snapshot: ::protobuf::MessageField<Snapshot>,
    ///  Indicates which fields in the provided snapshot to update.
    ///  Must be specified and non-empty.
    // @@protoc_insertion_point(field:google.pubsub.v1.UpdateSnapshotRequest.update_mask)
    pub update_mask: ::protobuf::MessageField<::protobuf::well_known_types::field_mask::FieldMask>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.UpdateSnapshotRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateSnapshotRequest {
    fn default() -> &'a UpdateSnapshotRequest {
        <UpdateSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSnapshotRequest {
    pub fn new() -> UpdateSnapshotRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Snapshot>(
            "snapshot",
            |m: &UpdateSnapshotRequest| { &m.snapshot },
            |m: &mut UpdateSnapshotRequest| { &mut m.snapshot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::field_mask::FieldMask>(
            "update_mask",
            |m: &UpdateSnapshotRequest| { &m.update_mask },
            |m: &mut UpdateSnapshotRequest| { &mut m.update_mask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateSnapshotRequest>(
            "UpdateSnapshotRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateSnapshotRequest {
    const NAME: &'static str = "UpdateSnapshotRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.snapshot)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_mask)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.snapshot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.snapshot.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.update_mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateSnapshotRequest {
        UpdateSnapshotRequest::new()
    }

    fn clear(&mut self) {
        self.snapshot.clear();
        self.update_mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateSnapshotRequest {
        static instance: UpdateSnapshotRequest = UpdateSnapshotRequest {
            snapshot: ::protobuf::MessageField::none(),
            update_mask: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateSnapshotRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateSnapshotRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSnapshotRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A snapshot resource. Snapshots are used in
///  <a href="https://cloud.google.com/pubsub/docs/replay-overview">Seek</a>
///  operations, which allow
///  you to manage message acknowledgments in bulk. That is, you can set the
///  acknowledgment state of messages in an existing subscription to the state
///  captured by a snapshot.
// @@protoc_insertion_point(message:google.pubsub.v1.Snapshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Snapshot {
    // message fields
    ///  The name of the snapshot.
    // @@protoc_insertion_point(field:google.pubsub.v1.Snapshot.name)
    pub name: ::std::string::String,
    ///  The name of the topic from which this snapshot is retaining messages.
    // @@protoc_insertion_point(field:google.pubsub.v1.Snapshot.topic)
    pub topic: ::std::string::String,
    ///  The snapshot is guaranteed to exist up until this time.
    ///  A newly-created snapshot expires no later than 7 days from the time of its
    ///  creation. Its exact lifetime is determined at creation by the existing
    ///  backlog in the source subscription. Specifically, the lifetime of the
    ///  snapshot is `7 days - (age of oldest unacked message in the subscription)`.
    ///  For example, consider a subscription whose oldest unacked message is 3 days
    ///  old. If a snapshot is created from this subscription, the snapshot -- which
    ///  will always capture this 3-day-old backlog as long as the snapshot
    ///  exists -- will expire in 4 days. The service will refuse to create a
    ///  snapshot that would expire in less than 1 hour after creation.
    // @@protoc_insertion_point(field:google.pubsub.v1.Snapshot.expire_time)
    pub expire_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
    ///  managing labels</a>.
    // @@protoc_insertion_point(field:google.pubsub.v1.Snapshot.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.Snapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Snapshot {
    fn default() -> &'a Snapshot {
        <Snapshot as ::protobuf::Message>::default_instance()
    }
}

impl Snapshot {
    pub fn new() -> Snapshot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Snapshot| { &m.name },
            |m: &mut Snapshot| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &Snapshot| { &m.topic },
            |m: &mut Snapshot| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "expire_time",
            |m: &Snapshot| { &m.expire_time },
            |m: &mut Snapshot| { &mut m.expire_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &Snapshot| { &m.labels },
            |m: &mut Snapshot| { &mut m.labels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Snapshot>(
            "Snapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Snapshot {
    const NAME: &'static str = "Snapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.topic = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.expire_time)?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(v) = self.expire_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(v) = self.expire_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Snapshot {
        Snapshot::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.topic.clear();
        self.expire_time.clear();
        self.labels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Snapshot {
        static instance: ::protobuf::rt::Lazy<Snapshot> = ::protobuf::rt::Lazy::new();
        instance.get(Snapshot::new)
    }
}

impl ::protobuf::MessageFull for Snapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Snapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Snapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Snapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the GetSnapshot method.
// @@protoc_insertion_point(message:google.pubsub.v1.GetSnapshotRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSnapshotRequest {
    // message fields
    ///  The name of the snapshot to get.
    ///  Format is `projects/{project}/snapshots/{snap}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.GetSnapshotRequest.snapshot)
    pub snapshot: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.GetSnapshotRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSnapshotRequest {
    fn default() -> &'a GetSnapshotRequest {
        <GetSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotRequest {
    pub fn new() -> GetSnapshotRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "snapshot",
            |m: &GetSnapshotRequest| { &m.snapshot },
            |m: &mut GetSnapshotRequest| { &mut m.snapshot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSnapshotRequest>(
            "GetSnapshotRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSnapshotRequest {
    const NAME: &'static str = "GetSnapshotRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshot = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.snapshot.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.snapshot.is_empty() {
            os.write_string(1, &self.snapshot)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSnapshotRequest {
        GetSnapshotRequest::new()
    }

    fn clear(&mut self) {
        self.snapshot.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSnapshotRequest {
        static instance: GetSnapshotRequest = GetSnapshotRequest {
            snapshot: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSnapshotRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSnapshotRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `ListSnapshots` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListSnapshotsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSnapshotsRequest {
    // message fields
    ///  The name of the project in which to list snapshots.
    ///  Format is `projects/{project-id}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSnapshotsRequest.project)
    pub project: ::std::string::String,
    ///  Maximum number of snapshots to return.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSnapshotsRequest.page_size)
    pub page_size: i32,
    ///  The value returned by the last `ListSnapshotsResponse`; indicates that this
    ///  is a continuation of a prior `ListSnapshots` call, and that the system
    ///  should return the next page of data.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSnapshotsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListSnapshotsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSnapshotsRequest {
    fn default() -> &'a ListSnapshotsRequest {
        <ListSnapshotsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotsRequest {
    pub fn new() -> ListSnapshotsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &ListSnapshotsRequest| { &m.project },
            |m: &mut ListSnapshotsRequest| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListSnapshotsRequest| { &m.page_size },
            |m: &mut ListSnapshotsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListSnapshotsRequest| { &m.page_token },
            |m: &mut ListSnapshotsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSnapshotsRequest>(
            "ListSnapshotsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSnapshotsRequest {
    const NAME: &'static str = "ListSnapshotsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.project = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSnapshotsRequest {
        ListSnapshotsRequest::new()
    }

    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSnapshotsRequest {
        static instance: ListSnapshotsRequest = ListSnapshotsRequest {
            project: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSnapshotsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSnapshotsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSnapshotsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response for the `ListSnapshots` method.
// @@protoc_insertion_point(message:google.pubsub.v1.ListSnapshotsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSnapshotsResponse {
    // message fields
    ///  The resulting snapshots.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSnapshotsResponse.snapshots)
    pub snapshots: ::std::vec::Vec<Snapshot>,
    ///  If not empty, indicates that there may be more snapshot that match the
    ///  request; this value should be passed in a new `ListSnapshotsRequest`.
    // @@protoc_insertion_point(field:google.pubsub.v1.ListSnapshotsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.ListSnapshotsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSnapshotsResponse {
    fn default() -> &'a ListSnapshotsResponse {
        <ListSnapshotsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotsResponse {
    pub fn new() -> ListSnapshotsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshots",
            |m: &ListSnapshotsResponse| { &m.snapshots },
            |m: &mut ListSnapshotsResponse| { &mut m.snapshots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListSnapshotsResponse| { &m.next_page_token },
            |m: &mut ListSnapshotsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSnapshotsResponse>(
            "ListSnapshotsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSnapshotsResponse {
    const NAME: &'static str = "ListSnapshotsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshots.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.snapshots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.snapshots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSnapshotsResponse {
        ListSnapshotsResponse::new()
    }

    fn clear(&mut self) {
        self.snapshots.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSnapshotsResponse {
        static instance: ListSnapshotsResponse = ListSnapshotsResponse {
            snapshots: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSnapshotsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSnapshotsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSnapshotsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `DeleteSnapshot` method.
// @@protoc_insertion_point(message:google.pubsub.v1.DeleteSnapshotRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSnapshotRequest {
    // message fields
    ///  The name of the snapshot to delete.
    ///  Format is `projects/{project}/snapshots/{snap}`.
    // @@protoc_insertion_point(field:google.pubsub.v1.DeleteSnapshotRequest.snapshot)
    pub snapshot: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.DeleteSnapshotRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSnapshotRequest {
    fn default() -> &'a DeleteSnapshotRequest {
        <DeleteSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSnapshotRequest {
    pub fn new() -> DeleteSnapshotRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "snapshot",
            |m: &DeleteSnapshotRequest| { &m.snapshot },
            |m: &mut DeleteSnapshotRequest| { &mut m.snapshot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSnapshotRequest>(
            "DeleteSnapshotRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSnapshotRequest {
    const NAME: &'static str = "DeleteSnapshotRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshot = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.snapshot.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.snapshot.is_empty() {
            os.write_string(1, &self.snapshot)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSnapshotRequest {
        DeleteSnapshotRequest::new()
    }

    fn clear(&mut self) {
        self.snapshot.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSnapshotRequest {
        static instance: DeleteSnapshotRequest = DeleteSnapshotRequest {
            snapshot: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSnapshotRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSnapshotRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request for the `Seek` method.
// @@protoc_insertion_point(message:google.pubsub.v1.SeekRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SeekRequest {
    // message fields
    ///  The subscription to affect.
    // @@protoc_insertion_point(field:google.pubsub.v1.SeekRequest.subscription)
    pub subscription: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<seek_request::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.SeekRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SeekRequest {
    fn default() -> &'a SeekRequest {
        <SeekRequest as ::protobuf::Message>::default_instance()
    }
}

impl SeekRequest {
    pub fn new() -> SeekRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp time = 2;

    pub fn time(&self) -> &::protobuf::well_known_types::timestamp::Timestamp {
        match self.target {
            ::std::option::Option::Some(seek_request::Target::Time(ref v)) => v,
            _ => <::protobuf::well_known_types::timestamp::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_time(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(seek_request::Target::Time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::timestamp::Timestamp) {
        self.target = ::std::option::Option::Some(seek_request::Target::Time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::timestamp::Timestamp {
        if let ::std::option::Option::Some(seek_request::Target::Time(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(seek_request::Target::Time(::protobuf::well_known_types::timestamp::Timestamp::new()));
        }
        match self.target {
            ::std::option::Option::Some(seek_request::Target::Time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::timestamp::Timestamp {
        if self.has_time() {
            match self.target.take() {
                ::std::option::Option::Some(seek_request::Target::Time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::timestamp::Timestamp::new()
        }
    }

    // string snapshot = 3;

    pub fn snapshot(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(seek_request::Target::Snapshot(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_snapshot(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_snapshot(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(seek_request::Target::Snapshot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(seek_request::Target::Snapshot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_snapshot(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(seek_request::Target::Snapshot(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(seek_request::Target::Snapshot(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(seek_request::Target::Snapshot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_snapshot(&mut self) -> ::std::string::String {
        if self.has_snapshot() {
            match self.target.take() {
                ::std::option::Option::Some(seek_request::Target::Snapshot(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscription",
            |m: &SeekRequest| { &m.subscription },
            |m: &mut SeekRequest| { &mut m.subscription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            SeekRequest::has_time,
            SeekRequest::time,
            SeekRequest::mut_time,
            SeekRequest::set_time,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "snapshot",
            SeekRequest::has_snapshot,
            SeekRequest::snapshot,
            SeekRequest::set_snapshot,
        ));
        oneofs.push(seek_request::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SeekRequest>(
            "SeekRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SeekRequest {
    const NAME: &'static str = "SeekRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscription = is.read_string()?;
                },
                18 => {
                    self.target = ::std::option::Option::Some(seek_request::Target::Time(is.read_message()?));
                },
                26 => {
                    self.target = ::std::option::Option::Some(seek_request::Target::Snapshot(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &seek_request::Target::Time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &seek_request::Target::Snapshot(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &seek_request::Target::Time(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &seek_request::Target::Snapshot(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SeekRequest {
        SeekRequest::new()
    }

    fn clear(&mut self) {
        self.subscription.clear();
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SeekRequest {
        static instance: SeekRequest = SeekRequest {
            subscription: ::std::string::String::new(),
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SeekRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SeekRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SeekRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SeekRequest`
pub mod seek_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.pubsub.v1.SeekRequest.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:google.pubsub.v1.SeekRequest.time)
        Time(::protobuf::well_known_types::timestamp::Timestamp),
        // @@protoc_insertion_point(oneof_field:google.pubsub.v1.SeekRequest.snapshot)
        Snapshot(::std::string::String),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SeekRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

///  Response for the `Seek` method (this response is empty).
// @@protoc_insertion_point(message:google.pubsub.v1.SeekResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SeekResponse {
    // special fields
    // @@protoc_insertion_point(special_field:google.pubsub.v1.SeekResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SeekResponse {
    fn default() -> &'a SeekResponse {
        <SeekResponse as ::protobuf::Message>::default_instance()
    }
}

impl SeekResponse {
    pub fn new() -> SeekResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SeekResponse>(
            "SeekResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SeekResponse {
    const NAME: &'static str = "SeekResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SeekResponse {
        SeekResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SeekResponse {
        static instance: SeekResponse = SeekResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SeekResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SeekResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SeekResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dgoogle/pubsub/v1/pubsub.proto\x12\x10google.pubsub.v1\x1a\x1cgoogl\
    e/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1egoogle/pro\
    tobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x20google/pr\
    otobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"V\n\x14M\
    essageStoragePolicy\x12>\n\x1ballowed_persistence_regions\x18\x01\x20\
    \x03(\tR\x19allowedPersistenceRegions\"\x93\x02\n\x05Topic\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12;\n\x06labels\x18\x02\x20\x03(\x0b2#\
    .google.pubsub.v1.Topic.LabelsEntryR\x06labels\x12\\\n\x16message_storag\
    e_policy\x18\x03\x20\x01(\x0b2&.google.pubsub.v1.MessageStoragePolicyR\
    \x14messageStoragePolicy\x12\x20\n\x0ckms_key_name\x18\x05\x20\x01(\tR\n\
    kmsKeyName\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xb4\
    \x02\n\rPubsubMessage\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\
    \x12O\n\nattributes\x18\x02\x20\x03(\x0b2/.google.pubsub.v1.PubsubMessag\
    e.AttributesEntryR\nattributes\x12\x1d\n\nmessage_id\x18\x03\x20\x01(\tR\
    \tmessageId\x12=\n\x0cpublish_time\x18\x04\x20\x01(\x0b2\x1a.google.prot\
    obuf.TimestampR\x0bpublishTime\x12!\n\x0cordering_key\x18\x05\x20\x01(\t\
    R\x0borderingKey\x1a=\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"'\n\x0fGetTopicRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05t\
    opic\"\x80\x01\n\x12UpdateTopicRequest\x12-\n\x05topic\x18\x01\x20\x01(\
    \x0b2\x17.google.pubsub.v1.TopicR\x05topic\x12;\n\x0bupdate_mask\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\"c\n\x0ePublis\
    hRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\x12;\n\x08messa\
    ges\x18\x02\x20\x03(\x0b2\x1f.google.pubsub.v1.PubsubMessageR\x08message\
    s\"2\n\x0fPublishResponse\x12\x1f\n\x0bmessage_ids\x18\x01\x20\x03(\tR\n\
    messageIds\"i\n\x11ListTopicsRequest\x12\x18\n\x07project\x18\x01\x20\
    \x01(\tR\x07project\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSi\
    ze\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"m\n\x12ListTopi\
    csResponse\x12/\n\x06topics\x18\x01\x20\x03(\x0b2\x17.google.pubsub.v1.T\
    opicR\x06topics\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageT\
    oken\"q\n\x1dListTopicSubscriptionsRequest\x12\x14\n\x05topic\x18\x01\
    \x20\x01(\tR\x05topic\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08page\
    Size\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"n\n\x1eListTo\
    picSubscriptionsResponse\x12$\n\rsubscriptions\x18\x01\x20\x03(\tR\rsubs\
    criptions\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\
    m\n\x19ListTopicSnapshotsRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\
    \x05topic\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\
    \n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"b\n\x1aListTopicSnapshots\
    Response\x12\x1c\n\tsnapshots\x18\x01\x20\x03(\tR\tsnapshots\x12&\n\x0fn\
    ext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"*\n\x12DeleteTopicReq\
    uest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\"\x90\x05\n\x0cSubs\
    cription\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05topi\
    c\x18\x02\x20\x01(\tR\x05topic\x12=\n\x0bpush_config\x18\x04\x20\x01(\
    \x0b2\x1c.google.pubsub.v1.PushConfigR\npushConfig\x120\n\x14ack_deadlin\
    e_seconds\x18\x05\x20\x01(\x05R\x12ackDeadlineSeconds\x122\n\x15retain_a\
    cked_messages\x18\x07\x20\x01(\x08R\x13retainAckedMessages\x12W\n\x1ames\
    sage_retention_duration\x18\x08\x20\x01(\x0b2\x19.google.protobuf.Durati\
    onR\x18messageRetentionDuration\x12B\n\x06labels\x18\t\x20\x03(\x0b2*.go\
    ogle.pubsub.v1.Subscription.LabelsEntryR\x06labels\x126\n\x17enable_mess\
    age_ordering\x18\n\x20\x01(\x08R\x15enableMessageOrdering\x12O\n\x11expi\
    ration_policy\x18\x0b\x20\x01(\x0b2\".google.pubsub.v1.ExpirationPolicyR\
    \x10expirationPolicy\x12P\n\x12dead_letter_policy\x18\r\x20\x01(\x0b2\".\
    google.pubsub.v1.DeadLetterPolicyR\x10deadLetterPolicy\x1a9\n\x0bLabelsE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"r\n\x10DeadLetterPolicy\x12*\n\x11d\
    ead_letter_topic\x18\x01\x20\x01(\tR\x0fdeadLetterTopic\x122\n\x15max_de\
    livery_attempts\x18\x02\x20\x01(\x05R\x13maxDeliveryAttempts\"?\n\x10Exp\
    irationPolicy\x12+\n\x03ttl\x18\x01\x20\x01(\x0b2\x19.google.protobuf.Du\
    rationR\x03ttl\"\xfd\x02\n\nPushConfig\x12#\n\rpush_endpoint\x18\x01\x20\
    \x01(\tR\x0cpushEndpoint\x12L\n\nattributes\x18\x02\x20\x03(\x0b2,.googl\
    e.pubsub.v1.PushConfig.AttributesEntryR\nattributes\x12G\n\noidc_token\
    \x18\x03\x20\x01(\x0b2&.google.pubsub.v1.PushConfig.OidcTokenH\0R\toidcT\
    oken\x1a[\n\tOidcToken\x122\n\x15service_account_email\x18\x01\x20\x01(\
    \tR\x13serviceAccountEmail\x12\x1a\n\x08audience\x18\x02\x20\x01(\tR\x08\
    audience\x1a=\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x17\n\
    \x15authentication_method\"\x8e\x01\n\x0fReceivedMessage\x12\x15\n\x06ac\
    k_id\x18\x01\x20\x01(\tR\x05ackId\x129\n\x07message\x18\x02\x20\x01(\x0b\
    2\x1f.google.pubsub.v1.PubsubMessageR\x07message\x12)\n\x10delivery_atte\
    mpt\x18\x03\x20\x01(\x05R\x0fdeliveryAttempt\"<\n\x16GetSubscriptionRequ\
    est\x12\"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\"\x9c\
    \x01\n\x19UpdateSubscriptionRequest\x12B\n\x0csubscription\x18\x01\x20\
    \x01(\x0b2\x1e.google.pubsub.v1.SubscriptionR\x0csubscription\x12;\n\x0b\
    update_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdate\
    Mask\"p\n\x18ListSubscriptionsRequest\x12\x18\n\x07project\x18\x01\x20\
    \x01(\tR\x07project\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSi\
    ze\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"\x89\x01\n\x19L\
    istSubscriptionsResponse\x12D\n\rsubscriptions\x18\x01\x20\x03(\x0b2\x1e\
    .google.pubsub.v1.SubscriptionR\rsubscriptions\x12&\n\x0fnext_page_token\
    \x18\x02\x20\x01(\tR\rnextPageToken\"?\n\x19DeleteSubscriptionRequest\
    \x12\"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\"|\n\x17Mod\
    ifyPushConfigRequest\x12\"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubs\
    cription\x12=\n\x0bpush_config\x18\x02\x20\x01(\x0b2\x1c.google.pubsub.v\
    1.PushConfigR\npushConfig\"\x83\x01\n\x0bPullRequest\x12\"\n\x0csubscrip\
    tion\x18\x01\x20\x01(\tR\x0csubscription\x12-\n\x12return_immediately\
    \x18\x02\x20\x01(\x08R\x11returnImmediately\x12!\n\x0cmax_messages\x18\
    \x03\x20\x01(\x05R\x0bmaxMessages\"^\n\x0cPullResponse\x12N\n\x11receive\
    d_messages\x18\x01\x20\x03(\x0b2!.google.pubsub.v1.ReceivedMessageR\x10r\
    eceivedMessages\"\x89\x01\n\x18ModifyAckDeadlineRequest\x12\"\n\x0csubsc\
    ription\x18\x01\x20\x01(\tR\x0csubscription\x12\x17\n\x07ack_ids\x18\x04\
    \x20\x03(\tR\x06ackIds\x120\n\x14ack_deadline_seconds\x18\x03\x20\x01(\
    \x05R\x12ackDeadlineSeconds\"Q\n\x12AcknowledgeRequest\x12\"\n\x0csubscr\
    iption\x18\x01\x20\x01(\tR\x0csubscription\x12\x17\n\x07ack_ids\x18\x02\
    \x20\x03(\tR\x06ackIds\"\x81\x02\n\x14StreamingPullRequest\x12\"\n\x0csu\
    bscription\x18\x01\x20\x01(\tR\x0csubscription\x12\x17\n\x07ack_ids\x18\
    \x02\x20\x03(\tR\x06ackIds\x126\n\x17modify_deadline_seconds\x18\x03\x20\
    \x03(\x05R\x15modifyDeadlineSeconds\x125\n\x17modify_deadline_ack_ids\
    \x18\x04\x20\x03(\tR\x14modifyDeadlineAckIds\x12=\n\x1bstream_ack_deadli\
    ne_seconds\x18\x05\x20\x01(\x05R\x18streamAckDeadlineSeconds\"g\n\x15Str\
    eamingPullResponse\x12N\n\x11received_messages\x18\x01\x20\x03(\x0b2!.go\
    ogle.pubsub.v1.ReceivedMessageR\x10receivedMessages\"\xd7\x01\n\x15Creat\
    eSnapshotRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\"\n\
    \x0csubscription\x18\x02\x20\x01(\tR\x0csubscription\x12K\n\x06labels\
    \x18\x03\x20\x03(\x0b23.google.pubsub.v1.CreateSnapshotRequest.LabelsEnt\
    ryR\x06labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x8c\
    \x01\n\x15UpdateSnapshotRequest\x126\n\x08snapshot\x18\x01\x20\x01(\x0b2\
    \x1a.google.pubsub.v1.SnapshotR\x08snapshot\x12;\n\x0bupdate_mask\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\"\xec\x01\
    \n\x08Snapshot\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\
    \x05topic\x18\x02\x20\x01(\tR\x05topic\x12;\n\x0bexpire_time\x18\x03\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\nexpireTime\x12>\n\x06labels\
    \x18\x04\x20\x03(\x0b2&.google.pubsub.v1.Snapshot.LabelsEntryR\x06labels\
    \x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"0\n\x12GetSnapsh\
    otRequest\x12\x1a\n\x08snapshot\x18\x01\x20\x01(\tR\x08snapshot\"l\n\x14\
    ListSnapshotsRequest\x12\x18\n\x07project\x18\x01\x20\x01(\tR\x07project\
    \x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_\
    token\x18\x03\x20\x01(\tR\tpageToken\"y\n\x15ListSnapshotsResponse\x128\
    \n\tsnapshots\x18\x01\x20\x03(\x0b2\x1a.google.pubsub.v1.SnapshotR\tsnap\
    shots\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"3\n\
    \x15DeleteSnapshotRequest\x12\x1a\n\x08snapshot\x18\x01\x20\x01(\tR\x08s\
    napshot\"\x8b\x01\n\x0bSeekRequest\x12\"\n\x0csubscription\x18\x01\x20\
    \x01(\tR\x0csubscription\x120\n\x04time\x18\x02\x20\x01(\x0b2\x1a.google\
    .protobuf.TimestampH\0R\x04time\x12\x1c\n\x08snapshot\x18\x03\x20\x01(\t\
    H\0R\x08snapshotB\x08\n\x06target\"\x0e\n\x0cSeekResponse2\xb1\t\n\tPubl\
    isher\x12j\n\x0bCreateTopic\x12\x17.google.pubsub.v1.Topic\x1a\x17.googl\
    e.pubsub.v1.Topic\")\x82\xd3\xe4\x93\x02#\x1a\x1e/v1/{name=projects/*/to\
    pics/*}:\x01*\x12}\n\x0bUpdateTopic\x12$.google.pubsub.v1.UpdateTopicReq\
    uest\x1a\x17.google.pubsub.v1.Topic\"/\x82\xd3\xe4\x93\x02)2$/v1/{topic.\
    name=projects/*/topics/*}:\x01*\x12\x82\x01\n\x07Publish\x12\x20.google.\
    pubsub.v1.PublishRequest\x1a!.google.pubsub.v1.PublishResponse\"2\x82\
    \xd3\xe4\x93\x02,\"'/v1/{topic=projects/*/topics/*}:publish:\x01*\x12o\n\
    \x08GetTopic\x12!.google.pubsub.v1.GetTopicRequest\x1a\x17.google.pubsub\
    .v1.Topic\"'\x82\xd3\xe4\x93\x02!\x12\x1f/v1/{topic=projects/*/topics/*}\
    \x12\x80\x01\n\nListTopics\x12#.google.pubsub.v1.ListTopicsRequest\x1a$.\
    google.pubsub.v1.ListTopicsResponse\"'\x82\xd3\xe4\x93\x02!\x12\x1f/v1/{\
    project=projects/*}/topics\x12\xb2\x01\n\x16ListTopicSubscriptions\x12/.\
    google.pubsub.v1.ListTopicSubscriptionsRequest\x1a0.google.pubsub.v1.Lis\
    tTopicSubscriptionsResponse\"5\x82\xd3\xe4\x93\x02/\x12-/v1/{topic=proje\
    cts/*/topics/*}/subscriptions\x12\xa2\x01\n\x12ListTopicSnapshots\x12+.g\
    oogle.pubsub.v1.ListTopicSnapshotsRequest\x1a,.google.pubsub.v1.ListTopi\
    cSnapshotsResponse\"1\x82\xd3\xe4\x93\x02+\x12)/v1/{topic=projects/*/top\
    ics/*}/snapshots\x12t\n\x0bDeleteTopic\x12$.google.pubsub.v1.DeleteTopic\
    Request\x1a\x16.google.protobuf.Empty\"'\x82\xd3\xe4\x93\x02!*\x1f/v1/{t\
    opic=projects/*/topics/*}\x1ap\xd2AUhttps://www.googleapis.com/auth/clou\
    d-platform,https://www.googleapis.com/auth/pubsub\xcaA\x15pubsub.googlea\
    pis.com2\xeb\x12\n\nSubscriber\x12\x86\x01\n\x12CreateSubscription\x12\
    \x1e.google.pubsub.v1.Subscription\x1a\x1e.google.pubsub.v1.Subscription\
    \"0\x82\xd3\xe4\x93\x02*\x1a%/v1/{name=projects/*/subscriptions/*}:\x01*\
    \x12\x92\x01\n\x0fGetSubscription\x12(.google.pubsub.v1.GetSubscriptionR\
    equest\x1a\x1e.google.pubsub.v1.Subscription\"5\x82\xd3\xe4\x93\x02/\x12\
    -/v1/{subscription=projects/*/subscriptions/*}\x12\xa0\x01\n\x12UpdateSu\
    bscription\x12+.google.pubsub.v1.UpdateSubscriptionRequest\x1a\x1e.googl\
    e.pubsub.v1.Subscription\"=\x82\xd3\xe4\x93\x02722/v1/{subscription.name\
    =projects/*/subscriptions/*}:\x01*\x12\x9c\x01\n\x11ListSubscriptions\
    \x12*.google.pubsub.v1.ListSubscriptionsRequest\x1a+.google.pubsub.v1.Li\
    stSubscriptionsResponse\".\x82\xd3\xe4\x93\x02(\x12&/v1/{project=project\
    s/*}/subscriptions\x12\x90\x01\n\x12DeleteSubscription\x12+.google.pubsu\
    b.v1.DeleteSubscriptionRequest\x1a\x16.google.protobuf.Empty\"5\x82\xd3\
    \xe4\x93\x02/*-/v1/{subscription=projects/*/subscriptions/*}\x12\xa3\x01\
    \n\x11ModifyAckDeadline\x12*.google.pubsub.v1.ModifyAckDeadlineRequest\
    \x1a\x16.google.protobuf.Empty\"J\x82\xd3\xe4\x93\x02D\"?/v1/{subscripti\
    on=projects/*/subscriptions/*}:modifyAckDeadline:\x01*\x12\x91\x01\n\x0b\
    Acknowledge\x12$.google.pubsub.v1.AcknowledgeRequest\x1a\x16.google.prot\
    obuf.Empty\"D\x82\xd3\xe4\x93\x02>\"9/v1/{subscription=projects/*/subscr\
    iptions/*}:acknowledge:\x01*\x12\x84\x01\n\x04Pull\x12\x1d.google.pubsub\
    .v1.PullRequest\x1a\x1e.google.pubsub.v1.PullResponse\"=\x82\xd3\xe4\x93\
    \x027\"2/v1/{subscription=projects/*/subscriptions/*}:pull:\x01*\x12f\n\
    \rStreamingPull\x12&.google.pubsub.v1.StreamingPullRequest\x1a'.google.p\
    ubsub.v1.StreamingPullResponse\"\0(\x010\x01\x12\xa0\x01\n\x10ModifyPush\
    Config\x12).google.pubsub.v1.ModifyPushConfigRequest\x1a\x16.google.prot\
    obuf.Empty\"I\x82\xd3\xe4\x93\x02C\">/v1/{subscription=projects/*/subscr\
    iptions/*}:modifyPushConfig:\x01*\x12~\n\x0bGetSnapshot\x12$.google.pubs\
    ub.v1.GetSnapshotRequest\x1a\x1a.google.pubsub.v1.Snapshot\"-\x82\xd3\
    \xe4\x93\x02'\x12%/v1/{snapshot=projects/*/snapshots/*}\x12\x8c\x01\n\rL\
    istSnapshots\x12&.google.pubsub.v1.ListSnapshotsRequest\x1a'.google.pubs\
    ub.v1.ListSnapshotsResponse\"*\x82\xd3\xe4\x93\x02$\x12\"/v1/{project=pr\
    ojects/*}/snapshots\x12\x83\x01\n\x0eCreateSnapshot\x12'.google.pubsub.v\
    1.CreateSnapshotRequest\x1a\x1a.google.pubsub.v1.Snapshot\",\x82\xd3\xe4\
    \x93\x02&\x1a!/v1/{name=projects/*/snapshots/*}:\x01*\x12\x8c\x01\n\x0eU\
    pdateSnapshot\x12'.google.pubsub.v1.UpdateSnapshotRequest\x1a\x1a.google\
    .pubsub.v1.Snapshot\"5\x82\xd3\xe4\x93\x02/2*/v1/{snapshot.name=projects\
    /*/snapshots/*}:\x01*\x12\x80\x01\n\x0eDeleteSnapshot\x12'.google.pubsub\
    .v1.DeleteSnapshotRequest\x1a\x16.google.protobuf.Empty\"-\x82\xd3\xe4\
    \x93\x02'*%/v1/{snapshot=projects/*/snapshots/*}\x12\x84\x01\n\x04Seek\
    \x12\x1d.google.pubsub.v1.SeekRequest\x1a\x1e.google.pubsub.v1.SeekRespo\
    nse\"=\x82\xd3\xe4\x93\x027\"2/v1/{subscription=projects/*/subscriptions\
    /*}:seek:\x01*\x1ap\xd2AUhttps://www.googleapis.com/auth/cloud-platform,\
    https://www.googleapis.com/auth/pubsub\xcaA\x15pubsub.googleapis.comB\
    \xae\x01\n\x14com.google.pubsub.v1B\x0bPubsubProtoP\x01Z6google.golang.o\
    rg/genproto/googleapis/pubsub/v1;pubsub\xf8\x01\x01\xaa\x02\x16Google.Cl\
    oud.PubSub.V1\xca\x02\x16Google\\Cloud\\PubSub\\V1\xea\x02\x19Google::Cl\
    oud::PubSub::V1J\xf6\xd3\x02\n\x07\x12\x05\x0f\0\xaa\x08\x17\n\xbe\x04\n\
    \x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20LL\
    C.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202\
    .0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20fil\
    e\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20m\
    ay\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x19\n\t\n\x02\x03\0\x12\
    \x03\x13\0&\n\t\n\x02\x03\x01\x12\x03\x14\0!\n\t\n\x02\x03\x02\x12\x03\
    \x15\0(\n\t\n\x02\x03\x03\x12\x03\x16\0%\n\t\n\x02\x03\x04\x12\x03\x17\0\
    *\n\t\n\x02\x03\x05\x12\x03\x18\0)\n\x08\n\x01\x08\x12\x03\x1a\0\x1f\n\t\
    \n\x02\x08\x1f\x12\x03\x1a\0\x1f\n\x08\n\x01\x08\x12\x03\x1b\03\n\t\n\
    \x02\x08%\x12\x03\x1b\03\n\x08\n\x01\x08\x12\x03\x1c\0M\n\t\n\x02\x08\
    \x0b\x12\x03\x1c\0M\n\x08\n\x01\x08\x12\x03\x1d\0\"\n\t\n\x02\x08\n\x12\
    \x03\x1d\0\"\n\x08\n\x01\x08\x12\x03\x1e\0,\n\t\n\x02\x08\x08\x12\x03\
    \x1e\0,\n\x08\n\x01\x08\x12\x03\x1f\0-\n\t\n\x02\x08\x01\x12\x03\x1f\0-\
    \n\x08\n\x01\x08\x12\x03\x20\03\n\t\n\x02\x08)\x12\x03\x20\03\n\x08\n\
    \x01\x08\x12\x03!\02\n\t\n\x02\x08-\x12\x03!\02\nj\n\x02\x06\0\x12\x04%\
    \0t\x01\x1a^\x20The\x20service\x20that\x20an\x20application\x20uses\x20t\
    o\x20manipulate\x20topics,\x20and\x20to\x20send\n\x20messages\x20to\x20a\
    \x20topic.\n\n\n\n\x03\x06\0\x01\x12\x03%\x08\x11\n\n\n\x03\x06\0\x03\
    \x12\x03&\x02=\n\x0c\n\x05\x06\0\x03\x99\x08\x12\x03&\x02=\n\x0b\n\x03\
    \x06\0\x03\x12\x04'\x02)/\n\r\n\x05\x06\0\x03\x9a\x08\x12\x04'\x02)/\n\
    \xa5\x01\n\x04\x06\0\x02\0\x12\x04.\x023\x03\x1a\x96\x01\x20Creates\x20t\
    he\x20given\x20topic\x20with\x20the\x20given\x20name.\x20See\x20the\n\
    \x20<a\x20href=\"https://cloud.google.com/pubsub/docs/admin#resource_nam\
    es\">\n\x20resource\x20name\x20rules</a>.\n\n\x0c\n\x05\x06\0\x02\0\x01\
    \x12\x03.\x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03.\x12\x17\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03.\"'\n\r\n\x05\x06\0\x02\0\x04\x12\x04/\x042\
    \x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04/\x042\x06\ng\n\x04\
    \x06\0\x02\x01\x12\x047\x02<\x03\x1aY\x20Updates\x20an\x20existing\x20to\
    pic.\x20Note\x20that\x20certain\x20properties\x20of\x20a\n\x20topic\x20a\
    re\x20not\x20modifiable.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x037\x06\
    \x11\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x037\x12$\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x037/4\n\r\n\x05\x06\0\x02\x01\x04\x12\x048\x04;\x06\n\x11\
    \n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x048\x04;\x06\ni\n\x04\x06\0\
    \x02\x02\x12\x04@\x02E\x03\x1a[\x20Adds\x20one\x20or\x20more\x20messages\
    \x20to\x20the\x20topic.\x20Returns\x20`NOT_FOUND`\x20if\x20the\x20topic\
    \n\x20does\x20not\x20exist.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03@\x06\
    \r\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03@\x0e\x1c\n\x0c\n\x05\x06\0\x02\
    \x02\x03\x12\x03@'6\n\r\n\x05\x06\0\x02\x02\x04\x12\x04A\x04D\x06\n\x11\
    \n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04A\x04D\x06\n2\n\x04\x06\0\
    \x02\x03\x12\x04H\x02L\x03\x1a$\x20Gets\x20the\x20configuration\x20of\
    \x20a\x20topic.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03H\x06\x0e\n\x0c\n\
    \x05\x06\0\x02\x03\x02\x12\x03H\x0f\x1e\n\x0c\n\x05\x06\0\x02\x03\x03\
    \x12\x03H).\n\r\n\x05\x06\0\x02\x03\x04\x12\x04I\x04K\x06\n\x11\n\t\x06\
    \0\x02\x03\x04\xb0\xca\xbc\"\x12\x04I\x04K\x06\n&\n\x04\x06\0\x02\x04\
    \x12\x04O\x02S\x03\x1a\x18\x20Lists\x20matching\x20topics.\n\n\x0c\n\x05\
    \x06\0\x02\x04\x01\x12\x03O\x06\x10\n\x0c\n\x05\x06\0\x02\x04\x02\x12\
    \x03O\x11\"\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03O-?\n\r\n\x05\x06\0\x02\
    \x04\x04\x12\x04P\x04R\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\
    \x04P\x04R\x06\nC\n\x04\x06\0\x02\x05\x12\x04V\x02[\x03\x1a5\x20Lists\
    \x20the\x20names\x20of\x20the\x20subscriptions\x20on\x20this\x20topic.\n\
    \n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03V\x06\x1c\n\x0c\n\x05\x06\0\x02\
    \x05\x02\x12\x03V\x1d:\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03W\x0f-\n\r\n\
    \x05\x06\0\x02\x05\x04\x12\x04X\x04Z\x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\
    \xca\xbc\"\x12\x04X\x04Z\x06\n\xe5\x02\n\x04\x06\0\x02\x06\x12\x04c\x02h\
    \x03\x1a\xd6\x02\x20Lists\x20the\x20names\x20of\x20the\x20snapshots\x20o\
    n\x20this\x20topic.\x20Snapshots\x20are\x20used\x20in\n\x20<a\x20href=\"\
    https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>\n\x20ope\
    rations,\x20which\x20allow\n\x20you\x20to\x20manage\x20message\x20acknow\
    ledgments\x20in\x20bulk.\x20That\x20is,\x20you\x20can\x20set\x20the\n\
    \x20acknowledgment\x20state\x20of\x20messages\x20in\x20an\x20existing\
    \x20subscription\x20to\x20the\x20state\n\x20captured\x20by\x20a\x20snaps\
    hot.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03c\x06\x18\n\x0c\n\x05\x06\0\
    \x02\x06\x02\x12\x03c\x192\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03d\x0f)\n\
    \r\n\x05\x06\0\x02\x06\x04\x12\x04e\x04g\x06\n\x11\n\t\x06\0\x02\x06\x04\
    \xb0\xca\xbc\"\x12\x04e\x04g\x06\n\xf3\x02\n\x04\x06\0\x02\x07\x12\x04o\
    \x02s\x03\x1a\xe4\x02\x20Deletes\x20the\x20topic\x20with\x20the\x20given\
    \x20name.\x20Returns\x20`NOT_FOUND`\x20if\x20the\x20topic\n\x20does\x20n\
    ot\x20exist.\x20After\x20a\x20topic\x20is\x20deleted,\x20a\x20new\x20top\
    ic\x20may\x20be\x20created\x20with\n\x20the\x20same\x20name;\x20this\x20\
    is\x20an\x20entirely\x20new\x20topic\x20with\x20none\x20of\x20the\x20old\
    \n\x20configuration\x20or\x20subscriptions.\x20Existing\x20subscriptions\
    \x20to\x20this\x20topic\x20are\n\x20not\x20deleted,\x20but\x20their\x20`\
    topic`\x20field\x20is\x20set\x20to\x20`_deleted-topic_`.\n\n\x0c\n\x05\
    \x06\0\x02\x07\x01\x12\x03o\x06\x11\n\x0c\n\x05\x06\0\x02\x07\x02\x12\
    \x03o\x12$\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03o/D\n\r\n\x05\x06\0\x02\
    \x07\x04\x12\x04p\x04r\x06\n\x11\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\
    \x04p\x04r\x06\n\n\n\x02\x04\0\x12\x04v\0}\x01\n\n\n\x03\x04\0\x01\x12\
    \x03v\x08\x1c\n\xf4\x02\n\x04\x04\0\x02\0\x12\x03|\x022\x1a\xe6\x02\x20A\
    \x20list\x20of\x20IDs\x20of\x20GCP\x20regions\x20where\x20messages\x20th\
    at\x20are\x20published\x20to\x20the\x20topic\n\x20may\x20be\x20persisted\
    \x20in\x20storage.\x20Messages\x20published\x20by\x20publishers\x20runni\
    ng\x20in\n\x20non-allowed\x20GCP\x20regions\x20(or\x20running\x20outside\
    \x20of\x20GCP\x20altogether)\x20will\x20be\n\x20routed\x20for\x20storage\
    \x20in\x20one\x20of\x20the\x20allowed\x20regions.\x20An\x20empty\x20list\
    \x20means\x20that\n\x20no\x20regions\x20are\x20allowed,\x20and\x20is\x20\
    not\x20a\x20valid\x20configuration.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\
    \x03|\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03|\x0b\x11\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03|\x12-\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03|01\n!\n\
    \x02\x04\x01\x12\x06\x80\x01\0\x97\x01\x01\x1a\x13\x20A\x20topic\x20reso\
    urce.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x80\x01\x08\r\n\x82\x03\n\x04\
    \x04\x01\x02\0\x12\x04\x87\x01\x02\x12\x1a\xf3\x02\x20The\x20name\x20of\
    \x20the\x20topic.\x20It\x20must\x20have\x20the\x20format\n\x20`\"project\
    s/{project}/topics/{topic}\"`.\x20`{topic}`\x20must\x20start\x20with\x20\
    a\x20letter,\n\x20and\x20contain\x20only\x20letters\x20(`[A-Za-z]`),\x20\
    numbers\x20(`[0-9]`),\x20dashes\x20(`-`),\n\x20underscores\x20(`_`),\x20\
    periods\x20(`.`),\x20tildes\x20(`~`),\x20plus\x20(`+`)\x20or\x20percent\
    \n\x20signs\x20(`%`).\x20It\x20must\x20be\x20between\x203\x20and\x20255\
    \x20characters\x20in\x20length,\x20and\x20it\n\x20must\x20not\x20start\
    \x20with\x20`\"goog\"`.\n\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\x87\x01\
    \x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x87\x01\t\r\n\r\n\x05\x04\
    \x01\x02\0\x03\x12\x04\x87\x01\x10\x11\nm\n\x04\x04\x01\x02\x01\x12\x04\
    \x8b\x01\x02!\x1a_\x20See\x20<a\x20href=\"https://cloud.google.com/pubsu\
    b/docs/labels\">\x20Creating\x20and\n\x20managing\x20labels</a>.\n\n\r\n\
    \x05\x04\x01\x02\x01\x06\x12\x04\x8b\x01\x02\x15\n\r\n\x05\x04\x01\x02\
    \x01\x01\x12\x04\x8b\x01\x16\x1c\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\
    \x8b\x01\x1f\x20\n\xb7\x01\n\x04\x04\x01\x02\x02\x12\x04\x90\x01\x022\
    \x1a\xa8\x01\x20Policy\x20constraining\x20the\x20set\x20of\x20Google\x20\
    Cloud\x20Platform\x20regions\x20where\x20messages\n\x20published\x20to\
    \x20the\x20topic\x20may\x20be\x20stored.\x20If\x20not\x20present,\x20the\
    n\x20no\x20constraints\n\x20are\x20in\x20effect.\n\n\r\n\x05\x04\x01\x02\
    \x02\x06\x12\x04\x90\x01\x02\x16\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\
    \x90\x01\x17-\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\x90\x0101\n\xcb\x01\
    \n\x04\x04\x01\x02\x03\x12\x04\x96\x01\x02\x1a\x1a\xbc\x01\x20The\x20res\
    ource\x20name\x20of\x20the\x20Cloud\x20KMS\x20CryptoKey\x20to\x20be\x20u\
    sed\x20to\x20protect\x20access\n\x20to\x20messages\x20published\x20on\
    \x20this\x20topic.\n\n\x20The\x20expected\x20format\x20is\x20`projects/*\
    /locations/*/keyRings/*/cryptoKeys/*`.\n\n\r\n\x05\x04\x01\x02\x03\x05\
    \x12\x04\x96\x01\x02\x08\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\x96\x01\t\
    \x15\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\x96\x01\x18\x19\n\x8e\x04\n\
    \x02\x04\x02\x12\x06\xa1\x01\0\xbc\x01\x01\x1a\xff\x03\x20A\x20message\
    \x20that\x20is\x20published\x20by\x20publishers\x20and\x20consumed\x20by\
    \x20subscribers.\x20The\n\x20message\x20must\x20contain\x20either\x20a\
    \x20non-empty\x20data\x20field\x20or\x20at\x20least\x20one\x20attribute.\
    \n\x20Note\x20that\x20client\x20libraries\x20represent\x20this\x20object\
    \x20differently\n\x20depending\x20on\x20the\x20language.\x20See\x20the\
    \x20corresponding\n\x20<a\x20href=\"https://cloud.google.com/pubsub/docs\
    /reference/libraries\">client\n\x20library\x20documentation</a>\x20for\
    \x20more\x20information.\x20See\n\x20<a\x20href=\"https://cloud.google.c\
    om/pubsub/quotas\">Quotas\x20and\x20limits</a>\n\x20for\x20more\x20infor\
    mation\x20about\x20message\x20limits.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\
    \xa1\x01\x08\x15\nq\n\x04\x04\x02\x02\0\x12\x04\xa4\x01\x02\x11\x1ac\x20\
    The\x20message\x20data\x20field.\x20If\x20this\x20field\x20is\x20empty,\
    \x20the\x20message\x20must\x20contain\n\x20at\x20least\x20one\x20attribu\
    te.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xa4\x01\x02\x07\n\r\n\x05\x04\
    \x02\x02\0\x01\x12\x04\xa4\x01\x08\x0c\n\r\n\x05\x04\x02\x02\0\x03\x12\
    \x04\xa4\x01\x0f\x10\n5\n\x04\x04\x02\x02\x01\x12\x04\xa7\x01\x02%\x1a'\
    \x20Optional\x20attributes\x20for\x20this\x20message.\n\n\r\n\x05\x04\
    \x02\x02\x01\x06\x12\x04\xa7\x01\x02\x15\n\r\n\x05\x04\x02\x02\x01\x01\
    \x12\x04\xa7\x01\x16\x20\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xa7\x01#$\
    \n\xb3\x02\n\x04\x04\x02\x02\x02\x12\x04\xad\x01\x02\x18\x1a\xa4\x02\x20\
    ID\x20of\x20this\x20message,\x20assigned\x20by\x20the\x20server\x20when\
    \x20the\x20message\x20is\x20published.\n\x20Guaranteed\x20to\x20be\x20un\
    ique\x20within\x20the\x20topic.\x20This\x20value\x20may\x20be\x20read\
    \x20by\x20a\n\x20subscriber\x20that\x20receives\x20a\x20`PubsubMessage`\
    \x20via\x20a\x20`Pull`\x20call\x20or\x20a\x20push\n\x20delivery.\x20It\
    \x20must\x20not\x20be\x20populated\x20by\x20the\x20publisher\x20in\x20a\
    \x20`Publish`\x20call.\n\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\xad\x01\
    \x02\x08\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xad\x01\t\x13\n\r\n\x05\
    \x04\x02\x02\x02\x03\x12\x04\xad\x01\x16\x17\n\xbb\x01\n\x04\x04\x02\x02\
    \x03\x12\x04\xb2\x01\x02-\x1a\xac\x01\x20The\x20time\x20at\x20which\x20t\
    he\x20message\x20was\x20published,\x20populated\x20by\x20the\x20server\
    \x20when\n\x20it\x20receives\x20the\x20`Publish`\x20call.\x20It\x20must\
    \x20not\x20be\x20populated\x20by\x20the\n\x20publisher\x20in\x20a\x20`Pu\
    blish`\x20call.\n\n\r\n\x05\x04\x02\x02\x03\x06\x12\x04\xb2\x01\x02\x1b\
    \n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xb2\x01\x1c(\n\r\n\x05\x04\x02\
    \x02\x03\x03\x12\x04\xb2\x01+,\n\x92\x04\n\x04\x04\x02\x02\x04\x12\x04\
    \xbb\x01\x02\x1a\x1a\x83\x04\x20Identifies\x20related\x20messages\x20for\
    \x20which\x20publish\x20order\x20should\x20be\x20respected.\n\x20If\x20a\
    \x20`Subscription`\x20has\x20`enable_message_ordering`\x20set\x20to\x20`\
    true`,\x20messages\n\x20published\x20with\x20the\x20same\x20`ordering_ke\
    y`\x20value\x20will\x20be\x20delivered\x20to\n\x20subscribers\x20in\x20t\
    he\x20order\x20in\x20which\x20they\x20are\x20received\x20by\x20the\x20Pu\
    b/Sub\x20system.\n\x20<b>EXPERIMENTAL:</b>\x20This\x20feature\x20is\x20p\
    art\x20of\x20a\x20closed\x20alpha\x20release.\x20This\n\x20API\x20might\
    \x20be\x20changed\x20in\x20backward-incompatible\x20ways\x20and\x20is\
    \x20not\x20recommended\n\x20for\x20production\x20use.\x20It\x20is\x20not\
    \x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\r\n\
    \x05\x04\x02\x02\x04\x05\x12\x04\xbb\x01\x02\x08\n\r\n\x05\x04\x02\x02\
    \x04\x01\x12\x04\xbb\x01\t\x15\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xbb\
    \x01\x18\x19\n0\n\x02\x04\x03\x12\x06\xbf\x01\0\xc3\x01\x01\x1a\"\x20Req\
    uest\x20for\x20the\x20GetTopic\x20method.\n\n\x0b\n\x03\x04\x03\x01\x12\
    \x04\xbf\x01\x08\x17\n]\n\x04\x04\x03\x02\0\x12\x04\xc2\x01\x02\x13\x1aO\
    \x20The\x20name\x20of\x20the\x20topic\x20to\x20get.\n\x20Format\x20is\
    \x20`projects/{project}/topics/{topic}`.\n\n\r\n\x05\x04\x03\x02\0\x05\
    \x12\x04\xc2\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xc2\x01\t\
    \x0e\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xc2\x01\x11\x12\n3\n\x02\x04\
    \x04\x12\x06\xc6\x01\0\xd0\x01\x01\x1a%\x20Request\x20for\x20the\x20Upda\
    teTopic\x20method.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xc6\x01\x08\x1a\n)\
    \n\x04\x04\x04\x02\0\x12\x04\xc8\x01\x02\x12\x1a\x1b\x20The\x20updated\
    \x20topic\x20object.\n\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xc8\x01\x02\
    \x07\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xc8\x01\x08\r\n\r\n\x05\x04\x04\
    \x02\0\x03\x12\x04\xc8\x01\x10\x11\n\xe1\x02\n\x04\x04\x04\x02\x01\x12\
    \x04\xcf\x01\x02,\x1a\xd2\x02\x20Indicates\x20which\x20fields\x20in\x20t\
    he\x20provided\x20topic\x20to\x20update.\x20Must\x20be\x20specified\n\
    \x20and\x20non-empty.\x20Note\x20that\x20if\x20`update_mask`\x20contains\
    \n\x20\"message_storage_policy\"\x20then\x20the\x20new\x20value\x20will\
    \x20be\x20determined\x20based\x20on\x20the\n\x20policy\x20configured\x20\
    at\x20the\x20project\x20or\x20organization\x20level.\x20The\n\x20`messag\
    e_storage_policy`\x20must\x20not\x20be\x20set\x20in\x20the\x20`topic`\
    \x20provided\x20above.\n\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\xcf\x01\
    \x02\x1b\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xcf\x01\x1c'\n\r\n\x05\
    \x04\x04\x02\x01\x03\x12\x04\xcf\x01*+\n/\n\x02\x04\x05\x12\x06\xd3\x01\
    \0\xda\x01\x01\x1a!\x20Request\x20for\x20the\x20Publish\x20method.\n\n\
    \x0b\n\x03\x04\x05\x01\x12\x04\xd3\x01\x08\x16\n|\n\x04\x04\x05\x02\0\
    \x12\x04\xd6\x01\x02\x13\x1an\x20The\x20messages\x20in\x20the\x20request\
    \x20will\x20be\x20published\x20on\x20this\x20topic.\n\x20Format\x20is\
    \x20`projects/{project}/topics/{topic}`.\n\n\r\n\x05\x04\x05\x02\0\x05\
    \x12\x04\xd6\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xd6\x01\t\
    \x0e\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xd6\x01\x11\x12\n(\n\x04\x04\
    \x05\x02\x01\x12\x04\xd9\x01\x02&\x1a\x1a\x20The\x20messages\x20to\x20pu\
    blish.\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xd9\x01\x02\n\n\r\n\x05\
    \x04\x05\x02\x01\x06\x12\x04\xd9\x01\x0b\x18\n\r\n\x05\x04\x05\x02\x01\
    \x01\x12\x04\xd9\x01\x19!\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xd9\x01$\
    %\n2\n\x02\x04\x06\x12\x06\xdd\x01\0\xe2\x01\x01\x1a$\x20Response\x20for\
    \x20the\x20`Publish`\x20method.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xdd\
    \x01\x08\x17\n\xa8\x01\n\x04\x04\x06\x02\0\x12\x04\xe1\x01\x02\"\x1a\x99\
    \x01\x20The\x20server-assigned\x20ID\x20of\x20each\x20published\x20messa\
    ge,\x20in\x20the\x20same\x20order\x20as\n\x20the\x20messages\x20in\x20th\
    e\x20request.\x20IDs\x20are\x20guaranteed\x20to\x20be\x20unique\x20withi\
    n\n\x20the\x20topic.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xe1\x01\x02\n\
    \n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xe1\x01\x0b\x11\n\r\n\x05\x04\x06\
    \x02\0\x01\x12\x04\xe1\x01\x12\x1d\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \xe1\x01\x20!\n4\n\x02\x04\x07\x12\x06\xe5\x01\0\xf1\x01\x01\x1a&\x20Req\
    uest\x20for\x20the\x20`ListTopics`\x20method.\n\n\x0b\n\x03\x04\x07\x01\
    \x12\x04\xe5\x01\x08\x19\nd\n\x04\x04\x07\x02\0\x12\x04\xe8\x01\x02\x15\
    \x1aV\x20The\x20name\x20of\x20the\x20project\x20in\x20which\x20to\x20lis\
    t\x20topics.\n\x20Format\x20is\x20`projects/{project-id}`.\n\n\r\n\x05\
    \x04\x07\x02\0\x05\x12\x04\xe8\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\
    \x12\x04\xe8\x01\t\x10\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xe8\x01\x13\
    \x14\n3\n\x04\x04\x07\x02\x01\x12\x04\xeb\x01\x02\x16\x1a%\x20Maximum\
    \x20number\x20of\x20topics\x20to\x20return.\n\n\r\n\x05\x04\x07\x02\x01\
    \x05\x12\x04\xeb\x01\x02\x07\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xeb\
    \x01\x08\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xeb\x01\x14\x15\n\xc4\
    \x01\n\x04\x04\x07\x02\x02\x12\x04\xf0\x01\x02\x18\x1a\xb5\x01\x20The\
    \x20value\x20returned\x20by\x20the\x20last\x20`ListTopicsResponse`;\x20i\
    ndicates\x20that\x20this\x20is\n\x20a\x20continuation\x20of\x20a\x20prio\
    r\x20`ListTopics`\x20call,\x20and\x20that\x20the\x20system\x20should\n\
    \x20return\x20the\x20next\x20page\x20of\x20data.\n\n\r\n\x05\x04\x07\x02\
    \x02\x05\x12\x04\xf0\x01\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\
    \xf0\x01\t\x13\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xf0\x01\x16\x17\n5\
    \n\x02\x04\x08\x12\x06\xf4\x01\0\xfb\x01\x01\x1a'\x20Response\x20for\x20\
    the\x20`ListTopics`\x20method.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xf4\x01\
    \x08\x1a\n%\n\x04\x04\x08\x02\0\x12\x04\xf6\x01\x02\x1c\x1a\x17\x20The\
    \x20resulting\x20topics.\n\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xf6\x01\
    \x02\n\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xf6\x01\x0b\x10\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\xf6\x01\x11\x17\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\xf6\x01\x1a\x1b\n\x99\x01\n\x04\x04\x08\x02\x01\x12\x04\xfa\x01\x02\
    \x1d\x1a\x8a\x01\x20If\x20not\x20empty,\x20indicates\x20that\x20there\
    \x20may\x20be\x20more\x20topics\x20that\x20match\x20the\n\x20request;\
    \x20this\x20value\x20should\x20be\x20passed\x20in\x20a\x20new\x20`ListTo\
    picsRequest`.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xfa\x01\x02\x08\n\
    \r\n\x05\x04\x08\x02\x01\x01\x12\x04\xfa\x01\t\x18\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xfa\x01\x1b\x1c\n@\n\x02\x04\t\x12\x06\xfe\x01\0\x8a\
    \x02\x01\x1a2\x20Request\x20for\x20the\x20`ListTopicSubscriptions`\x20me\
    thod.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xfe\x01\x08%\ny\n\x04\x04\t\x02\0\
    \x12\x04\x81\x02\x02\x13\x1ak\x20The\x20name\x20of\x20the\x20topic\x20th\
    at\x20subscriptions\x20are\x20attached\x20to.\n\x20Format\x20is\x20`proj\
    ects/{project}/topics/{topic}`.\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x81\
    \x02\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x81\x02\t\x0e\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\x81\x02\x11\x12\n?\n\x04\x04\t\x02\x01\x12\x04\
    \x84\x02\x02\x16\x1a1\x20Maximum\x20number\x20of\x20subscription\x20name\
    s\x20to\x20return.\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x84\x02\x02\x07\
    \n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x84\x02\x08\x11\n\r\n\x05\x04\t\x02\
    \x01\x03\x12\x04\x84\x02\x14\x15\n\xdc\x01\n\x04\x04\t\x02\x02\x12\x04\
    \x89\x02\x02\x18\x1a\xcd\x01\x20The\x20value\x20returned\x20by\x20the\
    \x20last\x20`ListTopicSubscriptionsResponse`;\x20indicates\n\x20that\x20\
    this\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20`ListTopicSubscri\
    ptions`\x20call,\x20and\n\x20that\x20the\x20system\x20should\x20return\
    \x20the\x20next\x20page\x20of\x20data.\n\n\r\n\x05\x04\t\x02\x02\x05\x12\
    \x04\x89\x02\x02\x08\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x89\x02\t\x13\n\
    \r\n\x05\x04\t\x02\x02\x03\x12\x04\x89\x02\x16\x17\nA\n\x02\x04\n\x12\
    \x06\x8d\x02\0\x95\x02\x01\x1a3\x20Response\x20for\x20the\x20`ListTopicS\
    ubscriptions`\x20method.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x8d\x02\x08&\nF\
    \n\x04\x04\n\x02\0\x12\x04\x8f\x02\x02$\x1a8\x20The\x20names\x20of\x20th\
    e\x20subscriptions\x20that\x20match\x20the\x20request.\n\n\r\n\x05\x04\n\
    \x02\0\x04\x12\x04\x8f\x02\x02\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x8f\
    \x02\x0b\x11\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x8f\x02\x12\x1f\n\r\n\x05\
    \x04\n\x02\0\x03\x12\x04\x8f\x02\"#\n\xc7\x01\n\x04\x04\n\x02\x01\x12\
    \x04\x94\x02\x02\x1d\x1a\xb8\x01\x20If\x20not\x20empty,\x20indicates\x20\
    that\x20there\x20may\x20be\x20more\x20subscriptions\x20that\x20match\n\
    \x20the\x20request;\x20this\x20value\x20should\x20be\x20passed\x20in\x20\
    a\x20new\n\x20`ListTopicSubscriptionsRequest`\x20to\x20get\x20more\x20su\
    bscriptions.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x94\x02\x02\x08\n\r\n\
    \x05\x04\n\x02\x01\x01\x12\x04\x94\x02\t\x18\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\x94\x02\x1b\x1c\n<\n\x02\x04\x0b\x12\x06\x98\x02\0\xa4\x02\x01\
    \x1a.\x20Request\x20for\x20the\x20`ListTopicSnapshots`\x20method.\n\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\x98\x02\x08!\nu\n\x04\x04\x0b\x02\0\x12\
    \x04\x9b\x02\x02\x13\x1ag\x20The\x20name\x20of\x20the\x20topic\x20that\
    \x20snapshots\x20are\x20attached\x20to.\n\x20Format\x20is\x20`projects/{\
    project}/topics/{topic}`.\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x9b\x02\
    \x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9b\x02\t\x0e\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\x9b\x02\x11\x12\n;\n\x04\x04\x0b\x02\x01\x12\x04\
    \x9e\x02\x02\x16\x1a-\x20Maximum\x20number\x20of\x20snapshot\x20names\
    \x20to\x20return.\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x9e\x02\x02\
    \x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x9e\x02\x08\x11\n\r\n\x05\x04\
    \x0b\x02\x01\x03\x12\x04\x9e\x02\x14\x15\n\xd4\x01\n\x04\x04\x0b\x02\x02\
    \x12\x04\xa3\x02\x02\x18\x1a\xc5\x01\x20The\x20value\x20returned\x20by\
    \x20the\x20last\x20`ListTopicSnapshotsResponse`;\x20indicates\n\x20that\
    \x20this\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20`ListTopicSna\
    pshots`\x20call,\x20and\n\x20that\x20the\x20system\x20should\x20return\
    \x20the\x20next\x20page\x20of\x20data.\n\n\r\n\x05\x04\x0b\x02\x02\x05\
    \x12\x04\xa3\x02\x02\x08\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xa3\x02\t\
    \x13\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xa3\x02\x16\x17\n=\n\x02\x04\
    \x0c\x12\x06\xa7\x02\0\xaf\x02\x01\x1a/\x20Response\x20for\x20the\x20`Li\
    stTopicSnapshots`\x20method.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa7\x02\
    \x08\"\nB\n\x04\x04\x0c\x02\0\x12\x04\xa9\x02\x02\x20\x1a4\x20The\x20nam\
    es\x20of\x20the\x20snapshots\x20that\x20match\x20the\x20request.\n\n\r\n\
    \x05\x04\x0c\x02\0\x04\x12\x04\xa9\x02\x02\n\n\r\n\x05\x04\x0c\x02\0\x05\
    \x12\x04\xa9\x02\x0b\x11\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa9\x02\x12\
    \x1b\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa9\x02\x1e\x1f\n\xbb\x01\n\x04\
    \x04\x0c\x02\x01\x12\x04\xae\x02\x02\x1d\x1a\xac\x01\x20If\x20not\x20emp\
    ty,\x20indicates\x20that\x20there\x20may\x20be\x20more\x20snapshots\x20t\
    hat\x20match\n\x20the\x20request;\x20this\x20value\x20should\x20be\x20pa\
    ssed\x20in\x20a\x20new\n\x20`ListTopicSnapshotsRequest`\x20to\x20get\x20\
    more\x20snapshots.\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xae\x02\x02\
    \x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xae\x02\t\x18\n\r\n\x05\x04\
    \x0c\x02\x01\x03\x12\x04\xae\x02\x1b\x1c\n5\n\x02\x04\r\x12\x06\xb2\x02\
    \0\xb6\x02\x01\x1a'\x20Request\x20for\x20the\x20`DeleteTopic`\x20method.\
    \n\n\x0b\n\x03\x04\r\x01\x12\x04\xb2\x02\x08\x1a\n\\\n\x04\x04\r\x02\0\
    \x12\x04\xb5\x02\x02\x13\x1aN\x20Name\x20of\x20the\x20topic\x20to\x20del\
    ete.\n\x20Format\x20is\x20`projects/{project}/topics/{topic}`.\n\n\r\n\
    \x05\x04\r\x02\0\x05\x12\x04\xb5\x02\x02\x08\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xb5\x02\t\x0e\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb5\x02\x11\x12\
    \n\xe2\x01\n\x02\x06\x01\x12\x06\xbb\x02\0\x91\x04\x01\x1a\xd3\x01\x20Th\
    e\x20service\x20that\x20an\x20application\x20uses\x20to\x20manipulate\
    \x20subscriptions\x20and\x20to\n\x20consume\x20messages\x20from\x20a\x20\
    subscription\x20via\x20the\x20`Pull`\x20method\x20or\x20by\n\x20establis\
    hing\x20a\x20bi-directional\x20stream\x20using\x20the\x20`StreamingPull`\
    \x20method.\n\n\x0b\n\x03\x06\x01\x01\x12\x04\xbb\x02\x08\x12\n\x0b\n\
    \x03\x06\x01\x03\x12\x04\xbc\x02\x02=\n\r\n\x05\x06\x01\x03\x99\x08\x12\
    \x04\xbc\x02\x02=\n\r\n\x03\x06\x01\x03\x12\x06\xbd\x02\x02\xbf\x02/\n\
    \x0f\n\x05\x06\x01\x03\x9a\x08\x12\x06\xbd\x02\x02\xbf\x02/\n\xa6\x05\n\
    \x04\x06\x01\x02\0\x12\x06\xce\x02\x02\xd3\x02\x03\x1a\x95\x05\x20Create\
    s\x20a\x20subscription\x20to\x20a\x20given\x20topic.\x20See\x20the\n\x20\
    <a\x20href=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"\
    >\n\x20resource\x20name\x20rules</a>.\n\x20If\x20the\x20subscription\x20\
    already\x20exists,\x20returns\x20`ALREADY_EXISTS`.\n\x20If\x20the\x20cor\
    responding\x20topic\x20doesn't\x20exist,\x20returns\x20`NOT_FOUND`.\n\n\
    \x20If\x20the\x20name\x20is\x20not\x20provided\x20in\x20the\x20request,\
    \x20the\x20server\x20will\x20assign\x20a\x20random\n\x20name\x20for\x20t\
    his\x20subscription\x20on\x20the\x20same\x20project\x20as\x20the\x20topi\
    c,\x20conforming\n\x20to\x20the\n\x20[resource\x20name\n\x20format](http\
    s://cloud.google.com/pubsub/docs/admin#resource_names).\x20The\n\x20gene\
    rated\x20name\x20is\x20populated\x20in\x20the\x20returned\x20Subscriptio\
    n\x20object.\x20Note\x20that\n\x20for\x20REST\x20API\x20requests,\x20you\
    \x20must\x20specify\x20a\x20name\x20in\x20the\x20request.\n\n\r\n\x05\
    \x06\x01\x02\0\x01\x12\x04\xce\x02\x06\x18\n\r\n\x05\x06\x01\x02\0\x02\
    \x12\x04\xce\x02\x19%\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\xce\x020<\n\
    \x0f\n\x05\x06\x01\x02\0\x04\x12\x06\xcf\x02\x04\xd2\x02\x06\n\x13\n\t\
    \x06\x01\x02\0\x04\xb0\xca\xbc\"\x12\x06\xcf\x02\x04\xd2\x02\x06\nC\n\
    \x04\x06\x01\x02\x01\x12\x06\xd6\x02\x02\xda\x02\x03\x1a3\x20Gets\x20the\
    \x20configuration\x20details\x20of\x20a\x20subscription.\n\n\r\n\x05\x06\
    \x01\x02\x01\x01\x12\x04\xd6\x02\x06\x15\n\r\n\x05\x06\x01\x02\x01\x02\
    \x12\x04\xd6\x02\x16,\n\r\n\x05\x06\x01\x02\x01\x03\x12\x04\xd6\x027C\n\
    \x0f\n\x05\x06\x01\x02\x01\x04\x12\x06\xd7\x02\x04\xd9\x02\x06\n\x13\n\t\
    \x06\x01\x02\x01\x04\xb0\xca\xbc\"\x12\x06\xd7\x02\x04\xd9\x02\x06\n\x8b\
    \x01\n\x04\x06\x01\x02\x02\x12\x06\xde\x02\x02\xe3\x02\x03\x1a{\x20Updat\
    es\x20an\x20existing\x20subscription.\x20Note\x20that\x20certain\x20prop\
    erties\x20of\x20a\n\x20subscription,\x20such\x20as\x20its\x20topic,\x20a\
    re\x20not\x20modifiable.\n\n\r\n\x05\x06\x01\x02\x02\x01\x12\x04\xde\x02\
    \x06\x18\n\r\n\x05\x06\x01\x02\x02\x02\x12\x04\xde\x02\x192\n\r\n\x05\
    \x06\x01\x02\x02\x03\x12\x04\xde\x02=I\n\x0f\n\x05\x06\x01\x02\x02\x04\
    \x12\x06\xdf\x02\x04\xe2\x02\x06\n\x13\n\t\x06\x01\x02\x02\x04\xb0\xca\
    \xbc\"\x12\x06\xdf\x02\x04\xe2\x02\x06\n/\n\x04\x06\x01\x02\x03\x12\x06\
    \xe6\x02\x02\xeb\x02\x03\x1a\x1f\x20Lists\x20matching\x20subscriptions.\
    \n\n\r\n\x05\x06\x01\x02\x03\x01\x12\x04\xe6\x02\x06\x17\n\r\n\x05\x06\
    \x01\x02\x03\x02\x12\x04\xe6\x02\x180\n\r\n\x05\x06\x01\x02\x03\x03\x12\
    \x04\xe7\x02\x0f(\n\x0f\n\x05\x06\x01\x02\x03\x04\x12\x06\xe8\x02\x04\
    \xea\x02\x06\n\x13\n\t\x06\x01\x02\x03\x04\xb0\xca\xbc\"\x12\x06\xe8\x02\
    \x04\xea\x02\x06\n\xef\x02\n\x04\x06\x01\x02\x04\x12\x06\xf2\x02\x02\xf7\
    \x02\x03\x1a\xde\x02\x20Deletes\x20an\x20existing\x20subscription.\x20Al\
    l\x20messages\x20retained\x20in\x20the\x20subscription\n\x20are\x20immed\
    iately\x20dropped.\x20Calls\x20to\x20`Pull`\x20after\x20deletion\x20will\
    \x20return\n\x20`NOT_FOUND`.\x20After\x20a\x20subscription\x20is\x20dele\
    ted,\x20a\x20new\x20one\x20may\x20be\x20created\x20with\n\x20the\x20same\
    \x20name,\x20but\x20the\x20new\x20one\x20has\x20no\x20association\x20wit\
    h\x20the\x20old\n\x20subscription\x20or\x20its\x20topic\x20unless\x20the\
    \x20same\x20topic\x20is\x20specified.\n\n\r\n\x05\x06\x01\x02\x04\x01\
    \x12\x04\xf2\x02\x06\x18\n\r\n\x05\x06\x01\x02\x04\x02\x12\x04\xf2\x02\
    \x192\n\r\n\x05\x06\x01\x02\x04\x03\x12\x04\xf3\x02\x0f$\n\x0f\n\x05\x06\
    \x01\x02\x04\x04\x12\x06\xf4\x02\x04\xf6\x02\x06\n\x13\n\t\x06\x01\x02\
    \x04\x04\xb0\xca\xbc\"\x12\x06\xf4\x02\x04\xf6\x02\x06\n\xe7\x02\n\x04\
    \x06\x01\x02\x05\x12\x06\xfe\x02\x02\x84\x03\x03\x1a\xd6\x02\x20Modifies\
    \x20the\x20ack\x20deadline\x20for\x20a\x20specific\x20message.\x20This\
    \x20method\x20is\x20useful\n\x20to\x20indicate\x20that\x20more\x20time\
    \x20is\x20needed\x20to\x20process\x20a\x20message\x20by\x20the\n\x20subs\
    criber,\x20or\x20to\x20make\x20the\x20message\x20available\x20for\x20red\
    elivery\x20if\x20the\n\x20processing\x20was\x20interrupted.\x20Note\x20t\
    hat\x20this\x20does\x20not\x20modify\x20the\n\x20subscription-level\x20`\
    ackDeadlineSeconds`\x20used\x20for\x20subsequent\x20messages.\n\n\r\n\
    \x05\x06\x01\x02\x05\x01\x12\x04\xfe\x02\x06\x17\n\r\n\x05\x06\x01\x02\
    \x05\x02\x12\x04\xfe\x02\x180\n\r\n\x05\x06\x01\x02\x05\x03\x12\x04\xff\
    \x02\x0f$\n\x0f\n\x05\x06\x01\x02\x05\x04\x12\x06\x80\x03\x04\x83\x03\
    \x06\n\x13\n\t\x06\x01\x02\x05\x04\xb0\xca\xbc\"\x12\x06\x80\x03\x04\x83\
    \x03\x06\n\xed\x02\n\x04\x06\x01\x02\x06\x12\x06\x8d\x03\x02\x92\x03\x03\
    \x1a\xdc\x02\x20Acknowledges\x20the\x20messages\x20associated\x20with\
    \x20the\x20`ack_ids`\x20in\x20the\n\x20`AcknowledgeRequest`.\x20The\x20P\
    ub/Sub\x20system\x20can\x20remove\x20the\x20relevant\x20messages\n\x20fr\
    om\x20the\x20subscription.\n\n\x20Acknowledging\x20a\x20message\x20whose\
    \x20ack\x20deadline\x20has\x20expired\x20may\x20succeed,\n\x20but\x20suc\
    h\x20a\x20message\x20may\x20be\x20redelivered\x20later.\x20Acknowledging\
    \x20a\x20message\x20more\n\x20than\x20once\x20will\x20not\x20result\x20i\
    n\x20an\x20error.\n\n\r\n\x05\x06\x01\x02\x06\x01\x12\x04\x8d\x03\x06\
    \x11\n\r\n\x05\x06\x01\x02\x06\x02\x12\x04\x8d\x03\x12$\n\r\n\x05\x06\
    \x01\x02\x06\x03\x12\x04\x8d\x03/D\n\x0f\n\x05\x06\x01\x02\x06\x04\x12\
    \x06\x8e\x03\x04\x91\x03\x06\n\x13\n\t\x06\x01\x02\x06\x04\xb0\xca\xbc\"\
    \x12\x06\x8e\x03\x04\x91\x03\x06\n\xab\x01\n\x04\x06\x01\x02\x07\x12\x06\
    \x97\x03\x02\x9c\x03\x03\x1a\x9a\x01\x20Pulls\x20messages\x20from\x20the\
    \x20server.\x20The\x20server\x20may\x20return\x20`UNAVAILABLE`\x20if\n\
    \x20there\x20are\x20too\x20many\x20concurrent\x20pull\x20requests\x20pen\
    ding\x20for\x20the\x20given\n\x20subscription.\n\n\r\n\x05\x06\x01\x02\
    \x07\x01\x12\x04\x97\x03\x06\n\n\r\n\x05\x06\x01\x02\x07\x02\x12\x04\x97\
    \x03\x0b\x16\n\r\n\x05\x06\x01\x02\x07\x03\x12\x04\x97\x03!-\n\x0f\n\x05\
    \x06\x01\x02\x07\x04\x12\x06\x98\x03\x04\x9b\x03\x06\n\x13\n\t\x06\x01\
    \x02\x07\x04\xb0\xca\xbc\"\x12\x06\x98\x03\x04\x9b\x03\x06\n\xe2\x03\n\
    \x04\x06\x01\x02\x08\x12\x06\xa5\x03\x02\xa6\x03/\x1a\xd1\x03\x20Establi\
    shes\x20a\x20stream\x20with\x20the\x20server,\x20which\x20sends\x20messa\
    ges\x20down\x20to\x20the\n\x20client.\x20The\x20client\x20streams\x20ack\
    nowledgements\x20and\x20ack\x20deadline\x20modifications\n\x20back\x20to\
    \x20the\x20server.\x20The\x20server\x20will\x20close\x20the\x20stream\
    \x20and\x20return\x20the\x20status\n\x20on\x20any\x20error.\x20The\x20se\
    rver\x20may\x20close\x20the\x20stream\x20with\x20status\x20`UNAVAILABLE`\
    \x20to\n\x20reassign\x20server-side\x20resources,\x20in\x20which\x20case\
    ,\x20the\x20client\x20should\n\x20re-establish\x20the\x20stream.\x20Flow\
    \x20control\x20can\x20be\x20achieved\x20by\x20configuring\x20the\n\x20un\
    derlying\x20RPC\x20channel.\n\n\r\n\x05\x06\x01\x02\x08\x01\x12\x04\xa5\
    \x03\x06\x13\n\r\n\x05\x06\x01\x02\x08\x05\x12\x04\xa5\x03\x14\x1a\n\r\n\
    \x05\x06\x01\x02\x08\x02\x12\x04\xa5\x03\x1b/\n\r\n\x05\x06\x01\x02\x08\
    \x06\x12\x04\xa6\x03\x0f\x15\n\r\n\x05\x06\x01\x02\x08\x03\x12\x04\xa6\
    \x03\x16+\n\xf7\x02\n\x04\x06\x01\x02\t\x12\x06\xae\x03\x02\xb4\x03\x03\
    \x1a\xe6\x02\x20Modifies\x20the\x20`PushConfig`\x20for\x20a\x20specified\
    \x20subscription.\n\n\x20This\x20may\x20be\x20used\x20to\x20change\x20a\
    \x20push\x20subscription\x20to\x20a\x20pull\x20one\x20(signified\x20by\n\
    \x20an\x20empty\x20`PushConfig`)\x20or\x20vice\x20versa,\x20or\x20change\
    \x20the\x20endpoint\x20URL\x20and\x20other\n\x20attributes\x20of\x20a\
    \x20push\x20subscription.\x20Messages\x20will\x20accumulate\x20for\x20de\
    livery\n\x20continuously\x20through\x20the\x20call\x20regardless\x20of\
    \x20changes\x20to\x20the\x20`PushConfig`.\n\n\r\n\x05\x06\x01\x02\t\x01\
    \x12\x04\xae\x03\x06\x16\n\r\n\x05\x06\x01\x02\t\x02\x12\x04\xae\x03\x17\
    .\n\r\n\x05\x06\x01\x02\t\x03\x12\x04\xaf\x03\x0f$\n\x0f\n\x05\x06\x01\
    \x02\t\x04\x12\x06\xb0\x03\x04\xb3\x03\x06\n\x13\n\t\x06\x01\x02\t\x04\
    \xb0\xca\xbc\"\x12\x06\xb0\x03\x04\xb3\x03\x06\n\xe4\x02\n\x04\x06\x01\
    \x02\n\x12\x06\xbb\x03\x02\xbf\x03\x03\x1a\xd3\x02\x20Gets\x20the\x20con\
    figuration\x20details\x20of\x20a\x20snapshot.\x20Snapshots\x20are\x20use\
    d\x20in\n\x20<a\x20href=\"https://cloud.google.com/pubsub/docs/replay-ov\
    erview\">Seek</a>\n\x20operations,\x20which\x20allow\x20you\x20to\x20man\
    age\x20message\x20acknowledgments\x20in\x20bulk.\x20That\n\x20is,\x20you\
    \x20can\x20set\x20the\x20acknowledgment\x20state\x20of\x20messages\x20in\
    \x20an\x20existing\n\x20subscription\x20to\x20the\x20state\x20captured\
    \x20by\x20a\x20snapshot.\n\n\r\n\x05\x06\x01\x02\n\x01\x12\x04\xbb\x03\
    \x06\x11\n\r\n\x05\x06\x01\x02\n\x02\x12\x04\xbb\x03\x12$\n\r\n\x05\x06\
    \x01\x02\n\x03\x12\x04\xbb\x03/7\n\x0f\n\x05\x06\x01\x02\n\x04\x12\x06\
    \xbc\x03\x04\xbe\x03\x06\n\x13\n\t\x06\x01\x02\n\x04\xb0\xca\xbc\"\x12\
    \x06\xbc\x03\x04\xbe\x03\x06\n\xd5\x02\n\x04\x06\x01\x02\x0b\x12\x06\xc7\
    \x03\x02\xcb\x03\x03\x1a\xc4\x02\x20Lists\x20the\x20existing\x20snapshot\
    s.\x20Snapshots\x20are\x20used\x20in\n\x20<a\x20href=\"https://cloud.goo\
    gle.com/pubsub/docs/replay-overview\">Seek</a>\n\x20operations,\x20which\
    \x20allow\n\x20you\x20to\x20manage\x20message\x20acknowledgments\x20in\
    \x20bulk.\x20That\x20is,\x20you\x20can\x20set\x20the\n\x20acknowledgment\
    \x20state\x20of\x20messages\x20in\x20an\x20existing\x20subscription\x20t\
    o\x20the\x20state\n\x20captured\x20by\x20a\x20snapshot.\n\n\r\n\x05\x06\
    \x01\x02\x0b\x01\x12\x04\xc7\x03\x06\x13\n\r\n\x05\x06\x01\x02\x0b\x02\
    \x12\x04\xc7\x03\x14(\n\r\n\x05\x06\x01\x02\x0b\x03\x12\x04\xc7\x033H\n\
    \x0f\n\x05\x06\x01\x02\x0b\x04\x12\x06\xc8\x03\x04\xca\x03\x06\n\x13\n\t\
    \x06\x01\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xc8\x03\x04\xca\x03\x06\n\xb9\
    \x08\n\x04\x06\x01\x02\x0c\x12\x06\xdf\x03\x02\xe4\x03\x03\x1a\xa8\x08\
    \x20Creates\x20a\x20snapshot\x20from\x20the\x20requested\x20subscription\
    .\x20Snapshots\x20are\x20used\x20in\n\x20<a\x20href=\"https://cloud.goog\
    le.com/pubsub/docs/replay-overview\">Seek</a>\n\x20operations,\x20which\
    \x20allow\n\x20you\x20to\x20manage\x20message\x20acknowledgments\x20in\
    \x20bulk.\x20That\x20is,\x20you\x20can\x20set\x20the\n\x20acknowledgment\
    \x20state\x20of\x20messages\x20in\x20an\x20existing\x20subscription\x20t\
    o\x20the\x20state\n\x20captured\x20by\x20a\x20snapshot.\n\x20<br><br>If\
    \x20the\x20snapshot\x20already\x20exists,\x20returns\x20`ALREADY_EXISTS`\
    .\n\x20If\x20the\x20requested\x20subscription\x20doesn't\x20exist,\x20re\
    turns\x20`NOT_FOUND`.\n\x20If\x20the\x20backlog\x20in\x20the\x20subscrip\
    tion\x20is\x20too\x20old\x20--\x20and\x20the\x20resulting\x20snapshot\n\
    \x20would\x20expire\x20in\x20less\x20than\x201\x20hour\x20--\x20then\x20\
    `FAILED_PRECONDITION`\x20is\x20returned.\n\x20See\x20also\x20the\x20`Sna\
    pshot.expire_time`\x20field.\x20If\x20the\x20name\x20is\x20not\x20provid\
    ed\x20in\n\x20the\x20request,\x20the\x20server\x20will\x20assign\x20a\
    \x20random\n\x20name\x20for\x20this\x20snapshot\x20on\x20the\x20same\x20\
    project\x20as\x20the\x20subscription,\x20conforming\n\x20to\x20the\n\x20\
    [resource\x20name\n\x20format](https://cloud.google.com/pubsub/docs/admi\
    n#resource_names).\x20The\n\x20generated\x20name\x20is\x20populated\x20i\
    n\x20the\x20returned\x20Snapshot\x20object.\x20Note\x20that\x20for\n\x20\
    REST\x20API\x20requests,\x20you\x20must\x20specify\x20a\x20name\x20in\
    \x20the\x20request.\n\n\r\n\x05\x06\x01\x02\x0c\x01\x12\x04\xdf\x03\x06\
    \x14\n\r\n\x05\x06\x01\x02\x0c\x02\x12\x04\xdf\x03\x15*\n\r\n\x05\x06\
    \x01\x02\x0c\x03\x12\x04\xdf\x035=\n\x0f\n\x05\x06\x01\x02\x0c\x04\x12\
    \x06\xe0\x03\x04\xe3\x03\x06\n\x13\n\t\x06\x01\x02\x0c\x04\xb0\xca\xbc\"\
    \x12\x06\xe0\x03\x04\xe3\x03\x06\n\xd5\x02\n\x04\x06\x01\x02\r\x12\x06\
    \xec\x03\x02\xf1\x03\x03\x1a\xc4\x02\x20Updates\x20an\x20existing\x20sna\
    pshot.\x20Snapshots\x20are\x20used\x20in\n\x20<a\x20href=\"https://cloud\
    .google.com/pubsub/docs/replay-overview\">Seek</a>\n\x20operations,\x20w\
    hich\x20allow\n\x20you\x20to\x20manage\x20message\x20acknowledgments\x20\
    in\x20bulk.\x20That\x20is,\x20you\x20can\x20set\x20the\n\x20acknowledgme\
    nt\x20state\x20of\x20messages\x20in\x20an\x20existing\x20subscription\
    \x20to\x20the\x20state\n\x20captured\x20by\x20a\x20snapshot.\n\n\r\n\x05\
    \x06\x01\x02\r\x01\x12\x04\xec\x03\x06\x14\n\r\n\x05\x06\x01\x02\r\x02\
    \x12\x04\xec\x03\x15*\n\r\n\x05\x06\x01\x02\r\x03\x12\x04\xec\x035=\n\
    \x0f\n\x05\x06\x01\x02\r\x04\x12\x06\xed\x03\x04\xf0\x03\x06\n\x13\n\t\
    \x06\x01\x02\r\x04\xb0\xca\xbc\"\x12\x06\xed\x03\x04\xf0\x03\x06\n\x81\
    \x05\n\x04\x06\x01\x02\x0e\x12\x06\xfd\x03\x02\x81\x04\x03\x1a\xf0\x04\
    \x20Removes\x20an\x20existing\x20snapshot.\x20Snapshots\x20are\x20used\
    \x20in\n\x20<a\x20href=\"https://cloud.google.com/pubsub/docs/replay-ove\
    rview\">Seek</a>\n\x20operations,\x20which\x20allow\n\x20you\x20to\x20ma\
    nage\x20message\x20acknowledgments\x20in\x20bulk.\x20That\x20is,\x20you\
    \x20can\x20set\x20the\n\x20acknowledgment\x20state\x20of\x20messages\x20\
    in\x20an\x20existing\x20subscription\x20to\x20the\x20state\n\x20captured\
    \x20by\x20a\x20snapshot.<br><br>\n\x20When\x20the\x20snapshot\x20is\x20d\
    eleted,\x20all\x20messages\x20retained\x20in\x20the\x20snapshot\n\x20are\
    \x20immediately\x20dropped.\x20After\x20a\x20snapshot\x20is\x20deleted,\
    \x20a\x20new\x20one\x20may\x20be\n\x20created\x20with\x20the\x20same\x20\
    name,\x20but\x20the\x20new\x20one\x20has\x20no\x20association\x20with\
    \x20the\x20old\n\x20snapshot\x20or\x20its\x20subscription,\x20unless\x20\
    the\x20same\x20subscription\x20is\x20specified.\n\n\r\n\x05\x06\x01\x02\
    \x0e\x01\x12\x04\xfd\x03\x06\x14\n\r\n\x05\x06\x01\x02\x0e\x02\x12\x04\
    \xfd\x03\x15*\n\r\n\x05\x06\x01\x02\x0e\x03\x12\x04\xfd\x035J\n\x0f\n\
    \x05\x06\x01\x02\x0e\x04\x12\x06\xfe\x03\x04\x80\x04\x06\n\x13\n\t\x06\
    \x01\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\xfe\x03\x04\x80\x04\x06\n\xf5\x03\
    \n\x04\x06\x01\x02\x0f\x12\x06\x8b\x04\x02\x90\x04\x03\x1a\xe4\x03\x20Se\
    eks\x20an\x20existing\x20subscription\x20to\x20a\x20point\x20in\x20time\
    \x20or\x20to\x20a\x20given\x20snapshot,\n\x20whichever\x20is\x20provided\
    \x20in\x20the\x20request.\x20Snapshots\x20are\x20used\x20in\n\x20<a\x20h\
    ref=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>\n\
    \x20operations,\x20which\x20allow\n\x20you\x20to\x20manage\x20message\
    \x20acknowledgments\x20in\x20bulk.\x20That\x20is,\x20you\x20can\x20set\
    \x20the\n\x20acknowledgment\x20state\x20of\x20messages\x20in\x20an\x20ex\
    isting\x20subscription\x20to\x20the\x20state\n\x20captured\x20by\x20a\
    \x20snapshot.\x20Note\x20that\x20both\x20the\x20subscription\x20and\x20t\
    he\x20snapshot\n\x20must\x20be\x20on\x20the\x20same\x20topic.\n\n\r\n\
    \x05\x06\x01\x02\x0f\x01\x12\x04\x8b\x04\x06\n\n\r\n\x05\x06\x01\x02\x0f\
    \x02\x12\x04\x8b\x04\x0b\x16\n\r\n\x05\x06\x01\x02\x0f\x03\x12\x04\x8b\
    \x04!-\n\x0f\n\x05\x06\x01\x02\x0f\x04\x12\x06\x8c\x04\x04\x8f\x04\x06\n\
    \x13\n\t\x06\x01\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\x8c\x04\x04\x8f\x04\
    \x06\n(\n\x02\x04\x0e\x12\x06\x94\x04\0\xf0\x04\x01\x1a\x1a\x20A\x20subs\
    cription\x20resource.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x94\x04\x08\x14\
    \n\x9e\x03\n\x04\x04\x0e\x02\0\x12\x04\x9b\x04\x02\x12\x1a\x8f\x03\x20Th\
    e\x20name\x20of\x20the\x20subscription.\x20It\x20must\x20have\x20the\x20\
    format\n\x20`\"projects/{project}/subscriptions/{subscription}\"`.\x20`{\
    subscription}`\x20must\n\x20start\x20with\x20a\x20letter,\x20and\x20cont\
    ain\x20only\x20letters\x20(`[A-Za-z]`),\x20numbers\n\x20(`[0-9]`),\x20da\
    shes\x20(`-`),\x20underscores\x20(`_`),\x20periods\x20(`.`),\x20tildes\
    \x20(`~`),\n\x20plus\x20(`+`)\x20or\x20percent\x20signs\x20(`%`).\x20It\
    \x20must\x20be\x20between\x203\x20and\x20255\x20characters\n\x20in\x20le\
    ngth,\x20and\x20it\x20must\x20not\x20start\x20with\x20`\"goog\"`.\n\n\r\
    \n\x05\x04\x0e\x02\0\x05\x12\x04\x9b\x04\x02\x08\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\x9b\x04\t\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9b\x04\x10\
    \x11\n\xdd\x01\n\x04\x04\x0e\x02\x01\x12\x04\xa1\x04\x02\x13\x1a\xce\x01\
    \x20The\x20name\x20of\x20the\x20topic\x20from\x20which\x20this\x20subscr\
    iption\x20is\x20receiving\x20messages.\n\x20Format\x20is\x20`projects/{p\
    roject}/topics/{topic}`.\n\x20The\x20value\x20of\x20this\x20field\x20wil\
    l\x20be\x20`_deleted-topic_`\x20if\x20the\x20topic\x20has\x20been\n\x20d\
    eleted.\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xa1\x04\x02\x08\n\r\n\
    \x05\x04\x0e\x02\x01\x01\x12\x04\xa1\x04\t\x0e\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\xa1\x04\x11\x12\n\xc9\x01\n\x04\x04\x0e\x02\x02\x12\x04\xa6\
    \x04\x02\x1d\x1a\xba\x01\x20If\x20push\x20delivery\x20is\x20used\x20with\
    \x20this\x20subscription,\x20this\x20field\x20is\n\x20used\x20to\x20conf\
    igure\x20it.\x20An\x20empty\x20`pushConfig`\x20signifies\x20that\x20the\
    \x20subscriber\n\x20will\x20pull\x20and\x20ack\x20messages\x20using\x20A\
    PI\x20methods.\n\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\xa6\x04\x02\x0c\n\
    \r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa6\x04\r\x18\n\r\n\x05\x04\x0e\x02\
    \x02\x03\x12\x04\xa6\x04\x1b\x1c\n\xc7\x08\n\x04\x04\x0e\x02\x03\x12\x04\
    \xbc\x04\x02!\x1a\xb8\x08\x20The\x20approximate\x20amount\x20of\x20time\
    \x20(on\x20a\x20best-effort\x20basis)\x20Pub/Sub\x20waits\x20for\n\x20th\
    e\x20subscriber\x20to\x20acknowledge\x20receipt\x20before\x20resending\
    \x20the\x20message.\x20In\x20the\n\x20interval\x20after\x20the\x20messag\
    e\x20is\x20delivered\x20and\x20before\x20it\x20is\x20acknowledged,\x20it\
    \n\x20is\x20considered\x20to\x20be\x20<i>outstanding</i>.\x20During\x20t\
    hat\x20time\x20period,\x20the\n\x20message\x20will\x20not\x20be\x20redel\
    ivered\x20(on\x20a\x20best-effort\x20basis).\n\n\x20For\x20pull\x20subsc\
    riptions,\x20this\x20value\x20is\x20used\x20as\x20the\x20initial\x20valu\
    e\x20for\x20the\x20ack\n\x20deadline.\x20To\x20override\x20this\x20value\
    \x20for\x20a\x20given\x20message,\x20call\n\x20`ModifyAckDeadline`\x20wi\
    th\x20the\x20corresponding\x20`ack_id`\x20if\x20using\n\x20non-streaming\
    \x20pull\x20or\x20send\x20the\x20`ack_id`\x20in\x20a\n\x20`StreamingModi\
    fyAckDeadlineRequest`\x20if\x20using\x20streaming\x20pull.\n\x20The\x20m\
    inimum\x20custom\x20deadline\x20you\x20can\x20specify\x20is\x2010\x20sec\
    onds.\n\x20The\x20maximum\x20custom\x20deadline\x20you\x20can\x20specify\
    \x20is\x20600\x20seconds\x20(10\x20minutes).\n\x20If\x20this\x20paramete\
    r\x20is\x200,\x20a\x20default\x20value\x20of\x2010\x20seconds\x20is\x20u\
    sed.\n\n\x20For\x20push\x20delivery,\x20this\x20value\x20is\x20also\x20u\
    sed\x20to\x20set\x20the\x20request\x20timeout\x20for\n\x20the\x20call\
    \x20to\x20the\x20push\x20endpoint.\n\n\x20If\x20the\x20subscriber\x20nev\
    er\x20acknowledges\x20the\x20message,\x20the\x20Pub/Sub\n\x20system\x20w\
    ill\x20eventually\x20redeliver\x20the\x20message.\n\n\r\n\x05\x04\x0e\
    \x02\x03\x05\x12\x04\xbc\x04\x02\x07\n\r\n\x05\x04\x0e\x02\x03\x01\x12\
    \x04\xbc\x04\x08\x1c\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xbc\x04\x1f\
    \x20\n\x80\x03\n\x04\x04\x0e\x02\x04\x12\x04\xc5\x04\x02!\x1a\xf1\x02\
    \x20Indicates\x20whether\x20to\x20retain\x20acknowledged\x20messages.\
    \x20If\x20true,\x20then\n\x20messages\x20are\x20not\x20expunged\x20from\
    \x20the\x20subscription's\x20backlog,\x20even\x20if\x20they\x20are\n\x20\
    acknowledged,\x20until\x20they\x20fall\x20out\x20of\x20the\x20`message_r\
    etention_duration`\n\x20window.\x20This\x20must\x20be\x20true\x20if\x20y\
    ou\x20would\x20like\x20to\n\x20<a\n\x20href=\"https://cloud.google.com/p\
    ubsub/docs/replay-overview#seek_to_a_time\">\n\x20Seek\x20to\x20a\x20tim\
    estamp</a>.\n\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xc5\x04\x02\x06\n\r\
    \n\x05\x04\x0e\x02\x04\x01\x12\x04\xc5\x04\x07\x1c\n\r\n\x05\x04\x0e\x02\
    \x04\x03\x12\x04\xc5\x04\x1f\x20\n\xf4\x02\n\x04\x04\x0e\x02\x05\x12\x04\
    \xcd\x04\x02:\x1a\xe5\x02\x20How\x20long\x20to\x20retain\x20unacknowledg\
    ed\x20messages\x20in\x20the\x20subscription's\x20backlog,\n\x20from\x20t\
    he\x20moment\x20a\x20message\x20is\x20published.\n\x20If\x20`retain_acke\
    d_messages`\x20is\x20true,\x20then\x20this\x20also\x20configures\x20the\
    \x20retention\n\x20of\x20acknowledged\x20messages,\x20and\x20thus\x20con\
    figures\x20how\x20far\x20back\x20in\x20time\x20a\x20`Seek`\n\x20can\x20b\
    e\x20done.\x20Defaults\x20to\x207\x20days.\x20Cannot\x20be\x20more\x20th\
    an\x207\x20days\x20or\x20less\x20than\x2010\n\x20minutes.\n\n\r\n\x05\
    \x04\x0e\x02\x05\x06\x12\x04\xcd\x04\x02\x1a\n\r\n\x05\x04\x0e\x02\x05\
    \x01\x12\x04\xcd\x04\x1b5\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\xcd\x048\
    9\nm\n\x04\x04\x0e\x02\x06\x12\x04\xd1\x04\x02!\x1a_\x20See\x20<a\x20hre\
    f=\"https://cloud.google.com/pubsub/docs/labels\">\x20Creating\x20and\n\
    \x20managing\x20labels</a>.\n\n\r\n\x05\x04\x0e\x02\x06\x06\x12\x04\xd1\
    \x04\x02\x15\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\xd1\x04\x16\x1c\n\r\n\
    \x05\x04\x0e\x02\x06\x03\x12\x04\xd1\x04\x1f\x20\n\xd1\x03\n\x04\x04\x0e\
    \x02\x07\x12\x04\xda\x04\x02$\x1a\xc2\x03\x20If\x20true,\x20messages\x20\
    published\x20with\x20the\x20same\x20`ordering_key`\x20in\x20`PubsubMessa\
    ge`\n\x20will\x20be\x20delivered\x20to\x20the\x20subscribers\x20in\x20th\
    e\x20order\x20in\x20which\x20they\n\x20are\x20received\x20by\x20the\x20P\
    ub/Sub\x20system.\x20Otherwise,\x20they\x20may\x20be\x20delivered\x20in\
    \n\x20any\x20order.\n\x20<b>EXPERIMENTAL:</b>\x20This\x20feature\x20is\
    \x20part\x20of\x20a\x20closed\x20alpha\x20release.\x20This\n\x20API\x20m\
    ight\x20be\x20changed\x20in\x20backward-incompatible\x20ways\x20and\x20i\
    s\x20not\x20recommended\n\x20for\x20production\x20use.\x20It\x20is\x20no\
    t\x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\r\n\
    \x05\x04\x0e\x02\x07\x05\x12\x04\xda\x04\x02\x06\n\r\n\x05\x04\x0e\x02\
    \x07\x01\x12\x04\xda\x04\x07\x1e\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\
    \xda\x04!#\n\xa9\x03\n\x04\x04\x0e\x02\x08\x12\x04\xe2\x04\x02*\x1a\x9a\
    \x03\x20A\x20policy\x20that\x20specifies\x20the\x20conditions\x20for\x20\
    this\x20subscription's\x20expiration.\n\x20A\x20subscription\x20is\x20co\
    nsidered\x20active\x20as\x20long\x20as\x20any\x20connected\x20subscriber\
    \x20is\n\x20successfully\x20consuming\x20messages\x20from\x20the\x20subs\
    cription\x20or\x20is\x20issuing\n\x20operations\x20on\x20the\x20subscrip\
    tion.\x20If\x20`expiration_policy`\x20is\x20not\x20set,\x20a\n\x20*defau\
    lt\x20policy*\x20with\x20`ttl`\x20of\x2031\x20days\x20will\x20be\x20used\
    .\x20The\x20minimum\x20allowed\n\x20value\x20for\x20`expiration_policy.t\
    tl`\x20is\x201\x20day.\n\n\r\n\x05\x04\x0e\x02\x08\x06\x12\x04\xe2\x04\
    \x02\x12\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xe2\x04\x13$\n\r\n\x05\
    \x04\x0e\x02\x08\x03\x12\x04\xe2\x04')\n\xef\x04\n\x04\x04\x0e\x02\t\x12\
    \x04\xef\x04\x02+\x1a\xe0\x04\x20A\x20policy\x20that\x20specifies\x20the\
    \x20conditions\x20for\x20dead\x20lettering\x20messages\x20in\n\x20this\
    \x20subscription.\x20If\x20dead_letter_policy\x20is\x20not\x20set,\x20de\
    ad\x20lettering\n\x20is\x20disabled.\n\n\x20The\x20Cloud\x20Pub/Sub\x20s\
    ervice\x20account\x20associated\x20with\x20this\x20subscriptions's\n\x20\
    parent\x20project\x20(i.e.,\n\x20service-{project_number}@gcp-sa-pubsub.\
    iam.gserviceaccount.com)\x20must\x20have\n\x20permission\x20to\x20Acknow\
    ledge()\x20messages\x20on\x20this\x20subscription.\n\x20<b>EXPERIMENTAL:\
    </b>\x20This\x20feature\x20is\x20part\x20of\x20a\x20closed\x20alpha\x20r\
    elease.\x20This\n\x20API\x20might\x20be\x20changed\x20in\x20backward-inc\
    ompatible\x20ways\x20and\x20is\x20not\x20recommended\n\x20for\x20product\
    ion\x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20d\
    eprecation\x20policy.\n\n\r\n\x05\x04\x0e\x02\t\x06\x12\x04\xef\x04\x02\
    \x12\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\xef\x04\x13%\n\r\n\x05\x04\x0e\
    \x02\t\x03\x12\x04\xef\x04(*\n\xf9\x01\n\x02\x04\x0f\x12\x06\xf7\x04\0\
    \x91\x05\x01\x1a\xea\x01\x20Dead\x20lettering\x20is\x20done\x20on\x20a\
    \x20best\x20effort\x20basis.\x20The\x20same\x20message\x20might\x20be\n\
    \x20dead\x20lettered\x20multiple\x20times.\n\n\x20If\x20validation\x20on\
    \x20any\x20of\x20the\x20fields\x20fails\x20at\x20subscription\x20creatio\
    n/updation,\n\x20the\x20create/update\x20subscription\x20request\x20will\
    \x20fail.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xf7\x04\x08\x18\n\xa6\x04\n\
    \x04\x04\x0f\x02\0\x12\x04\x81\x05\x02\x1f\x1a\x97\x04\x20The\x20name\
    \x20of\x20the\x20topic\x20to\x20which\x20dead\x20letter\x20messages\x20s\
    hould\x20be\x20published.\n\x20Format\x20is\x20`projects/{project}/topic\
    s/{topic}`.The\x20Cloud\x20Pub/Sub\x20service\n\x20account\x20associated\
    \x20with\x20the\x20enclosing\x20subscription's\x20parent\x20project\x20(\
    i.e.,\n\x20service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.co\
    m)\x20must\x20have\n\x20permission\x20to\x20Publish()\x20to\x20this\x20t\
    opic.\n\n\x20The\x20operation\x20will\x20fail\x20if\x20the\x20topic\x20d\
    oes\x20not\x20exist.\n\x20Users\x20should\x20ensure\x20that\x20there\x20\
    is\x20a\x20subscription\x20attached\x20to\x20this\x20topic\n\x20since\
    \x20messages\x20published\x20to\x20a\x20topic\x20with\x20no\x20subscript\
    ions\x20are\x20lost.\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x81\x05\x02\
    \x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x81\x05\t\x1a\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\x81\x05\x1d\x1e\n\x84\x04\n\x04\x04\x0f\x02\x01\x12\
    \x04\x90\x05\x02\"\x1a\xf5\x03\x20The\x20maximum\x20number\x20of\x20deli\
    very\x20attempts\x20for\x20any\x20message.\x20The\x20value\x20must\x20be\
    \n\x20between\x205\x20and\x20100.\n\n\x20The\x20number\x20of\x20delivery\
    \x20attempts\x20is\x20defined\x20as\x201\x20+\x20(the\x20sum\x20of\x20nu\
    mber\x20of\n\x20NACKs\x20and\x20number\x20of\x20times\x20the\x20acknowle\
    dgement\x20deadline\x20has\x20been\x20exceeded\n\x20for\x20the\x20messag\
    e).\n\n\x20A\x20NACK\x20is\x20any\x20call\x20to\x20ModifyAckDeadline\x20\
    with\x20a\x200\x20deadline.\x20Note\x20that\n\x20client\x20libraries\x20\
    may\x20automatically\x20extend\x20ack_deadlines.\n\n\x20This\x20field\
    \x20will\x20be\x20honored\x20on\x20a\x20best\x20effort\x20basis.\n\n\x20\
    If\x20this\x20parameter\x20is\x200,\x20a\x20default\x20value\x20of\x205\
    \x20is\x20used.\n\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x90\x05\x02\x07\
    \n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x90\x05\x08\x1d\n\r\n\x05\x04\x0f\
    \x02\x01\x03\x12\x04\x90\x05\x20!\nt\n\x02\x04\x10\x12\x06\x95\x05\0\x9d\
    \x05\x01\x1af\x20A\x20policy\x20that\x20specifies\x20the\x20conditions\
    \x20for\x20resource\x20expiration\x20(i.e.,\n\x20automatic\x20resource\
    \x20deletion).\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x95\x05\x08\x18\n\x89\
    \x03\n\x04\x04\x10\x02\0\x12\x04\x9c\x05\x02#\x1a\xfa\x02\x20Specifies\
    \x20the\x20\"time-to-live\"\x20duration\x20for\x20an\x20associated\x20re\
    source.\x20The\n\x20resource\x20expires\x20if\x20it\x20is\x20not\x20acti\
    ve\x20for\x20a\x20period\x20of\x20`ttl`.\x20The\x20definition\n\x20of\
    \x20\"activity\"\x20depends\x20on\x20the\x20type\x20of\x20the\x20associa\
    ted\x20resource.\x20The\x20minimum\n\x20and\x20maximum\x20allowed\x20val\
    ues\x20for\x20`ttl`\x20depend\x20on\x20the\x20type\x20of\x20the\x20assoc\
    iated\n\x20resource,\x20as\x20well.\x20If\x20`ttl`\x20is\x20not\x20set,\
    \x20the\x20associated\x20resource\x20never\n\x20expires.\n\n\r\n\x05\x04\
    \x10\x02\0\x06\x12\x04\x9c\x05\x02\x1a\n\r\n\x05\x04\x10\x02\0\x01\x12\
    \x04\x9c\x05\x1b\x1e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x9c\x05!\"\n;\n\
    \x02\x04\x11\x12\x06\xa0\x05\0\xda\x05\x01\x1a-\x20Configuration\x20for\
    \x20a\x20push\x20delivery\x20endpoint.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xa0\x05\x08\x12\n\x9a\x01\n\x04\x04\x11\x03\0\x12\x06\xa4\x05\x02\xb3\
    \x05\x03\x1a\x89\x01\x20Contains\x20information\x20needed\x20for\x20gene\
    rating\x20an\n\x20[OpenID\x20Connect\n\x20token](https://developers.goog\
    le.com/identity/protocols/OpenIDConnect).\n\n\r\n\x05\x04\x11\x03\0\x01\
    \x12\x04\xa4\x05\n\x13\n\xab\x02\n\x06\x04\x11\x03\0\x02\0\x12\x04\xaa\
    \x05\x04%\x1a\x9a\x02\x20[Service\x20account\n\x20email](https://cloud.g\
    oogle.com/iam/docs/service-accounts)\n\x20to\x20be\x20used\x20for\x20gen\
    erating\x20the\x20OIDC\x20token.\x20The\x20caller\x20(for\n\x20CreateSub\
    scription,\x20UpdateSubscription,\x20and\x20ModifyPushConfig\x20RPCs)\
    \x20must\n\x20have\x20the\x20iam.serviceAccounts.actAs\x20permission\x20\
    for\x20the\x20service\x20account.\n\n\x0f\n\x07\x04\x11\x03\0\x02\0\x05\
    \x12\x04\xaa\x05\x04\n\n\x0f\n\x07\x04\x11\x03\0\x02\0\x01\x12\x04\xaa\
    \x05\x0b\x20\n\x0f\n\x07\x04\x11\x03\0\x02\0\x03\x12\x04\xaa\x05#$\n\xb0\
    \x03\n\x06\x04\x11\x03\0\x02\x01\x12\x04\xb2\x05\x04\x18\x1a\x9f\x03\x20\
    Audience\x20to\x20be\x20used\x20when\x20generating\x20OIDC\x20token.\x20\
    The\x20audience\x20claim\n\x20identifies\x20the\x20recipients\x20that\
    \x20the\x20JWT\x20is\x20intended\x20for.\x20The\x20audience\n\x20value\
    \x20is\x20a\x20single\x20case-sensitive\x20string.\x20Having\x20multiple\
    \x20values\x20(array)\n\x20for\x20the\x20audience\x20field\x20is\x20not\
    \x20supported.\x20More\x20info\x20about\x20the\x20OIDC\x20JWT\n\x20token\
    \x20audience\x20here:\x20https://tools.ietf.org/html/rfc7519#section-4.1\
    .3\n\x20Note:\x20if\x20not\x20specified,\x20the\x20Push\x20endpoint\x20U\
    RL\x20will\x20be\x20used.\n\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\x12\
    \x04\xb2\x05\x04\n\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\xb2\x05\
    \x0b\x13\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x03\x12\x04\xb2\x05\x16\x17\n\
    \x97\x01\n\x04\x04\x11\x02\0\x12\x04\xb7\x05\x02\x1b\x1a\x88\x01\x20A\
    \x20URL\x20locating\x20the\x20endpoint\x20to\x20which\x20messages\x20sho\
    uld\x20be\x20pushed.\n\x20For\x20example,\x20a\x20Webhook\x20endpoint\
    \x20might\x20use\x20\"https://example.com/push\".\n\n\r\n\x05\x04\x11\
    \x02\0\x05\x12\x04\xb7\x05\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\
    \xb7\x05\t\x16\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb7\x05\x19\x1a\n\x82\
    \x08\n\x04\x04\x11\x02\x01\x12\x04\xce\x05\x02%\x1a\xf3\x07\x20Endpoint\
    \x20configuration\x20attributes\x20that\x20can\x20be\x20used\x20to\x20co\
    ntrol\x20different\n\x20aspects\x20of\x20the\x20message\x20delivery.\n\n\
    \x20The\x20only\x20currently\x20supported\x20attribute\x20is\x20`x-goog-\
    version`,\x20which\x20you\x20can\n\x20use\x20to\x20change\x20the\x20form\
    at\x20of\x20the\x20pushed\x20message.\x20This\x20attribute\n\x20indicate\
    s\x20the\x20version\x20of\x20the\x20data\x20expected\x20by\x20the\x20end\
    point.\x20This\n\x20controls\x20the\x20shape\x20of\x20the\x20pushed\x20m\
    essage\x20(i.e.,\x20its\x20fields\x20and\x20metadata).\n\n\x20If\x20not\
    \x20present\x20during\x20the\x20`CreateSubscription`\x20call,\x20it\x20w\
    ill\x20default\x20to\n\x20the\x20version\x20of\x20the\x20Pub/Sub\x20API\
    \x20used\x20to\x20make\x20such\x20call.\x20If\x20not\x20present\x20in\
    \x20a\n\x20`ModifyPushConfig`\x20call,\x20its\x20value\x20will\x20not\
    \x20be\x20changed.\x20`GetSubscription`\n\x20calls\x20will\x20always\x20\
    return\x20a\x20valid\x20version,\x20even\x20if\x20the\x20subscription\
    \x20was\n\x20created\x20without\x20this\x20attribute.\n\n\x20The\x20only\
    \x20supported\x20values\x20for\x20the\x20`x-goog-version`\x20attribute\
    \x20are:\n\n\x20*\x20`v1beta1`:\x20uses\x20the\x20push\x20format\x20defi\
    ned\x20in\x20the\x20v1beta1\x20Pub/Sub\x20API.\n\x20*\x20`v1`\x20or\x20`\
    v1beta2`:\x20uses\x20the\x20push\x20format\x20defined\x20in\x20the\x20v1\
    \x20Pub/Sub\x20API.\n\n\x20For\x20example:\n\x20<pre><code>attributes\
    \x20{\x20\"x-goog-version\":\x20\"v1\"\x20}\x20</code></pre>\n\n\r\n\x05\
    \x04\x11\x02\x01\x06\x12\x04\xce\x05\x02\x15\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xce\x05\x16\x20\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xce\
    \x05#$\n\xca\x02\n\x04\x04\x11\x08\0\x12\x06\xd5\x05\x02\xd9\x05\x03\x1a\
    \xb9\x02\x20An\x20authentication\x20method\x20used\x20by\x20push\x20endp\
    oints\x20to\x20verify\x20the\x20source\x20of\n\x20push\x20requests.\x20T\
    his\x20can\x20be\x20used\x20with\x20push\x20endpoints\x20that\x20are\x20\
    private\x20by\n\x20default\x20to\x20allow\x20requests\x20only\x20from\
    \x20the\x20Cloud\x20Pub/Sub\x20system,\x20for\x20example.\n\x20This\x20f\
    ield\x20is\x20optional\x20and\x20should\x20be\x20set\x20only\x20by\x20us\
    ers\x20interested\x20in\n\x20authenticated\x20push.\n\n\r\n\x05\x04\x11\
    \x08\0\x01\x12\x04\xd5\x05\x08\x1d\n\x9d\x01\n\x04\x04\x11\x02\x02\x12\
    \x04\xd8\x05\x04\x1d\x1a\x8e\x01\x20If\x20specified,\x20Pub/Sub\x20will\
    \x20generate\x20and\x20attach\x20an\x20OIDC\x20JWT\x20token\x20as\x20an\
    \n\x20`Authorization`\x20header\x20in\x20the\x20HTTP\x20request\x20for\
    \x20every\x20pushed\x20message.\n\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\
    \xd8\x05\x04\r\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xd8\x05\x0e\x18\n\r\
    \n\x05\x04\x11\x02\x02\x03\x12\x04\xd8\x05\x1b\x1c\nB\n\x02\x04\x12\x12\
    \x06\xdd\x05\0\xf5\x05\x01\x1a4\x20A\x20message\x20and\x20its\x20corresp\
    onding\x20acknowledgment\x20ID.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xdd\
    \x05\x08\x17\nH\n\x04\x04\x12\x02\0\x12\x04\xdf\x05\x02\x14\x1a:\x20This\
    \x20ID\x20can\x20be\x20used\x20to\x20acknowledge\x20the\x20received\x20m\
    essage.\n\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xdf\x05\x02\x08\n\r\n\x05\
    \x04\x12\x02\0\x01\x12\x04\xdf\x05\t\x0f\n\r\n\x05\x04\x12\x02\0\x03\x12\
    \x04\xdf\x05\x12\x13\n\x1c\n\x04\x04\x12\x02\x01\x12\x04\xe2\x05\x02\x1c\
    \x1a\x0e\x20The\x20message.\n\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xe2\
    \x05\x02\x0f\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xe2\x05\x10\x17\n\r\n\
    \x05\x04\x12\x02\x01\x03\x12\x04\xe2\x05\x1a\x1b\n\xc6\x06\n\x04\x04\x12\
    \x02\x02\x12\x04\xf4\x05\x02\x1d\x1a\xb7\x06\x20Delivery\x20attempt\x20c\
    ounter\x20is\x201\x20+\x20(the\x20sum\x20of\x20number\x20of\x20NACKs\x20\
    and\x20number\x20of\n\x20ack_deadline\x20exceeds)\x20for\x20this\x20mess\
    age.\n\n\x20A\x20NACK\x20is\x20any\x20call\x20to\x20ModifyAckDeadline\
    \x20with\x20a\x200\x20deadline.\x20An\x20ack_deadline\n\x20exceeds\x20ev\
    ent\x20is\x20whenever\x20a\x20message\x20is\x20not\x20acknowledged\x20wi\
    thin\n\x20ack_deadline.\x20Note\x20that\x20ack_deadline\x20is\x20initial\
    ly\n\x20Subscription.ackDeadlineSeconds,\x20but\x20may\x20get\x20extende\
    d\x20automatically\x20by\n\x20the\x20client\x20library.\n\n\x20The\x20fi\
    rst\x20delivery\x20of\x20a\x20given\x20message\x20will\x20have\x20this\
    \x20value\x20as\x201.\x20The\x20value\n\x20is\x20calculated\x20at\x20bes\
    t\x20effort\x20and\x20is\x20approximate.\n\n\x20If\x20a\x20DeadLetterPol\
    icy\x20is\x20not\x20set\x20on\x20the\x20subscription,\x20this\x20will\
    \x20be\x200.\n\x20<b>EXPERIMENTAL:</b>\x20This\x20feature\x20is\x20part\
    \x20of\x20a\x20closed\x20alpha\x20release.\x20This\n\x20API\x20might\x20\
    be\x20changed\x20in\x20backward-incompatible\x20ways\x20and\x20is\x20not\
    \x20recommended\n\x20for\x20production\x20use.\x20It\x20is\x20not\x20sub\
    ject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\r\n\x05\x04\
    \x12\x02\x02\x05\x12\x04\xf4\x05\x02\x07\n\r\n\x05\x04\x12\x02\x02\x01\
    \x12\x04\xf4\x05\x08\x18\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xf4\x05\
    \x1b\x1c\n7\n\x02\x04\x13\x12\x06\xf8\x05\0\xfc\x05\x01\x1a)\x20Request\
    \x20for\x20the\x20GetSubscription\x20method.\n\n\x0b\n\x03\x04\x13\x01\
    \x12\x04\xf8\x05\x08\x1e\ni\n\x04\x04\x13\x02\0\x12\x04\xfb\x05\x02\x1a\
    \x1a[\x20The\x20name\x20of\x20the\x20subscription\x20to\x20get.\n\x20For\
    mat\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\x05\x04\
    \x13\x02\0\x05\x12\x04\xfb\x05\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\
    \x04\xfb\x05\t\x15\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xfb\x05\x18\x19\n\
    :\n\x02\x04\x14\x12\x06\xff\x05\0\x86\x06\x01\x1a,\x20Request\x20for\x20\
    the\x20UpdateSubscription\x20method.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xff\x05\x08!\n0\n\x04\x04\x14\x02\0\x12\x04\x81\x06\x02\x20\x1a\"\x20Th\
    e\x20updated\x20subscription\x20object.\n\n\r\n\x05\x04\x14\x02\0\x06\
    \x12\x04\x81\x06\x02\x0e\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x81\x06\x0f\
    \x1b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x81\x06\x1e\x1f\np\n\x04\x04\
    \x14\x02\x01\x12\x04\x85\x06\x02,\x1ab\x20Indicates\x20which\x20fields\
    \x20in\x20the\x20provided\x20subscription\x20to\x20update.\n\x20Must\x20\
    be\x20specified\x20and\x20non-empty.\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\
    \x04\x85\x06\x02\x1b\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x85\x06\x1c'\
    \n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x85\x06*+\n;\n\x02\x04\x15\x12\
    \x06\x89\x06\0\x95\x06\x01\x1a-\x20Request\x20for\x20the\x20`ListSubscri\
    ptions`\x20method.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\x89\x06\x08\x20\nk\
    \n\x04\x04\x15\x02\0\x12\x04\x8c\x06\x02\x15\x1a]\x20The\x20name\x20of\
    \x20the\x20project\x20in\x20which\x20to\x20list\x20subscriptions.\n\x20F\
    ormat\x20is\x20`projects/{project-id}`.\n\n\r\n\x05\x04\x15\x02\0\x05\
    \x12\x04\x8c\x06\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x8c\x06\t\
    \x10\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x8c\x06\x13\x14\n:\n\x04\x04\
    \x15\x02\x01\x12\x04\x8f\x06\x02\x16\x1a,\x20Maximum\x20number\x20of\x20\
    subscriptions\x20to\x20return.\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\
    \x8f\x06\x02\x07\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x8f\x06\x08\x11\n\
    \r\n\x05\x04\x15\x02\x01\x03\x12\x04\x8f\x06\x14\x15\n\xd2\x01\n\x04\x04\
    \x15\x02\x02\x12\x04\x94\x06\x02\x18\x1a\xc3\x01\x20The\x20value\x20retu\
    rned\x20by\x20the\x20last\x20`ListSubscriptionsResponse`;\x20indicates\
    \x20that\n\x20this\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20`Li\
    stSubscriptions`\x20call,\x20and\x20that\x20the\n\x20system\x20should\
    \x20return\x20the\x20next\x20page\x20of\x20data.\n\n\r\n\x05\x04\x15\x02\
    \x02\x05\x12\x04\x94\x06\x02\x08\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\
    \x94\x06\t\x13\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\x94\x06\x16\x17\n<\
    \n\x02\x04\x16\x12\x06\x98\x06\0\xa0\x06\x01\x1a.\x20Response\x20for\x20\
    the\x20`ListSubscriptions`\x20method.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\
    \x98\x06\x08!\n9\n\x04\x04\x16\x02\0\x12\x04\x9a\x06\x02*\x1a+\x20The\
    \x20subscriptions\x20that\x20match\x20the\x20request.\n\n\r\n\x05\x04\
    \x16\x02\0\x04\x12\x04\x9a\x06\x02\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\
    \x9a\x06\x0b\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x9a\x06\x18%\n\r\n\
    \x05\x04\x16\x02\0\x03\x12\x04\x9a\x06()\n\xc2\x01\n\x04\x04\x16\x02\x01\
    \x12\x04\x9f\x06\x02\x1d\x1a\xb3\x01\x20If\x20not\x20empty,\x20indicates\
    \x20that\x20there\x20may\x20be\x20more\x20subscriptions\x20that\x20match\
    \n\x20the\x20request;\x20this\x20value\x20should\x20be\x20passed\x20in\
    \x20a\x20new\n\x20`ListSubscriptionsRequest`\x20to\x20get\x20more\x20sub\
    scriptions.\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\x9f\x06\x02\x08\n\r\
    \n\x05\x04\x16\x02\x01\x01\x12\x04\x9f\x06\t\x18\n\r\n\x05\x04\x16\x02\
    \x01\x03\x12\x04\x9f\x06\x1b\x1c\n:\n\x02\x04\x17\x12\x06\xa3\x06\0\xa7\
    \x06\x01\x1a,\x20Request\x20for\x20the\x20DeleteSubscription\x20method.\
    \n\n\x0b\n\x03\x04\x17\x01\x12\x04\xa3\x06\x08!\n`\n\x04\x04\x17\x02\0\
    \x12\x04\xa6\x06\x02\x1a\x1aR\x20The\x20subscription\x20to\x20delete.\n\
    \x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\
    \x05\x04\x17\x02\0\x05\x12\x04\xa6\x06\x02\x08\n\r\n\x05\x04\x17\x02\0\
    \x01\x12\x04\xa6\x06\t\x15\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xa6\x06\
    \x18\x19\n8\n\x02\x04\x18\x12\x06\xaa\x06\0\xb6\x06\x01\x1a*\x20Request\
    \x20for\x20the\x20ModifyPushConfig\x20method.\n\n\x0b\n\x03\x04\x18\x01\
    \x12\x04\xaa\x06\x08\x1f\nb\n\x04\x04\x18\x02\0\x12\x04\xad\x06\x02\x1a\
    \x1aT\x20The\x20name\x20of\x20the\x20subscription.\n\x20Format\x20is\x20\
    `projects/{project}/subscriptions/{sub}`.\n\n\r\n\x05\x04\x18\x02\0\x05\
    \x12\x04\xad\x06\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xad\x06\t\
    \x15\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xad\x06\x18\x19\n\xb8\x02\n\x04\
    \x04\x18\x02\x01\x12\x04\xb5\x06\x02\x1d\x1a\xa9\x02\x20The\x20push\x20c\
    onfiguration\x20for\x20future\x20deliveries.\n\n\x20An\x20empty\x20`push\
    Config`\x20indicates\x20that\x20the\x20Pub/Sub\x20system\x20should\n\x20\
    stop\x20pushing\x20messages\x20from\x20the\x20given\x20subscription\x20a\
    nd\x20allow\n\x20messages\x20to\x20be\x20pulled\x20and\x20acknowledged\
    \x20-\x20effectively\x20pausing\n\x20the\x20subscription\x20if\x20`Pull`\
    \x20or\x20`StreamingPull`\x20is\x20not\x20called.\n\n\r\n\x05\x04\x18\
    \x02\x01\x06\x12\x04\xb5\x06\x02\x0c\n\r\n\x05\x04\x18\x02\x01\x01\x12\
    \x04\xb5\x06\r\x18\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xb5\x06\x1b\x1c\
    \n.\n\x02\x04\x19\x12\x06\xb9\x06\0\xc8\x06\x01\x1a\x20\x20Request\x20fo\
    r\x20the\x20`Pull`\x20method.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xb9\x06\
    \x08\x13\n{\n\x04\x04\x19\x02\0\x12\x04\xbc\x06\x02\x1a\x1am\x20The\x20s\
    ubscription\x20from\x20which\x20messages\x20should\x20be\x20pulled.\n\
    \x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\
    \x05\x04\x19\x02\0\x05\x12\x04\xbc\x06\x02\x08\n\r\n\x05\x04\x19\x02\0\
    \x01\x12\x04\xbc\x06\t\x15\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xbc\x06\
    \x18\x19\n\xa9\x02\n\x04\x04\x19\x02\x01\x12\x04\xc2\x06\x02\x1e\x1a\x9a\
    \x02\x20If\x20this\x20field\x20set\x20to\x20true,\x20the\x20system\x20wi\
    ll\x20respond\x20immediately\x20even\x20if\n\x20it\x20there\x20are\x20no\
    \x20messages\x20available\x20to\x20return\x20in\x20the\x20`Pull`\x20resp\
    onse.\n\x20Otherwise,\x20the\x20system\x20may\x20wait\x20(for\x20a\x20bo\
    unded\x20amount\x20of\x20time)\x20until\x20at\n\x20least\x20one\x20messa\
    ge\x20is\x20available,\x20rather\x20than\x20returning\x20no\x20messages.\
    \n\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xc2\x06\x02\x06\n\r\n\x05\x04\
    \x19\x02\x01\x01\x12\x04\xc2\x06\x07\x19\n\r\n\x05\x04\x19\x02\x01\x03\
    \x12\x04\xc2\x06\x1c\x1d\n\xa8\x01\n\x04\x04\x19\x02\x02\x12\x04\xc7\x06\
    \x02\x19\x1a\x99\x01\x20The\x20maximum\x20number\x20of\x20messages\x20to\
    \x20return\x20for\x20this\x20request.\x20Must\x20be\x20a\n\x20positive\
    \x20integer.\x20The\x20Pub/Sub\x20system\x20may\x20return\x20fewer\x20th\
    an\x20the\x20number\n\x20specified.\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\
    \x04\xc7\x06\x02\x07\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xc7\x06\x08\
    \x14\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xc7\x06\x17\x18\n/\n\x02\x04\
    \x1a\x12\x06\xcb\x06\0\xd1\x06\x01\x1a!\x20Response\x20for\x20the\x20`Pu\
    ll`\x20method.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xcb\x06\x08\x14\n\xaa\
    \x02\n\x04\x04\x1a\x02\0\x12\x04\xd0\x06\x021\x1a\x9b\x02\x20Received\
    \x20Pub/Sub\x20messages.\x20The\x20list\x20will\x20be\x20empty\x20if\x20\
    there\x20are\x20no\x20more\n\x20messages\x20available\x20in\x20the\x20ba\
    cklog.\x20For\x20JSON,\x20the\x20response\x20can\x20be\x20entirely\n\x20\
    empty.\x20The\x20Pub/Sub\x20system\x20may\x20return\x20fewer\x20than\x20\
    the\x20`maxMessages`\x20requested\n\x20even\x20if\x20there\x20are\x20mor\
    e\x20messages\x20available\x20in\x20the\x20backlog.\n\n\r\n\x05\x04\x1a\
    \x02\0\x04\x12\x04\xd0\x06\x02\n\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xd0\
    \x06\x0b\x1a\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd0\x06\x1b,\n\r\n\x05\
    \x04\x1a\x02\0\x03\x12\x04\xd0\x06/0\n9\n\x02\x04\x1b\x12\x06\xd4\x06\0\
    \xe5\x06\x01\x1a+\x20Request\x20for\x20the\x20ModifyAckDeadline\x20metho\
    d.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xd4\x06\x08\x20\nb\n\x04\x04\x1b\
    \x02\0\x12\x04\xd7\x06\x02\x1a\x1aT\x20The\x20name\x20of\x20the\x20subsc\
    ription.\n\x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\
    \n\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xd7\x06\x02\x08\n\r\n\x05\x04\x1b\
    \x02\0\x01\x12\x04\xd7\x06\t\x15\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xd7\
    \x06\x18\x19\n+\n\x04\x04\x1b\x02\x01\x12\x04\xda\x06\x02\x1e\x1a\x1d\
    \x20List\x20of\x20acknowledgment\x20IDs.\n\n\r\n\x05\x04\x1b\x02\x01\x04\
    \x12\x04\xda\x06\x02\n\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xda\x06\x0b\
    \x11\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xda\x06\x12\x19\n\r\n\x05\x04\
    \x1b\x02\x01\x03\x12\x04\xda\x06\x1c\x1d\n\xaa\x04\n\x04\x04\x1b\x02\x02\
    \x12\x04\xe4\x06\x02!\x1a\x9b\x04\x20The\x20new\x20ack\x20deadline\x20wi\
    th\x20respect\x20to\x20the\x20time\x20this\x20request\x20was\x20sent\x20\
    to\n\x20the\x20Pub/Sub\x20system.\x20For\x20example,\x20if\x20the\x20val\
    ue\x20is\x2010,\x20the\x20new\n\x20ack\x20deadline\x20will\x20expire\x20\
    10\x20seconds\x20after\x20the\x20`ModifyAckDeadline`\x20call\n\x20was\
    \x20made.\x20Specifying\x20zero\x20might\x20immediately\x20make\x20the\
    \x20message\x20available\x20for\n\x20delivery\x20to\x20another\x20subscr\
    iber\x20client.\x20This\x20typically\x20results\x20in\x20an\n\x20increas\
    e\x20in\x20the\x20rate\x20of\x20message\x20redeliveries\x20(that\x20is,\
    \x20duplicates).\n\x20The\x20minimum\x20deadline\x20you\x20can\x20specif\
    y\x20is\x200\x20seconds.\n\x20The\x20maximum\x20deadline\x20you\x20can\
    \x20specify\x20is\x20600\x20seconds\x20(10\x20minutes).\n\n\r\n\x05\x04\
    \x1b\x02\x02\x05\x12\x04\xe4\x06\x02\x07\n\r\n\x05\x04\x1b\x02\x02\x01\
    \x12\x04\xe4\x06\x08\x1c\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xe4\x06\
    \x1f\x20\n3\n\x02\x04\x1c\x12\x06\xe8\x06\0\xf0\x06\x01\x1a%\x20Request\
    \x20for\x20the\x20Acknowledge\x20method.\n\n\x0b\n\x03\x04\x1c\x01\x12\
    \x04\xe8\x06\x08\x1a\nz\n\x04\x04\x1c\x02\0\x12\x04\xeb\x06\x02\x1a\x1al\
    \x20The\x20subscription\x20whose\x20message\x20is\x20being\x20acknowledg\
    ed.\n\x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\
    \n\x05\x04\x1c\x02\0\x05\x12\x04\xeb\x06\x02\x08\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\xeb\x06\t\x15\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xeb\x06\
    \x18\x19\n\x9e\x01\n\x04\x04\x1c\x02\x01\x12\x04\xef\x06\x02\x1e\x1a\x8f\
    \x01\x20The\x20acknowledgment\x20ID\x20for\x20the\x20messages\x20being\
    \x20acknowledged\x20that\x20was\x20returned\n\x20by\x20the\x20Pub/Sub\
    \x20system\x20in\x20the\x20`Pull`\x20response.\x20Must\x20not\x20be\x20e\
    mpty.\n\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xef\x06\x02\n\n\r\n\x05\
    \x04\x1c\x02\x01\x05\x12\x04\xef\x06\x0b\x11\n\r\n\x05\x04\x1c\x02\x01\
    \x01\x12\x04\xef\x06\x12\x19\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xef\
    \x06\x1c\x1d\n\xe1\x01\n\x02\x04\x1d\x12\x06\xf5\x06\0\x9c\x07\x01\x1a\
    \xd2\x01\x20Request\x20for\x20the\x20`StreamingPull`\x20streaming\x20RPC\
    \x20method.\x20This\x20request\x20is\x20used\x20to\n\x20establish\x20the\
    \x20initial\x20stream\x20as\x20well\x20as\x20to\x20stream\x20acknowledge\
    ments\x20and\x20ack\n\x20deadline\x20modifications\x20from\x20the\x20cli\
    ent\x20to\x20the\x20server.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xf5\x06\
    \x08\x1c\n\xfc\x01\n\x04\x04\x1d\x02\0\x12\x04\xfa\x06\x02\x1a\x1a\xed\
    \x01\x20The\x20subscription\x20for\x20which\x20to\x20initialize\x20the\
    \x20new\x20stream.\x20This\x20must\x20be\n\x20provided\x20in\x20the\x20f\
    irst\x20request\x20on\x20the\x20stream,\x20and\x20must\x20not\x20be\x20s\
    et\x20in\n\x20subsequent\x20requests\x20from\x20client\x20to\x20server.\
    \n\x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\
    \x05\x04\x1d\x02\0\x05\x12\x04\xfa\x06\x02\x08\n\r\n\x05\x04\x1d\x02\0\
    \x01\x12\x04\xfa\x06\t\x15\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xfa\x06\
    \x18\x19\n\x85\x03\n\x04\x04\x1d\x02\x01\x12\x04\x81\x07\x02\x1e\x1a\xf6\
    \x02\x20List\x20of\x20acknowledgement\x20IDs\x20for\x20acknowledging\x20\
    previously\x20received\x20messages\n\x20(received\x20on\x20this\x20strea\
    m\x20or\x20a\x20different\x20stream).\x20If\x20an\x20ack\x20ID\x20has\
    \x20expired,\n\x20the\x20corresponding\x20message\x20may\x20be\x20redeli\
    vered\x20later.\x20Acknowledging\x20a\x20message\n\x20more\x20than\x20on\
    ce\x20will\x20not\x20result\x20in\x20an\x20error.\x20If\x20the\x20acknow\
    ledgement\x20ID\x20is\n\x20malformed,\x20the\x20stream\x20will\x20be\x20\
    aborted\x20with\x20status\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\x04\x1d\x02\
    \x01\x04\x12\x04\x81\x07\x02\n\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\x81\
    \x07\x0b\x11\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\x81\x07\x12\x19\n\r\n\
    \x05\x04\x1d\x02\x01\x03\x12\x04\x81\x07\x1c\x1d\n\x89\x06\n\x04\x04\x1d\
    \x02\x02\x12\x04\x8e\x07\x02-\x1a\xfa\x05\x20The\x20list\x20of\x20new\
    \x20ack\x20deadlines\x20for\x20the\x20IDs\x20listed\x20in\n\x20`modify_d\
    eadline_ack_ids`.\x20The\x20size\x20of\x20this\x20list\x20must\x20be\x20\
    the\x20same\x20as\x20the\n\x20size\x20of\x20`modify_deadline_ack_ids`.\
    \x20If\x20it\x20differs\x20the\x20stream\x20will\x20be\x20aborted\n\x20w\
    ith\x20`INVALID_ARGUMENT`.\x20Each\x20element\x20in\x20this\x20list\x20i\
    s\x20applied\x20to\x20the\n\x20element\x20in\x20the\x20same\x20position\
    \x20in\x20`modify_deadline_ack_ids`.\x20The\x20new\x20ack\n\x20deadline\
    \x20is\x20with\x20respect\x20to\x20the\x20time\x20this\x20request\x20was\
    \x20sent\x20to\x20the\x20Pub/Sub\n\x20system.\x20Must\x20be\x20>=\x200.\
    \x20For\x20example,\x20if\x20the\x20value\x20is\x2010,\x20the\x20new\x20\
    ack\x20deadline\n\x20will\x20expire\x2010\x20seconds\x20after\x20this\
    \x20request\x20is\x20received.\x20If\x20the\x20value\x20is\x200,\n\x20th\
    e\x20message\x20is\x20immediately\x20made\x20available\x20for\x20another\
    \x20streaming\x20or\n\x20non-streaming\x20pull\x20request.\x20If\x20the\
    \x20value\x20is\x20<\x200\x20(an\x20error),\x20the\x20stream\x20will\n\
    \x20be\x20aborted\x20with\x20status\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\
    \x04\x1d\x02\x02\x04\x12\x04\x8e\x07\x02\n\n\r\n\x05\x04\x1d\x02\x02\x05\
    \x12\x04\x8e\x07\x0b\x10\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\x8e\x07\
    \x11(\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x8e\x07+,\n\xc8\x02\n\x04\
    \x04\x1d\x02\x03\x12\x04\x95\x07\x02.\x1a\xb9\x02\x20List\x20of\x20ackno\
    wledgement\x20IDs\x20whose\x20deadline\x20will\x20be\x20modified\x20base\
    d\x20on\x20the\n\x20corresponding\x20element\x20in\x20`modify_deadline_s\
    econds`.\x20This\x20field\x20can\x20be\x20used\n\x20to\x20indicate\x20th\
    at\x20more\x20time\x20is\x20needed\x20to\x20process\x20a\x20message\x20b\
    y\x20the\n\x20subscriber,\x20or\x20to\x20make\x20the\x20message\x20avail\
    able\x20for\x20redelivery\x20if\x20the\n\x20processing\x20was\x20interru\
    pted.\n\n\r\n\x05\x04\x1d\x02\x03\x04\x12\x04\x95\x07\x02\n\n\r\n\x05\
    \x04\x1d\x02\x03\x05\x12\x04\x95\x07\x0b\x11\n\r\n\x05\x04\x1d\x02\x03\
    \x01\x12\x04\x95\x07\x12)\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\x95\x07,\
    -\n\xb4\x02\n\x04\x04\x1d\x02\x04\x12\x04\x9b\x07\x02(\x1a\xa5\x02\x20Th\
    e\x20ack\x20deadline\x20to\x20use\x20for\x20the\x20stream.\x20This\x20mu\
    st\x20be\x20provided\x20in\x20the\n\x20first\x20request\x20on\x20the\x20\
    stream,\x20but\x20it\x20can\x20also\x20be\x20updated\x20on\x20subsequent\
    \n\x20requests\x20from\x20client\x20to\x20server.\x20The\x20minimum\x20d\
    eadline\x20you\x20can\x20specify\x20is\x2010\n\x20seconds.\x20The\x20max\
    imum\x20deadline\x20you\x20can\x20specify\x20is\x20600\x20seconds\x20(10\
    \x20minutes).\n\n\r\n\x05\x04\x1d\x02\x04\x05\x12\x04\x9b\x07\x02\x07\n\
    \r\n\x05\x04\x1d\x02\x04\x01\x12\x04\x9b\x07\x08#\n\r\n\x05\x04\x1d\x02\
    \x04\x03\x12\x04\x9b\x07&'\n\x81\x01\n\x02\x04\x1e\x12\x06\xa0\x07\0\xa3\
    \x07\x01\x1as\x20Response\x20for\x20the\x20`StreamingPull`\x20method.\
    \x20This\x20response\x20is\x20used\x20to\x20stream\n\x20messages\x20from\
    \x20the\x20server\x20to\x20the\x20client.\n\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\xa0\x07\x08\x1d\nB\n\x04\x04\x1e\x02\0\x12\x04\xa2\x07\x021\x1a4\
    \x20Received\x20Pub/Sub\x20messages.\x20This\x20will\x20not\x20be\x20emp\
    ty.\n\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xa2\x07\x02\n\n\r\n\x05\x04\
    \x1e\x02\0\x06\x12\x04\xa2\x07\x0b\x1a\n\r\n\x05\x04\x1e\x02\0\x01\x12\
    \x04\xa2\x07\x1b,\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xa2\x07/0\n8\n\x02\
    \x04\x1f\x12\x06\xa6\x07\0\xbe\x07\x01\x1a*\x20Request\x20for\x20the\x20\
    `CreateSnapshot`\x20method.\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xa6\x07\
    \x08\x1d\n\xa3\x03\n\x04\x04\x1f\x02\0\x12\x04\xae\x07\x02\x12\x1a\x94\
    \x03\x20Optional\x20user-provided\x20name\x20for\x20this\x20snapshot.\n\
    \x20If\x20the\x20name\x20is\x20not\x20provided\x20in\x20the\x20request,\
    \x20the\x20server\x20will\x20assign\x20a\x20random\n\x20name\x20for\x20t\
    his\x20snapshot\x20on\x20the\x20same\x20project\x20as\x20the\x20subscrip\
    tion.\n\x20Note\x20that\x20for\x20REST\x20API\x20requests,\x20you\x20mus\
    t\x20specify\x20a\x20name.\x20\x20See\x20the\n\x20<a\x20href=\"https://c\
    loud.google.com/pubsub/docs/admin#resource_names\">\n\x20resource\x20nam\
    e\x20rules</a>.\n\x20Format\x20is\x20`projects/{project}/snapshots/{snap\
    }`.\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xae\x07\x02\x08\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\xae\x07\t\r\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \xae\x07\x10\x11\n\xad\x04\n\x04\x04\x1f\x02\x01\x12\x04\xb9\x07\x02\x1a\
    \x1a\x9e\x04\x20The\x20subscription\x20whose\x20backlog\x20the\x20snapsh\
    ot\x20retains.\n\x20Specifically,\x20the\x20created\x20snapshot\x20is\
    \x20guaranteed\x20to\x20retain:\n\x20\x20(a)\x20The\x20existing\x20backl\
    og\x20on\x20the\x20subscription.\x20More\x20precisely,\x20this\x20is\n\
    \x20\x20\x20\x20\x20\x20defined\x20as\x20the\x20messages\x20in\x20the\
    \x20subscription's\x20backlog\x20that\x20are\n\x20\x20\x20\x20\x20\x20un\
    acknowledged\x20upon\x20the\x20successful\x20completion\x20of\x20the\n\
    \x20\x20\x20\x20\x20\x20`CreateSnapshot`\x20request;\x20as\x20well\x20as\
    :\n\x20\x20(b)\x20Any\x20messages\x20published\x20to\x20the\x20subscript\
    ion's\x20topic\x20following\x20the\n\x20\x20\x20\x20\x20\x20successful\
    \x20completion\x20of\x20the\x20CreateSnapshot\x20request.\n\x20Format\
    \x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\r\n\x05\x04\x1f\
    \x02\x01\x05\x12\x04\xb9\x07\x02\x08\n\r\n\x05\x04\x1f\x02\x01\x01\x12\
    \x04\xb9\x07\t\x15\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xb9\x07\x18\x19\
    \nm\n\x04\x04\x1f\x02\x02\x12\x04\xbd\x07\x02!\x1a_\x20See\x20<a\x20href\
    =\"https://cloud.google.com/pubsub/docs/labels\">\x20Creating\x20and\n\
    \x20managing\x20labels</a>.\n\n\r\n\x05\x04\x1f\x02\x02\x06\x12\x04\xbd\
    \x07\x02\x15\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xbd\x07\x16\x1c\n\r\n\
    \x05\x04\x1f\x02\x02\x03\x12\x04\xbd\x07\x1f\x20\n6\n\x02\x04\x20\x12\
    \x06\xc1\x07\0\xc8\x07\x01\x1a(\x20Request\x20for\x20the\x20UpdateSnapsh\
    ot\x20method.\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xc1\x07\x08\x1d\n,\n\x04\
    \x04\x20\x02\0\x12\x04\xc3\x07\x02\x18\x1a\x1e\x20The\x20updated\x20snap\
    shot\x20object.\n\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\xc3\x07\x02\n\n\r\
    \n\x05\x04\x20\x02\0\x01\x12\x04\xc3\x07\x0b\x13\n\r\n\x05\x04\x20\x02\0\
    \x03\x12\x04\xc3\x07\x16\x17\nl\n\x04\x04\x20\x02\x01\x12\x04\xc7\x07\
    \x02,\x1a^\x20Indicates\x20which\x20fields\x20in\x20the\x20provided\x20s\
    napshot\x20to\x20update.\n\x20Must\x20be\x20specified\x20and\x20non-empt\
    y.\n\n\r\n\x05\x04\x20\x02\x01\x06\x12\x04\xc7\x07\x02\x1b\n\r\n\x05\x04\
    \x20\x02\x01\x01\x12\x04\xc7\x07\x1c'\n\r\n\x05\x04\x20\x02\x01\x03\x12\
    \x04\xc7\x07*+\n\xca\x02\n\x02\x04!\x12\x06\xd0\x07\0\xe6\x07\x01\x1a\
    \xbb\x02\x20A\x20snapshot\x20resource.\x20Snapshots\x20are\x20used\x20in\
    \n\x20<a\x20href=\"https://cloud.google.com/pubsub/docs/replay-overview\
    \">Seek</a>\n\x20operations,\x20which\x20allow\n\x20you\x20to\x20manage\
    \x20message\x20acknowledgments\x20in\x20bulk.\x20That\x20is,\x20you\x20c\
    an\x20set\x20the\n\x20acknowledgment\x20state\x20of\x20messages\x20in\
    \x20an\x20existing\x20subscription\x20to\x20the\x20state\n\x20captured\
    \x20by\x20a\x20snapshot.\n\n\x0b\n\x03\x04!\x01\x12\x04\xd0\x07\x08\x10\
    \n)\n\x04\x04!\x02\0\x12\x04\xd2\x07\x02\x12\x1a\x1b\x20The\x20name\x20o\
    f\x20the\x20snapshot.\n\n\r\n\x05\x04!\x02\0\x05\x12\x04\xd2\x07\x02\x08\
    \n\r\n\x05\x04!\x02\0\x01\x12\x04\xd2\x07\t\r\n\r\n\x05\x04!\x02\0\x03\
    \x12\x04\xd2\x07\x10\x11\nU\n\x04\x04!\x02\x01\x12\x04\xd5\x07\x02\x13\
    \x1aG\x20The\x20name\x20of\x20the\x20topic\x20from\x20which\x20this\x20s\
    napshot\x20is\x20retaining\x20messages.\n\n\r\n\x05\x04!\x02\x01\x05\x12\
    \x04\xd5\x07\x02\x08\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xd5\x07\t\x0e\n\
    \r\n\x05\x04!\x02\x01\x03\x12\x04\xd5\x07\x11\x12\n\xd4\x05\n\x04\x04!\
    \x02\x02\x12\x04\xe1\x07\x02,\x1a\xc5\x05\x20The\x20snapshot\x20is\x20gu\
    aranteed\x20to\x20exist\x20up\x20until\x20this\x20time.\n\x20A\x20newly-\
    created\x20snapshot\x20expires\x20no\x20later\x20than\x207\x20days\x20fr\
    om\x20the\x20time\x20of\x20its\n\x20creation.\x20Its\x20exact\x20lifetim\
    e\x20is\x20determined\x20at\x20creation\x20by\x20the\x20existing\n\x20ba\
    cklog\x20in\x20the\x20source\x20subscription.\x20Specifically,\x20the\
    \x20lifetime\x20of\x20the\n\x20snapshot\x20is\x20`7\x20days\x20-\x20(age\
    \x20of\x20oldest\x20unacked\x20message\x20in\x20the\x20subscription)`.\n\
    \x20For\x20example,\x20consider\x20a\x20subscription\x20whose\x20oldest\
    \x20unacked\x20message\x20is\x203\x20days\n\x20old.\x20If\x20a\x20snapsh\
    ot\x20is\x20created\x20from\x20this\x20subscription,\x20the\x20snapshot\
    \x20--\x20which\n\x20will\x20always\x20capture\x20this\x203-day-old\x20b\
    acklog\x20as\x20long\x20as\x20the\x20snapshot\n\x20exists\x20--\x20will\
    \x20expire\x20in\x204\x20days.\x20The\x20service\x20will\x20refuse\x20to\
    \x20create\x20a\n\x20snapshot\x20that\x20would\x20expire\x20in\x20less\
    \x20than\x201\x20hour\x20after\x20creation.\n\n\r\n\x05\x04!\x02\x02\x06\
    \x12\x04\xe1\x07\x02\x1b\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xe1\x07\x1c'\
    \n\r\n\x05\x04!\x02\x02\x03\x12\x04\xe1\x07*+\nm\n\x04\x04!\x02\x03\x12\
    \x04\xe5\x07\x02!\x1a_\x20See\x20<a\x20href=\"https://cloud.google.com/p\
    ubsub/docs/labels\">\x20Creating\x20and\n\x20managing\x20labels</a>.\n\n\
    \r\n\x05\x04!\x02\x03\x06\x12\x04\xe5\x07\x02\x15\n\r\n\x05\x04!\x02\x03\
    \x01\x12\x04\xe5\x07\x16\x1c\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xe5\x07\
    \x1f\x20\n3\n\x02\x04\"\x12\x06\xe9\x07\0\xed\x07\x01\x1a%\x20Request\
    \x20for\x20the\x20GetSnapshot\x20method.\n\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xe9\x07\x08\x1a\nb\n\x04\x04\"\x02\0\x12\x04\xec\x07\x02\x16\x1aT\x20Th\
    e\x20name\x20of\x20the\x20snapshot\x20to\x20get.\n\x20Format\x20is\x20`p\
    rojects/{project}/snapshots/{snap}`.\n\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \xec\x07\x02\x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xec\x07\t\x11\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xec\x07\x14\x15\n7\n\x02\x04#\x12\x06\xf0\
    \x07\0\xfc\x07\x01\x1a)\x20Request\x20for\x20the\x20`ListSnapshots`\x20m\
    ethod.\n\n\x0b\n\x03\x04#\x01\x12\x04\xf0\x07\x08\x1c\ng\n\x04\x04#\x02\
    \0\x12\x04\xf3\x07\x02\x15\x1aY\x20The\x20name\x20of\x20the\x20project\
    \x20in\x20which\x20to\x20list\x20snapshots.\n\x20Format\x20is\x20`projec\
    ts/{project-id}`.\n\n\r\n\x05\x04#\x02\0\x05\x12\x04\xf3\x07\x02\x08\n\r\
    \n\x05\x04#\x02\0\x01\x12\x04\xf3\x07\t\x10\n\r\n\x05\x04#\x02\0\x03\x12\
    \x04\xf3\x07\x13\x14\n6\n\x04\x04#\x02\x01\x12\x04\xf6\x07\x02\x16\x1a(\
    \x20Maximum\x20number\x20of\x20snapshots\x20to\x20return.\n\n\r\n\x05\
    \x04#\x02\x01\x05\x12\x04\xf6\x07\x02\x07\n\r\n\x05\x04#\x02\x01\x01\x12\
    \x04\xf6\x07\x08\x11\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xf6\x07\x14\x15\
    \n\xca\x01\n\x04\x04#\x02\x02\x12\x04\xfb\x07\x02\x18\x1a\xbb\x01\x20The\
    \x20value\x20returned\x20by\x20the\x20last\x20`ListSnapshotsResponse`;\
    \x20indicates\x20that\x20this\n\x20is\x20a\x20continuation\x20of\x20a\
    \x20prior\x20`ListSnapshots`\x20call,\x20and\x20that\x20the\x20system\n\
    \x20should\x20return\x20the\x20next\x20page\x20of\x20data.\n\n\r\n\x05\
    \x04#\x02\x02\x05\x12\x04\xfb\x07\x02\x08\n\r\n\x05\x04#\x02\x02\x01\x12\
    \x04\xfb\x07\t\x13\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xfb\x07\x16\x17\n8\
    \n\x02\x04$\x12\x06\xff\x07\0\x86\x08\x01\x1a*\x20Response\x20for\x20the\
    \x20`ListSnapshots`\x20method.\n\n\x0b\n\x03\x04$\x01\x12\x04\xff\x07\
    \x08\x1d\n(\n\x04\x04$\x02\0\x12\x04\x81\x08\x02\"\x1a\x1a\x20The\x20res\
    ulting\x20snapshots.\n\n\r\n\x05\x04$\x02\0\x04\x12\x04\x81\x08\x02\n\n\
    \r\n\x05\x04$\x02\0\x06\x12\x04\x81\x08\x0b\x13\n\r\n\x05\x04$\x02\0\x01\
    \x12\x04\x81\x08\x14\x1d\n\r\n\x05\x04$\x02\0\x03\x12\x04\x81\x08\x20!\n\
    \x9e\x01\n\x04\x04$\x02\x01\x12\x04\x85\x08\x02\x1d\x1a\x8f\x01\x20If\
    \x20not\x20empty,\x20indicates\x20that\x20there\x20may\x20be\x20more\x20\
    snapshot\x20that\x20match\x20the\n\x20request;\x20this\x20value\x20shoul\
    d\x20be\x20passed\x20in\x20a\x20new\x20`ListSnapshotsRequest`.\n\n\r\n\
    \x05\x04$\x02\x01\x05\x12\x04\x85\x08\x02\x08\n\r\n\x05\x04$\x02\x01\x01\
    \x12\x04\x85\x08\t\x18\n\r\n\x05\x04$\x02\x01\x03\x12\x04\x85\x08\x1b\
    \x1c\n8\n\x02\x04%\x12\x06\x89\x08\0\x8d\x08\x01\x1a*\x20Request\x20for\
    \x20the\x20`DeleteSnapshot`\x20method.\n\n\x0b\n\x03\x04%\x01\x12\x04\
    \x89\x08\x08\x1d\ne\n\x04\x04%\x02\0\x12\x04\x8c\x08\x02\x16\x1aW\x20The\
    \x20name\x20of\x20the\x20snapshot\x20to\x20delete.\n\x20Format\x20is\x20\
    `projects/{project}/snapshots/{snap}`.\n\n\r\n\x05\x04%\x02\0\x05\x12\
    \x04\x8c\x08\x02\x08\n\r\n\x05\x04%\x02\0\x01\x12\x04\x8c\x08\t\x11\n\r\
    \n\x05\x04%\x02\0\x03\x12\x04\x8c\x08\x14\x15\n.\n\x02\x04&\x12\x06\x90\
    \x08\0\xa7\x08\x01\x1a\x20\x20Request\x20for\x20the\x20`Seek`\x20method.\
    \n\n\x0b\n\x03\x04&\x01\x12\x04\x90\x08\x08\x13\n+\n\x04\x04&\x02\0\x12\
    \x04\x92\x08\x02\x1a\x1a\x1d\x20The\x20subscription\x20to\x20affect.\n\n\
    \r\n\x05\x04&\x02\0\x05\x12\x04\x92\x08\x02\x08\n\r\n\x05\x04&\x02\0\x01\
    \x12\x04\x92\x08\t\x15\n\r\n\x05\x04&\x02\0\x03\x12\x04\x92\x08\x18\x19\
    \n\x0e\n\x04\x04&\x08\0\x12\x06\x94\x08\x02\xa6\x08\x03\n\r\n\x05\x04&\
    \x08\0\x01\x12\x04\x94\x08\x08\x0e\n\xbe\x05\n\x04\x04&\x02\x01\x12\x04\
    \xa0\x08\x04'\x1a\xaf\x05\x20The\x20time\x20to\x20seek\x20to.\n\x20Messa\
    ges\x20retained\x20in\x20the\x20subscription\x20that\x20were\x20publishe\
    d\x20before\x20this\n\x20time\x20are\x20marked\x20as\x20acknowledged,\
    \x20and\x20messages\x20retained\x20in\x20the\n\x20subscription\x20that\
    \x20were\x20published\x20after\x20this\x20time\x20are\x20marked\x20as\n\
    \x20unacknowledged.\x20Note\x20that\x20this\x20operation\x20affects\x20o\
    nly\x20those\x20messages\n\x20retained\x20in\x20the\x20subscription\x20(\
    configured\x20by\x20the\x20combination\x20of\n\x20`message_retention_dur\
    ation`\x20and\x20`retain_acked_messages`).\x20For\x20example,\n\x20if\
    \x20`time`\x20corresponds\x20to\x20a\x20point\x20before\x20the\x20messag\
    e\x20retention\n\x20window\x20(or\x20to\x20a\x20point\x20before\x20the\
    \x20system's\x20notion\x20of\x20the\x20subscription\n\x20creation\x20tim\
    e),\x20only\x20retained\x20messages\x20will\x20be\x20marked\x20as\x20una\
    cknowledged,\n\x20and\x20already-expunged\x20messages\x20will\x20not\x20\
    be\x20restored.\n\n\r\n\x05\x04&\x02\x01\x06\x12\x04\xa0\x08\x04\x1d\n\r\
    \n\x05\x04&\x02\x01\x01\x12\x04\xa0\x08\x1e\"\n\r\n\x05\x04&\x02\x01\x03\
    \x12\x04\xa0\x08%&\n\xa8\x01\n\x04\x04&\x02\x02\x12\x04\xa5\x08\x04\x18\
    \x1a\x99\x01\x20The\x20snapshot\x20to\x20seek\x20to.\x20The\x20snapshot'\
    s\x20topic\x20must\x20be\x20the\x20same\x20as\x20that\x20of\n\x20the\x20\
    provided\x20subscription.\n\x20Format\x20is\x20`projects/{project}/snaps\
    hots/{snap}`.\n\n\r\n\x05\x04&\x02\x02\x05\x12\x04\xa5\x08\x04\n\n\r\n\
    \x05\x04&\x02\x02\x01\x12\x04\xa5\x08\x0b\x13\n\r\n\x05\x04&\x02\x02\x03\
    \x12\x04\xa5\x08\x16\x17\nF\n\x02\x04'\x12\x04\xaa\x08\0\x17\x1a:\x20Res\
    ponse\x20for\x20the\x20`Seek`\x20method\x20(this\x20response\x20is\x20em\
    pty).\n\n\x0b\n\x03\x04'\x01\x12\x04\xaa\x08\x08\x14b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::client::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::field_mask::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(41);
            messages.push(MessageStoragePolicy::generated_message_descriptor_data());
            messages.push(Topic::generated_message_descriptor_data());
            messages.push(PubsubMessage::generated_message_descriptor_data());
            messages.push(GetTopicRequest::generated_message_descriptor_data());
            messages.push(UpdateTopicRequest::generated_message_descriptor_data());
            messages.push(PublishRequest::generated_message_descriptor_data());
            messages.push(PublishResponse::generated_message_descriptor_data());
            messages.push(ListTopicsRequest::generated_message_descriptor_data());
            messages.push(ListTopicsResponse::generated_message_descriptor_data());
            messages.push(ListTopicSubscriptionsRequest::generated_message_descriptor_data());
            messages.push(ListTopicSubscriptionsResponse::generated_message_descriptor_data());
            messages.push(ListTopicSnapshotsRequest::generated_message_descriptor_data());
            messages.push(ListTopicSnapshotsResponse::generated_message_descriptor_data());
            messages.push(DeleteTopicRequest::generated_message_descriptor_data());
            messages.push(Subscription::generated_message_descriptor_data());
            messages.push(DeadLetterPolicy::generated_message_descriptor_data());
            messages.push(ExpirationPolicy::generated_message_descriptor_data());
            messages.push(PushConfig::generated_message_descriptor_data());
            messages.push(ReceivedMessage::generated_message_descriptor_data());
            messages.push(GetSubscriptionRequest::generated_message_descriptor_data());
            messages.push(UpdateSubscriptionRequest::generated_message_descriptor_data());
            messages.push(ListSubscriptionsRequest::generated_message_descriptor_data());
            messages.push(ListSubscriptionsResponse::generated_message_descriptor_data());
            messages.push(DeleteSubscriptionRequest::generated_message_descriptor_data());
            messages.push(ModifyPushConfigRequest::generated_message_descriptor_data());
            messages.push(PullRequest::generated_message_descriptor_data());
            messages.push(PullResponse::generated_message_descriptor_data());
            messages.push(ModifyAckDeadlineRequest::generated_message_descriptor_data());
            messages.push(AcknowledgeRequest::generated_message_descriptor_data());
            messages.push(StreamingPullRequest::generated_message_descriptor_data());
            messages.push(StreamingPullResponse::generated_message_descriptor_data());
            messages.push(CreateSnapshotRequest::generated_message_descriptor_data());
            messages.push(UpdateSnapshotRequest::generated_message_descriptor_data());
            messages.push(Snapshot::generated_message_descriptor_data());
            messages.push(GetSnapshotRequest::generated_message_descriptor_data());
            messages.push(ListSnapshotsRequest::generated_message_descriptor_data());
            messages.push(ListSnapshotsResponse::generated_message_descriptor_data());
            messages.push(DeleteSnapshotRequest::generated_message_descriptor_data());
            messages.push(SeekRequest::generated_message_descriptor_data());
            messages.push(SeekResponse::generated_message_descriptor_data());
            messages.push(push_config::OidcToken::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
