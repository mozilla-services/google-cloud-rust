// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/asset/v1/asset_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyLongrunningMetadata {
    // message fields
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyLongrunningMetadata {
    fn default() -> &'a AnalyzeIamPolicyLongrunningMetadata {
        <AnalyzeIamPolicyLongrunningMetadata as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyLongrunningMetadata {
    pub fn new() -> AnalyzeIamPolicyLongrunningMetadata {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp create_time = 1;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyLongrunningMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyLongrunningMetadata {
        AnalyzeIamPolicyLongrunningMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &AnalyzeIamPolicyLongrunningMetadata| { &m.create_time },
                |m: &mut AnalyzeIamPolicyLongrunningMetadata| { &mut m.create_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyLongrunningMetadata>(
                "AnalyzeIamPolicyLongrunningMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyLongrunningMetadata {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyLongrunningMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyLongrunningMetadata::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyLongrunningMetadata {
    fn clear(&mut self) {
        self.create_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyLongrunningMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyLongrunningMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExportAssetsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    pub relationship_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportAssetsRequest {
    fn default() -> &'a ExportAssetsRequest {
        <ExportAssetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExportAssetsRequest {
    pub fn new() -> ExportAssetsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp read_time = 2;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 4;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // .google.cloud.asset.v1.OutputConfig output_config = 5;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }

    // repeated string relationship_types = 6;


    pub fn get_relationship_types(&self) -> &[::std::string::String] {
        &self.relationship_types
    }
    pub fn clear_relationship_types(&mut self) {
        self.relationship_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_relationship_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.relationship_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relationship_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.relationship_types
    }

    // Take field
    pub fn take_relationship_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.relationship_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExportAssetsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.relationship_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.content_type);
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.relationship_types {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.relationship_types {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportAssetsRequest {
        ExportAssetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ExportAssetsRequest| { &m.parent },
                |m: &mut ExportAssetsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ExportAssetsRequest| { &m.read_time },
                |m: &mut ExportAssetsRequest| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &ExportAssetsRequest| { &m.asset_types },
                |m: &mut ExportAssetsRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &ExportAssetsRequest| { &m.content_type },
                |m: &mut ExportAssetsRequest| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &ExportAssetsRequest| { &m.output_config },
                |m: &mut ExportAssetsRequest| { &mut m.output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relationship_types",
                |m: &ExportAssetsRequest| { &m.relationship_types },
                |m: &mut ExportAssetsRequest| { &mut m.relationship_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExportAssetsRequest>(
                "ExportAssetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExportAssetsRequest {
        static instance: ::protobuf::rt::LazyV2<ExportAssetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExportAssetsRequest::new)
    }
}

impl ::protobuf::Clear for ExportAssetsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.read_time.clear();
        self.asset_types.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.output_config.clear();
        self.relationship_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportAssetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportAssetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExportAssetsResponse {
    // message fields
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    pub output_result: ::protobuf::SingularPtrField<OutputResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportAssetsResponse {
    fn default() -> &'a ExportAssetsResponse {
        <ExportAssetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExportAssetsResponse {
    pub fn new() -> ExportAssetsResponse {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp read_time = 1;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.cloud.asset.v1.OutputConfig output_config = 2;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }

    // .google.cloud.asset.v1.OutputResult output_result = 3;


    pub fn get_output_result(&self) -> &OutputResult {
        self.output_result.as_ref().unwrap_or_else(|| <OutputResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_result(&mut self) {
        self.output_result.clear();
    }

    pub fn has_output_result(&self) -> bool {
        self.output_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_result(&mut self, v: OutputResult) {
        self.output_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_result(&mut self) -> &mut OutputResult {
        if self.output_result.is_none() {
            self.output_result.set_default();
        }
        self.output_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_result(&mut self) -> OutputResult {
        self.output_result.take().unwrap_or_else(|| OutputResult::new())
    }
}

impl ::protobuf::Message for ExportAssetsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportAssetsResponse {
        ExportAssetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ExportAssetsResponse| { &m.read_time },
                |m: &mut ExportAssetsResponse| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &ExportAssetsResponse| { &m.output_config },
                |m: &mut ExportAssetsResponse| { &mut m.output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputResult>>(
                "output_result",
                |m: &ExportAssetsResponse| { &m.output_result },
                |m: &mut ExportAssetsResponse| { &mut m.output_result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExportAssetsResponse>(
                "ExportAssetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExportAssetsResponse {
        static instance: ::protobuf::rt::LazyV2<ExportAssetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExportAssetsResponse::new)
    }
}

impl ::protobuf::Clear for ExportAssetsResponse {
    fn clear(&mut self) {
        self.read_time.clear();
        self.output_config.clear();
        self.output_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportAssetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportAssetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAssetsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub relationship_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAssetsRequest {
    fn default() -> &'a ListAssetsRequest {
        <ListAssetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAssetsRequest {
    pub fn new() -> ListAssetsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp read_time = 2;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 4;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // int32 page_size = 5;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 6;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // repeated string relationship_types = 7;


    pub fn get_relationship_types(&self) -> &[::std::string::String] {
        &self.relationship_types
    }
    pub fn clear_relationship_types(&mut self) {
        self.relationship_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_relationship_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.relationship_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relationship_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.relationship_types
    }

    // Take field
    pub fn take_relationship_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.relationship_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListAssetsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.relationship_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.content_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.page_token);
        }
        for value in &self.relationship_types {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if self.page_size != 0 {
            os.write_int32(5, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(6, &self.page_token)?;
        }
        for v in &self.relationship_types {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAssetsRequest {
        ListAssetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListAssetsRequest| { &m.parent },
                |m: &mut ListAssetsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ListAssetsRequest| { &m.read_time },
                |m: &mut ListAssetsRequest| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &ListAssetsRequest| { &m.asset_types },
                |m: &mut ListAssetsRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &ListAssetsRequest| { &m.content_type },
                |m: &mut ListAssetsRequest| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListAssetsRequest| { &m.page_size },
                |m: &mut ListAssetsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListAssetsRequest| { &m.page_token },
                |m: &mut ListAssetsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relationship_types",
                |m: &ListAssetsRequest| { &m.relationship_types },
                |m: &mut ListAssetsRequest| { &mut m.relationship_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAssetsRequest>(
                "ListAssetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAssetsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAssetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAssetsRequest::new)
    }
}

impl ::protobuf::Clear for ListAssetsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.read_time.clear();
        self.asset_types.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.page_size = 0;
        self.page_token.clear();
        self.relationship_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAssetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAssetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAssetsResponse {
    // message fields
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub assets: ::protobuf::RepeatedField<super::assets::Asset>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAssetsResponse {
    fn default() -> &'a ListAssetsResponse {
        <ListAssetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListAssetsResponse {
    pub fn new() -> ListAssetsResponse {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp read_time = 1;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .google.cloud.asset.v1.Asset assets = 2;


    pub fn get_assets(&self) -> &[super::assets::Asset] {
        &self.assets
    }
    pub fn clear_assets(&mut self) {
        self.assets.clear();
    }

    // Param is passed by value, moved
    pub fn set_assets(&mut self, v: ::protobuf::RepeatedField<super::assets::Asset>) {
        self.assets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assets(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::Asset> {
        &mut self.assets
    }

    // Take field
    pub fn take_assets(&mut self) -> ::protobuf::RepeatedField<super::assets::Asset> {
        ::std::mem::replace(&mut self.assets, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAssetsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assets)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.assets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.assets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAssetsResponse {
        ListAssetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ListAssetsResponse| { &m.read_time },
                |m: &mut ListAssetsResponse| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::Asset>>(
                "assets",
                |m: &ListAssetsResponse| { &m.assets },
                |m: &mut ListAssetsResponse| { &mut m.assets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListAssetsResponse| { &m.next_page_token },
                |m: &mut ListAssetsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAssetsResponse>(
                "ListAssetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAssetsResponse {
        static instance: ::protobuf::rt::LazyV2<ListAssetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAssetsResponse::new)
    }
}

impl ::protobuf::Clear for ListAssetsResponse {
    fn clear(&mut self) {
        self.read_time.clear();
        self.assets.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAssetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAssetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetAssetsHistoryRequest {
    // message fields
    pub parent: ::std::string::String,
    pub asset_names: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub read_time_window: ::protobuf::SingularPtrField<super::assets::TimeWindow>,
    pub relationship_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetAssetsHistoryRequest {
    fn default() -> &'a BatchGetAssetsHistoryRequest {
        <BatchGetAssetsHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetAssetsHistoryRequest {
    pub fn new() -> BatchGetAssetsHistoryRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // repeated string asset_names = 2;


    pub fn get_asset_names(&self) -> &[::std::string::String] {
        &self.asset_names
    }
    pub fn clear_asset_names(&mut self) {
        self.asset_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_names
    }

    // Take field
    pub fn take_asset_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_names, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 3;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // .google.cloud.asset.v1.TimeWindow read_time_window = 4;


    pub fn get_read_time_window(&self) -> &super::assets::TimeWindow {
        self.read_time_window.as_ref().unwrap_or_else(|| <super::assets::TimeWindow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time_window(&mut self) {
        self.read_time_window.clear();
    }

    pub fn has_read_time_window(&self) -> bool {
        self.read_time_window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time_window(&mut self, v: super::assets::TimeWindow) {
        self.read_time_window = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time_window(&mut self) -> &mut super::assets::TimeWindow {
        if self.read_time_window.is_none() {
            self.read_time_window.set_default();
        }
        self.read_time_window.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time_window(&mut self) -> super::assets::TimeWindow {
        self.read_time_window.take().unwrap_or_else(|| super::assets::TimeWindow::new())
    }

    // repeated string relationship_types = 5;


    pub fn get_relationship_types(&self) -> &[::std::string::String] {
        &self.relationship_types
    }
    pub fn clear_relationship_types(&mut self) {
        self.relationship_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_relationship_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.relationship_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relationship_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.relationship_types
    }

    // Take field
    pub fn take_relationship_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.relationship_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetAssetsHistoryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time_window {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_names)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time_window)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.relationship_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        for value in &self.asset_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.content_type);
        }
        if let Some(ref v) = self.read_time_window.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.relationship_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        for v in &self.asset_names {
            os.write_string(2, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if let Some(ref v) = self.read_time_window.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.relationship_types {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetAssetsHistoryRequest {
        BatchGetAssetsHistoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &BatchGetAssetsHistoryRequest| { &m.parent },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_names",
                |m: &BatchGetAssetsHistoryRequest| { &m.asset_names },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.asset_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &BatchGetAssetsHistoryRequest| { &m.content_type },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::TimeWindow>>(
                "read_time_window",
                |m: &BatchGetAssetsHistoryRequest| { &m.read_time_window },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.read_time_window },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relationship_types",
                |m: &BatchGetAssetsHistoryRequest| { &m.relationship_types },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.relationship_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetAssetsHistoryRequest>(
                "BatchGetAssetsHistoryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetAssetsHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<BatchGetAssetsHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetAssetsHistoryRequest::new)
    }
}

impl ::protobuf::Clear for BatchGetAssetsHistoryRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.asset_names.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.read_time_window.clear();
        self.relationship_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetAssetsHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetAssetsHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetAssetsHistoryResponse {
    // message fields
    pub assets: ::protobuf::RepeatedField<super::assets::TemporalAsset>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetAssetsHistoryResponse {
    fn default() -> &'a BatchGetAssetsHistoryResponse {
        <BatchGetAssetsHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetAssetsHistoryResponse {
    pub fn new() -> BatchGetAssetsHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.TemporalAsset assets = 1;


    pub fn get_assets(&self) -> &[super::assets::TemporalAsset] {
        &self.assets
    }
    pub fn clear_assets(&mut self) {
        self.assets.clear();
    }

    // Param is passed by value, moved
    pub fn set_assets(&mut self, v: ::protobuf::RepeatedField<super::assets::TemporalAsset>) {
        self.assets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assets(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::TemporalAsset> {
        &mut self.assets
    }

    // Take field
    pub fn take_assets(&mut self) -> ::protobuf::RepeatedField<super::assets::TemporalAsset> {
        ::std::mem::replace(&mut self.assets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetAssetsHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.assets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.assets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.assets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetAssetsHistoryResponse {
        BatchGetAssetsHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::TemporalAsset>>(
                "assets",
                |m: &BatchGetAssetsHistoryResponse| { &m.assets },
                |m: &mut BatchGetAssetsHistoryResponse| { &mut m.assets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetAssetsHistoryResponse>(
                "BatchGetAssetsHistoryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetAssetsHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<BatchGetAssetsHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetAssetsHistoryResponse::new)
    }
}

impl ::protobuf::Clear for BatchGetAssetsHistoryResponse {
    fn clear(&mut self) {
        self.assets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetAssetsHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetAssetsHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFeedRequest {
    // message fields
    pub parent: ::std::string::String,
    pub feed_id: ::std::string::String,
    pub feed: ::protobuf::SingularPtrField<Feed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFeedRequest {
    fn default() -> &'a CreateFeedRequest {
        <CreateFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateFeedRequest {
    pub fn new() -> CreateFeedRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string feed_id = 2;


    pub fn get_feed_id(&self) -> &str {
        &self.feed_id
    }
    pub fn clear_feed_id(&mut self) {
        self.feed_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_id(&mut self, v: ::std::string::String) {
        self.feed_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_id(&mut self) -> &mut ::std::string::String {
        &mut self.feed_id
    }

    // Take field
    pub fn take_feed_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feed_id, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.Feed feed = 3;


    pub fn get_feed(&self) -> &Feed {
        self.feed.as_ref().unwrap_or_else(|| <Feed as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feed(&mut self) {
        self.feed.clear();
    }

    pub fn has_feed(&self) -> bool {
        self.feed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed(&mut self, v: Feed) {
        self.feed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed(&mut self) -> &mut Feed {
        if self.feed.is_none() {
            self.feed.set_default();
        }
        self.feed.as_mut().unwrap()
    }

    // Take field
    pub fn take_feed(&mut self) -> Feed {
        self.feed.take().unwrap_or_else(|| Feed::new())
    }
}

impl ::protobuf::Message for CreateFeedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.feed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feed_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.feed_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.feed_id);
        }
        if let Some(ref v) = self.feed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.feed_id.is_empty() {
            os.write_string(2, &self.feed_id)?;
        }
        if let Some(ref v) = self.feed.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFeedRequest {
        CreateFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateFeedRequest| { &m.parent },
                |m: &mut CreateFeedRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "feed_id",
                |m: &CreateFeedRequest| { &m.feed_id },
                |m: &mut CreateFeedRequest| { &mut m.feed_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feed>>(
                "feed",
                |m: &CreateFeedRequest| { &m.feed },
                |m: &mut CreateFeedRequest| { &mut m.feed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFeedRequest>(
                "CreateFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateFeedRequest {
        static instance: ::protobuf::rt::LazyV2<CreateFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateFeedRequest::new)
    }
}

impl ::protobuf::Clear for CreateFeedRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.feed_id.clear();
        self.feed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRequest {
    fn default() -> &'a GetFeedRequest {
        <GetFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRequest {
    pub fn new() -> GetFeedRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFeedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRequest {
        GetFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetFeedRequest| { &m.name },
                |m: &mut GetFeedRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRequest>(
                "GetFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFeedRequest {
        static instance: ::protobuf::rt::LazyV2<GetFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFeedRequest::new)
    }
}

impl ::protobuf::Clear for GetFeedRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFeedsRequest {
    // message fields
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFeedsRequest {
    fn default() -> &'a ListFeedsRequest {
        <ListFeedsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListFeedsRequest {
    pub fn new() -> ListFeedsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListFeedsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFeedsRequest {
        ListFeedsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListFeedsRequest| { &m.parent },
                |m: &mut ListFeedsRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListFeedsRequest>(
                "ListFeedsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListFeedsRequest {
        static instance: ::protobuf::rt::LazyV2<ListFeedsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListFeedsRequest::new)
    }
}

impl ::protobuf::Clear for ListFeedsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFeedsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFeedsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFeedsResponse {
    // message fields
    pub feeds: ::protobuf::RepeatedField<Feed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFeedsResponse {
    fn default() -> &'a ListFeedsResponse {
        <ListFeedsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListFeedsResponse {
    pub fn new() -> ListFeedsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.Feed feeds = 1;


    pub fn get_feeds(&self) -> &[Feed] {
        &self.feeds
    }
    pub fn clear_feeds(&mut self) {
        self.feeds.clear();
    }

    // Param is passed by value, moved
    pub fn set_feeds(&mut self, v: ::protobuf::RepeatedField<Feed>) {
        self.feeds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feeds(&mut self) -> &mut ::protobuf::RepeatedField<Feed> {
        &mut self.feeds
    }

    // Take field
    pub fn take_feeds(&mut self) -> ::protobuf::RepeatedField<Feed> {
        ::std::mem::replace(&mut self.feeds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListFeedsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.feeds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.feeds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.feeds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.feeds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFeedsResponse {
        ListFeedsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feed>>(
                "feeds",
                |m: &ListFeedsResponse| { &m.feeds },
                |m: &mut ListFeedsResponse| { &mut m.feeds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListFeedsResponse>(
                "ListFeedsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListFeedsResponse {
        static instance: ::protobuf::rt::LazyV2<ListFeedsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListFeedsResponse::new)
    }
}

impl ::protobuf::Clear for ListFeedsResponse {
    fn clear(&mut self) {
        self.feeds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFeedsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFeedsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateFeedRequest {
    // message fields
    pub feed: ::protobuf::SingularPtrField<Feed>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateFeedRequest {
    fn default() -> &'a UpdateFeedRequest {
        <UpdateFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateFeedRequest {
    pub fn new() -> UpdateFeedRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.Feed feed = 1;


    pub fn get_feed(&self) -> &Feed {
        self.feed.as_ref().unwrap_or_else(|| <Feed as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feed(&mut self) {
        self.feed.clear();
    }

    pub fn has_feed(&self) -> bool {
        self.feed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed(&mut self, v: Feed) {
        self.feed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed(&mut self) -> &mut Feed {
        if self.feed.is_none() {
            self.feed.set_default();
        }
        self.feed.as_mut().unwrap()
    }

    // Take field
    pub fn take_feed(&mut self) -> Feed {
        self.feed.take().unwrap_or_else(|| Feed::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateFeedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.feed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.feed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.feed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateFeedRequest {
        UpdateFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feed>>(
                "feed",
                |m: &UpdateFeedRequest| { &m.feed },
                |m: &mut UpdateFeedRequest| { &mut m.feed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateFeedRequest| { &m.update_mask },
                |m: &mut UpdateFeedRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateFeedRequest>(
                "UpdateFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateFeedRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateFeedRequest::new)
    }
}

impl ::protobuf::Clear for UpdateFeedRequest {
    fn clear(&mut self) {
        self.feed.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteFeedRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteFeedRequest {
    fn default() -> &'a DeleteFeedRequest {
        <DeleteFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteFeedRequest {
    pub fn new() -> DeleteFeedRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteFeedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteFeedRequest {
        DeleteFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteFeedRequest| { &m.name },
                |m: &mut DeleteFeedRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteFeedRequest>(
                "DeleteFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteFeedRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteFeedRequest::new)
    }
}

impl ::protobuf::Clear for DeleteFeedRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputConfig {
    // message oneof groups
    pub destination: ::std::option::Option<OutputConfig_oneof_destination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputConfig {
    fn default() -> &'a OutputConfig {
        <OutputConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OutputConfig_oneof_destination {
    gcs_destination(GcsDestination),
    bigquery_destination(BigQueryDestination),
}

impl OutputConfig {
    pub fn new() -> OutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.GcsDestination gcs_destination = 1;


    pub fn get_gcs_destination(&self) -> &GcsDestination {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(ref v)) => v,
            _ => <GcsDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_gcs_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_destination(&mut self, v: GcsDestination) {
        self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_destination(&mut self) -> &mut GcsDestination {
        if let ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(GcsDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_destination(&mut self) -> GcsDestination {
        if self.has_gcs_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            GcsDestination::new()
        }
    }

    // .google.cloud.asset.v1.BigQueryDestination bigquery_destination = 2;


    pub fn get_bigquery_destination(&self) -> &BigQueryDestination {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(ref v)) => v,
            _ => <BigQueryDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bigquery_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_bigquery_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bigquery_destination(&mut self, v: BigQueryDestination) {
        self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bigquery_destination(&mut self) -> &mut BigQueryDestination {
        if let ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(BigQueryDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bigquery_destination(&mut self) -> BigQueryDestination {
        if self.has_bigquery_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            BigQueryDestination::new()
        }
    }
}

impl ::protobuf::Message for OutputConfig {
    fn is_initialized(&self) -> bool {
        if let Some(OutputConfig_oneof_destination::gcs_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OutputConfig_oneof_destination::bigquery_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &OutputConfig_oneof_destination::gcs_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &OutputConfig_oneof_destination::gcs_destination(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputConfig {
        OutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GcsDestination>(
                "gcs_destination",
                OutputConfig::has_gcs_destination,
                OutputConfig::get_gcs_destination,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BigQueryDestination>(
                "bigquery_destination",
                OutputConfig::has_bigquery_destination,
                OutputConfig::get_bigquery_destination,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputConfig>(
                "OutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputConfig {
        static instance: ::protobuf::rt::LazyV2<OutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputConfig::new)
    }
}

impl ::protobuf::Clear for OutputConfig {
    fn clear(&mut self) {
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputResult {
    // message oneof groups
    pub result: ::std::option::Option<OutputResult_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputResult {
    fn default() -> &'a OutputResult {
        <OutputResult as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OutputResult_oneof_result {
    gcs_result(GcsOutputResult),
}

impl OutputResult {
    pub fn new() -> OutputResult {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.GcsOutputResult gcs_result = 1;


    pub fn get_gcs_result(&self) -> &GcsOutputResult {
        match self.result {
            ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(ref v)) => v,
            _ => <GcsOutputResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_gcs_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_result(&mut self, v: GcsOutputResult) {
        self.result = ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_result(&mut self) -> &mut GcsOutputResult {
        if let ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(GcsOutputResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_result(&mut self) -> GcsOutputResult {
        if self.has_gcs_result() {
            match self.result.take() {
                ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GcsOutputResult::new()
        }
    }
}

impl ::protobuf::Message for OutputResult {
    fn is_initialized(&self) -> bool {
        if let Some(OutputResult_oneof_result::gcs_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &OutputResult_oneof_result::gcs_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &OutputResult_oneof_result::gcs_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputResult {
        OutputResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GcsOutputResult>(
                "gcs_result",
                OutputResult::has_gcs_result,
                OutputResult::get_gcs_result,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputResult>(
                "OutputResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputResult {
        static instance: ::protobuf::rt::LazyV2<OutputResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputResult::new)
    }
}

impl ::protobuf::Clear for OutputResult {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsOutputResult {
    // message fields
    pub uris: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsOutputResult {
    fn default() -> &'a GcsOutputResult {
        <GcsOutputResult as ::protobuf::Message>::default_instance()
    }
}

impl GcsOutputResult {
    pub fn new() -> GcsOutputResult {
        ::std::default::Default::default()
    }

    // repeated string uris = 1;


    pub fn get_uris(&self) -> &[::std::string::String] {
        &self.uris
    }
    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GcsOutputResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uris)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uris {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uris {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsOutputResult {
        GcsOutputResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uris",
                |m: &GcsOutputResult| { &m.uris },
                |m: &mut GcsOutputResult| { &mut m.uris },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsOutputResult>(
                "GcsOutputResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsOutputResult {
        static instance: ::protobuf::rt::LazyV2<GcsOutputResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsOutputResult::new)
    }
}

impl ::protobuf::Clear for GcsOutputResult {
    fn clear(&mut self) {
        self.uris.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsOutputResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsOutputResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsDestination {
    // message oneof groups
    pub object_uri: ::std::option::Option<GcsDestination_oneof_object_uri>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsDestination {
    fn default() -> &'a GcsDestination {
        <GcsDestination as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GcsDestination_oneof_object_uri {
    uri(::std::string::String),
    uri_prefix(::std::string::String),
}

impl GcsDestination {
    pub fn new() -> GcsDestination {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_uri(&mut self) {
        self.object_uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(_)) = self.object_uri {
        } else {
            self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(::std::string::String::new()));
        }
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        if self.has_uri() {
            match self.object_uri.take() {
                ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string uri_prefix = 2;


    pub fn get_uri_prefix(&self) -> &str {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_uri_prefix(&mut self) {
        self.object_uri = ::std::option::Option::None;
    }

    pub fn has_uri_prefix(&self) -> bool {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri_prefix(&mut self, v: ::std::string::String) {
        self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri_prefix(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(_)) = self.object_uri {
        } else {
            self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(::std::string::String::new()));
        }
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri_prefix(&mut self) -> ::std::string::String {
        if self.has_uri_prefix() {
            match self.object_uri.take() {
                ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for GcsDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.object_uri {
            match v {
                &GcsDestination_oneof_object_uri::uri(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &GcsDestination_oneof_object_uri::uri_prefix(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.object_uri {
            match v {
                &GcsDestination_oneof_object_uri::uri(ref v) => {
                    os.write_string(1, v)?;
                },
                &GcsDestination_oneof_object_uri::uri_prefix(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsDestination {
        GcsDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "uri",
                GcsDestination::has_uri,
                GcsDestination::get_uri,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "uri_prefix",
                GcsDestination::has_uri_prefix,
                GcsDestination::get_uri_prefix,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsDestination>(
                "GcsDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsDestination {
        static instance: ::protobuf::rt::LazyV2<GcsDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsDestination::new)
    }
}

impl ::protobuf::Clear for GcsDestination {
    fn clear(&mut self) {
        self.object_uri = ::std::option::Option::None;
        self.object_uri = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BigQueryDestination {
    // message fields
    pub dataset: ::std::string::String,
    pub table: ::std::string::String,
    pub force: bool,
    pub partition_spec: ::protobuf::SingularPtrField<PartitionSpec>,
    pub separate_tables_per_asset_type: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BigQueryDestination {
    fn default() -> &'a BigQueryDestination {
        <BigQueryDestination as ::protobuf::Message>::default_instance()
    }
}

impl BigQueryDestination {
    pub fn new() -> BigQueryDestination {
        ::std::default::Default::default()
    }

    // string dataset = 1;


    pub fn get_dataset(&self) -> &str {
        &self.dataset
    }
    pub fn clear_dataset(&mut self) {
        self.dataset.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset(&mut self, v: ::std::string::String) {
        self.dataset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset(&mut self) -> &mut ::std::string::String {
        &mut self.dataset
    }

    // Take field
    pub fn take_dataset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset, ::std::string::String::new())
    }

    // string table = 2;


    pub fn get_table(&self) -> &str {
        &self.table
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }

    // bool force = 3;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    // .google.cloud.asset.v1.PartitionSpec partition_spec = 4;


    pub fn get_partition_spec(&self) -> &PartitionSpec {
        self.partition_spec.as_ref().unwrap_or_else(|| <PartitionSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_partition_spec(&mut self) {
        self.partition_spec.clear();
    }

    pub fn has_partition_spec(&self) -> bool {
        self.partition_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_spec(&mut self, v: PartitionSpec) {
        self.partition_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_spec(&mut self) -> &mut PartitionSpec {
        if self.partition_spec.is_none() {
            self.partition_spec.set_default();
        }
        self.partition_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_spec(&mut self) -> PartitionSpec {
        self.partition_spec.take().unwrap_or_else(|| PartitionSpec::new())
    }

    // bool separate_tables_per_asset_type = 5;


    pub fn get_separate_tables_per_asset_type(&self) -> bool {
        self.separate_tables_per_asset_type
    }
    pub fn clear_separate_tables_per_asset_type(&mut self) {
        self.separate_tables_per_asset_type = false;
    }

    // Param is passed by value, moved
    pub fn set_separate_tables_per_asset_type(&mut self, v: bool) {
        self.separate_tables_per_asset_type = v;
    }
}

impl ::protobuf::Message for BigQueryDestination {
    fn is_initialized(&self) -> bool {
        for v in &self.partition_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.partition_spec)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.separate_tables_per_asset_type = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataset.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset);
        }
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table);
        }
        if self.force != false {
            my_size += 2;
        }
        if let Some(ref v) = self.partition_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.separate_tables_per_asset_type != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dataset.is_empty() {
            os.write_string(1, &self.dataset)?;
        }
        if !self.table.is_empty() {
            os.write_string(2, &self.table)?;
        }
        if self.force != false {
            os.write_bool(3, self.force)?;
        }
        if let Some(ref v) = self.partition_spec.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.separate_tables_per_asset_type != false {
            os.write_bool(5, self.separate_tables_per_asset_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BigQueryDestination {
        BigQueryDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset",
                |m: &BigQueryDestination| { &m.dataset },
                |m: &mut BigQueryDestination| { &mut m.dataset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table",
                |m: &BigQueryDestination| { &m.table },
                |m: &mut BigQueryDestination| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force",
                |m: &BigQueryDestination| { &m.force },
                |m: &mut BigQueryDestination| { &mut m.force },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PartitionSpec>>(
                "partition_spec",
                |m: &BigQueryDestination| { &m.partition_spec },
                |m: &mut BigQueryDestination| { &mut m.partition_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "separate_tables_per_asset_type",
                |m: &BigQueryDestination| { &m.separate_tables_per_asset_type },
                |m: &mut BigQueryDestination| { &mut m.separate_tables_per_asset_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BigQueryDestination>(
                "BigQueryDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BigQueryDestination {
        static instance: ::protobuf::rt::LazyV2<BigQueryDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BigQueryDestination::new)
    }
}

impl ::protobuf::Clear for BigQueryDestination {
    fn clear(&mut self) {
        self.dataset.clear();
        self.table.clear();
        self.force = false;
        self.partition_spec.clear();
        self.separate_tables_per_asset_type = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BigQueryDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BigQueryDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartitionSpec {
    // message fields
    pub partition_key: PartitionSpec_PartitionKey,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PartitionSpec {
    fn default() -> &'a PartitionSpec {
        <PartitionSpec as ::protobuf::Message>::default_instance()
    }
}

impl PartitionSpec {
    pub fn new() -> PartitionSpec {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.PartitionSpec.PartitionKey partition_key = 1;


    pub fn get_partition_key(&self) -> PartitionSpec_PartitionKey {
        self.partition_key
    }
    pub fn clear_partition_key(&mut self) {
        self.partition_key = PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: PartitionSpec_PartitionKey) {
        self.partition_key = v;
    }
}

impl ::protobuf::Message for PartitionSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.partition_key, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.partition_key != PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.partition_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.partition_key != PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.partition_key))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartitionSpec {
        PartitionSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartitionSpec_PartitionKey>>(
                "partition_key",
                |m: &PartitionSpec| { &m.partition_key },
                |m: &mut PartitionSpec| { &mut m.partition_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PartitionSpec>(
                "PartitionSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PartitionSpec {
        static instance: ::protobuf::rt::LazyV2<PartitionSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PartitionSpec::new)
    }
}

impl ::protobuf::Clear for PartitionSpec {
    fn clear(&mut self) {
        self.partition_key = PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartitionSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartitionSpec_PartitionKey {
    PARTITION_KEY_UNSPECIFIED = 0,
    READ_TIME = 1,
    REQUEST_TIME = 2,
}

impl ::protobuf::ProtobufEnum for PartitionSpec_PartitionKey {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartitionSpec_PartitionKey> {
        match value {
            0 => ::std::option::Option::Some(PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED),
            1 => ::std::option::Option::Some(PartitionSpec_PartitionKey::READ_TIME),
            2 => ::std::option::Option::Some(PartitionSpec_PartitionKey::REQUEST_TIME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartitionSpec_PartitionKey] = &[
            PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED,
            PartitionSpec_PartitionKey::READ_TIME,
            PartitionSpec_PartitionKey::REQUEST_TIME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PartitionSpec_PartitionKey>("PartitionSpec.PartitionKey", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PartitionSpec_PartitionKey {
}

impl ::std::default::Default for PartitionSpec_PartitionKey {
    fn default() -> Self {
        PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionSpec_PartitionKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PubsubDestination {
    // message fields
    pub topic: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubsubDestination {
    fn default() -> &'a PubsubDestination {
        <PubsubDestination as ::protobuf::Message>::default_instance()
    }
}

impl PubsubDestination {
    pub fn new() -> PubsubDestination {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PubsubDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubsubDestination {
        PubsubDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &PubsubDestination| { &m.topic },
                |m: &mut PubsubDestination| { &mut m.topic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PubsubDestination>(
                "PubsubDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PubsubDestination {
        static instance: ::protobuf::rt::LazyV2<PubsubDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PubsubDestination::new)
    }
}

impl ::protobuf::Clear for PubsubDestination {
    fn clear(&mut self) {
        self.topic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubsubDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubsubDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeedOutputConfig {
    // message oneof groups
    pub destination: ::std::option::Option<FeedOutputConfig_oneof_destination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeedOutputConfig {
    fn default() -> &'a FeedOutputConfig {
        <FeedOutputConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FeedOutputConfig_oneof_destination {
    pubsub_destination(PubsubDestination),
}

impl FeedOutputConfig {
    pub fn new() -> FeedOutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.PubsubDestination pubsub_destination = 1;


    pub fn get_pubsub_destination(&self) -> &PubsubDestination {
        match self.destination {
            ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(ref v)) => v,
            _ => <PubsubDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pubsub_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_pubsub_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pubsub_destination(&mut self, v: PubsubDestination) {
        self.destination = ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pubsub_destination(&mut self) -> &mut PubsubDestination {
        if let ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(PubsubDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pubsub_destination(&mut self) -> PubsubDestination {
        if self.has_pubsub_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            PubsubDestination::new()
        }
    }
}

impl ::protobuf::Message for FeedOutputConfig {
    fn is_initialized(&self) -> bool {
        if let Some(FeedOutputConfig_oneof_destination::pubsub_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &FeedOutputConfig_oneof_destination::pubsub_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &FeedOutputConfig_oneof_destination::pubsub_destination(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeedOutputConfig {
        FeedOutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PubsubDestination>(
                "pubsub_destination",
                FeedOutputConfig::has_pubsub_destination,
                FeedOutputConfig::get_pubsub_destination,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeedOutputConfig>(
                "FeedOutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeedOutputConfig {
        static instance: ::protobuf::rt::LazyV2<FeedOutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeedOutputConfig::new)
    }
}

impl ::protobuf::Clear for FeedOutputConfig {
    fn clear(&mut self) {
        self.destination = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeedOutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedOutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Feed {
    // message fields
    pub name: ::std::string::String,
    pub asset_names: ::protobuf::RepeatedField<::std::string::String>,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub feed_output_config: ::protobuf::SingularPtrField<FeedOutputConfig>,
    pub condition: ::protobuf::SingularPtrField<super::expr::Expr>,
    pub relationship_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Feed {
    fn default() -> &'a Feed {
        <Feed as ::protobuf::Message>::default_instance()
    }
}

impl Feed {
    pub fn new() -> Feed {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string asset_names = 2;


    pub fn get_asset_names(&self) -> &[::std::string::String] {
        &self.asset_names
    }
    pub fn clear_asset_names(&mut self) {
        self.asset_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_names
    }

    // Take field
    pub fn take_asset_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_names, ::protobuf::RepeatedField::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 4;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // .google.cloud.asset.v1.FeedOutputConfig feed_output_config = 5;


    pub fn get_feed_output_config(&self) -> &FeedOutputConfig {
        self.feed_output_config.as_ref().unwrap_or_else(|| <FeedOutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feed_output_config(&mut self) {
        self.feed_output_config.clear();
    }

    pub fn has_feed_output_config(&self) -> bool {
        self.feed_output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed_output_config(&mut self, v: FeedOutputConfig) {
        self.feed_output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_output_config(&mut self) -> &mut FeedOutputConfig {
        if self.feed_output_config.is_none() {
            self.feed_output_config.set_default();
        }
        self.feed_output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_feed_output_config(&mut self) -> FeedOutputConfig {
        self.feed_output_config.take().unwrap_or_else(|| FeedOutputConfig::new())
    }

    // .google.type.Expr condition = 6;


    pub fn get_condition(&self) -> &super::expr::Expr {
        self.condition.as_ref().unwrap_or_else(|| <super::expr::Expr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: super::expr::Expr) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut super::expr::Expr {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> super::expr::Expr {
        self.condition.take().unwrap_or_else(|| super::expr::Expr::new())
    }

    // repeated string relationship_types = 7;


    pub fn get_relationship_types(&self) -> &[::std::string::String] {
        &self.relationship_types
    }
    pub fn clear_relationship_types(&mut self) {
        self.relationship_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_relationship_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.relationship_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relationship_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.relationship_types
    }

    // Take field
    pub fn take_relationship_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.relationship_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Feed {
    fn is_initialized(&self) -> bool {
        for v in &self.feed_output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_names)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feed_output_config)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.relationship_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.asset_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.content_type);
        }
        if let Some(ref v) = self.feed_output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.relationship_types {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.asset_names {
            os.write_string(2, &v)?;
        };
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if let Some(ref v) = self.feed_output_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.relationship_types {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Feed {
        Feed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Feed| { &m.name },
                |m: &mut Feed| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_names",
                |m: &Feed| { &m.asset_names },
                |m: &mut Feed| { &mut m.asset_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &Feed| { &m.asset_types },
                |m: &mut Feed| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &Feed| { &m.content_type },
                |m: &mut Feed| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeedOutputConfig>>(
                "feed_output_config",
                |m: &Feed| { &m.feed_output_config },
                |m: &mut Feed| { &mut m.feed_output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::expr::Expr>>(
                "condition",
                |m: &Feed| { &m.condition },
                |m: &mut Feed| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relationship_types",
                |m: &Feed| { &m.relationship_types },
                |m: &mut Feed| { &mut m.relationship_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Feed>(
                "Feed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Feed {
        static instance: ::protobuf::rt::LazyV2<Feed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Feed::new)
    }
}

impl ::protobuf::Clear for Feed {
    fn clear(&mut self) {
        self.name.clear();
        self.asset_names.clear();
        self.asset_types.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.feed_output_config.clear();
        self.condition.clear();
        self.relationship_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Feed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Feed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllResourcesRequest {
    // message fields
    pub scope: ::std::string::String,
    pub query: ::std::string::String,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub order_by: ::std::string::String,
    pub read_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllResourcesRequest {
    fn default() -> &'a SearchAllResourcesRequest {
        <SearchAllResourcesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllResourcesRequest {
    pub fn new() -> SearchAllResourcesRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string query = 2;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // int32 page_size = 4;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string order_by = 6;


    pub fn get_order_by(&self) -> &str {
        &self.order_by
    }
    pub fn clear_order_by(&mut self) {
        self.order_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_by(&mut self, v: ::std::string::String) {
        self.order_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_by(&mut self) -> &mut ::std::string::String {
        &mut self.order_by
    }

    // Take field
    pub fn take_order_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_by, ::std::string::String::new())
    }

    // .google.protobuf.FieldMask read_mask = 8;


    pub fn get_read_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.read_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_mask(&mut self) {
        self.read_mask.clear();
    }

    pub fn has_read_mask(&self) -> bool {
        self.read_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.read_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.read_mask.is_none() {
            self.read_mask.set_default();
        }
        self.read_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.read_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for SearchAllResourcesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_by)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.query);
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if !self.order_by.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.order_by);
        }
        if let Some(ref v) = self.read_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if !self.query.is_empty() {
            os.write_string(2, &self.query)?;
        }
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.page_size != 0 {
            os.write_int32(4, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            os.write_string(6, &self.order_by)?;
        }
        if let Some(ref v) = self.read_mask.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllResourcesRequest {
        SearchAllResourcesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &SearchAllResourcesRequest| { &m.scope },
                |m: &mut SearchAllResourcesRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &SearchAllResourcesRequest| { &m.query },
                |m: &mut SearchAllResourcesRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &SearchAllResourcesRequest| { &m.asset_types },
                |m: &mut SearchAllResourcesRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &SearchAllResourcesRequest| { &m.page_size },
                |m: &mut SearchAllResourcesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &SearchAllResourcesRequest| { &m.page_token },
                |m: &mut SearchAllResourcesRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "order_by",
                |m: &SearchAllResourcesRequest| { &m.order_by },
                |m: &mut SearchAllResourcesRequest| { &mut m.order_by },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "read_mask",
                |m: &SearchAllResourcesRequest| { &m.read_mask },
                |m: &mut SearchAllResourcesRequest| { &mut m.read_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllResourcesRequest>(
                "SearchAllResourcesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllResourcesRequest {
        static instance: ::protobuf::rt::LazyV2<SearchAllResourcesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllResourcesRequest::new)
    }
}

impl ::protobuf::Clear for SearchAllResourcesRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.query.clear();
        self.asset_types.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.order_by.clear();
        self.read_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllResourcesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllResourcesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllResourcesResponse {
    // message fields
    pub results: ::protobuf::RepeatedField<super::assets::ResourceSearchResult>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllResourcesResponse {
    fn default() -> &'a SearchAllResourcesResponse {
        <SearchAllResourcesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllResourcesResponse {
    pub fn new() -> SearchAllResourcesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.ResourceSearchResult results = 1;


    pub fn get_results(&self) -> &[super::assets::ResourceSearchResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::assets::ResourceSearchResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::ResourceSearchResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::assets::ResourceSearchResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchAllResourcesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllResourcesResponse {
        SearchAllResourcesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::ResourceSearchResult>>(
                "results",
                |m: &SearchAllResourcesResponse| { &m.results },
                |m: &mut SearchAllResourcesResponse| { &mut m.results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &SearchAllResourcesResponse| { &m.next_page_token },
                |m: &mut SearchAllResourcesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllResourcesResponse>(
                "SearchAllResourcesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllResourcesResponse {
        static instance: ::protobuf::rt::LazyV2<SearchAllResourcesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllResourcesResponse::new)
    }
}

impl ::protobuf::Clear for SearchAllResourcesResponse {
    fn clear(&mut self) {
        self.results.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllResourcesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllResourcesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllIamPoliciesRequest {
    // message fields
    pub scope: ::std::string::String,
    pub query: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub order_by: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllIamPoliciesRequest {
    fn default() -> &'a SearchAllIamPoliciesRequest {
        <SearchAllIamPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllIamPoliciesRequest {
    pub fn new() -> SearchAllIamPoliciesRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string query = 2;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // repeated string asset_types = 5;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // string order_by = 7;


    pub fn get_order_by(&self) -> &str {
        &self.order_by
    }
    pub fn clear_order_by(&mut self) {
        self.order_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_by(&mut self, v: ::std::string::String) {
        self.order_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_by(&mut self) -> &mut ::std::string::String {
        &mut self.order_by
    }

    // Take field
    pub fn take_order_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_by, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchAllIamPoliciesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_by)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.query);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.order_by.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.order_by);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if !self.query.is_empty() {
            os.write_string(2, &self.query)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        for v in &self.asset_types {
            os.write_string(5, &v)?;
        };
        if !self.order_by.is_empty() {
            os.write_string(7, &self.order_by)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllIamPoliciesRequest {
        SearchAllIamPoliciesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &SearchAllIamPoliciesRequest| { &m.scope },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &SearchAllIamPoliciesRequest| { &m.query },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &SearchAllIamPoliciesRequest| { &m.page_size },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &SearchAllIamPoliciesRequest| { &m.page_token },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &SearchAllIamPoliciesRequest| { &m.asset_types },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "order_by",
                |m: &SearchAllIamPoliciesRequest| { &m.order_by },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.order_by },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllIamPoliciesRequest>(
                "SearchAllIamPoliciesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllIamPoliciesRequest {
        static instance: ::protobuf::rt::LazyV2<SearchAllIamPoliciesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllIamPoliciesRequest::new)
    }
}

impl ::protobuf::Clear for SearchAllIamPoliciesRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.query.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.asset_types.clear();
        self.order_by.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllIamPoliciesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllIamPoliciesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllIamPoliciesResponse {
    // message fields
    pub results: ::protobuf::RepeatedField<super::assets::IamPolicySearchResult>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllIamPoliciesResponse {
    fn default() -> &'a SearchAllIamPoliciesResponse {
        <SearchAllIamPoliciesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllIamPoliciesResponse {
    pub fn new() -> SearchAllIamPoliciesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.IamPolicySearchResult results = 1;


    pub fn get_results(&self) -> &[super::assets::IamPolicySearchResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::assets::IamPolicySearchResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::IamPolicySearchResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::assets::IamPolicySearchResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchAllIamPoliciesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllIamPoliciesResponse {
        SearchAllIamPoliciesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::IamPolicySearchResult>>(
                "results",
                |m: &SearchAllIamPoliciesResponse| { &m.results },
                |m: &mut SearchAllIamPoliciesResponse| { &mut m.results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &SearchAllIamPoliciesResponse| { &m.next_page_token },
                |m: &mut SearchAllIamPoliciesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllIamPoliciesResponse>(
                "SearchAllIamPoliciesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllIamPoliciesResponse {
        static instance: ::protobuf::rt::LazyV2<SearchAllIamPoliciesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllIamPoliciesResponse::new)
    }
}

impl ::protobuf::Clear for SearchAllIamPoliciesResponse {
    fn clear(&mut self) {
        self.results.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllIamPoliciesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllIamPoliciesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery {
    // message fields
    pub scope: ::std::string::String,
    pub resource_selector: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_ResourceSelector>,
    pub identity_selector: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_IdentitySelector>,
    pub access_selector: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_AccessSelector>,
    pub options: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_Options>,
    pub condition_context: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_ConditionContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery {
    fn default() -> &'a IamPolicyAnalysisQuery {
        <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery {
    pub fn new() -> IamPolicyAnalysisQuery {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.ResourceSelector resource_selector = 2;


    pub fn get_resource_selector(&self) -> &IamPolicyAnalysisQuery_ResourceSelector {
        self.resource_selector.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_ResourceSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource_selector(&mut self) {
        self.resource_selector.clear();
    }

    pub fn has_resource_selector(&self) -> bool {
        self.resource_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource_selector(&mut self, v: IamPolicyAnalysisQuery_ResourceSelector) {
        self.resource_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_selector(&mut self) -> &mut IamPolicyAnalysisQuery_ResourceSelector {
        if self.resource_selector.is_none() {
            self.resource_selector.set_default();
        }
        self.resource_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource_selector(&mut self) -> IamPolicyAnalysisQuery_ResourceSelector {
        self.resource_selector.take().unwrap_or_else(|| IamPolicyAnalysisQuery_ResourceSelector::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.IdentitySelector identity_selector = 3;


    pub fn get_identity_selector(&self) -> &IamPolicyAnalysisQuery_IdentitySelector {
        self.identity_selector.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_IdentitySelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identity_selector(&mut self) {
        self.identity_selector.clear();
    }

    pub fn has_identity_selector(&self) -> bool {
        self.identity_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_selector(&mut self, v: IamPolicyAnalysisQuery_IdentitySelector) {
        self.identity_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_selector(&mut self) -> &mut IamPolicyAnalysisQuery_IdentitySelector {
        if self.identity_selector.is_none() {
            self.identity_selector.set_default();
        }
        self.identity_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_selector(&mut self) -> IamPolicyAnalysisQuery_IdentitySelector {
        self.identity_selector.take().unwrap_or_else(|| IamPolicyAnalysisQuery_IdentitySelector::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.AccessSelector access_selector = 4;


    pub fn get_access_selector(&self) -> &IamPolicyAnalysisQuery_AccessSelector {
        self.access_selector.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_AccessSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_access_selector(&mut self) {
        self.access_selector.clear();
    }

    pub fn has_access_selector(&self) -> bool {
        self.access_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_selector(&mut self, v: IamPolicyAnalysisQuery_AccessSelector) {
        self.access_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_selector(&mut self) -> &mut IamPolicyAnalysisQuery_AccessSelector {
        if self.access_selector.is_none() {
            self.access_selector.set_default();
        }
        self.access_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_selector(&mut self) -> IamPolicyAnalysisQuery_AccessSelector {
        self.access_selector.take().unwrap_or_else(|| IamPolicyAnalysisQuery_AccessSelector::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.Options options = 5;


    pub fn get_options(&self) -> &IamPolicyAnalysisQuery_Options {
        self.options.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_Options as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: IamPolicyAnalysisQuery_Options) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut IamPolicyAnalysisQuery_Options {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> IamPolicyAnalysisQuery_Options {
        self.options.take().unwrap_or_else(|| IamPolicyAnalysisQuery_Options::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.ConditionContext condition_context = 6;


    pub fn get_condition_context(&self) -> &IamPolicyAnalysisQuery_ConditionContext {
        self.condition_context.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_ConditionContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition_context(&mut self) {
        self.condition_context.clear();
    }

    pub fn has_condition_context(&self) -> bool {
        self.condition_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition_context(&mut self, v: IamPolicyAnalysisQuery_ConditionContext) {
        self.condition_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition_context(&mut self) -> &mut IamPolicyAnalysisQuery_ConditionContext {
        if self.condition_context.is_none() {
            self.condition_context.set_default();
        }
        self.condition_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition_context(&mut self) -> IamPolicyAnalysisQuery_ConditionContext {
        self.condition_context.take().unwrap_or_else(|| IamPolicyAnalysisQuery_ConditionContext::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.identity_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.access_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource_selector)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identity_selector)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.access_selector)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if let Some(ref v) = self.resource_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.identity_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.access_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.condition_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if let Some(ref v) = self.resource_selector.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.identity_selector.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.access_selector.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.condition_context.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery {
        IamPolicyAnalysisQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &IamPolicyAnalysisQuery| { &m.scope },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_ResourceSelector>>(
                "resource_selector",
                |m: &IamPolicyAnalysisQuery| { &m.resource_selector },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.resource_selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_IdentitySelector>>(
                "identity_selector",
                |m: &IamPolicyAnalysisQuery| { &m.identity_selector },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.identity_selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_AccessSelector>>(
                "access_selector",
                |m: &IamPolicyAnalysisQuery| { &m.access_selector },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.access_selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_Options>>(
                "options",
                |m: &IamPolicyAnalysisQuery| { &m.options },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_ConditionContext>>(
                "condition_context",
                |m: &IamPolicyAnalysisQuery| { &m.condition_context },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.condition_context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery>(
                "IamPolicyAnalysisQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery {
    fn clear(&mut self) {
        self.scope.clear();
        self.resource_selector.clear();
        self.identity_selector.clear();
        self.access_selector.clear();
        self.options.clear();
        self.condition_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_ResourceSelector {
    // message fields
    pub full_resource_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_ResourceSelector {
    fn default() -> &'a IamPolicyAnalysisQuery_ResourceSelector {
        <IamPolicyAnalysisQuery_ResourceSelector as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_ResourceSelector {
    pub fn new() -> IamPolicyAnalysisQuery_ResourceSelector {
        ::std::default::Default::default()
    }

    // string full_resource_name = 1;


    pub fn get_full_resource_name(&self) -> &str {
        &self.full_resource_name
    }
    pub fn clear_full_resource_name(&mut self) {
        self.full_resource_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_resource_name(&mut self, v: ::std::string::String) {
        self.full_resource_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_resource_name(&mut self) -> &mut ::std::string::String {
        &mut self.full_resource_name
    }

    // Take field
    pub fn take_full_resource_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.full_resource_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_ResourceSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.full_resource_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.full_resource_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.full_resource_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.full_resource_name.is_empty() {
            os.write_string(1, &self.full_resource_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_ResourceSelector {
        IamPolicyAnalysisQuery_ResourceSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "full_resource_name",
                |m: &IamPolicyAnalysisQuery_ResourceSelector| { &m.full_resource_name },
                |m: &mut IamPolicyAnalysisQuery_ResourceSelector| { &mut m.full_resource_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_ResourceSelector>(
                "IamPolicyAnalysisQuery.ResourceSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_ResourceSelector {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_ResourceSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_ResourceSelector::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_ResourceSelector {
    fn clear(&mut self) {
        self.full_resource_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_ResourceSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_ResourceSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_IdentitySelector {
    // message fields
    pub identity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_IdentitySelector {
    fn default() -> &'a IamPolicyAnalysisQuery_IdentitySelector {
        <IamPolicyAnalysisQuery_IdentitySelector as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_IdentitySelector {
    pub fn new() -> IamPolicyAnalysisQuery_IdentitySelector {
        ::std::default::Default::default()
    }

    // string identity = 1;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_IdentitySelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity.is_empty() {
            os.write_string(1, &self.identity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_IdentitySelector {
        IamPolicyAnalysisQuery_IdentitySelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity",
                |m: &IamPolicyAnalysisQuery_IdentitySelector| { &m.identity },
                |m: &mut IamPolicyAnalysisQuery_IdentitySelector| { &mut m.identity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_IdentitySelector>(
                "IamPolicyAnalysisQuery.IdentitySelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_IdentitySelector {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_IdentitySelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_IdentitySelector::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_IdentitySelector {
    fn clear(&mut self) {
        self.identity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_IdentitySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_IdentitySelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_AccessSelector {
    // message fields
    pub roles: ::protobuf::RepeatedField<::std::string::String>,
    pub permissions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_AccessSelector {
    fn default() -> &'a IamPolicyAnalysisQuery_AccessSelector {
        <IamPolicyAnalysisQuery_AccessSelector as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_AccessSelector {
    pub fn new() -> IamPolicyAnalysisQuery_AccessSelector {
        ::std::default::Default::default()
    }

    // repeated string roles = 1;


    pub fn get_roles(&self) -> &[::std::string::String] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }

    // repeated string permissions = 2;


    pub fn get_permissions(&self) -> &[::std::string::String] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.permissions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_AccessSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.roles)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.roles {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.permissions {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.roles {
            os.write_string(1, &v)?;
        };
        for v in &self.permissions {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_AccessSelector {
        IamPolicyAnalysisQuery_AccessSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "roles",
                |m: &IamPolicyAnalysisQuery_AccessSelector| { &m.roles },
                |m: &mut IamPolicyAnalysisQuery_AccessSelector| { &mut m.roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permissions",
                |m: &IamPolicyAnalysisQuery_AccessSelector| { &m.permissions },
                |m: &mut IamPolicyAnalysisQuery_AccessSelector| { &mut m.permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_AccessSelector>(
                "IamPolicyAnalysisQuery.AccessSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_AccessSelector {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_AccessSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_AccessSelector::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_AccessSelector {
    fn clear(&mut self) {
        self.roles.clear();
        self.permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_AccessSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_AccessSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_Options {
    // message fields
    pub expand_groups: bool,
    pub expand_roles: bool,
    pub expand_resources: bool,
    pub output_resource_edges: bool,
    pub output_group_edges: bool,
    pub analyze_service_account_impersonation: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_Options {
    fn default() -> &'a IamPolicyAnalysisQuery_Options {
        <IamPolicyAnalysisQuery_Options as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_Options {
    pub fn new() -> IamPolicyAnalysisQuery_Options {
        ::std::default::Default::default()
    }

    // bool expand_groups = 1;


    pub fn get_expand_groups(&self) -> bool {
        self.expand_groups
    }
    pub fn clear_expand_groups(&mut self) {
        self.expand_groups = false;
    }

    // Param is passed by value, moved
    pub fn set_expand_groups(&mut self, v: bool) {
        self.expand_groups = v;
    }

    // bool expand_roles = 2;


    pub fn get_expand_roles(&self) -> bool {
        self.expand_roles
    }
    pub fn clear_expand_roles(&mut self) {
        self.expand_roles = false;
    }

    // Param is passed by value, moved
    pub fn set_expand_roles(&mut self, v: bool) {
        self.expand_roles = v;
    }

    // bool expand_resources = 3;


    pub fn get_expand_resources(&self) -> bool {
        self.expand_resources
    }
    pub fn clear_expand_resources(&mut self) {
        self.expand_resources = false;
    }

    // Param is passed by value, moved
    pub fn set_expand_resources(&mut self, v: bool) {
        self.expand_resources = v;
    }

    // bool output_resource_edges = 4;


    pub fn get_output_resource_edges(&self) -> bool {
        self.output_resource_edges
    }
    pub fn clear_output_resource_edges(&mut self) {
        self.output_resource_edges = false;
    }

    // Param is passed by value, moved
    pub fn set_output_resource_edges(&mut self, v: bool) {
        self.output_resource_edges = v;
    }

    // bool output_group_edges = 5;


    pub fn get_output_group_edges(&self) -> bool {
        self.output_group_edges
    }
    pub fn clear_output_group_edges(&mut self) {
        self.output_group_edges = false;
    }

    // Param is passed by value, moved
    pub fn set_output_group_edges(&mut self, v: bool) {
        self.output_group_edges = v;
    }

    // bool analyze_service_account_impersonation = 6;


    pub fn get_analyze_service_account_impersonation(&self) -> bool {
        self.analyze_service_account_impersonation
    }
    pub fn clear_analyze_service_account_impersonation(&mut self) {
        self.analyze_service_account_impersonation = false;
    }

    // Param is passed by value, moved
    pub fn set_analyze_service_account_impersonation(&mut self, v: bool) {
        self.analyze_service_account_impersonation = v;
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_Options {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expand_groups = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expand_roles = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expand_resources = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.output_resource_edges = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.output_group_edges = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.analyze_service_account_impersonation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.expand_groups != false {
            my_size += 2;
        }
        if self.expand_roles != false {
            my_size += 2;
        }
        if self.expand_resources != false {
            my_size += 2;
        }
        if self.output_resource_edges != false {
            my_size += 2;
        }
        if self.output_group_edges != false {
            my_size += 2;
        }
        if self.analyze_service_account_impersonation != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.expand_groups != false {
            os.write_bool(1, self.expand_groups)?;
        }
        if self.expand_roles != false {
            os.write_bool(2, self.expand_roles)?;
        }
        if self.expand_resources != false {
            os.write_bool(3, self.expand_resources)?;
        }
        if self.output_resource_edges != false {
            os.write_bool(4, self.output_resource_edges)?;
        }
        if self.output_group_edges != false {
            os.write_bool(5, self.output_group_edges)?;
        }
        if self.analyze_service_account_impersonation != false {
            os.write_bool(6, self.analyze_service_account_impersonation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_Options {
        IamPolicyAnalysisQuery_Options::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expand_groups",
                |m: &IamPolicyAnalysisQuery_Options| { &m.expand_groups },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.expand_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expand_roles",
                |m: &IamPolicyAnalysisQuery_Options| { &m.expand_roles },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.expand_roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expand_resources",
                |m: &IamPolicyAnalysisQuery_Options| { &m.expand_resources },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.expand_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "output_resource_edges",
                |m: &IamPolicyAnalysisQuery_Options| { &m.output_resource_edges },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.output_resource_edges },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "output_group_edges",
                |m: &IamPolicyAnalysisQuery_Options| { &m.output_group_edges },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.output_group_edges },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "analyze_service_account_impersonation",
                |m: &IamPolicyAnalysisQuery_Options| { &m.analyze_service_account_impersonation },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.analyze_service_account_impersonation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_Options>(
                "IamPolicyAnalysisQuery.Options",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_Options {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_Options> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_Options::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_Options {
    fn clear(&mut self) {
        self.expand_groups = false;
        self.expand_roles = false;
        self.expand_resources = false;
        self.output_resource_edges = false;
        self.output_group_edges = false;
        self.analyze_service_account_impersonation = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_Options {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_Options {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_ConditionContext {
    // message oneof groups
    pub TimeContext: ::std::option::Option<IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_ConditionContext {
    fn default() -> &'a IamPolicyAnalysisQuery_ConditionContext {
        <IamPolicyAnalysisQuery_ConditionContext as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext {
    access_time(::protobuf::well_known_types::Timestamp),
}

impl IamPolicyAnalysisQuery_ConditionContext {
    pub fn new() -> IamPolicyAnalysisQuery_ConditionContext {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp access_time = 1;


    pub fn get_access_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.TimeContext {
            ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_access_time(&mut self) {
        self.TimeContext = ::std::option::Option::None;
    }

    pub fn has_access_time(&self) -> bool {
        match self.TimeContext {
            ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_access_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.TimeContext = ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_access_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(_)) = self.TimeContext {
        } else {
            self.TimeContext = ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.TimeContext {
            ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_access_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_access_time() {
            match self.TimeContext.take() {
                ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_ConditionContext {
    fn is_initialized(&self) -> bool {
        if let Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v)) = self.TimeContext {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TimeContext = ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.TimeContext {
            match v {
                &IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.TimeContext {
            match v {
                &IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_ConditionContext {
        IamPolicyAnalysisQuery_ConditionContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "access_time",
                IamPolicyAnalysisQuery_ConditionContext::has_access_time,
                IamPolicyAnalysisQuery_ConditionContext::get_access_time,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_ConditionContext>(
                "IamPolicyAnalysisQuery.ConditionContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_ConditionContext {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_ConditionContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_ConditionContext::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_ConditionContext {
    fn clear(&mut self) {
        self.TimeContext = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_ConditionContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_ConditionContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyRequest {
    // message fields
    pub analysis_query: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery>,
    pub saved_analysis_query: ::std::string::String,
    pub execution_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyRequest {
    fn default() -> &'a AnalyzeIamPolicyRequest {
        <AnalyzeIamPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyRequest {
    pub fn new() -> AnalyzeIamPolicyRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery analysis_query = 1;


    pub fn get_analysis_query(&self) -> &IamPolicyAnalysisQuery {
        self.analysis_query.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_analysis_query(&mut self) {
        self.analysis_query.clear();
    }

    pub fn has_analysis_query(&self) -> bool {
        self.analysis_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_analysis_query(&mut self, v: IamPolicyAnalysisQuery) {
        self.analysis_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_analysis_query(&mut self) -> &mut IamPolicyAnalysisQuery {
        if self.analysis_query.is_none() {
            self.analysis_query.set_default();
        }
        self.analysis_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_analysis_query(&mut self) -> IamPolicyAnalysisQuery {
        self.analysis_query.take().unwrap_or_else(|| IamPolicyAnalysisQuery::new())
    }

    // string saved_analysis_query = 3;


    pub fn get_saved_analysis_query(&self) -> &str {
        &self.saved_analysis_query
    }
    pub fn clear_saved_analysis_query(&mut self) {
        self.saved_analysis_query.clear();
    }

    // Param is passed by value, moved
    pub fn set_saved_analysis_query(&mut self, v: ::std::string::String) {
        self.saved_analysis_query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saved_analysis_query(&mut self) -> &mut ::std::string::String {
        &mut self.saved_analysis_query
    }

    // Take field
    pub fn take_saved_analysis_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.saved_analysis_query, ::std::string::String::new())
    }

    // .google.protobuf.Duration execution_timeout = 2;


    pub fn get_execution_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.execution_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execution_timeout(&mut self) {
        self.execution_timeout.clear();
    }

    pub fn has_execution_timeout(&self) -> bool {
        self.execution_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.execution_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.execution_timeout.is_none() {
            self.execution_timeout.set_default();
        }
        self.execution_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_execution_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.execution_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.analysis_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.execution_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.analysis_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.saved_analysis_query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execution_timeout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.analysis_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.saved_analysis_query.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.saved_analysis_query);
        }
        if let Some(ref v) = self.execution_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.analysis_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.saved_analysis_query.is_empty() {
            os.write_string(3, &self.saved_analysis_query)?;
        }
        if let Some(ref v) = self.execution_timeout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyRequest {
        AnalyzeIamPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery>>(
                "analysis_query",
                |m: &AnalyzeIamPolicyRequest| { &m.analysis_query },
                |m: &mut AnalyzeIamPolicyRequest| { &mut m.analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "saved_analysis_query",
                |m: &AnalyzeIamPolicyRequest| { &m.saved_analysis_query },
                |m: &mut AnalyzeIamPolicyRequest| { &mut m.saved_analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "execution_timeout",
                |m: &AnalyzeIamPolicyRequest| { &m.execution_timeout },
                |m: &mut AnalyzeIamPolicyRequest| { &mut m.execution_timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyRequest>(
                "AnalyzeIamPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyRequest {
    fn clear(&mut self) {
        self.analysis_query.clear();
        self.saved_analysis_query.clear();
        self.execution_timeout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyResponse {
    // message fields
    pub main_analysis: ::protobuf::SingularPtrField<AnalyzeIamPolicyResponse_IamPolicyAnalysis>,
    pub service_account_impersonation_analysis: ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis>,
    pub fully_explored: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyResponse {
    fn default() -> &'a AnalyzeIamPolicyResponse {
        <AnalyzeIamPolicyResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyResponse {
    pub fn new() -> AnalyzeIamPolicyResponse {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis main_analysis = 1;


    pub fn get_main_analysis(&self) -> &AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        self.main_analysis.as_ref().unwrap_or_else(|| <AnalyzeIamPolicyResponse_IamPolicyAnalysis as ::protobuf::Message>::default_instance())
    }
    pub fn clear_main_analysis(&mut self) {
        self.main_analysis.clear();
    }

    pub fn has_main_analysis(&self) -> bool {
        self.main_analysis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_analysis(&mut self, v: AnalyzeIamPolicyResponse_IamPolicyAnalysis) {
        self.main_analysis = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_analysis(&mut self) -> &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        if self.main_analysis.is_none() {
            self.main_analysis.set_default();
        }
        self.main_analysis.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_analysis(&mut self) -> AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        self.main_analysis.take().unwrap_or_else(|| AnalyzeIamPolicyResponse_IamPolicyAnalysis::new())
    }

    // repeated .google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis service_account_impersonation_analysis = 2;


    pub fn get_service_account_impersonation_analysis(&self) -> &[AnalyzeIamPolicyResponse_IamPolicyAnalysis] {
        &self.service_account_impersonation_analysis
    }
    pub fn clear_service_account_impersonation_analysis(&mut self) {
        self.service_account_impersonation_analysis.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account_impersonation_analysis(&mut self, v: ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis>) {
        self.service_account_impersonation_analysis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_account_impersonation_analysis(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis> {
        &mut self.service_account_impersonation_analysis
    }

    // Take field
    pub fn take_service_account_impersonation_analysis(&mut self) -> ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis> {
        ::std::mem::replace(&mut self.service_account_impersonation_analysis, ::protobuf::RepeatedField::new())
    }

    // bool fully_explored = 3;


    pub fn get_fully_explored(&self) -> bool {
        self.fully_explored
    }
    pub fn clear_fully_explored(&mut self) {
        self.fully_explored = false;
    }

    // Param is passed by value, moved
    pub fn set_fully_explored(&mut self, v: bool) {
        self.fully_explored = v;
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.main_analysis {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service_account_impersonation_analysis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.main_analysis)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_account_impersonation_analysis)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fully_explored = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.main_analysis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.service_account_impersonation_analysis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.fully_explored != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.main_analysis.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.service_account_impersonation_analysis {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.fully_explored != false {
            os.write_bool(3, self.fully_explored)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyResponse {
        AnalyzeIamPolicyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzeIamPolicyResponse_IamPolicyAnalysis>>(
                "main_analysis",
                |m: &AnalyzeIamPolicyResponse| { &m.main_analysis },
                |m: &mut AnalyzeIamPolicyResponse| { &mut m.main_analysis },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzeIamPolicyResponse_IamPolicyAnalysis>>(
                "service_account_impersonation_analysis",
                |m: &AnalyzeIamPolicyResponse| { &m.service_account_impersonation_analysis },
                |m: &mut AnalyzeIamPolicyResponse| { &mut m.service_account_impersonation_analysis },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fully_explored",
                |m: &AnalyzeIamPolicyResponse| { &m.fully_explored },
                |m: &mut AnalyzeIamPolicyResponse| { &mut m.fully_explored },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyResponse>(
                "AnalyzeIamPolicyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyResponse {
    fn clear(&mut self) {
        self.main_analysis.clear();
        self.service_account_impersonation_analysis.clear();
        self.fully_explored = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    // message fields
    pub analysis_query: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery>,
    pub analysis_results: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult>,
    pub fully_explored: bool,
    pub non_critical_errors: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn default() -> &'a AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        <AnalyzeIamPolicyResponse_IamPolicyAnalysis as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    pub fn new() -> AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery analysis_query = 1;


    pub fn get_analysis_query(&self) -> &IamPolicyAnalysisQuery {
        self.analysis_query.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_analysis_query(&mut self) {
        self.analysis_query.clear();
    }

    pub fn has_analysis_query(&self) -> bool {
        self.analysis_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_analysis_query(&mut self, v: IamPolicyAnalysisQuery) {
        self.analysis_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_analysis_query(&mut self) -> &mut IamPolicyAnalysisQuery {
        if self.analysis_query.is_none() {
            self.analysis_query.set_default();
        }
        self.analysis_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_analysis_query(&mut self) -> IamPolicyAnalysisQuery {
        self.analysis_query.take().unwrap_or_else(|| IamPolicyAnalysisQuery::new())
    }

    // repeated .google.cloud.asset.v1.IamPolicyAnalysisResult analysis_results = 2;


    pub fn get_analysis_results(&self) -> &[super::assets::IamPolicyAnalysisResult] {
        &self.analysis_results
    }
    pub fn clear_analysis_results(&mut self) {
        self.analysis_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_analysis_results(&mut self, v: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult>) {
        self.analysis_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_analysis_results(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult> {
        &mut self.analysis_results
    }

    // Take field
    pub fn take_analysis_results(&mut self) -> ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult> {
        ::std::mem::replace(&mut self.analysis_results, ::protobuf::RepeatedField::new())
    }

    // bool fully_explored = 3;


    pub fn get_fully_explored(&self) -> bool {
        self.fully_explored
    }
    pub fn clear_fully_explored(&mut self) {
        self.fully_explored = false;
    }

    // Param is passed by value, moved
    pub fn set_fully_explored(&mut self, v: bool) {
        self.fully_explored = v;
    }

    // repeated .google.cloud.asset.v1.IamPolicyAnalysisState non_critical_errors = 5;


    pub fn get_non_critical_errors(&self) -> &[super::assets::IamPolicyAnalysisState] {
        &self.non_critical_errors
    }
    pub fn clear_non_critical_errors(&mut self) {
        self.non_critical_errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_non_critical_errors(&mut self, v: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState>) {
        self.non_critical_errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_non_critical_errors(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState> {
        &mut self.non_critical_errors
    }

    // Take field
    pub fn take_non_critical_errors(&mut self) -> ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState> {
        ::std::mem::replace(&mut self.non_critical_errors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn is_initialized(&self) -> bool {
        for v in &self.analysis_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.analysis_results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.non_critical_errors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.analysis_query)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.analysis_results)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fully_explored = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.non_critical_errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.analysis_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.analysis_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.fully_explored != false {
            my_size += 2;
        }
        for value in &self.non_critical_errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.analysis_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.analysis_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.fully_explored != false {
            os.write_bool(3, self.fully_explored)?;
        }
        for v in &self.non_critical_errors {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        AnalyzeIamPolicyResponse_IamPolicyAnalysis::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery>>(
                "analysis_query",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.analysis_query },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::IamPolicyAnalysisResult>>(
                "analysis_results",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.analysis_results },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.analysis_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fully_explored",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.fully_explored },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.fully_explored },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::IamPolicyAnalysisState>>(
                "non_critical_errors",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.non_critical_errors },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.non_critical_errors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyResponse_IamPolicyAnalysis>(
                "AnalyzeIamPolicyResponse.IamPolicyAnalysis",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyResponse_IamPolicyAnalysis> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyResponse_IamPolicyAnalysis::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn clear(&mut self) {
        self.analysis_query.clear();
        self.analysis_results.clear();
        self.fully_explored = false;
        self.non_critical_errors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisOutputConfig {
    // message oneof groups
    pub destination: ::std::option::Option<IamPolicyAnalysisOutputConfig_oneof_destination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisOutputConfig {
    fn default() -> &'a IamPolicyAnalysisOutputConfig {
        <IamPolicyAnalysisOutputConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum IamPolicyAnalysisOutputConfig_oneof_destination {
    gcs_destination(IamPolicyAnalysisOutputConfig_GcsDestination),
    bigquery_destination(IamPolicyAnalysisOutputConfig_BigQueryDestination),
}

impl IamPolicyAnalysisOutputConfig {
    pub fn new() -> IamPolicyAnalysisOutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.GcsDestination gcs_destination = 1;


    pub fn get_gcs_destination(&self) -> &IamPolicyAnalysisOutputConfig_GcsDestination {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v)) => v,
            _ => <IamPolicyAnalysisOutputConfig_GcsDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_gcs_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_destination(&mut self, v: IamPolicyAnalysisOutputConfig_GcsDestination) {
        self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_destination(&mut self) -> &mut IamPolicyAnalysisOutputConfig_GcsDestination {
        if let ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(IamPolicyAnalysisOutputConfig_GcsDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_destination(&mut self) -> IamPolicyAnalysisOutputConfig_GcsDestination {
        if self.has_gcs_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            IamPolicyAnalysisOutputConfig_GcsDestination::new()
        }
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.BigQueryDestination bigquery_destination = 2;


    pub fn get_bigquery_destination(&self) -> &IamPolicyAnalysisOutputConfig_BigQueryDestination {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v)) => v,
            _ => <IamPolicyAnalysisOutputConfig_BigQueryDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bigquery_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_bigquery_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bigquery_destination(&mut self, v: IamPolicyAnalysisOutputConfig_BigQueryDestination) {
        self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bigquery_destination(&mut self) -> &mut IamPolicyAnalysisOutputConfig_BigQueryDestination {
        if let ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(IamPolicyAnalysisOutputConfig_BigQueryDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bigquery_destination(&mut self) -> IamPolicyAnalysisOutputConfig_BigQueryDestination {
        if self.has_bigquery_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            IamPolicyAnalysisOutputConfig_BigQueryDestination::new()
        }
    }
}

impl ::protobuf::Message for IamPolicyAnalysisOutputConfig {
    fn is_initialized(&self) -> bool {
        if let Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisOutputConfig {
        IamPolicyAnalysisOutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IamPolicyAnalysisOutputConfig_GcsDestination>(
                "gcs_destination",
                IamPolicyAnalysisOutputConfig::has_gcs_destination,
                IamPolicyAnalysisOutputConfig::get_gcs_destination,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IamPolicyAnalysisOutputConfig_BigQueryDestination>(
                "bigquery_destination",
                IamPolicyAnalysisOutputConfig::has_bigquery_destination,
                IamPolicyAnalysisOutputConfig::get_bigquery_destination,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig>(
                "IamPolicyAnalysisOutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisOutputConfig {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisOutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisOutputConfig::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisOutputConfig {
    fn clear(&mut self) {
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisOutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisOutputConfig_GcsDestination {
    // message fields
    pub uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisOutputConfig_GcsDestination {
    fn default() -> &'a IamPolicyAnalysisOutputConfig_GcsDestination {
        <IamPolicyAnalysisOutputConfig_GcsDestination as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisOutputConfig_GcsDestination {
    pub fn new() -> IamPolicyAnalysisOutputConfig_GcsDestination {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisOutputConfig_GcsDestination {
        IamPolicyAnalysisOutputConfig_GcsDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &IamPolicyAnalysisOutputConfig_GcsDestination| { &m.uri },
                |m: &mut IamPolicyAnalysisOutputConfig_GcsDestination| { &mut m.uri },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig_GcsDestination>(
                "IamPolicyAnalysisOutputConfig.GcsDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisOutputConfig_GcsDestination {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisOutputConfig_GcsDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisOutputConfig_GcsDestination::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn clear(&mut self) {
        self.uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisOutputConfig_BigQueryDestination {
    // message fields
    pub dataset: ::std::string::String,
    pub table_prefix: ::std::string::String,
    pub partition_key: IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey,
    pub write_disposition: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn default() -> &'a IamPolicyAnalysisOutputConfig_BigQueryDestination {
        <IamPolicyAnalysisOutputConfig_BigQueryDestination as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisOutputConfig_BigQueryDestination {
    pub fn new() -> IamPolicyAnalysisOutputConfig_BigQueryDestination {
        ::std::default::Default::default()
    }

    // string dataset = 1;


    pub fn get_dataset(&self) -> &str {
        &self.dataset
    }
    pub fn clear_dataset(&mut self) {
        self.dataset.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset(&mut self, v: ::std::string::String) {
        self.dataset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset(&mut self) -> &mut ::std::string::String {
        &mut self.dataset
    }

    // Take field
    pub fn take_dataset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset, ::std::string::String::new())
    }

    // string table_prefix = 2;


    pub fn get_table_prefix(&self) -> &str {
        &self.table_prefix
    }
    pub fn clear_table_prefix(&mut self) {
        self.table_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_prefix(&mut self, v: ::std::string::String) {
        self.table_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.table_prefix
    }

    // Take field
    pub fn take_table_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table_prefix, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey partition_key = 3;


    pub fn get_partition_key(&self) -> IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
        self.partition_key
    }
    pub fn clear_partition_key(&mut self) {
        self.partition_key = IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey) {
        self.partition_key = v;
    }

    // string write_disposition = 4;


    pub fn get_write_disposition(&self) -> &str {
        &self.write_disposition
    }
    pub fn clear_write_disposition(&mut self) {
        self.write_disposition.clear();
    }

    // Param is passed by value, moved
    pub fn set_write_disposition(&mut self, v: ::std::string::String) {
        self.write_disposition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_write_disposition(&mut self) -> &mut ::std::string::String {
        &mut self.write_disposition
    }

    // Take field
    pub fn take_write_disposition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.write_disposition, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table_prefix)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.partition_key, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.write_disposition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataset.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset);
        }
        if !self.table_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table_prefix);
        }
        if self.partition_key != IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.partition_key);
        }
        if !self.write_disposition.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.write_disposition);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dataset.is_empty() {
            os.write_string(1, &self.dataset)?;
        }
        if !self.table_prefix.is_empty() {
            os.write_string(2, &self.table_prefix)?;
        }
        if self.partition_key != IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.partition_key))?;
        }
        if !self.write_disposition.is_empty() {
            os.write_string(4, &self.write_disposition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisOutputConfig_BigQueryDestination {
        IamPolicyAnalysisOutputConfig_BigQueryDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.dataset },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.dataset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_prefix",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.table_prefix },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.table_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey>>(
                "partition_key",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.partition_key },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.partition_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "write_disposition",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.write_disposition },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.write_disposition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig_BigQueryDestination>(
                "IamPolicyAnalysisOutputConfig.BigQueryDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisOutputConfig_BigQueryDestination {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisOutputConfig_BigQueryDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisOutputConfig_BigQueryDestination::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn clear(&mut self) {
        self.dataset.clear();
        self.table_prefix.clear();
        self.partition_key = IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED;
        self.write_disposition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    PARTITION_KEY_UNSPECIFIED = 0,
    REQUEST_TIME = 1,
}

impl ::protobuf::ProtobufEnum for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey> {
        match value {
            0 => ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED),
            1 => ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::REQUEST_TIME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey] = &[
            IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED,
            IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::REQUEST_TIME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey>("IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
}

impl ::std::default::Default for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    fn default() -> Self {
        IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyLongrunningRequest {
    // message fields
    pub analysis_query: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery>,
    pub saved_analysis_query: ::std::string::String,
    pub output_config: ::protobuf::SingularPtrField<IamPolicyAnalysisOutputConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyLongrunningRequest {
    fn default() -> &'a AnalyzeIamPolicyLongrunningRequest {
        <AnalyzeIamPolicyLongrunningRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyLongrunningRequest {
    pub fn new() -> AnalyzeIamPolicyLongrunningRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery analysis_query = 1;


    pub fn get_analysis_query(&self) -> &IamPolicyAnalysisQuery {
        self.analysis_query.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_analysis_query(&mut self) {
        self.analysis_query.clear();
    }

    pub fn has_analysis_query(&self) -> bool {
        self.analysis_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_analysis_query(&mut self, v: IamPolicyAnalysisQuery) {
        self.analysis_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_analysis_query(&mut self) -> &mut IamPolicyAnalysisQuery {
        if self.analysis_query.is_none() {
            self.analysis_query.set_default();
        }
        self.analysis_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_analysis_query(&mut self) -> IamPolicyAnalysisQuery {
        self.analysis_query.take().unwrap_or_else(|| IamPolicyAnalysisQuery::new())
    }

    // string saved_analysis_query = 3;


    pub fn get_saved_analysis_query(&self) -> &str {
        &self.saved_analysis_query
    }
    pub fn clear_saved_analysis_query(&mut self) {
        self.saved_analysis_query.clear();
    }

    // Param is passed by value, moved
    pub fn set_saved_analysis_query(&mut self, v: ::std::string::String) {
        self.saved_analysis_query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saved_analysis_query(&mut self) -> &mut ::std::string::String {
        &mut self.saved_analysis_query
    }

    // Take field
    pub fn take_saved_analysis_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.saved_analysis_query, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig output_config = 2;


    pub fn get_output_config(&self) -> &IamPolicyAnalysisOutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <IamPolicyAnalysisOutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: IamPolicyAnalysisOutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut IamPolicyAnalysisOutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> IamPolicyAnalysisOutputConfig {
        self.output_config.take().unwrap_or_else(|| IamPolicyAnalysisOutputConfig::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyLongrunningRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.analysis_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.analysis_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.saved_analysis_query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.analysis_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.saved_analysis_query.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.saved_analysis_query);
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.analysis_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.saved_analysis_query.is_empty() {
            os.write_string(3, &self.saved_analysis_query)?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyLongrunningRequest {
        AnalyzeIamPolicyLongrunningRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery>>(
                "analysis_query",
                |m: &AnalyzeIamPolicyLongrunningRequest| { &m.analysis_query },
                |m: &mut AnalyzeIamPolicyLongrunningRequest| { &mut m.analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "saved_analysis_query",
                |m: &AnalyzeIamPolicyLongrunningRequest| { &m.saved_analysis_query },
                |m: &mut AnalyzeIamPolicyLongrunningRequest| { &mut m.saved_analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisOutputConfig>>(
                "output_config",
                |m: &AnalyzeIamPolicyLongrunningRequest| { &m.output_config },
                |m: &mut AnalyzeIamPolicyLongrunningRequest| { &mut m.output_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyLongrunningRequest>(
                "AnalyzeIamPolicyLongrunningRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyLongrunningRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyLongrunningRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyLongrunningRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyLongrunningRequest {
    fn clear(&mut self) {
        self.analysis_query.clear();
        self.saved_analysis_query.clear();
        self.output_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyLongrunningRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyLongrunningRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyLongrunningResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyLongrunningResponse {
    fn default() -> &'a AnalyzeIamPolicyLongrunningResponse {
        <AnalyzeIamPolicyLongrunningResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyLongrunningResponse {
    pub fn new() -> AnalyzeIamPolicyLongrunningResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyLongrunningResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyLongrunningResponse {
        AnalyzeIamPolicyLongrunningResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyLongrunningResponse>(
                "AnalyzeIamPolicyLongrunningResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyLongrunningResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyLongrunningResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyLongrunningResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyLongrunningResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyLongrunningResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyLongrunningResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedQuery {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub creator: ::std::string::String,
    pub last_update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub last_updater: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub content: ::protobuf::SingularPtrField<SavedQuery_QueryContent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedQuery {
    fn default() -> &'a SavedQuery {
        <SavedQuery as ::protobuf::Message>::default_instance()
    }
}

impl SavedQuery {
    pub fn new() -> SavedQuery {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp create_time = 3;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string creator = 4;


    pub fn get_creator(&self) -> &str {
        &self.creator
    }
    pub fn clear_creator(&mut self) {
        self.creator.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: ::std::string::String) {
        self.creator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator(&mut self) -> &mut ::std::string::String {
        &mut self.creator
    }

    // Take field
    pub fn take_creator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.creator, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp last_update_time = 5;


    pub fn get_last_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_update_time(&mut self) {
        self.last_update_time.clear();
    }

    pub fn has_last_update_time(&self) -> bool {
        self.last_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_update_time.is_none() {
            self.last_update_time.set_default();
        }
        self.last_update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string last_updater = 6;


    pub fn get_last_updater(&self) -> &str {
        &self.last_updater
    }
    pub fn clear_last_updater(&mut self) {
        self.last_updater.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_updater(&mut self, v: ::std::string::String) {
        self.last_updater = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updater(&mut self) -> &mut ::std::string::String {
        &mut self.last_updater
    }

    // Take field
    pub fn take_last_updater(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_updater, ::std::string::String::new())
    }

    // repeated .google.cloud.asset.v1.SavedQuery.LabelsEntry labels = 7;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // .google.cloud.asset.v1.SavedQuery.QueryContent content = 8;


    pub fn get_content(&self) -> &SavedQuery_QueryContent {
        self.content.as_ref().unwrap_or_else(|| <SavedQuery_QueryContent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: SavedQuery_QueryContent) {
        self.content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut SavedQuery_QueryContent {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> SavedQuery_QueryContent {
        self.content.take().unwrap_or_else(|| SavedQuery_QueryContent::new())
    }
}

impl ::protobuf::Message for SavedQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.creator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_update_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_updater)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.creator);
        }
        if let Some(ref v) = self.last_update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.last_updater.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.last_updater);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.labels);
        if let Some(ref v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.creator.is_empty() {
            os.write_string(4, &self.creator)?;
        }
        if let Some(ref v) = self.last_update_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.last_updater.is_empty() {
            os.write_string(6, &self.last_updater)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.labels, os)?;
        if let Some(ref v) = self.content.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedQuery {
        SavedQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SavedQuery| { &m.name },
                |m: &mut SavedQuery| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &SavedQuery| { &m.description },
                |m: &mut SavedQuery| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &SavedQuery| { &m.create_time },
                |m: &mut SavedQuery| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creator",
                |m: &SavedQuery| { &m.creator },
                |m: &mut SavedQuery| { &mut m.creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_update_time",
                |m: &SavedQuery| { &m.last_update_time },
                |m: &mut SavedQuery| { &mut m.last_update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_updater",
                |m: &SavedQuery| { &m.last_updater },
                |m: &mut SavedQuery| { &mut m.last_updater },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &SavedQuery| { &m.labels },
                |m: &mut SavedQuery| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SavedQuery_QueryContent>>(
                "content",
                |m: &SavedQuery| { &m.content },
                |m: &mut SavedQuery| { &mut m.content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedQuery>(
                "SavedQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedQuery {
        static instance: ::protobuf::rt::LazyV2<SavedQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedQuery::new)
    }
}

impl ::protobuf::Clear for SavedQuery {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.create_time.clear();
        self.creator.clear();
        self.last_update_time.clear();
        self.last_updater.clear();
        self.labels.clear();
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedQuery_QueryContent {
    // message oneof groups
    pub query_content: ::std::option::Option<SavedQuery_QueryContent_oneof_query_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedQuery_QueryContent {
    fn default() -> &'a SavedQuery_QueryContent {
        <SavedQuery_QueryContent as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SavedQuery_QueryContent_oneof_query_content {
    iam_policy_analysis_query(IamPolicyAnalysisQuery),
}

impl SavedQuery_QueryContent {
    pub fn new() -> SavedQuery_QueryContent {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery iam_policy_analysis_query = 1;


    pub fn get_iam_policy_analysis_query(&self) -> &IamPolicyAnalysisQuery {
        match self.query_content {
            ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(ref v)) => v,
            _ => <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_iam_policy_analysis_query(&mut self) {
        self.query_content = ::std::option::Option::None;
    }

    pub fn has_iam_policy_analysis_query(&self) -> bool {
        match self.query_content {
            ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_iam_policy_analysis_query(&mut self, v: IamPolicyAnalysisQuery) {
        self.query_content = ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_iam_policy_analysis_query(&mut self) -> &mut IamPolicyAnalysisQuery {
        if let ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(_)) = self.query_content {
        } else {
            self.query_content = ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(IamPolicyAnalysisQuery::new()));
        }
        match self.query_content {
            ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_iam_policy_analysis_query(&mut self) -> IamPolicyAnalysisQuery {
        if self.has_iam_policy_analysis_query() {
            match self.query_content.take() {
                ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(v)) => v,
                _ => panic!(),
            }
        } else {
            IamPolicyAnalysisQuery::new()
        }
    }
}

impl ::protobuf::Message for SavedQuery_QueryContent {
    fn is_initialized(&self) -> bool {
        if let Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(ref v)) = self.query_content {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_content = ::std::option::Option::Some(SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.query_content {
            match v {
                &SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.query_content {
            match v {
                &SavedQuery_QueryContent_oneof_query_content::iam_policy_analysis_query(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedQuery_QueryContent {
        SavedQuery_QueryContent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IamPolicyAnalysisQuery>(
                "iam_policy_analysis_query",
                SavedQuery_QueryContent::has_iam_policy_analysis_query,
                SavedQuery_QueryContent::get_iam_policy_analysis_query,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedQuery_QueryContent>(
                "SavedQuery.QueryContent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedQuery_QueryContent {
        static instance: ::protobuf::rt::LazyV2<SavedQuery_QueryContent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedQuery_QueryContent::new)
    }
}

impl ::protobuf::Clear for SavedQuery_QueryContent {
    fn clear(&mut self) {
        self.query_content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedQuery_QueryContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedQuery_QueryContent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSavedQueryRequest {
    // message fields
    pub parent: ::std::string::String,
    pub saved_query: ::protobuf::SingularPtrField<SavedQuery>,
    pub saved_query_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSavedQueryRequest {
    fn default() -> &'a CreateSavedQueryRequest {
        <CreateSavedQueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSavedQueryRequest {
    pub fn new() -> CreateSavedQueryRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.SavedQuery saved_query = 2;


    pub fn get_saved_query(&self) -> &SavedQuery {
        self.saved_query.as_ref().unwrap_or_else(|| <SavedQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_saved_query(&mut self) {
        self.saved_query.clear();
    }

    pub fn has_saved_query(&self) -> bool {
        self.saved_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saved_query(&mut self, v: SavedQuery) {
        self.saved_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saved_query(&mut self) -> &mut SavedQuery {
        if self.saved_query.is_none() {
            self.saved_query.set_default();
        }
        self.saved_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_saved_query(&mut self) -> SavedQuery {
        self.saved_query.take().unwrap_or_else(|| SavedQuery::new())
    }

    // string saved_query_id = 3;


    pub fn get_saved_query_id(&self) -> &str {
        &self.saved_query_id
    }
    pub fn clear_saved_query_id(&mut self) {
        self.saved_query_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_saved_query_id(&mut self, v: ::std::string::String) {
        self.saved_query_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saved_query_id(&mut self) -> &mut ::std::string::String {
        &mut self.saved_query_id
    }

    // Take field
    pub fn take_saved_query_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.saved_query_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateSavedQueryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.saved_query {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.saved_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.saved_query_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.saved_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.saved_query_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.saved_query_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.saved_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.saved_query_id.is_empty() {
            os.write_string(3, &self.saved_query_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSavedQueryRequest {
        CreateSavedQueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateSavedQueryRequest| { &m.parent },
                |m: &mut CreateSavedQueryRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SavedQuery>>(
                "saved_query",
                |m: &CreateSavedQueryRequest| { &m.saved_query },
                |m: &mut CreateSavedQueryRequest| { &mut m.saved_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "saved_query_id",
                |m: &CreateSavedQueryRequest| { &m.saved_query_id },
                |m: &mut CreateSavedQueryRequest| { &mut m.saved_query_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSavedQueryRequest>(
                "CreateSavedQueryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSavedQueryRequest {
        static instance: ::protobuf::rt::LazyV2<CreateSavedQueryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSavedQueryRequest::new)
    }
}

impl ::protobuf::Clear for CreateSavedQueryRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.saved_query.clear();
        self.saved_query_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSavedQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSavedQueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSavedQueryRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSavedQueryRequest {
    fn default() -> &'a GetSavedQueryRequest {
        <GetSavedQueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSavedQueryRequest {
    pub fn new() -> GetSavedQueryRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSavedQueryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSavedQueryRequest {
        GetSavedQueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetSavedQueryRequest| { &m.name },
                |m: &mut GetSavedQueryRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSavedQueryRequest>(
                "GetSavedQueryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSavedQueryRequest {
        static instance: ::protobuf::rt::LazyV2<GetSavedQueryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSavedQueryRequest::new)
    }
}

impl ::protobuf::Clear for GetSavedQueryRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSavedQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSavedQueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSavedQueriesRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSavedQueriesRequest {
    fn default() -> &'a ListSavedQueriesRequest {
        <ListSavedQueriesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSavedQueriesRequest {
    pub fn new() -> ListSavedQueriesRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 4;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSavedQueriesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSavedQueriesRequest {
        ListSavedQueriesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListSavedQueriesRequest| { &m.parent },
                |m: &mut ListSavedQueriesRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListSavedQueriesRequest| { &m.filter },
                |m: &mut ListSavedQueriesRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListSavedQueriesRequest| { &m.page_size },
                |m: &mut ListSavedQueriesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListSavedQueriesRequest| { &m.page_token },
                |m: &mut ListSavedQueriesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSavedQueriesRequest>(
                "ListSavedQueriesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSavedQueriesRequest {
        static instance: ::protobuf::rt::LazyV2<ListSavedQueriesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSavedQueriesRequest::new)
    }
}

impl ::protobuf::Clear for ListSavedQueriesRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSavedQueriesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSavedQueriesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSavedQueriesResponse {
    // message fields
    pub saved_queries: ::protobuf::RepeatedField<SavedQuery>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSavedQueriesResponse {
    fn default() -> &'a ListSavedQueriesResponse {
        <ListSavedQueriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSavedQueriesResponse {
    pub fn new() -> ListSavedQueriesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.SavedQuery saved_queries = 1;


    pub fn get_saved_queries(&self) -> &[SavedQuery] {
        &self.saved_queries
    }
    pub fn clear_saved_queries(&mut self) {
        self.saved_queries.clear();
    }

    // Param is passed by value, moved
    pub fn set_saved_queries(&mut self, v: ::protobuf::RepeatedField<SavedQuery>) {
        self.saved_queries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_saved_queries(&mut self) -> &mut ::protobuf::RepeatedField<SavedQuery> {
        &mut self.saved_queries
    }

    // Take field
    pub fn take_saved_queries(&mut self) -> ::protobuf::RepeatedField<SavedQuery> {
        ::std::mem::replace(&mut self.saved_queries, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSavedQueriesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.saved_queries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.saved_queries)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.saved_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.saved_queries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSavedQueriesResponse {
        ListSavedQueriesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SavedQuery>>(
                "saved_queries",
                |m: &ListSavedQueriesResponse| { &m.saved_queries },
                |m: &mut ListSavedQueriesResponse| { &mut m.saved_queries },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListSavedQueriesResponse| { &m.next_page_token },
                |m: &mut ListSavedQueriesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSavedQueriesResponse>(
                "ListSavedQueriesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSavedQueriesResponse {
        static instance: ::protobuf::rt::LazyV2<ListSavedQueriesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSavedQueriesResponse::new)
    }
}

impl ::protobuf::Clear for ListSavedQueriesResponse {
    fn clear(&mut self) {
        self.saved_queries.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSavedQueriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSavedQueriesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSavedQueryRequest {
    // message fields
    pub saved_query: ::protobuf::SingularPtrField<SavedQuery>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSavedQueryRequest {
    fn default() -> &'a UpdateSavedQueryRequest {
        <UpdateSavedQueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSavedQueryRequest {
    pub fn new() -> UpdateSavedQueryRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.SavedQuery saved_query = 1;


    pub fn get_saved_query(&self) -> &SavedQuery {
        self.saved_query.as_ref().unwrap_or_else(|| <SavedQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_saved_query(&mut self) {
        self.saved_query.clear();
    }

    pub fn has_saved_query(&self) -> bool {
        self.saved_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saved_query(&mut self, v: SavedQuery) {
        self.saved_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saved_query(&mut self) -> &mut SavedQuery {
        if self.saved_query.is_none() {
            self.saved_query.set_default();
        }
        self.saved_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_saved_query(&mut self) -> SavedQuery {
        self.saved_query.take().unwrap_or_else(|| SavedQuery::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateSavedQueryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.saved_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.saved_query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.saved_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.saved_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSavedQueryRequest {
        UpdateSavedQueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SavedQuery>>(
                "saved_query",
                |m: &UpdateSavedQueryRequest| { &m.saved_query },
                |m: &mut UpdateSavedQueryRequest| { &mut m.saved_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateSavedQueryRequest| { &m.update_mask },
                |m: &mut UpdateSavedQueryRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSavedQueryRequest>(
                "UpdateSavedQueryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSavedQueryRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateSavedQueryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSavedQueryRequest::new)
    }
}

impl ::protobuf::Clear for UpdateSavedQueryRequest {
    fn clear(&mut self) {
        self.saved_query.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSavedQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSavedQueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSavedQueryRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSavedQueryRequest {
    fn default() -> &'a DeleteSavedQueryRequest {
        <DeleteSavedQueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSavedQueryRequest {
    pub fn new() -> DeleteSavedQueryRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSavedQueryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSavedQueryRequest {
        DeleteSavedQueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteSavedQueryRequest| { &m.name },
                |m: &mut DeleteSavedQueryRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSavedQueryRequest>(
                "DeleteSavedQueryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSavedQueryRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteSavedQueryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSavedQueryRequest::new)
    }
}

impl ::protobuf::Clear for DeleteSavedQueryRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSavedQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSavedQueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeMoveRequest {
    // message fields
    pub resource: ::std::string::String,
    pub destination_parent: ::std::string::String,
    pub view: AnalyzeMoveRequest_AnalysisView,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeMoveRequest {
    fn default() -> &'a AnalyzeMoveRequest {
        <AnalyzeMoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeMoveRequest {
    pub fn new() -> AnalyzeMoveRequest {
        ::std::default::Default::default()
    }

    // string resource = 1;


    pub fn get_resource(&self) -> &str {
        &self.resource
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        &mut self.resource
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource, ::std::string::String::new())
    }

    // string destination_parent = 2;


    pub fn get_destination_parent(&self) -> &str {
        &self.destination_parent
    }
    pub fn clear_destination_parent(&mut self) {
        self.destination_parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_parent(&mut self, v: ::std::string::String) {
        self.destination_parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_parent(&mut self) -> &mut ::std::string::String {
        &mut self.destination_parent
    }

    // Take field
    pub fn take_destination_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_parent, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.AnalyzeMoveRequest.AnalysisView view = 3;


    pub fn get_view(&self) -> AnalyzeMoveRequest_AnalysisView {
        self.view
    }
    pub fn clear_view(&mut self) {
        self.view = AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_view(&mut self, v: AnalyzeMoveRequest_AnalysisView) {
        self.view = v;
    }
}

impl ::protobuf::Message for AnalyzeMoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_parent)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.view, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.resource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.resource);
        }
        if !self.destination_parent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination_parent);
        }
        if self.view != AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.view);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.resource.is_empty() {
            os.write_string(1, &self.resource)?;
        }
        if !self.destination_parent.is_empty() {
            os.write_string(2, &self.destination_parent)?;
        }
        if self.view != AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.view))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeMoveRequest {
        AnalyzeMoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource",
                |m: &AnalyzeMoveRequest| { &m.resource },
                |m: &mut AnalyzeMoveRequest| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_parent",
                |m: &AnalyzeMoveRequest| { &m.destination_parent },
                |m: &mut AnalyzeMoveRequest| { &mut m.destination_parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AnalyzeMoveRequest_AnalysisView>>(
                "view",
                |m: &AnalyzeMoveRequest| { &m.view },
                |m: &mut AnalyzeMoveRequest| { &mut m.view },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeMoveRequest>(
                "AnalyzeMoveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeMoveRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeMoveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeMoveRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeMoveRequest {
    fn clear(&mut self) {
        self.resource.clear();
        self.destination_parent.clear();
        self.view = AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeMoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeMoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AnalyzeMoveRequest_AnalysisView {
    ANALYSIS_VIEW_UNSPECIFIED = 0,
    FULL = 1,
    BASIC = 2,
}

impl ::protobuf::ProtobufEnum for AnalyzeMoveRequest_AnalysisView {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnalyzeMoveRequest_AnalysisView> {
        match value {
            0 => ::std::option::Option::Some(AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED),
            1 => ::std::option::Option::Some(AnalyzeMoveRequest_AnalysisView::FULL),
            2 => ::std::option::Option::Some(AnalyzeMoveRequest_AnalysisView::BASIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AnalyzeMoveRequest_AnalysisView] = &[
            AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED,
            AnalyzeMoveRequest_AnalysisView::FULL,
            AnalyzeMoveRequest_AnalysisView::BASIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AnalyzeMoveRequest_AnalysisView>("AnalyzeMoveRequest.AnalysisView", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AnalyzeMoveRequest_AnalysisView {
}

impl ::std::default::Default for AnalyzeMoveRequest_AnalysisView {
    fn default() -> Self {
        AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeMoveRequest_AnalysisView {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeMoveResponse {
    // message fields
    pub move_analysis: ::protobuf::RepeatedField<MoveAnalysis>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeMoveResponse {
    fn default() -> &'a AnalyzeMoveResponse {
        <AnalyzeMoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeMoveResponse {
    pub fn new() -> AnalyzeMoveResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.MoveAnalysis move_analysis = 1;


    pub fn get_move_analysis(&self) -> &[MoveAnalysis] {
        &self.move_analysis
    }
    pub fn clear_move_analysis(&mut self) {
        self.move_analysis.clear();
    }

    // Param is passed by value, moved
    pub fn set_move_analysis(&mut self, v: ::protobuf::RepeatedField<MoveAnalysis>) {
        self.move_analysis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_move_analysis(&mut self) -> &mut ::protobuf::RepeatedField<MoveAnalysis> {
        &mut self.move_analysis
    }

    // Take field
    pub fn take_move_analysis(&mut self) -> ::protobuf::RepeatedField<MoveAnalysis> {
        ::std::mem::replace(&mut self.move_analysis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeMoveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.move_analysis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.move_analysis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.move_analysis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.move_analysis {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeMoveResponse {
        AnalyzeMoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveAnalysis>>(
                "move_analysis",
                |m: &AnalyzeMoveResponse| { &m.move_analysis },
                |m: &mut AnalyzeMoveResponse| { &mut m.move_analysis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeMoveResponse>(
                "AnalyzeMoveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeMoveResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeMoveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeMoveResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeMoveResponse {
    fn clear(&mut self) {
        self.move_analysis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeMoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeMoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveAnalysis {
    // message fields
    pub display_name: ::std::string::String,
    // message oneof groups
    pub result: ::std::option::Option<MoveAnalysis_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveAnalysis {
    fn default() -> &'a MoveAnalysis {
        <MoveAnalysis as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MoveAnalysis_oneof_result {
    analysis(MoveAnalysisResult),
    error(super::status::Status),
}

impl MoveAnalysis {
    pub fn new() -> MoveAnalysis {
        ::std::default::Default::default()
    }

    // string display_name = 1;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.MoveAnalysisResult analysis = 2;


    pub fn get_analysis(&self) -> &MoveAnalysisResult {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(ref v)) => v,
            _ => <MoveAnalysisResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_analysis(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_analysis(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_analysis(&mut self, v: MoveAnalysisResult) {
        self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(v))
    }

    // Mutable pointer to the field.
    pub fn mut_analysis(&mut self) -> &mut MoveAnalysisResult {
        if let ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(MoveAnalysisResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_analysis(&mut self) -> MoveAnalysisResult {
        if self.has_analysis() {
            match self.result.take() {
                ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(v)) => v,
                _ => panic!(),
            }
        } else {
            MoveAnalysisResult::new()
        }
    }

    // .google.rpc.Status error = 3;


    pub fn get_error(&self) -> &super::status::Status {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::error(ref v)) => v,
            _ => <super::status::Status as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::status::Status) {
        self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut super::status::Status {
        if let ::std::option::Option::Some(MoveAnalysis_oneof_result::error(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::error(super::status::Status::new()));
        }
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> super::status::Status {
        if self.has_error() {
            match self.result.take() {
                ::std::option::Option::Some(MoveAnalysis_oneof_result::error(v)) => v,
                _ => panic!(),
            }
        } else {
            super::status::Status::new()
        }
    }
}

impl ::protobuf::Message for MoveAnalysis {
    fn is_initialized(&self) -> bool {
        if let Some(MoveAnalysis_oneof_result::analysis(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MoveAnalysis_oneof_result::error(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.display_name);
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &MoveAnalysis_oneof_result::analysis(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MoveAnalysis_oneof_result::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.display_name.is_empty() {
            os.write_string(1, &self.display_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &MoveAnalysis_oneof_result::analysis(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MoveAnalysis_oneof_result::error(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveAnalysis {
        MoveAnalysis::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &MoveAnalysis| { &m.display_name },
                |m: &mut MoveAnalysis| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MoveAnalysisResult>(
                "analysis",
                MoveAnalysis::has_analysis,
                MoveAnalysis::get_analysis,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::status::Status>(
                "error",
                MoveAnalysis::has_error,
                MoveAnalysis::get_error,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveAnalysis>(
                "MoveAnalysis",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveAnalysis {
        static instance: ::protobuf::rt::LazyV2<MoveAnalysis> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveAnalysis::new)
    }
}

impl ::protobuf::Clear for MoveAnalysis {
    fn clear(&mut self) {
        self.display_name.clear();
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveAnalysis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveAnalysis {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveAnalysisResult {
    // message fields
    pub blockers: ::protobuf::RepeatedField<MoveImpact>,
    pub warnings: ::protobuf::RepeatedField<MoveImpact>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveAnalysisResult {
    fn default() -> &'a MoveAnalysisResult {
        <MoveAnalysisResult as ::protobuf::Message>::default_instance()
    }
}

impl MoveAnalysisResult {
    pub fn new() -> MoveAnalysisResult {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.MoveImpact blockers = 1;


    pub fn get_blockers(&self) -> &[MoveImpact] {
        &self.blockers
    }
    pub fn clear_blockers(&mut self) {
        self.blockers.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockers(&mut self, v: ::protobuf::RepeatedField<MoveImpact>) {
        self.blockers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockers(&mut self) -> &mut ::protobuf::RepeatedField<MoveImpact> {
        &mut self.blockers
    }

    // Take field
    pub fn take_blockers(&mut self) -> ::protobuf::RepeatedField<MoveImpact> {
        ::std::mem::replace(&mut self.blockers, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.asset.v1.MoveImpact warnings = 2;


    pub fn get_warnings(&self) -> &[MoveImpact] {
        &self.warnings
    }
    pub fn clear_warnings(&mut self) {
        self.warnings.clear();
    }

    // Param is passed by value, moved
    pub fn set_warnings(&mut self, v: ::protobuf::RepeatedField<MoveImpact>) {
        self.warnings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_warnings(&mut self) -> &mut ::protobuf::RepeatedField<MoveImpact> {
        &mut self.warnings
    }

    // Take field
    pub fn take_warnings(&mut self) -> ::protobuf::RepeatedField<MoveImpact> {
        ::std::mem::replace(&mut self.warnings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoveAnalysisResult {
    fn is_initialized(&self) -> bool {
        for v in &self.blockers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.warnings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blockers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.warnings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blockers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.warnings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blockers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.warnings {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveAnalysisResult {
        MoveAnalysisResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveImpact>>(
                "blockers",
                |m: &MoveAnalysisResult| { &m.blockers },
                |m: &mut MoveAnalysisResult| { &mut m.blockers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveImpact>>(
                "warnings",
                |m: &MoveAnalysisResult| { &m.warnings },
                |m: &mut MoveAnalysisResult| { &mut m.warnings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveAnalysisResult>(
                "MoveAnalysisResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveAnalysisResult {
        static instance: ::protobuf::rt::LazyV2<MoveAnalysisResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveAnalysisResult::new)
    }
}

impl ::protobuf::Clear for MoveAnalysisResult {
    fn clear(&mut self) {
        self.blockers.clear();
        self.warnings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveAnalysisResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveAnalysisResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveImpact {
    // message fields
    pub detail: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveImpact {
    fn default() -> &'a MoveImpact {
        <MoveImpact as ::protobuf::Message>::default_instance()
    }
}

impl MoveImpact {
    pub fn new() -> MoveImpact {
        ::std::default::Default::default()
    }

    // string detail = 1;


    pub fn get_detail(&self) -> &str {
        &self.detail
    }
    pub fn clear_detail(&mut self) {
        self.detail.clear();
    }

    // Param is passed by value, moved
    pub fn set_detail(&mut self, v: ::std::string::String) {
        self.detail = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detail(&mut self) -> &mut ::std::string::String {
        &mut self.detail
    }

    // Take field
    pub fn take_detail(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.detail, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MoveImpact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.detail.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.detail);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.detail.is_empty() {
            os.write_string(1, &self.detail)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveImpact {
        MoveImpact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detail",
                |m: &MoveImpact| { &m.detail },
                |m: &mut MoveImpact| { &mut m.detail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveImpact>(
                "MoveImpact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveImpact {
        static instance: ::protobuf::rt::LazyV2<MoveImpact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveImpact::new)
    }
}

impl ::protobuf::Clear for MoveImpact {
    fn clear(&mut self) {
        self.detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveImpact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveImpact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAssetsOutputConfig {
    // message fields
    pub bigquery_destination: ::protobuf::SingularPtrField<QueryAssetsOutputConfig_BigQueryDestination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAssetsOutputConfig {
    fn default() -> &'a QueryAssetsOutputConfig {
        <QueryAssetsOutputConfig as ::protobuf::Message>::default_instance()
    }
}

impl QueryAssetsOutputConfig {
    pub fn new() -> QueryAssetsOutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.QueryAssetsOutputConfig.BigQueryDestination bigquery_destination = 1;


    pub fn get_bigquery_destination(&self) -> &QueryAssetsOutputConfig_BigQueryDestination {
        self.bigquery_destination.as_ref().unwrap_or_else(|| <QueryAssetsOutputConfig_BigQueryDestination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bigquery_destination(&mut self) {
        self.bigquery_destination.clear();
    }

    pub fn has_bigquery_destination(&self) -> bool {
        self.bigquery_destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bigquery_destination(&mut self, v: QueryAssetsOutputConfig_BigQueryDestination) {
        self.bigquery_destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bigquery_destination(&mut self) -> &mut QueryAssetsOutputConfig_BigQueryDestination {
        if self.bigquery_destination.is_none() {
            self.bigquery_destination.set_default();
        }
        self.bigquery_destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_bigquery_destination(&mut self) -> QueryAssetsOutputConfig_BigQueryDestination {
        self.bigquery_destination.take().unwrap_or_else(|| QueryAssetsOutputConfig_BigQueryDestination::new())
    }
}

impl ::protobuf::Message for QueryAssetsOutputConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.bigquery_destination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bigquery_destination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bigquery_destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bigquery_destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAssetsOutputConfig {
        QueryAssetsOutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryAssetsOutputConfig_BigQueryDestination>>(
                "bigquery_destination",
                |m: &QueryAssetsOutputConfig| { &m.bigquery_destination },
                |m: &mut QueryAssetsOutputConfig| { &mut m.bigquery_destination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAssetsOutputConfig>(
                "QueryAssetsOutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAssetsOutputConfig {
        static instance: ::protobuf::rt::LazyV2<QueryAssetsOutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAssetsOutputConfig::new)
    }
}

impl ::protobuf::Clear for QueryAssetsOutputConfig {
    fn clear(&mut self) {
        self.bigquery_destination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAssetsOutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAssetsOutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAssetsOutputConfig_BigQueryDestination {
    // message fields
    pub dataset: ::std::string::String,
    pub table: ::std::string::String,
    pub write_disposition: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAssetsOutputConfig_BigQueryDestination {
    fn default() -> &'a QueryAssetsOutputConfig_BigQueryDestination {
        <QueryAssetsOutputConfig_BigQueryDestination as ::protobuf::Message>::default_instance()
    }
}

impl QueryAssetsOutputConfig_BigQueryDestination {
    pub fn new() -> QueryAssetsOutputConfig_BigQueryDestination {
        ::std::default::Default::default()
    }

    // string dataset = 1;


    pub fn get_dataset(&self) -> &str {
        &self.dataset
    }
    pub fn clear_dataset(&mut self) {
        self.dataset.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset(&mut self, v: ::std::string::String) {
        self.dataset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset(&mut self) -> &mut ::std::string::String {
        &mut self.dataset
    }

    // Take field
    pub fn take_dataset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset, ::std::string::String::new())
    }

    // string table = 2;


    pub fn get_table(&self) -> &str {
        &self.table
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }

    // string write_disposition = 3;


    pub fn get_write_disposition(&self) -> &str {
        &self.write_disposition
    }
    pub fn clear_write_disposition(&mut self) {
        self.write_disposition.clear();
    }

    // Param is passed by value, moved
    pub fn set_write_disposition(&mut self, v: ::std::string::String) {
        self.write_disposition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_write_disposition(&mut self) -> &mut ::std::string::String {
        &mut self.write_disposition
    }

    // Take field
    pub fn take_write_disposition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.write_disposition, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryAssetsOutputConfig_BigQueryDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.write_disposition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataset.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset);
        }
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table);
        }
        if !self.write_disposition.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.write_disposition);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dataset.is_empty() {
            os.write_string(1, &self.dataset)?;
        }
        if !self.table.is_empty() {
            os.write_string(2, &self.table)?;
        }
        if !self.write_disposition.is_empty() {
            os.write_string(3, &self.write_disposition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAssetsOutputConfig_BigQueryDestination {
        QueryAssetsOutputConfig_BigQueryDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset",
                |m: &QueryAssetsOutputConfig_BigQueryDestination| { &m.dataset },
                |m: &mut QueryAssetsOutputConfig_BigQueryDestination| { &mut m.dataset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table",
                |m: &QueryAssetsOutputConfig_BigQueryDestination| { &m.table },
                |m: &mut QueryAssetsOutputConfig_BigQueryDestination| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "write_disposition",
                |m: &QueryAssetsOutputConfig_BigQueryDestination| { &m.write_disposition },
                |m: &mut QueryAssetsOutputConfig_BigQueryDestination| { &mut m.write_disposition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAssetsOutputConfig_BigQueryDestination>(
                "QueryAssetsOutputConfig.BigQueryDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAssetsOutputConfig_BigQueryDestination {
        static instance: ::protobuf::rt::LazyV2<QueryAssetsOutputConfig_BigQueryDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAssetsOutputConfig_BigQueryDestination::new)
    }
}

impl ::protobuf::Clear for QueryAssetsOutputConfig_BigQueryDestination {
    fn clear(&mut self) {
        self.dataset.clear();
        self.table.clear();
        self.write_disposition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAssetsOutputConfig_BigQueryDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAssetsOutputConfig_BigQueryDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAssetsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub output_config: ::protobuf::SingularPtrField<QueryAssetsOutputConfig>,
    // message oneof groups
    pub query: ::std::option::Option<QueryAssetsRequest_oneof_query>,
    pub time: ::std::option::Option<QueryAssetsRequest_oneof_time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAssetsRequest {
    fn default() -> &'a QueryAssetsRequest {
        <QueryAssetsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueryAssetsRequest_oneof_query {
    statement(::std::string::String),
    job_reference(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueryAssetsRequest_oneof_time {
    read_time_window(super::assets::TimeWindow),
    read_time(::protobuf::well_known_types::Timestamp),
}

impl QueryAssetsRequest {
    pub fn new() -> QueryAssetsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string statement = 2;


    pub fn get_statement(&self) -> &str {
        match self.query {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_statement(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_statement(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: ::std::string::String) {
        self.query = ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(v))
    }

    // Mutable pointer to the field.
    pub fn mut_statement(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(::std::string::String::new()));
        }
        match self.query {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_statement(&mut self) -> ::std::string::String {
        if self.has_statement() {
            match self.query.take() {
                ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string job_reference = 3;


    pub fn get_job_reference(&self) -> &str {
        match self.query {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_job_reference(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_job_reference(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_job_reference(&mut self, v: ::std::string::String) {
        self.query = ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(v))
    }

    // Mutable pointer to the field.
    pub fn mut_job_reference(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(::std::string::String::new()));
        }
        match self.query {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_job_reference(&mut self) -> ::std::string::String {
        if self.has_job_reference() {
            match self.query.take() {
                ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int32 page_size = 4;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // .google.protobuf.Duration timeout = 6;


    pub fn get_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeout(&mut self) {
        self.timeout.clear();
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.timeout.is_none() {
            self.timeout.set_default();
        }
        self.timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.cloud.asset.v1.TimeWindow read_time_window = 7;


    pub fn get_read_time_window(&self) -> &super::assets::TimeWindow {
        match self.time {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(ref v)) => v,
            _ => <super::assets::TimeWindow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_read_time_window(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_read_time_window(&self) -> bool {
        match self.time {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_time_window(&mut self, v: super::assets::TimeWindow) {
        self.time = ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_time_window(&mut self) -> &mut super::assets::TimeWindow {
        if let ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(_)) = self.time {
        } else {
            self.time = ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(super::assets::TimeWindow::new()));
        }
        match self.time {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_time_window(&mut self) -> super::assets::TimeWindow {
        if self.has_read_time_window() {
            match self.time.take() {
                ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(v)) => v,
                _ => panic!(),
            }
        } else {
            super::assets::TimeWindow::new()
        }
    }

    // .google.protobuf.Timestamp read_time = 8;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.time {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_read_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_read_time(&self) -> bool {
        match self.time {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(_)) = self.time {
        } else {
            self.time = ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.time {
            ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_time() {
            match self.time.take() {
                ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // .google.cloud.asset.v1.QueryAssetsOutputConfig output_config = 9;


    pub fn get_output_config(&self) -> &QueryAssetsOutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <QueryAssetsOutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: QueryAssetsOutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut QueryAssetsOutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> QueryAssetsOutputConfig {
        self.output_config.take().unwrap_or_else(|| QueryAssetsOutputConfig::new())
    }
}

impl ::protobuf::Message for QueryAssetsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(QueryAssetsRequest_oneof_time::read_time_window(ref v)) = self.time {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryAssetsRequest_oneof_time::read_time(ref v)) = self.time {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(QueryAssetsRequest_oneof_query::statement(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(QueryAssetsRequest_oneof_query::job_reference(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeout)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time = ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time_window(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time = ::std::option::Option::Some(QueryAssetsRequest_oneof_time::read_time(is.read_message()?));
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if let Some(ref v) = self.timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.query {
            match v {
                &QueryAssetsRequest_oneof_query::statement(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &QueryAssetsRequest_oneof_query::job_reference(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.time {
            match v {
                &QueryAssetsRequest_oneof_time::read_time_window(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryAssetsRequest_oneof_time::read_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(4, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if let Some(ref v) = self.timeout.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.query {
            match v {
                &QueryAssetsRequest_oneof_query::statement(ref v) => {
                    os.write_string(2, v)?;
                },
                &QueryAssetsRequest_oneof_query::job_reference(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.time {
            match v {
                &QueryAssetsRequest_oneof_time::read_time_window(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryAssetsRequest_oneof_time::read_time(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAssetsRequest {
        QueryAssetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &QueryAssetsRequest| { &m.parent },
                |m: &mut QueryAssetsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "statement",
                QueryAssetsRequest::has_statement,
                QueryAssetsRequest::get_statement,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "job_reference",
                QueryAssetsRequest::has_job_reference,
                QueryAssetsRequest::get_job_reference,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &QueryAssetsRequest| { &m.page_size },
                |m: &mut QueryAssetsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &QueryAssetsRequest| { &m.page_token },
                |m: &mut QueryAssetsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "timeout",
                |m: &QueryAssetsRequest| { &m.timeout },
                |m: &mut QueryAssetsRequest| { &mut m.timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::assets::TimeWindow>(
                "read_time_window",
                QueryAssetsRequest::has_read_time_window,
                QueryAssetsRequest::get_read_time_window,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "read_time",
                QueryAssetsRequest::has_read_time,
                QueryAssetsRequest::get_read_time,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryAssetsOutputConfig>>(
                "output_config",
                |m: &QueryAssetsRequest| { &m.output_config },
                |m: &mut QueryAssetsRequest| { &mut m.output_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAssetsRequest>(
                "QueryAssetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAssetsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAssetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAssetsRequest::new)
    }
}

impl ::protobuf::Clear for QueryAssetsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.query = ::std::option::Option::None;
        self.query = ::std::option::Option::None;
        self.page_size = 0;
        self.page_token.clear();
        self.timeout.clear();
        self.time = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.output_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAssetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAssetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAssetsResponse {
    // message fields
    pub job_reference: ::std::string::String,
    pub done: bool,
    // message oneof groups
    pub response: ::std::option::Option<QueryAssetsResponse_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAssetsResponse {
    fn default() -> &'a QueryAssetsResponse {
        <QueryAssetsResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueryAssetsResponse_oneof_response {
    error(super::status::Status),
    query_result(QueryResult),
    output_config(QueryAssetsOutputConfig),
}

impl QueryAssetsResponse {
    pub fn new() -> QueryAssetsResponse {
        ::std::default::Default::default()
    }

    // string job_reference = 1;


    pub fn get_job_reference(&self) -> &str {
        &self.job_reference
    }
    pub fn clear_job_reference(&mut self) {
        self.job_reference.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_reference(&mut self, v: ::std::string::String) {
        self.job_reference = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job_reference(&mut self) -> &mut ::std::string::String {
        &mut self.job_reference
    }

    // Take field
    pub fn take_job_reference(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.job_reference, ::std::string::String::new())
    }

    // bool done = 2;


    pub fn get_done(&self) -> bool {
        self.done
    }
    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }

    // .google.rpc.Status error = 3;


    pub fn get_error(&self) -> &super::status::Status {
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(ref v)) => v,
            _ => <super::status::Status as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::status::Status) {
        self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut super::status::Status {
        if let ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(super::status::Status::new()));
        }
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> super::status::Status {
        if self.has_error() {
            match self.response.take() {
                ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(v)) => v,
                _ => panic!(),
            }
        } else {
            super::status::Status::new()
        }
    }

    // .google.cloud.asset.v1.QueryResult query_result = 4;


    pub fn get_query_result(&self) -> &QueryResult {
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(ref v)) => v,
            _ => <QueryResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query_result(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_query_result(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query_result(&mut self, v: QueryResult) {
        self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query_result(&mut self) -> &mut QueryResult {
        if let ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(QueryResult::new()));
        }
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query_result(&mut self) -> QueryResult {
        if self.has_query_result() {
            match self.response.take() {
                ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryResult::new()
        }
    }

    // .google.cloud.asset.v1.QueryAssetsOutputConfig output_config = 5;


    pub fn get_output_config(&self) -> &QueryAssetsOutputConfig {
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(ref v)) => v,
            _ => <QueryAssetsOutputConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_output_config(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_output_config(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: QueryAssetsOutputConfig) {
        self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_output_config(&mut self) -> &mut QueryAssetsOutputConfig {
        if let ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(QueryAssetsOutputConfig::new()));
        }
        match self.response {
            ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_output_config(&mut self) -> QueryAssetsOutputConfig {
        if self.has_output_config() {
            match self.response.take() {
                ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryAssetsOutputConfig::new()
        }
    }
}

impl ::protobuf::Message for QueryAssetsResponse {
    fn is_initialized(&self) -> bool {
        if let Some(QueryAssetsResponse_oneof_response::error(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryAssetsResponse_oneof_response::query_result(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryAssetsResponse_oneof_response::output_config(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.job_reference)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::error(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::query_result(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(QueryAssetsResponse_oneof_response::output_config(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.job_reference.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.job_reference);
        }
        if self.done != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &QueryAssetsResponse_oneof_response::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryAssetsResponse_oneof_response::query_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryAssetsResponse_oneof_response::output_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.job_reference.is_empty() {
            os.write_string(1, &self.job_reference)?;
        }
        if self.done != false {
            os.write_bool(2, self.done)?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &QueryAssetsResponse_oneof_response::error(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryAssetsResponse_oneof_response::query_result(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryAssetsResponse_oneof_response::output_config(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAssetsResponse {
        QueryAssetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "job_reference",
                |m: &QueryAssetsResponse| { &m.job_reference },
                |m: &mut QueryAssetsResponse| { &mut m.job_reference },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "done",
                |m: &QueryAssetsResponse| { &m.done },
                |m: &mut QueryAssetsResponse| { &mut m.done },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::status::Status>(
                "error",
                QueryAssetsResponse::has_error,
                QueryAssetsResponse::get_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryResult>(
                "query_result",
                QueryAssetsResponse::has_query_result,
                QueryAssetsResponse::get_query_result,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryAssetsOutputConfig>(
                "output_config",
                QueryAssetsResponse::has_output_config,
                QueryAssetsResponse::get_output_config,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAssetsResponse>(
                "QueryAssetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAssetsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAssetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAssetsResponse::new)
    }
}

impl ::protobuf::Clear for QueryAssetsResponse {
    fn clear(&mut self) {
        self.job_reference.clear();
        self.done = false;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAssetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAssetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryResult {
    // message fields
    pub rows: ::protobuf::RepeatedField<::protobuf::well_known_types::Struct>,
    pub schema: ::protobuf::SingularPtrField<TableSchema>,
    pub next_page_token: ::std::string::String,
    pub total_rows: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryResult {
    fn default() -> &'a QueryResult {
        <QueryResult as ::protobuf::Message>::default_instance()
    }
}

impl QueryResult {
    pub fn new() -> QueryResult {
        ::std::default::Default::default()
    }

    // repeated .google.protobuf.Struct rows = 1;


    pub fn get_rows(&self) -> &[::protobuf::well_known_types::Struct] {
        &self.rows
    }
    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Struct>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Struct> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Struct> {
        ::std::mem::replace(&mut self.rows, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.TableSchema schema = 2;


    pub fn get_schema(&self) -> &TableSchema {
        self.schema.as_ref().unwrap_or_else(|| <TableSchema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: TableSchema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut TableSchema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> TableSchema {
        self.schema.take().unwrap_or_else(|| TableSchema::new())
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    // int64 total_rows = 4;


    pub fn get_total_rows(&self) -> i64 {
        self.total_rows
    }
    pub fn clear_total_rows(&mut self) {
        self.total_rows = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_rows(&mut self, v: i64) {
        self.total_rows = v;
    }
}

impl ::protobuf::Message for QueryResult {
    fn is_initialized(&self) -> bool {
        for v in &self.rows {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rows)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_rows = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        if self.total_rows != 0 {
            my_size += ::protobuf::rt::value_size(4, self.total_rows, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rows {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        if self.total_rows != 0 {
            os.write_int64(4, self.total_rows)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryResult {
        QueryResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "rows",
                |m: &QueryResult| { &m.rows },
                |m: &mut QueryResult| { &mut m.rows },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableSchema>>(
                "schema",
                |m: &QueryResult| { &m.schema },
                |m: &mut QueryResult| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &QueryResult| { &m.next_page_token },
                |m: &mut QueryResult| { &mut m.next_page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_rows",
                |m: &QueryResult| { &m.total_rows },
                |m: &mut QueryResult| { &mut m.total_rows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryResult>(
                "QueryResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryResult {
        static instance: ::protobuf::rt::LazyV2<QueryResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryResult::new)
    }
}

impl ::protobuf::Clear for QueryResult {
    fn clear(&mut self) {
        self.rows.clear();
        self.schema.clear();
        self.next_page_token.clear();
        self.total_rows = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableSchema {
    // message fields
    pub fields: ::protobuf::RepeatedField<TableFieldSchema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableSchema {
    fn default() -> &'a TableSchema {
        <TableSchema as ::protobuf::Message>::default_instance()
    }
}

impl TableSchema {
    pub fn new() -> TableSchema {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.TableFieldSchema fields = 1;


    pub fn get_fields(&self) -> &[TableFieldSchema] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<TableFieldSchema>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<TableFieldSchema> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<TableFieldSchema> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TableSchema {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableSchema {
        TableSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableFieldSchema>>(
                "fields",
                |m: &TableSchema| { &m.fields },
                |m: &mut TableSchema| { &mut m.fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableSchema>(
                "TableSchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableSchema {
        static instance: ::protobuf::rt::LazyV2<TableSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableSchema::new)
    }
}

impl ::protobuf::Clear for TableSchema {
    fn clear(&mut self) {
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableFieldSchema {
    // message fields
    pub field: ::std::string::String,
    pub field_type: ::std::string::String,
    pub mode: ::std::string::String,
    pub fields: ::protobuf::RepeatedField<TableFieldSchema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableFieldSchema {
    fn default() -> &'a TableFieldSchema {
        <TableFieldSchema as ::protobuf::Message>::default_instance()
    }
}

impl TableFieldSchema {
    pub fn new() -> TableFieldSchema {
        ::std::default::Default::default()
    }

    // string field = 1;


    pub fn get_field(&self) -> &str {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string mode = 3;


    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }

    // repeated .google.cloud.asset.v1.TableFieldSchema fields = 4;


    pub fn get_fields(&self) -> &[TableFieldSchema] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<TableFieldSchema>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<TableFieldSchema> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<TableFieldSchema> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TableFieldSchema {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mode)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mode);
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field.is_empty() {
            os.write_string(1, &self.field)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if !self.mode.is_empty() {
            os.write_string(3, &self.mode)?;
        }
        for v in &self.fields {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableFieldSchema {
        TableFieldSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "field",
                |m: &TableFieldSchema| { &m.field },
                |m: &mut TableFieldSchema| { &mut m.field },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &TableFieldSchema| { &m.field_type },
                |m: &mut TableFieldSchema| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mode",
                |m: &TableFieldSchema| { &m.mode },
                |m: &mut TableFieldSchema| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableFieldSchema>>(
                "fields",
                |m: &TableFieldSchema| { &m.fields },
                |m: &mut TableFieldSchema| { &mut m.fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableFieldSchema>(
                "TableFieldSchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableFieldSchema {
        static instance: ::protobuf::rt::LazyV2<TableFieldSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableFieldSchema::new)
    }
}

impl ::protobuf::Clear for TableFieldSchema {
    fn clear(&mut self) {
        self.field.clear();
        self.field_type.clear();
        self.mode.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableFieldSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableFieldSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetEffectiveIamPoliciesRequest {
    // message fields
    pub scope: ::std::string::String,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetEffectiveIamPoliciesRequest {
    fn default() -> &'a BatchGetEffectiveIamPoliciesRequest {
        <BatchGetEffectiveIamPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetEffectiveIamPoliciesRequest {
    pub fn new() -> BatchGetEffectiveIamPoliciesRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // repeated string names = 3;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetEffectiveIamPoliciesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        for v in &self.names {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetEffectiveIamPoliciesRequest {
        BatchGetEffectiveIamPoliciesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &BatchGetEffectiveIamPoliciesRequest| { &m.scope },
                |m: &mut BatchGetEffectiveIamPoliciesRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "names",
                |m: &BatchGetEffectiveIamPoliciesRequest| { &m.names },
                |m: &mut BatchGetEffectiveIamPoliciesRequest| { &mut m.names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetEffectiveIamPoliciesRequest>(
                "BatchGetEffectiveIamPoliciesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetEffectiveIamPoliciesRequest {
        static instance: ::protobuf::rt::LazyV2<BatchGetEffectiveIamPoliciesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetEffectiveIamPoliciesRequest::new)
    }
}

impl ::protobuf::Clear for BatchGetEffectiveIamPoliciesRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetEffectiveIamPoliciesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetEffectiveIamPoliciesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetEffectiveIamPoliciesResponse {
    // message fields
    pub policy_results: ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetEffectiveIamPoliciesResponse {
    fn default() -> &'a BatchGetEffectiveIamPoliciesResponse {
        <BatchGetEffectiveIamPoliciesResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetEffectiveIamPoliciesResponse {
    pub fn new() -> BatchGetEffectiveIamPoliciesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy policy_results = 2;


    pub fn get_policy_results(&self) -> &[BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy] {
        &self.policy_results
    }
    pub fn clear_policy_results(&mut self) {
        self.policy_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy_results(&mut self, v: ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy>) {
        self.policy_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policy_results(&mut self) -> &mut ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy> {
        &mut self.policy_results
    }

    // Take field
    pub fn take_policy_results(&mut self) -> ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy> {
        ::std::mem::replace(&mut self.policy_results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetEffectiveIamPoliciesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.policy_results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policy_results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.policy_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.policy_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetEffectiveIamPoliciesResponse {
        BatchGetEffectiveIamPoliciesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy>>(
                "policy_results",
                |m: &BatchGetEffectiveIamPoliciesResponse| { &m.policy_results },
                |m: &mut BatchGetEffectiveIamPoliciesResponse| { &mut m.policy_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetEffectiveIamPoliciesResponse>(
                "BatchGetEffectiveIamPoliciesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetEffectiveIamPoliciesResponse {
        static instance: ::protobuf::rt::LazyV2<BatchGetEffectiveIamPoliciesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetEffectiveIamPoliciesResponse::new)
    }
}

impl ::protobuf::Clear for BatchGetEffectiveIamPoliciesResponse {
    fn clear(&mut self) {
        self.policy_results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetEffectiveIamPoliciesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetEffectiveIamPoliciesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
    // message fields
    pub full_resource_name: ::std::string::String,
    pub policies: ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
    fn default() -> &'a BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
        <BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
    pub fn new() -> BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
        ::std::default::Default::default()
    }

    // string full_resource_name = 1;


    pub fn get_full_resource_name(&self) -> &str {
        &self.full_resource_name
    }
    pub fn clear_full_resource_name(&mut self) {
        self.full_resource_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_resource_name(&mut self, v: ::std::string::String) {
        self.full_resource_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_resource_name(&mut self) -> &mut ::std::string::String {
        &mut self.full_resource_name
    }

    // Take field
    pub fn take_full_resource_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.full_resource_name, ::std::string::String::new())
    }

    // repeated .google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo policies = 2;


    pub fn get_policies(&self) -> &[BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo] {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.full_resource_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.full_resource_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.full_resource_name);
        }
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.full_resource_name.is_empty() {
            os.write_string(1, &self.full_resource_name)?;
        }
        for v in &self.policies {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
        BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "full_resource_name",
                |m: &BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy| { &m.full_resource_name },
                |m: &mut BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy| { &mut m.full_resource_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo>>(
                "policies",
                |m: &BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy| { &m.policies },
                |m: &mut BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy| { &mut m.policies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy>(
                "BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
        static instance: ::protobuf::rt::LazyV2<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy::new)
    }
}

impl ::protobuf::Clear for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
    fn clear(&mut self) {
        self.full_resource_name.clear();
        self.policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
    // message fields
    pub attached_resource: ::std::string::String,
    pub policy: ::protobuf::SingularPtrField<super::policy::Policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
    fn default() -> &'a BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
        <BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
    pub fn new() -> BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
        ::std::default::Default::default()
    }

    // string attached_resource = 1;


    pub fn get_attached_resource(&self) -> &str {
        &self.attached_resource
    }
    pub fn clear_attached_resource(&mut self) {
        self.attached_resource.clear();
    }

    // Param is passed by value, moved
    pub fn set_attached_resource(&mut self, v: ::std::string::String) {
        self.attached_resource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attached_resource(&mut self) -> &mut ::std::string::String {
        &mut self.attached_resource
    }

    // Take field
    pub fn take_attached_resource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attached_resource, ::std::string::String::new())
    }

    // .google.iam.v1.Policy policy = 2;


    pub fn get_policy(&self) -> &super::policy::Policy {
        self.policy.as_ref().unwrap_or_else(|| <super::policy::Policy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: super::policy::Policy) {
        self.policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut super::policy::Policy {
        if self.policy.is_none() {
            self.policy.set_default();
        }
        self.policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_policy(&mut self) -> super::policy::Policy {
        self.policy.take().unwrap_or_else(|| super::policy::Policy::new())
    }
}

impl ::protobuf::Message for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attached_resource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.attached_resource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.attached_resource);
        }
        if let Some(ref v) = self.policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.attached_resource.is_empty() {
            os.write_string(1, &self.attached_resource)?;
        }
        if let Some(ref v) = self.policy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
        BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attached_resource",
                |m: &BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo| { &m.attached_resource },
                |m: &mut BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo| { &mut m.attached_resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::policy::Policy>>(
                "policy",
                |m: &BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo| { &m.policy },
                |m: &mut BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo| { &mut m.policy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo>(
                "BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
        static instance: ::protobuf::rt::LazyV2<BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo::new)
    }
}

impl ::protobuf::Clear for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
    fn clear(&mut self) {
        self.attached_resource.clear();
        self.policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetEffectiveIamPoliciesResponse_EffectiveIamPolicy_PolicyInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicy {
    // message fields
    pub attached_resource: ::std::string::String,
    pub applied_resource: ::std::string::String,
    pub rules: ::protobuf::RepeatedField<AnalyzerOrgPolicy_Rule>,
    pub inherit_from_parent: bool,
    pub reset: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicy {
    fn default() -> &'a AnalyzerOrgPolicy {
        <AnalyzerOrgPolicy as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzerOrgPolicy {
    pub fn new() -> AnalyzerOrgPolicy {
        ::std::default::Default::default()
    }

    // string attached_resource = 1;


    pub fn get_attached_resource(&self) -> &str {
        &self.attached_resource
    }
    pub fn clear_attached_resource(&mut self) {
        self.attached_resource.clear();
    }

    // Param is passed by value, moved
    pub fn set_attached_resource(&mut self, v: ::std::string::String) {
        self.attached_resource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attached_resource(&mut self) -> &mut ::std::string::String {
        &mut self.attached_resource
    }

    // Take field
    pub fn take_attached_resource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attached_resource, ::std::string::String::new())
    }

    // string applied_resource = 5;


    pub fn get_applied_resource(&self) -> &str {
        &self.applied_resource
    }
    pub fn clear_applied_resource(&mut self) {
        self.applied_resource.clear();
    }

    // Param is passed by value, moved
    pub fn set_applied_resource(&mut self, v: ::std::string::String) {
        self.applied_resource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_applied_resource(&mut self) -> &mut ::std::string::String {
        &mut self.applied_resource
    }

    // Take field
    pub fn take_applied_resource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.applied_resource, ::std::string::String::new())
    }

    // repeated .google.cloud.asset.v1.AnalyzerOrgPolicy.Rule rules = 2;


    pub fn get_rules(&self) -> &[AnalyzerOrgPolicy_Rule] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<AnalyzerOrgPolicy_Rule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzerOrgPolicy_Rule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<AnalyzerOrgPolicy_Rule> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }

    // bool inherit_from_parent = 3;


    pub fn get_inherit_from_parent(&self) -> bool {
        self.inherit_from_parent
    }
    pub fn clear_inherit_from_parent(&mut self) {
        self.inherit_from_parent = false;
    }

    // Param is passed by value, moved
    pub fn set_inherit_from_parent(&mut self, v: bool) {
        self.inherit_from_parent = v;
    }

    // bool reset = 4;


    pub fn get_reset(&self) -> bool {
        self.reset
    }
    pub fn clear_reset(&mut self) {
        self.reset = false;
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = v;
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attached_resource)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.applied_resource)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherit_from_parent = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.attached_resource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.attached_resource);
        }
        if !self.applied_resource.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.applied_resource);
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.inherit_from_parent != false {
            my_size += 2;
        }
        if self.reset != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.attached_resource.is_empty() {
            os.write_string(1, &self.attached_resource)?;
        }
        if !self.applied_resource.is_empty() {
            os.write_string(5, &self.applied_resource)?;
        }
        for v in &self.rules {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.inherit_from_parent != false {
            os.write_bool(3, self.inherit_from_parent)?;
        }
        if self.reset != false {
            os.write_bool(4, self.reset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicy {
        AnalyzerOrgPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attached_resource",
                |m: &AnalyzerOrgPolicy| { &m.attached_resource },
                |m: &mut AnalyzerOrgPolicy| { &mut m.attached_resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "applied_resource",
                |m: &AnalyzerOrgPolicy| { &m.applied_resource },
                |m: &mut AnalyzerOrgPolicy| { &mut m.applied_resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicy_Rule>>(
                "rules",
                |m: &AnalyzerOrgPolicy| { &m.rules },
                |m: &mut AnalyzerOrgPolicy| { &mut m.rules },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherit_from_parent",
                |m: &AnalyzerOrgPolicy| { &m.inherit_from_parent },
                |m: &mut AnalyzerOrgPolicy| { &mut m.inherit_from_parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reset",
                |m: &AnalyzerOrgPolicy| { &m.reset },
                |m: &mut AnalyzerOrgPolicy| { &mut m.reset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicy>(
                "AnalyzerOrgPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicy {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicy::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicy {
    fn clear(&mut self) {
        self.attached_resource.clear();
        self.applied_resource.clear();
        self.rules.clear();
        self.inherit_from_parent = false;
        self.reset = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicy_Rule {
    // message fields
    pub condition: ::protobuf::SingularPtrField<super::expr::Expr>,
    // message oneof groups
    pub kind: ::std::option::Option<AnalyzerOrgPolicy_Rule_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicy_Rule {
    fn default() -> &'a AnalyzerOrgPolicy_Rule {
        <AnalyzerOrgPolicy_Rule as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AnalyzerOrgPolicy_Rule_oneof_kind {
    values(AnalyzerOrgPolicy_Rule_StringValues),
    allow_all(bool),
    deny_all(bool),
    enforce(bool),
}

impl AnalyzerOrgPolicy_Rule {
    pub fn new() -> AnalyzerOrgPolicy_Rule {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicy.Rule.StringValues values = 3;


    pub fn get_values(&self) -> &AnalyzerOrgPolicy_Rule_StringValues {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(ref v)) => v,
            _ => <AnalyzerOrgPolicy_Rule_StringValues as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_values(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_values(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: AnalyzerOrgPolicy_Rule_StringValues) {
        self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(v))
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut AnalyzerOrgPolicy_Rule_StringValues {
        if let ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(AnalyzerOrgPolicy_Rule_StringValues::new()));
        }
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_values(&mut self) -> AnalyzerOrgPolicy_Rule_StringValues {
        if self.has_values() {
            match self.kind.take() {
                ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(v)) => v,
                _ => panic!(),
            }
        } else {
            AnalyzerOrgPolicy_Rule_StringValues::new()
        }
    }

    // bool allow_all = 4;


    pub fn get_allow_all(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::allow_all(v)) => v,
            _ => false,
        }
    }
    pub fn clear_allow_all(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_allow_all(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::allow_all(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_allow_all(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::allow_all(v))
    }

    // bool deny_all = 5;


    pub fn get_deny_all(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::deny_all(v)) => v,
            _ => false,
        }
    }
    pub fn clear_deny_all(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_deny_all(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::deny_all(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deny_all(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::deny_all(v))
    }

    // bool enforce = 6;


    pub fn get_enforce(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::enforce(v)) => v,
            _ => false,
        }
    }
    pub fn clear_enforce(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_enforce(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::enforce(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enforce(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::enforce(v))
    }

    // .google.type.Expr condition = 7;


    pub fn get_condition(&self) -> &super::expr::Expr {
        self.condition.as_ref().unwrap_or_else(|| <super::expr::Expr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: super::expr::Expr) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut super::expr::Expr {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> super::expr::Expr {
        self.condition.take().unwrap_or_else(|| super::expr::Expr::new())
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicy_Rule {
    fn is_initialized(&self) -> bool {
        if let Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::values(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::allow_all(is.read_bool()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::deny_all(is.read_bool()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AnalyzerOrgPolicy_Rule_oneof_kind::enforce(is.read_bool()?));
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AnalyzerOrgPolicy_Rule_oneof_kind::values(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AnalyzerOrgPolicy_Rule_oneof_kind::allow_all(v) => {
                    my_size += 2;
                },
                &AnalyzerOrgPolicy_Rule_oneof_kind::deny_all(v) => {
                    my_size += 2;
                },
                &AnalyzerOrgPolicy_Rule_oneof_kind::enforce(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AnalyzerOrgPolicy_Rule_oneof_kind::values(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AnalyzerOrgPolicy_Rule_oneof_kind::allow_all(v) => {
                    os.write_bool(4, v)?;
                },
                &AnalyzerOrgPolicy_Rule_oneof_kind::deny_all(v) => {
                    os.write_bool(5, v)?;
                },
                &AnalyzerOrgPolicy_Rule_oneof_kind::enforce(v) => {
                    os.write_bool(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicy_Rule {
        AnalyzerOrgPolicy_Rule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AnalyzerOrgPolicy_Rule_StringValues>(
                "values",
                AnalyzerOrgPolicy_Rule::has_values,
                AnalyzerOrgPolicy_Rule::get_values,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "allow_all",
                AnalyzerOrgPolicy_Rule::has_allow_all,
                AnalyzerOrgPolicy_Rule::get_allow_all,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "deny_all",
                AnalyzerOrgPolicy_Rule::has_deny_all,
                AnalyzerOrgPolicy_Rule::get_deny_all,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "enforce",
                AnalyzerOrgPolicy_Rule::has_enforce,
                AnalyzerOrgPolicy_Rule::get_enforce,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::expr::Expr>>(
                "condition",
                |m: &AnalyzerOrgPolicy_Rule| { &m.condition },
                |m: &mut AnalyzerOrgPolicy_Rule| { &mut m.condition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicy_Rule>(
                "AnalyzerOrgPolicy.Rule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicy_Rule {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicy_Rule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicy_Rule::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicy_Rule {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.condition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicy_Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicy_Rule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicy_Rule_StringValues {
    // message fields
    pub allowed_values: ::protobuf::RepeatedField<::std::string::String>,
    pub denied_values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicy_Rule_StringValues {
    fn default() -> &'a AnalyzerOrgPolicy_Rule_StringValues {
        <AnalyzerOrgPolicy_Rule_StringValues as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzerOrgPolicy_Rule_StringValues {
    pub fn new() -> AnalyzerOrgPolicy_Rule_StringValues {
        ::std::default::Default::default()
    }

    // repeated string allowed_values = 1;


    pub fn get_allowed_values(&self) -> &[::std::string::String] {
        &self.allowed_values
    }
    pub fn clear_allowed_values(&mut self) {
        self.allowed_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_values
    }

    // Take field
    pub fn take_allowed_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_values, ::protobuf::RepeatedField::new())
    }

    // repeated string denied_values = 2;


    pub fn get_denied_values(&self) -> &[::std::string::String] {
        &self.denied_values
    }
    pub fn clear_denied_values(&mut self) {
        self.denied_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_denied_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.denied_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denied_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.denied_values
    }

    // Take field
    pub fn take_denied_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.denied_values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicy_Rule_StringValues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_values)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.denied_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_values {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.denied_values {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_values {
            os.write_string(1, &v)?;
        };
        for v in &self.denied_values {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicy_Rule_StringValues {
        AnalyzerOrgPolicy_Rule_StringValues::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allowed_values",
                |m: &AnalyzerOrgPolicy_Rule_StringValues| { &m.allowed_values },
                |m: &mut AnalyzerOrgPolicy_Rule_StringValues| { &mut m.allowed_values },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "denied_values",
                |m: &AnalyzerOrgPolicy_Rule_StringValues| { &m.denied_values },
                |m: &mut AnalyzerOrgPolicy_Rule_StringValues| { &mut m.denied_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicy_Rule_StringValues>(
                "AnalyzerOrgPolicy.Rule.StringValues",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicy_Rule_StringValues {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicy_Rule_StringValues> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicy_Rule_StringValues::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicy_Rule_StringValues {
    fn clear(&mut self) {
        self.allowed_values.clear();
        self.denied_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicy_Rule_StringValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicy_Rule_StringValues {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicyConstraint {
    // message oneof groups
    pub constraint_definition: ::std::option::Option<AnalyzerOrgPolicyConstraint_oneof_constraint_definition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicyConstraint {
    fn default() -> &'a AnalyzerOrgPolicyConstraint {
        <AnalyzerOrgPolicyConstraint as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AnalyzerOrgPolicyConstraint_oneof_constraint_definition {
    google_defined_constraint(AnalyzerOrgPolicyConstraint_Constraint),
    custom_constraint(AnalyzerOrgPolicyConstraint_CustomConstraint),
}

impl AnalyzerOrgPolicyConstraint {
    pub fn new() -> AnalyzerOrgPolicyConstraint {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint google_defined_constraint = 1;


    pub fn get_google_defined_constraint(&self) -> &AnalyzerOrgPolicyConstraint_Constraint {
        match self.constraint_definition {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(ref v)) => v,
            _ => <AnalyzerOrgPolicyConstraint_Constraint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_google_defined_constraint(&mut self) {
        self.constraint_definition = ::std::option::Option::None;
    }

    pub fn has_google_defined_constraint(&self) -> bool {
        match self.constraint_definition {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_google_defined_constraint(&mut self, v: AnalyzerOrgPolicyConstraint_Constraint) {
        self.constraint_definition = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_google_defined_constraint(&mut self) -> &mut AnalyzerOrgPolicyConstraint_Constraint {
        if let ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(_)) = self.constraint_definition {
        } else {
            self.constraint_definition = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(AnalyzerOrgPolicyConstraint_Constraint::new()));
        }
        match self.constraint_definition {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_google_defined_constraint(&mut self) -> AnalyzerOrgPolicyConstraint_Constraint {
        if self.has_google_defined_constraint() {
            match self.constraint_definition.take() {
                ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(v)) => v,
                _ => panic!(),
            }
        } else {
            AnalyzerOrgPolicyConstraint_Constraint::new()
        }
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.CustomConstraint custom_constraint = 2;


    pub fn get_custom_constraint(&self) -> &AnalyzerOrgPolicyConstraint_CustomConstraint {
        match self.constraint_definition {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(ref v)) => v,
            _ => <AnalyzerOrgPolicyConstraint_CustomConstraint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_custom_constraint(&mut self) {
        self.constraint_definition = ::std::option::Option::None;
    }

    pub fn has_custom_constraint(&self) -> bool {
        match self.constraint_definition {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_custom_constraint(&mut self, v: AnalyzerOrgPolicyConstraint_CustomConstraint) {
        self.constraint_definition = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_custom_constraint(&mut self) -> &mut AnalyzerOrgPolicyConstraint_CustomConstraint {
        if let ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(_)) = self.constraint_definition {
        } else {
            self.constraint_definition = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(AnalyzerOrgPolicyConstraint_CustomConstraint::new()));
        }
        match self.constraint_definition {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_custom_constraint(&mut self) -> AnalyzerOrgPolicyConstraint_CustomConstraint {
        if self.has_custom_constraint() {
            match self.constraint_definition.take() {
                ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(v)) => v,
                _ => panic!(),
            }
        } else {
            AnalyzerOrgPolicyConstraint_CustomConstraint::new()
        }
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicyConstraint {
    fn is_initialized(&self) -> bool {
        if let Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(ref v)) = self.constraint_definition {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(ref v)) = self.constraint_definition {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.constraint_definition = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.constraint_definition = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.constraint_definition {
            match v {
                &AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.constraint_definition {
            match v {
                &AnalyzerOrgPolicyConstraint_oneof_constraint_definition::google_defined_constraint(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AnalyzerOrgPolicyConstraint_oneof_constraint_definition::custom_constraint(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicyConstraint {
        AnalyzerOrgPolicyConstraint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AnalyzerOrgPolicyConstraint_Constraint>(
                "google_defined_constraint",
                AnalyzerOrgPolicyConstraint::has_google_defined_constraint,
                AnalyzerOrgPolicyConstraint::get_google_defined_constraint,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AnalyzerOrgPolicyConstraint_CustomConstraint>(
                "custom_constraint",
                AnalyzerOrgPolicyConstraint::has_custom_constraint,
                AnalyzerOrgPolicyConstraint::get_custom_constraint,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint>(
                "AnalyzerOrgPolicyConstraint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicyConstraint {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicyConstraint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicyConstraint::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicyConstraint {
    fn clear(&mut self) {
        self.constraint_definition = ::std::option::Option::None;
        self.constraint_definition = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicyConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicyConstraint_Constraint {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    pub constraint_default: AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault,
    // message oneof groups
    pub constraint_type: ::std::option::Option<AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicyConstraint_Constraint {
    fn default() -> &'a AnalyzerOrgPolicyConstraint_Constraint {
        <AnalyzerOrgPolicyConstraint_Constraint as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type {
    list_constraint(AnalyzerOrgPolicyConstraint_Constraint_ListConstraint),
    boolean_constraint(AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint),
}

impl AnalyzerOrgPolicyConstraint_Constraint {
    pub fn new() -> AnalyzerOrgPolicyConstraint_Constraint {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.ConstraintDefault constraint_default = 4;


    pub fn get_constraint_default(&self) -> AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault {
        self.constraint_default
    }
    pub fn clear_constraint_default(&mut self) {
        self.constraint_default = AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::CONSTRAINT_DEFAULT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_constraint_default(&mut self, v: AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault) {
        self.constraint_default = v;
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.ListConstraint list_constraint = 5;


    pub fn get_list_constraint(&self) -> &AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
        match self.constraint_type {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(ref v)) => v,
            _ => <AnalyzerOrgPolicyConstraint_Constraint_ListConstraint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_list_constraint(&mut self) {
        self.constraint_type = ::std::option::Option::None;
    }

    pub fn has_list_constraint(&self) -> bool {
        match self.constraint_type {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_constraint(&mut self, v: AnalyzerOrgPolicyConstraint_Constraint_ListConstraint) {
        self.constraint_type = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_constraint(&mut self) -> &mut AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
        if let ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(_)) = self.constraint_type {
        } else {
            self.constraint_type = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(AnalyzerOrgPolicyConstraint_Constraint_ListConstraint::new()));
        }
        match self.constraint_type {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_constraint(&mut self) -> AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
        if self.has_list_constraint() {
            match self.constraint_type.take() {
                ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(v)) => v,
                _ => panic!(),
            }
        } else {
            AnalyzerOrgPolicyConstraint_Constraint_ListConstraint::new()
        }
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Constraint.BooleanConstraint boolean_constraint = 6;


    pub fn get_boolean_constraint(&self) -> &AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
        match self.constraint_type {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(ref v)) => v,
            _ => <AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_boolean_constraint(&mut self) {
        self.constraint_type = ::std::option::Option::None;
    }

    pub fn has_boolean_constraint(&self) -> bool {
        match self.constraint_type {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_constraint(&mut self, v: AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint) {
        self.constraint_type = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_boolean_constraint(&mut self) -> &mut AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
        if let ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(_)) = self.constraint_type {
        } else {
            self.constraint_type = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint::new()));
        }
        match self.constraint_type {
            ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_boolean_constraint(&mut self) -> AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
        if self.has_boolean_constraint() {
            match self.constraint_type.take() {
                ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(v)) => v,
                _ => panic!(),
            }
        } else {
            AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint::new()
        }
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicyConstraint_Constraint {
    fn is_initialized(&self) -> bool {
        if let Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(ref v)) = self.constraint_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(ref v)) = self.constraint_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.constraint_default, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.constraint_type = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.constraint_type = ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.constraint_default != AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::CONSTRAINT_DEFAULT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.constraint_default);
        }
        if let ::std::option::Option::Some(ref v) = self.constraint_type {
            match v {
                &AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.constraint_default != AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::CONSTRAINT_DEFAULT_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.constraint_default))?;
        }
        if let ::std::option::Option::Some(ref v) = self.constraint_type {
            match v {
                &AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::list_constraint(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AnalyzerOrgPolicyConstraint_Constraint_oneof_constraint_type::boolean_constraint(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicyConstraint_Constraint {
        AnalyzerOrgPolicyConstraint_Constraint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AnalyzerOrgPolicyConstraint_Constraint| { &m.name },
                |m: &mut AnalyzerOrgPolicyConstraint_Constraint| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &AnalyzerOrgPolicyConstraint_Constraint| { &m.display_name },
                |m: &mut AnalyzerOrgPolicyConstraint_Constraint| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &AnalyzerOrgPolicyConstraint_Constraint| { &m.description },
                |m: &mut AnalyzerOrgPolicyConstraint_Constraint| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault>>(
                "constraint_default",
                |m: &AnalyzerOrgPolicyConstraint_Constraint| { &m.constraint_default },
                |m: &mut AnalyzerOrgPolicyConstraint_Constraint| { &mut m.constraint_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AnalyzerOrgPolicyConstraint_Constraint_ListConstraint>(
                "list_constraint",
                AnalyzerOrgPolicyConstraint_Constraint::has_list_constraint,
                AnalyzerOrgPolicyConstraint_Constraint::get_list_constraint,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint>(
                "boolean_constraint",
                AnalyzerOrgPolicyConstraint_Constraint::has_boolean_constraint,
                AnalyzerOrgPolicyConstraint_Constraint::get_boolean_constraint,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint_Constraint>(
                "AnalyzerOrgPolicyConstraint.Constraint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicyConstraint_Constraint {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicyConstraint_Constraint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicyConstraint_Constraint::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicyConstraint_Constraint {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.description.clear();
        self.constraint_default = AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::CONSTRAINT_DEFAULT_UNSPECIFIED;
        self.constraint_type = ::std::option::Option::None;
        self.constraint_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicyConstraint_Constraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint_Constraint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
    // message fields
    pub supports_in: bool,
    pub supports_under: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
    fn default() -> &'a AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
        <AnalyzerOrgPolicyConstraint_Constraint_ListConstraint as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
    pub fn new() -> AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
        ::std::default::Default::default()
    }

    // bool supports_in = 1;


    pub fn get_supports_in(&self) -> bool {
        self.supports_in
    }
    pub fn clear_supports_in(&mut self) {
        self.supports_in = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_in(&mut self, v: bool) {
        self.supports_in = v;
    }

    // bool supports_under = 2;


    pub fn get_supports_under(&self) -> bool {
        self.supports_under
    }
    pub fn clear_supports_under(&mut self) {
        self.supports_under = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_under(&mut self, v: bool) {
        self.supports_under = v;
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_in = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_under = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.supports_in != false {
            my_size += 2;
        }
        if self.supports_under != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.supports_in != false {
            os.write_bool(1, self.supports_in)?;
        }
        if self.supports_under != false {
            os.write_bool(2, self.supports_under)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
        AnalyzerOrgPolicyConstraint_Constraint_ListConstraint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_in",
                |m: &AnalyzerOrgPolicyConstraint_Constraint_ListConstraint| { &m.supports_in },
                |m: &mut AnalyzerOrgPolicyConstraint_Constraint_ListConstraint| { &mut m.supports_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_under",
                |m: &AnalyzerOrgPolicyConstraint_Constraint_ListConstraint| { &m.supports_under },
                |m: &mut AnalyzerOrgPolicyConstraint_Constraint_ListConstraint| { &mut m.supports_under },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint_Constraint_ListConstraint>(
                "AnalyzerOrgPolicyConstraint.Constraint.ListConstraint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicyConstraint_Constraint_ListConstraint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicyConstraint_Constraint_ListConstraint::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
    fn clear(&mut self) {
        self.supports_in = false;
        self.supports_under = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint_Constraint_ListConstraint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
    fn default() -> &'a AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
        <AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
    pub fn new() -> AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
        AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint>(
                "AnalyzerOrgPolicyConstraint.Constraint.BooleanConstraint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint_Constraint_BooleanConstraint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault {
    CONSTRAINT_DEFAULT_UNSPECIFIED = 0,
    ALLOW = 1,
    DENY = 2,
}

impl ::protobuf::ProtobufEnum for AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault> {
        match value {
            0 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::CONSTRAINT_DEFAULT_UNSPECIFIED),
            1 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::ALLOW),
            2 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::DENY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault] = &[
            AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::CONSTRAINT_DEFAULT_UNSPECIFIED,
            AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::ALLOW,
            AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::DENY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault>("AnalyzerOrgPolicyConstraint.Constraint.ConstraintDefault", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault {
}

impl ::std::default::Default for AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault {
    fn default() -> Self {
        AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault::CONSTRAINT_DEFAULT_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint_Constraint_ConstraintDefault {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzerOrgPolicyConstraint_CustomConstraint {
    // message fields
    pub name: ::std::string::String,
    pub resource_types: ::protobuf::RepeatedField<::std::string::String>,
    pub method_types: ::std::vec::Vec<AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType>,
    pub condition: ::std::string::String,
    pub action_type: AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzerOrgPolicyConstraint_CustomConstraint {
    fn default() -> &'a AnalyzerOrgPolicyConstraint_CustomConstraint {
        <AnalyzerOrgPolicyConstraint_CustomConstraint as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzerOrgPolicyConstraint_CustomConstraint {
    pub fn new() -> AnalyzerOrgPolicyConstraint_CustomConstraint {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string resource_types = 2;


    pub fn get_resource_types(&self) -> &[::std::string::String] {
        &self.resource_types
    }
    pub fn clear_resource_types(&mut self) {
        self.resource_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.resource_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.resource_types
    }

    // Take field
    pub fn take_resource_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.resource_types, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.CustomConstraint.MethodType method_types = 3;


    pub fn get_method_types(&self) -> &[AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType] {
        &self.method_types
    }
    pub fn clear_method_types(&mut self) {
        self.method_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_method_types(&mut self, v: ::std::vec::Vec<AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType>) {
        self.method_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_method_types(&mut self) -> &mut ::std::vec::Vec<AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType> {
        &mut self.method_types
    }

    // Take field
    pub fn take_method_types(&mut self) -> ::std::vec::Vec<AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType> {
        ::std::mem::replace(&mut self.method_types, ::std::vec::Vec::new())
    }

    // string condition = 4;


    pub fn get_condition(&self) -> &str {
        &self.condition
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: ::std::string::String) {
        self.condition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut ::std::string::String {
        &mut self.condition
    }

    // Take field
    pub fn take_condition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.condition, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.CustomConstraint.ActionType action_type = 5;


    pub fn get_action_type(&self) -> AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType {
        self.action_type
    }
    pub fn clear_action_type(&mut self) {
        self.action_type = AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ACTION_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_action_type(&mut self, v: AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType) {
        self.action_type = v;
    }

    // string display_name = 6;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 7;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzerOrgPolicyConstraint_CustomConstraint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.resource_types)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.method_types, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.condition)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.resource_types {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.method_types {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        if !self.condition.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.condition);
        }
        if self.action_type != AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ACTION_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.action_type);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.resource_types {
            os.write_string(2, &v)?;
        };
        for v in &self.method_types {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        if !self.condition.is_empty() {
            os.write_string(4, &self.condition)?;
        }
        if self.action_type != AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ACTION_TYPE_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.action_type))?;
        }
        if !self.display_name.is_empty() {
            os.write_string(6, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(7, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzerOrgPolicyConstraint_CustomConstraint {
        AnalyzerOrgPolicyConstraint_CustomConstraint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AnalyzerOrgPolicyConstraint_CustomConstraint| { &m.name },
                |m: &mut AnalyzerOrgPolicyConstraint_CustomConstraint| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_types",
                |m: &AnalyzerOrgPolicyConstraint_CustomConstraint| { &m.resource_types },
                |m: &mut AnalyzerOrgPolicyConstraint_CustomConstraint| { &mut m.resource_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType>>(
                "method_types",
                |m: &AnalyzerOrgPolicyConstraint_CustomConstraint| { &m.method_types },
                |m: &mut AnalyzerOrgPolicyConstraint_CustomConstraint| { &mut m.method_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "condition",
                |m: &AnalyzerOrgPolicyConstraint_CustomConstraint| { &m.condition },
                |m: &mut AnalyzerOrgPolicyConstraint_CustomConstraint| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType>>(
                "action_type",
                |m: &AnalyzerOrgPolicyConstraint_CustomConstraint| { &m.action_type },
                |m: &mut AnalyzerOrgPolicyConstraint_CustomConstraint| { &mut m.action_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &AnalyzerOrgPolicyConstraint_CustomConstraint| { &m.display_name },
                |m: &mut AnalyzerOrgPolicyConstraint_CustomConstraint| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &AnalyzerOrgPolicyConstraint_CustomConstraint| { &m.description },
                |m: &mut AnalyzerOrgPolicyConstraint_CustomConstraint| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint_CustomConstraint>(
                "AnalyzerOrgPolicyConstraint.CustomConstraint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzerOrgPolicyConstraint_CustomConstraint {
        static instance: ::protobuf::rt::LazyV2<AnalyzerOrgPolicyConstraint_CustomConstraint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzerOrgPolicyConstraint_CustomConstraint::new)
    }
}

impl ::protobuf::Clear for AnalyzerOrgPolicyConstraint_CustomConstraint {
    fn clear(&mut self) {
        self.name.clear();
        self.resource_types.clear();
        self.method_types.clear();
        self.condition.clear();
        self.action_type = AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ACTION_TYPE_UNSPECIFIED;
        self.display_name.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzerOrgPolicyConstraint_CustomConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint_CustomConstraint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType {
    METHOD_TYPE_UNSPECIFIED = 0,
    CREATE = 1,
    UPDATE = 2,
    DELETE = 3,
}

impl ::protobuf::ProtobufEnum for AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType> {
        match value {
            0 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::METHOD_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::CREATE),
            2 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::UPDATE),
            3 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType] = &[
            AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::METHOD_TYPE_UNSPECIFIED,
            AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::CREATE,
            AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::UPDATE,
            AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType>("AnalyzerOrgPolicyConstraint.CustomConstraint.MethodType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType {
}

impl ::std::default::Default for AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType {
    fn default() -> Self {
        AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType::METHOD_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint_CustomConstraint_MethodType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType {
    ACTION_TYPE_UNSPECIFIED = 0,
    ALLOW = 1,
    DENY = 2,
}

impl ::protobuf::ProtobufEnum for AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType> {
        match value {
            0 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ACTION_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ALLOW),
            2 => ::std::option::Option::Some(AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::DENY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType] = &[
            AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ACTION_TYPE_UNSPECIFIED,
            AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ALLOW,
            AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::DENY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType>("AnalyzerOrgPolicyConstraint.CustomConstraint.ActionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType {
}

impl ::std::default::Default for AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType {
    fn default() -> Self {
        AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType::ACTION_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzerOrgPolicyConstraint_CustomConstraint_ActionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPoliciesRequest {
    // message fields
    pub scope: ::std::string::String,
    pub constraint: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_token: ::std::string::String,
    // message oneof groups
    pub _page_size: ::std::option::Option<AnalyzeOrgPoliciesRequest_oneof__page_size>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPoliciesRequest {
    fn default() -> &'a AnalyzeOrgPoliciesRequest {
        <AnalyzeOrgPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AnalyzeOrgPoliciesRequest_oneof__page_size {
    page_size(i32),
}

impl AnalyzeOrgPoliciesRequest {
    pub fn new() -> AnalyzeOrgPoliciesRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string constraint = 2;


    pub fn get_constraint(&self) -> &str {
        &self.constraint
    }
    pub fn clear_constraint(&mut self) {
        self.constraint.clear();
    }

    // Param is passed by value, moved
    pub fn set_constraint(&mut self, v: ::std::string::String) {
        self.constraint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_constraint(&mut self) -> &mut ::std::string::String {
        &mut self.constraint
    }

    // Take field
    pub fn take_constraint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.constraint, ::std::string::String::new())
    }

    // string filter = 3;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 4;


    pub fn get_page_size(&self) -> i32 {
        match self._page_size {
            ::std::option::Option::Some(AnalyzeOrgPoliciesRequest_oneof__page_size::page_size(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_page_size(&mut self) {
        self._page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        match self._page_size {
            ::std::option::Option::Some(AnalyzeOrgPoliciesRequest_oneof__page_size::page_size(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self._page_size = ::std::option::Option::Some(AnalyzeOrgPoliciesRequest_oneof__page_size::page_size(v))
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPoliciesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.constraint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._page_size = ::std::option::Option::Some(AnalyzeOrgPoliciesRequest_oneof__page_size::page_size(is.read_int32()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if !self.constraint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.constraint);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filter);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if let ::std::option::Option::Some(ref v) = self._page_size {
            match v {
                &AnalyzeOrgPoliciesRequest_oneof__page_size::page_size(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if !self.constraint.is_empty() {
            os.write_string(2, &self.constraint)?;
        }
        if !self.filter.is_empty() {
            os.write_string(3, &self.filter)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if let ::std::option::Option::Some(ref v) = self._page_size {
            match v {
                &AnalyzeOrgPoliciesRequest_oneof__page_size::page_size(v) => {
                    os.write_int32(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPoliciesRequest {
        AnalyzeOrgPoliciesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &AnalyzeOrgPoliciesRequest| { &m.scope },
                |m: &mut AnalyzeOrgPoliciesRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "constraint",
                |m: &AnalyzeOrgPoliciesRequest| { &m.constraint },
                |m: &mut AnalyzeOrgPoliciesRequest| { &mut m.constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &AnalyzeOrgPoliciesRequest| { &m.filter },
                |m: &mut AnalyzeOrgPoliciesRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "page_size",
                AnalyzeOrgPoliciesRequest::has_page_size,
                AnalyzeOrgPoliciesRequest::get_page_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &AnalyzeOrgPoliciesRequest| { &m.page_token },
                |m: &mut AnalyzeOrgPoliciesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPoliciesRequest>(
                "AnalyzeOrgPoliciesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPoliciesRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPoliciesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPoliciesRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPoliciesRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.constraint.clear();
        self.filter.clear();
        self._page_size = ::std::option::Option::None;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPoliciesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPoliciesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPoliciesResponse {
    // message fields
    pub org_policy_results: ::protobuf::RepeatedField<AnalyzeOrgPoliciesResponse_OrgPolicyResult>,
    pub constraint: ::protobuf::SingularPtrField<AnalyzerOrgPolicyConstraint>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPoliciesResponse {
    fn default() -> &'a AnalyzeOrgPoliciesResponse {
        <AnalyzeOrgPoliciesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeOrgPoliciesResponse {
    pub fn new() -> AnalyzeOrgPoliciesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.OrgPolicyResult org_policy_results = 1;


    pub fn get_org_policy_results(&self) -> &[AnalyzeOrgPoliciesResponse_OrgPolicyResult] {
        &self.org_policy_results
    }
    pub fn clear_org_policy_results(&mut self) {
        self.org_policy_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_org_policy_results(&mut self, v: ::protobuf::RepeatedField<AnalyzeOrgPoliciesResponse_OrgPolicyResult>) {
        self.org_policy_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_org_policy_results(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzeOrgPoliciesResponse_OrgPolicyResult> {
        &mut self.org_policy_results
    }

    // Take field
    pub fn take_org_policy_results(&mut self) -> ::protobuf::RepeatedField<AnalyzeOrgPoliciesResponse_OrgPolicyResult> {
        ::std::mem::replace(&mut self.org_policy_results, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint constraint = 2;


    pub fn get_constraint(&self) -> &AnalyzerOrgPolicyConstraint {
        self.constraint.as_ref().unwrap_or_else(|| <AnalyzerOrgPolicyConstraint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_constraint(&mut self) {
        self.constraint.clear();
    }

    pub fn has_constraint(&self) -> bool {
        self.constraint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_constraint(&mut self, v: AnalyzerOrgPolicyConstraint) {
        self.constraint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_constraint(&mut self) -> &mut AnalyzerOrgPolicyConstraint {
        if self.constraint.is_none() {
            self.constraint.set_default();
        }
        self.constraint.as_mut().unwrap()
    }

    // Take field
    pub fn take_constraint(&mut self) -> AnalyzerOrgPolicyConstraint {
        self.constraint.take().unwrap_or_else(|| AnalyzerOrgPolicyConstraint::new())
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPoliciesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.org_policy_results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.constraint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.org_policy_results)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.constraint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.org_policy_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.constraint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.org_policy_results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.constraint.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPoliciesResponse {
        AnalyzeOrgPoliciesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzeOrgPoliciesResponse_OrgPolicyResult>>(
                "org_policy_results",
                |m: &AnalyzeOrgPoliciesResponse| { &m.org_policy_results },
                |m: &mut AnalyzeOrgPoliciesResponse| { &mut m.org_policy_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicyConstraint>>(
                "constraint",
                |m: &AnalyzeOrgPoliciesResponse| { &m.constraint },
                |m: &mut AnalyzeOrgPoliciesResponse| { &mut m.constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &AnalyzeOrgPoliciesResponse| { &m.next_page_token },
                |m: &mut AnalyzeOrgPoliciesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPoliciesResponse>(
                "AnalyzeOrgPoliciesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPoliciesResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPoliciesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPoliciesResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPoliciesResponse {
    fn clear(&mut self) {
        self.org_policy_results.clear();
        self.constraint.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPoliciesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPoliciesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPoliciesResponse_OrgPolicyResult {
    // message fields
    pub consolidated_policy: ::protobuf::SingularPtrField<AnalyzerOrgPolicy>,
    pub policy_bundle: ::protobuf::RepeatedField<AnalyzerOrgPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPoliciesResponse_OrgPolicyResult {
    fn default() -> &'a AnalyzeOrgPoliciesResponse_OrgPolicyResult {
        <AnalyzeOrgPoliciesResponse_OrgPolicyResult as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeOrgPoliciesResponse_OrgPolicyResult {
    pub fn new() -> AnalyzeOrgPoliciesResponse_OrgPolicyResult {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicy consolidated_policy = 1;


    pub fn get_consolidated_policy(&self) -> &AnalyzerOrgPolicy {
        self.consolidated_policy.as_ref().unwrap_or_else(|| <AnalyzerOrgPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consolidated_policy(&mut self) {
        self.consolidated_policy.clear();
    }

    pub fn has_consolidated_policy(&self) -> bool {
        self.consolidated_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consolidated_policy(&mut self, v: AnalyzerOrgPolicy) {
        self.consolidated_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consolidated_policy(&mut self) -> &mut AnalyzerOrgPolicy {
        if self.consolidated_policy.is_none() {
            self.consolidated_policy.set_default();
        }
        self.consolidated_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_consolidated_policy(&mut self) -> AnalyzerOrgPolicy {
        self.consolidated_policy.take().unwrap_or_else(|| AnalyzerOrgPolicy::new())
    }

    // repeated .google.cloud.asset.v1.AnalyzerOrgPolicy policy_bundle = 2;


    pub fn get_policy_bundle(&self) -> &[AnalyzerOrgPolicy] {
        &self.policy_bundle
    }
    pub fn clear_policy_bundle(&mut self) {
        self.policy_bundle.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy_bundle(&mut self, v: ::protobuf::RepeatedField<AnalyzerOrgPolicy>) {
        self.policy_bundle = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policy_bundle(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzerOrgPolicy> {
        &mut self.policy_bundle
    }

    // Take field
    pub fn take_policy_bundle(&mut self) -> ::protobuf::RepeatedField<AnalyzerOrgPolicy> {
        ::std::mem::replace(&mut self.policy_bundle, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPoliciesResponse_OrgPolicyResult {
    fn is_initialized(&self) -> bool {
        for v in &self.consolidated_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.policy_bundle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consolidated_policy)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policy_bundle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consolidated_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.policy_bundle {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consolidated_policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.policy_bundle {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPoliciesResponse_OrgPolicyResult {
        AnalyzeOrgPoliciesResponse_OrgPolicyResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicy>>(
                "consolidated_policy",
                |m: &AnalyzeOrgPoliciesResponse_OrgPolicyResult| { &m.consolidated_policy },
                |m: &mut AnalyzeOrgPoliciesResponse_OrgPolicyResult| { &mut m.consolidated_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicy>>(
                "policy_bundle",
                |m: &AnalyzeOrgPoliciesResponse_OrgPolicyResult| { &m.policy_bundle },
                |m: &mut AnalyzeOrgPoliciesResponse_OrgPolicyResult| { &mut m.policy_bundle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPoliciesResponse_OrgPolicyResult>(
                "AnalyzeOrgPoliciesResponse.OrgPolicyResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPoliciesResponse_OrgPolicyResult {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPoliciesResponse_OrgPolicyResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPoliciesResponse_OrgPolicyResult::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPoliciesResponse_OrgPolicyResult {
    fn clear(&mut self) {
        self.consolidated_policy.clear();
        self.policy_bundle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPoliciesResponse_OrgPolicyResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPoliciesResponse_OrgPolicyResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedContainersRequest {
    // message fields
    pub scope: ::std::string::String,
    pub constraint: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_token: ::std::string::String,
    // message oneof groups
    pub _page_size: ::std::option::Option<AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedContainersRequest {
    fn default() -> &'a AnalyzeOrgPolicyGovernedContainersRequest {
        <AnalyzeOrgPolicyGovernedContainersRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size {
    page_size(i32),
}

impl AnalyzeOrgPolicyGovernedContainersRequest {
    pub fn new() -> AnalyzeOrgPolicyGovernedContainersRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string constraint = 2;


    pub fn get_constraint(&self) -> &str {
        &self.constraint
    }
    pub fn clear_constraint(&mut self) {
        self.constraint.clear();
    }

    // Param is passed by value, moved
    pub fn set_constraint(&mut self, v: ::std::string::String) {
        self.constraint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_constraint(&mut self) -> &mut ::std::string::String {
        &mut self.constraint
    }

    // Take field
    pub fn take_constraint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.constraint, ::std::string::String::new())
    }

    // string filter = 3;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 4;


    pub fn get_page_size(&self) -> i32 {
        match self._page_size {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size::page_size(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_page_size(&mut self) {
        self._page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        match self._page_size {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size::page_size(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self._page_size = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size::page_size(v))
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedContainersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.constraint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._page_size = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size::page_size(is.read_int32()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if !self.constraint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.constraint);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filter);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if let ::std::option::Option::Some(ref v) = self._page_size {
            match v {
                &AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size::page_size(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if !self.constraint.is_empty() {
            os.write_string(2, &self.constraint)?;
        }
        if !self.filter.is_empty() {
            os.write_string(3, &self.filter)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if let ::std::option::Option::Some(ref v) = self._page_size {
            match v {
                &AnalyzeOrgPolicyGovernedContainersRequest_oneof__page_size::page_size(v) => {
                    os.write_int32(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedContainersRequest {
        AnalyzeOrgPolicyGovernedContainersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &AnalyzeOrgPolicyGovernedContainersRequest| { &m.scope },
                |m: &mut AnalyzeOrgPolicyGovernedContainersRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "constraint",
                |m: &AnalyzeOrgPolicyGovernedContainersRequest| { &m.constraint },
                |m: &mut AnalyzeOrgPolicyGovernedContainersRequest| { &mut m.constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &AnalyzeOrgPolicyGovernedContainersRequest| { &m.filter },
                |m: &mut AnalyzeOrgPolicyGovernedContainersRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "page_size",
                AnalyzeOrgPolicyGovernedContainersRequest::has_page_size,
                AnalyzeOrgPolicyGovernedContainersRequest::get_page_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &AnalyzeOrgPolicyGovernedContainersRequest| { &m.page_token },
                |m: &mut AnalyzeOrgPolicyGovernedContainersRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedContainersRequest>(
                "AnalyzeOrgPolicyGovernedContainersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedContainersRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedContainersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedContainersRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedContainersRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.constraint.clear();
        self.filter.clear();
        self._page_size = ::std::option::Option::None;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedContainersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedContainersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedContainersResponse {
    // message fields
    pub governed_containers: ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer>,
    pub constraint: ::protobuf::SingularPtrField<AnalyzerOrgPolicyConstraint>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedContainersResponse {
    fn default() -> &'a AnalyzeOrgPolicyGovernedContainersResponse {
        <AnalyzeOrgPolicyGovernedContainersResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeOrgPolicyGovernedContainersResponse {
    pub fn new() -> AnalyzeOrgPolicyGovernedContainersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer governed_containers = 1;


    pub fn get_governed_containers(&self) -> &[AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer] {
        &self.governed_containers
    }
    pub fn clear_governed_containers(&mut self) {
        self.governed_containers.clear();
    }

    // Param is passed by value, moved
    pub fn set_governed_containers(&mut self, v: ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer>) {
        self.governed_containers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_governed_containers(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer> {
        &mut self.governed_containers
    }

    // Take field
    pub fn take_governed_containers(&mut self) -> ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer> {
        ::std::mem::replace(&mut self.governed_containers, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint constraint = 2;


    pub fn get_constraint(&self) -> &AnalyzerOrgPolicyConstraint {
        self.constraint.as_ref().unwrap_or_else(|| <AnalyzerOrgPolicyConstraint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_constraint(&mut self) {
        self.constraint.clear();
    }

    pub fn has_constraint(&self) -> bool {
        self.constraint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_constraint(&mut self, v: AnalyzerOrgPolicyConstraint) {
        self.constraint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_constraint(&mut self) -> &mut AnalyzerOrgPolicyConstraint {
        if self.constraint.is_none() {
            self.constraint.set_default();
        }
        self.constraint.as_mut().unwrap()
    }

    // Take field
    pub fn take_constraint(&mut self) -> AnalyzerOrgPolicyConstraint {
        self.constraint.take().unwrap_or_else(|| AnalyzerOrgPolicyConstraint::new())
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedContainersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.governed_containers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.constraint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.governed_containers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.constraint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.governed_containers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.constraint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.governed_containers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.constraint.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedContainersResponse {
        AnalyzeOrgPolicyGovernedContainersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer>>(
                "governed_containers",
                |m: &AnalyzeOrgPolicyGovernedContainersResponse| { &m.governed_containers },
                |m: &mut AnalyzeOrgPolicyGovernedContainersResponse| { &mut m.governed_containers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicyConstraint>>(
                "constraint",
                |m: &AnalyzeOrgPolicyGovernedContainersResponse| { &m.constraint },
                |m: &mut AnalyzeOrgPolicyGovernedContainersResponse| { &mut m.constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &AnalyzeOrgPolicyGovernedContainersResponse| { &m.next_page_token },
                |m: &mut AnalyzeOrgPolicyGovernedContainersResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedContainersResponse>(
                "AnalyzeOrgPolicyGovernedContainersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedContainersResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedContainersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedContainersResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedContainersResponse {
    fn clear(&mut self) {
        self.governed_containers.clear();
        self.constraint.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedContainersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedContainersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
    // message fields
    pub full_resource_name: ::std::string::String,
    pub parent: ::std::string::String,
    pub consolidated_policy: ::protobuf::SingularPtrField<AnalyzerOrgPolicy>,
    pub policy_bundle: ::protobuf::RepeatedField<AnalyzerOrgPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
    fn default() -> &'a AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
        <AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
    pub fn new() -> AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
        ::std::default::Default::default()
    }

    // string full_resource_name = 1;


    pub fn get_full_resource_name(&self) -> &str {
        &self.full_resource_name
    }
    pub fn clear_full_resource_name(&mut self) {
        self.full_resource_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_resource_name(&mut self, v: ::std::string::String) {
        self.full_resource_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_resource_name(&mut self) -> &mut ::std::string::String {
        &mut self.full_resource_name
    }

    // Take field
    pub fn take_full_resource_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.full_resource_name, ::std::string::String::new())
    }

    // string parent = 2;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicy consolidated_policy = 3;


    pub fn get_consolidated_policy(&self) -> &AnalyzerOrgPolicy {
        self.consolidated_policy.as_ref().unwrap_or_else(|| <AnalyzerOrgPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consolidated_policy(&mut self) {
        self.consolidated_policy.clear();
    }

    pub fn has_consolidated_policy(&self) -> bool {
        self.consolidated_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consolidated_policy(&mut self, v: AnalyzerOrgPolicy) {
        self.consolidated_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consolidated_policy(&mut self) -> &mut AnalyzerOrgPolicy {
        if self.consolidated_policy.is_none() {
            self.consolidated_policy.set_default();
        }
        self.consolidated_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_consolidated_policy(&mut self) -> AnalyzerOrgPolicy {
        self.consolidated_policy.take().unwrap_or_else(|| AnalyzerOrgPolicy::new())
    }

    // repeated .google.cloud.asset.v1.AnalyzerOrgPolicy policy_bundle = 4;


    pub fn get_policy_bundle(&self) -> &[AnalyzerOrgPolicy] {
        &self.policy_bundle
    }
    pub fn clear_policy_bundle(&mut self) {
        self.policy_bundle.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy_bundle(&mut self, v: ::protobuf::RepeatedField<AnalyzerOrgPolicy>) {
        self.policy_bundle = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policy_bundle(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzerOrgPolicy> {
        &mut self.policy_bundle
    }

    // Take field
    pub fn take_policy_bundle(&mut self) -> ::protobuf::RepeatedField<AnalyzerOrgPolicy> {
        ::std::mem::replace(&mut self.policy_bundle, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.consolidated_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.policy_bundle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.full_resource_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consolidated_policy)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policy_bundle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.full_resource_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.full_resource_name);
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parent);
        }
        if let Some(ref v) = self.consolidated_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.policy_bundle {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.full_resource_name.is_empty() {
            os.write_string(1, &self.full_resource_name)?;
        }
        if !self.parent.is_empty() {
            os.write_string(2, &self.parent)?;
        }
        if let Some(ref v) = self.consolidated_policy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.policy_bundle {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
        AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "full_resource_name",
                |m: &AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &m.full_resource_name },
                |m: &mut AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &mut m.full_resource_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &m.parent },
                |m: &mut AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicy>>(
                "consolidated_policy",
                |m: &AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &m.consolidated_policy },
                |m: &mut AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &mut m.consolidated_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicy>>(
                "policy_bundle",
                |m: &AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &m.policy_bundle },
                |m: &mut AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer| { &mut m.policy_bundle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer>(
                "AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
    fn clear(&mut self) {
        self.full_resource_name.clear();
        self.parent.clear();
        self.consolidated_policy.clear();
        self.policy_bundle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedContainersResponse_GovernedContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedAssetsRequest {
    // message fields
    pub scope: ::std::string::String,
    pub constraint: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_token: ::std::string::String,
    // message oneof groups
    pub _page_size: ::std::option::Option<AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedAssetsRequest {
    fn default() -> &'a AnalyzeOrgPolicyGovernedAssetsRequest {
        <AnalyzeOrgPolicyGovernedAssetsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size {
    page_size(i32),
}

impl AnalyzeOrgPolicyGovernedAssetsRequest {
    pub fn new() -> AnalyzeOrgPolicyGovernedAssetsRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string constraint = 2;


    pub fn get_constraint(&self) -> &str {
        &self.constraint
    }
    pub fn clear_constraint(&mut self) {
        self.constraint.clear();
    }

    // Param is passed by value, moved
    pub fn set_constraint(&mut self, v: ::std::string::String) {
        self.constraint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_constraint(&mut self) -> &mut ::std::string::String {
        &mut self.constraint
    }

    // Take field
    pub fn take_constraint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.constraint, ::std::string::String::new())
    }

    // string filter = 3;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 4;


    pub fn get_page_size(&self) -> i32 {
        match self._page_size {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size::page_size(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_page_size(&mut self) {
        self._page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        match self._page_size {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size::page_size(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self._page_size = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size::page_size(v))
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.constraint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._page_size = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size::page_size(is.read_int32()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if !self.constraint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.constraint);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filter);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if let ::std::option::Option::Some(ref v) = self._page_size {
            match v {
                &AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size::page_size(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if !self.constraint.is_empty() {
            os.write_string(2, &self.constraint)?;
        }
        if !self.filter.is_empty() {
            os.write_string(3, &self.filter)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if let ::std::option::Option::Some(ref v) = self._page_size {
            match v {
                &AnalyzeOrgPolicyGovernedAssetsRequest_oneof__page_size::page_size(v) => {
                    os.write_int32(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedAssetsRequest {
        AnalyzeOrgPolicyGovernedAssetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &AnalyzeOrgPolicyGovernedAssetsRequest| { &m.scope },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "constraint",
                |m: &AnalyzeOrgPolicyGovernedAssetsRequest| { &m.constraint },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsRequest| { &mut m.constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &AnalyzeOrgPolicyGovernedAssetsRequest| { &m.filter },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "page_size",
                AnalyzeOrgPolicyGovernedAssetsRequest::has_page_size,
                AnalyzeOrgPolicyGovernedAssetsRequest::get_page_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &AnalyzeOrgPolicyGovernedAssetsRequest| { &m.page_token },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedAssetsRequest>(
                "AnalyzeOrgPolicyGovernedAssetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedAssetsRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedAssetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedAssetsRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.constraint.clear();
        self.filter.clear();
        self._page_size = ::std::option::Option::None;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedAssetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedAssetsResponse {
    // message fields
    pub governed_assets: ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset>,
    pub constraint: ::protobuf::SingularPtrField<AnalyzerOrgPolicyConstraint>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedAssetsResponse {
    fn default() -> &'a AnalyzeOrgPolicyGovernedAssetsResponse {
        <AnalyzeOrgPolicyGovernedAssetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeOrgPolicyGovernedAssetsResponse {
    pub fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset governed_assets = 1;


    pub fn get_governed_assets(&self) -> &[AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset] {
        &self.governed_assets
    }
    pub fn clear_governed_assets(&mut self) {
        self.governed_assets.clear();
    }

    // Param is passed by value, moved
    pub fn set_governed_assets(&mut self, v: ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset>) {
        self.governed_assets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_governed_assets(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset> {
        &mut self.governed_assets
    }

    // Take field
    pub fn take_governed_assets(&mut self) -> ::protobuf::RepeatedField<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset> {
        ::std::mem::replace(&mut self.governed_assets, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicyConstraint constraint = 2;


    pub fn get_constraint(&self) -> &AnalyzerOrgPolicyConstraint {
        self.constraint.as_ref().unwrap_or_else(|| <AnalyzerOrgPolicyConstraint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_constraint(&mut self) {
        self.constraint.clear();
    }

    pub fn has_constraint(&self) -> bool {
        self.constraint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_constraint(&mut self, v: AnalyzerOrgPolicyConstraint) {
        self.constraint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_constraint(&mut self) -> &mut AnalyzerOrgPolicyConstraint {
        if self.constraint.is_none() {
            self.constraint.set_default();
        }
        self.constraint.as_mut().unwrap()
    }

    // Take field
    pub fn take_constraint(&mut self) -> AnalyzerOrgPolicyConstraint {
        self.constraint.take().unwrap_or_else(|| AnalyzerOrgPolicyConstraint::new())
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.governed_assets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.constraint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.governed_assets)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.constraint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.governed_assets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.constraint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.governed_assets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.constraint.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse {
        AnalyzeOrgPolicyGovernedAssetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset>>(
                "governed_assets",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse| { &m.governed_assets },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse| { &mut m.governed_assets },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicyConstraint>>(
                "constraint",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse| { &m.constraint },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse| { &mut m.constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse| { &m.next_page_token },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedAssetsResponse>(
                "AnalyzeOrgPolicyGovernedAssetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedAssetsResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedAssetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedAssetsResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn clear(&mut self) {
        self.governed_assets.clear();
        self.constraint.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedAssetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
    // message fields
    pub full_resource_name: ::std::string::String,
    pub parent: ::std::string::String,
    pub project: ::std::string::String,
    pub folders: ::protobuf::RepeatedField<::std::string::String>,
    pub organization: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
    fn default() -> &'a AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
        <AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
    pub fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
        ::std::default::Default::default()
    }

    // string full_resource_name = 1;


    pub fn get_full_resource_name(&self) -> &str {
        &self.full_resource_name
    }
    pub fn clear_full_resource_name(&mut self) {
        self.full_resource_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_resource_name(&mut self, v: ::std::string::String) {
        self.full_resource_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_resource_name(&mut self) -> &mut ::std::string::String {
        &mut self.full_resource_name
    }

    // Take field
    pub fn take_full_resource_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.full_resource_name, ::std::string::String::new())
    }

    // string parent = 2;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string project = 5;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // repeated string folders = 6;


    pub fn get_folders(&self) -> &[::std::string::String] {
        &self.folders
    }
    pub fn clear_folders(&mut self) {
        self.folders.clear();
    }

    // Param is passed by value, moved
    pub fn set_folders(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.folders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_folders(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.folders
    }

    // Take field
    pub fn take_folders(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.folders, ::protobuf::RepeatedField::new())
    }

    // string organization = 7;


    pub fn get_organization(&self) -> &str {
        &self.organization
    }
    pub fn clear_organization(&mut self) {
        self.organization.clear();
    }

    // Param is passed by value, moved
    pub fn set_organization(&mut self, v: ::std::string::String) {
        self.organization = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_organization(&mut self) -> &mut ::std::string::String {
        &mut self.organization
    }

    // Take field
    pub fn take_organization(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.organization, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.full_resource_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.folders)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.organization)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.full_resource_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.full_resource_name);
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parent);
        }
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.project);
        }
        for value in &self.folders {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.organization.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.organization);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.full_resource_name.is_empty() {
            os.write_string(1, &self.full_resource_name)?;
        }
        if !self.parent.is_empty() {
            os.write_string(2, &self.parent)?;
        }
        if !self.project.is_empty() {
            os.write_string(5, &self.project)?;
        }
        for v in &self.folders {
            os.write_string(6, &v)?;
        };
        if !self.organization.is_empty() {
            os.write_string(7, &self.organization)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
        AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "full_resource_name",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &m.full_resource_name },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &mut m.full_resource_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &m.parent },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &m.project },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folders",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &m.folders },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &mut m.folders },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "organization",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &m.organization },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource| { &mut m.organization },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource>(
                "AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
    fn clear(&mut self) {
        self.full_resource_name.clear();
        self.parent.clear();
        self.project.clear();
        self.folders.clear();
        self.organization.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
    // message fields
    pub attached_resource: ::std::string::String,
    pub policy: ::protobuf::SingularPtrField<super::policy::Policy>,
    pub project: ::std::string::String,
    pub folders: ::protobuf::RepeatedField<::std::string::String>,
    pub organization: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
    fn default() -> &'a AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
        <AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
    pub fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
        ::std::default::Default::default()
    }

    // string attached_resource = 1;


    pub fn get_attached_resource(&self) -> &str {
        &self.attached_resource
    }
    pub fn clear_attached_resource(&mut self) {
        self.attached_resource.clear();
    }

    // Param is passed by value, moved
    pub fn set_attached_resource(&mut self, v: ::std::string::String) {
        self.attached_resource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attached_resource(&mut self) -> &mut ::std::string::String {
        &mut self.attached_resource
    }

    // Take field
    pub fn take_attached_resource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attached_resource, ::std::string::String::new())
    }

    // .google.iam.v1.Policy policy = 2;


    pub fn get_policy(&self) -> &super::policy::Policy {
        self.policy.as_ref().unwrap_or_else(|| <super::policy::Policy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: super::policy::Policy) {
        self.policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut super::policy::Policy {
        if self.policy.is_none() {
            self.policy.set_default();
        }
        self.policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_policy(&mut self) -> super::policy::Policy {
        self.policy.take().unwrap_or_else(|| super::policy::Policy::new())
    }

    // string project = 5;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // repeated string folders = 6;


    pub fn get_folders(&self) -> &[::std::string::String] {
        &self.folders
    }
    pub fn clear_folders(&mut self) {
        self.folders.clear();
    }

    // Param is passed by value, moved
    pub fn set_folders(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.folders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_folders(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.folders
    }

    // Take field
    pub fn take_folders(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.folders, ::protobuf::RepeatedField::new())
    }

    // string organization = 7;


    pub fn get_organization(&self) -> &str {
        &self.organization
    }
    pub fn clear_organization(&mut self) {
        self.organization.clear();
    }

    // Param is passed by value, moved
    pub fn set_organization(&mut self, v: ::std::string::String) {
        self.organization = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_organization(&mut self) -> &mut ::std::string::String {
        &mut self.organization
    }

    // Take field
    pub fn take_organization(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.organization, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attached_resource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.policy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.folders)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.organization)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.attached_resource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.attached_resource);
        }
        if let Some(ref v) = self.policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.project);
        }
        for value in &self.folders {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.organization.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.organization);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.attached_resource.is_empty() {
            os.write_string(1, &self.attached_resource)?;
        }
        if let Some(ref v) = self.policy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.project.is_empty() {
            os.write_string(5, &self.project)?;
        }
        for v in &self.folders {
            os.write_string(6, &v)?;
        };
        if !self.organization.is_empty() {
            os.write_string(7, &self.organization)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
        AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attached_resource",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &m.attached_resource },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &mut m.attached_resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::policy::Policy>>(
                "policy",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &m.policy },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &mut m.policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &m.project },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folders",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &m.folders },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &mut m.folders },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "organization",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &m.organization },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy| { &mut m.organization },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy>(
                "AnalyzeOrgPolicyGovernedAssetsResponse.GovernedIamPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
    fn clear(&mut self) {
        self.attached_resource.clear();
        self.policy.clear();
        self.project.clear();
        self.folders.clear();
        self.organization.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
    // message fields
    pub consolidated_policy: ::protobuf::SingularPtrField<AnalyzerOrgPolicy>,
    pub policy_bundle: ::protobuf::RepeatedField<AnalyzerOrgPolicy>,
    // message oneof groups
    pub governed_asset: ::std::option::Option<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
    fn default() -> &'a AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
        <AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset {
    governed_resource(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource),
    governed_iam_policy(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy),
}

impl AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
    pub fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource governed_resource = 1;


    pub fn get_governed_resource(&self) -> &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
        match self.governed_asset {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(ref v)) => v,
            _ => <AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_governed_resource(&mut self) {
        self.governed_asset = ::std::option::Option::None;
    }

    pub fn has_governed_resource(&self) -> bool {
        match self.governed_asset {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_governed_resource(&mut self, v: AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource) {
        self.governed_asset = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_governed_resource(&mut self) -> &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
        if let ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(_)) = self.governed_asset {
        } else {
            self.governed_asset = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource::new()));
        }
        match self.governed_asset {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_governed_resource(&mut self) -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource {
        if self.has_governed_resource() {
            match self.governed_asset.take() {
                ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(v)) => v,
                _ => panic!(),
            }
        } else {
            AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource::new()
        }
    }

    // .google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedIamPolicy governed_iam_policy = 2;


    pub fn get_governed_iam_policy(&self) -> &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
        match self.governed_asset {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(ref v)) => v,
            _ => <AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_governed_iam_policy(&mut self) {
        self.governed_asset = ::std::option::Option::None;
    }

    pub fn has_governed_iam_policy(&self) -> bool {
        match self.governed_asset {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_governed_iam_policy(&mut self, v: AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy) {
        self.governed_asset = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_governed_iam_policy(&mut self) -> &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
        if let ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(_)) = self.governed_asset {
        } else {
            self.governed_asset = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy::new()));
        }
        match self.governed_asset {
            ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_governed_iam_policy(&mut self) -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy {
        if self.has_governed_iam_policy() {
            match self.governed_asset.take() {
                ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(v)) => v,
                _ => panic!(),
            }
        } else {
            AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy::new()
        }
    }

    // .google.cloud.asset.v1.AnalyzerOrgPolicy consolidated_policy = 3;


    pub fn get_consolidated_policy(&self) -> &AnalyzerOrgPolicy {
        self.consolidated_policy.as_ref().unwrap_or_else(|| <AnalyzerOrgPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consolidated_policy(&mut self) {
        self.consolidated_policy.clear();
    }

    pub fn has_consolidated_policy(&self) -> bool {
        self.consolidated_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consolidated_policy(&mut self, v: AnalyzerOrgPolicy) {
        self.consolidated_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consolidated_policy(&mut self) -> &mut AnalyzerOrgPolicy {
        if self.consolidated_policy.is_none() {
            self.consolidated_policy.set_default();
        }
        self.consolidated_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_consolidated_policy(&mut self) -> AnalyzerOrgPolicy {
        self.consolidated_policy.take().unwrap_or_else(|| AnalyzerOrgPolicy::new())
    }

    // repeated .google.cloud.asset.v1.AnalyzerOrgPolicy policy_bundle = 4;


    pub fn get_policy_bundle(&self) -> &[AnalyzerOrgPolicy] {
        &self.policy_bundle
    }
    pub fn clear_policy_bundle(&mut self) {
        self.policy_bundle.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy_bundle(&mut self, v: ::protobuf::RepeatedField<AnalyzerOrgPolicy>) {
        self.policy_bundle = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policy_bundle(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzerOrgPolicy> {
        &mut self.policy_bundle
    }

    // Take field
    pub fn take_policy_bundle(&mut self) -> ::protobuf::RepeatedField<AnalyzerOrgPolicy> {
        ::std::mem::replace(&mut self.policy_bundle, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
    fn is_initialized(&self) -> bool {
        if let Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(ref v)) = self.governed_asset {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(ref v)) = self.governed_asset {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.consolidated_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.policy_bundle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.governed_asset = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.governed_asset = ::std::option::Option::Some(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consolidated_policy)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policy_bundle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consolidated_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.policy_bundle {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.governed_asset {
            match v {
                &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consolidated_policy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.policy_bundle {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.governed_asset {
            match v {
                &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_resource(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset_oneof_governed_asset::governed_iam_policy(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
        AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AnalyzeOrgPolicyGovernedAssetsResponse_GovernedResource>(
                "governed_resource",
                AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset::has_governed_resource,
                AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset::get_governed_resource,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AnalyzeOrgPolicyGovernedAssetsResponse_GovernedIamPolicy>(
                "governed_iam_policy",
                AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset::has_governed_iam_policy,
                AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset::get_governed_iam_policy,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicy>>(
                "consolidated_policy",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset| { &m.consolidated_policy },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset| { &mut m.consolidated_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzerOrgPolicy>>(
                "policy_bundle",
                |m: &AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset| { &m.policy_bundle },
                |m: &mut AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset| { &mut m.policy_bundle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset>(
                "AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAsset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
        static instance: ::protobuf::rt::LazyV2<AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset::new)
    }
}

impl ::protobuf::Clear for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
    fn clear(&mut self) {
        self.governed_asset = ::std::option::Option::None;
        self.governed_asset = ::std::option::Option::None;
        self.consolidated_policy.clear();
        self.policy_bundle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeOrgPolicyGovernedAssetsResponse_GovernedAsset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContentType {
    CONTENT_TYPE_UNSPECIFIED = 0,
    RESOURCE = 1,
    IAM_POLICY = 2,
    ORG_POLICY = 4,
    ACCESS_POLICY = 5,
    OS_INVENTORY = 6,
    RELATIONSHIP = 7,
}

impl ::protobuf::ProtobufEnum for ContentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContentType> {
        match value {
            0 => ::std::option::Option::Some(ContentType::CONTENT_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ContentType::RESOURCE),
            2 => ::std::option::Option::Some(ContentType::IAM_POLICY),
            4 => ::std::option::Option::Some(ContentType::ORG_POLICY),
            5 => ::std::option::Option::Some(ContentType::ACCESS_POLICY),
            6 => ::std::option::Option::Some(ContentType::OS_INVENTORY),
            7 => ::std::option::Option::Some(ContentType::RELATIONSHIP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContentType] = &[
            ContentType::CONTENT_TYPE_UNSPECIFIED,
            ContentType::RESOURCE,
            ContentType::IAM_POLICY,
            ContentType::ORG_POLICY,
            ContentType::ACCESS_POLICY,
            ContentType::OS_INVENTORY,
            ContentType::RELATIONSHIP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContentType>("ContentType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContentType {
}

impl ::std::default::Default for ContentType {
    fn default() -> Self {
        ContentType::CONTENT_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)google/cloud/asset/v1/asset_service.proto\x12\x15google.cloud.asset.v\
    1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\
    \x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.proto\x1a\
    \"google/cloud/asset/v1/assets.proto\x1a\x1agoogle/iam/v1/policy.proto\
    \x1a#google/longrunning/operations.proto\x1a\x1egoogle/protobuf/duration\
    .proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x20google/protobuf/field_m\
    ask.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/tim\
    estamp.proto\x1a\x17google/rpc/status.proto\x1a\x16google/type/expr.prot\
    o\"g\n#AnalyzeIamPolicyLongrunningMetadata\x12@\n\x0bcreate_time\x18\x01\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTimeB\x03\xe0A\x03\
    \"\xf5\x02\n\x13ExportAssetsRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\
    \x06parentB'\xfaA!\x12\x1fcloudasset.googleapis.com/Asset\xe0A\x02\x127\
    \n\tread_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x08re\
    adTime\x12\x1f\n\x0basset_types\x18\x03\x20\x03(\tR\nassetTypes\x12E\n\
    \x0ccontent_type\x18\x04\x20\x01(\x0e2\".google.cloud.asset.v1.ContentTy\
    peR\x0bcontentType\x12M\n\routput_config\x18\x05\x20\x01(\x0b2#.google.c\
    loud.asset.v1.OutputConfigR\x0coutputConfigB\x03\xe0A\x02\x12-\n\x12rela\
    tionship_types\x18\x06\x20\x03(\tR\x11relationshipTypes\"\xe3\x01\n\x14E\
    xportAssetsResponse\x127\n\tread_time\x18\x01\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\x08readTime\x12H\n\routput_config\x18\x02\x20\x01(\
    \x0b2#.google.cloud.asset.v1.OutputConfigR\x0coutputConfig\x12H\n\routpu\
    t_result\x18\x03\x20\x01(\x0b2#.google.cloud.asset.v1.OutputResultR\x0co\
    utputResult\"\xe0\x02\n\x11ListAssetsRequest\x12?\n\x06parent\x18\x01\
    \x20\x01(\tR\x06parentB'\xfaA!\x12\x1fcloudasset.googleapis.com/Asset\
    \xe0A\x02\x127\n\tread_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Ti\
    mestampR\x08readTime\x12\x1f\n\x0basset_types\x18\x03\x20\x03(\tR\nasset\
    Types\x12E\n\x0ccontent_type\x18\x04\x20\x01(\x0e2\".google.cloud.asset.\
    v1.ContentTypeR\x0bcontentType\x12\x1b\n\tpage_size\x18\x05\x20\x01(\x05\
    R\x08pageSize\x12\x1d\n\npage_token\x18\x06\x20\x01(\tR\tpageToken\x12-\
    \n\x12relationship_types\x18\x07\x20\x03(\tR\x11relationshipTypes\"\xab\
    \x01\n\x12ListAssetsResponse\x127\n\tread_time\x18\x01\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\x08readTime\x124\n\x06assets\x18\x02\x20\x03\
    (\x0b2\x1c.google.cloud.asset.v1.AssetR\x06assets\x12&\n\x0fnext_page_to\
    ken\x18\x03\x20\x01(\tR\rnextPageToken\"\xd2\x02\n\x1cBatchGetAssetsHist\
    oryRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\x12\
    \x1fcloudasset.googleapis.com/Asset\xe0A\x02\x12\x1f\n\x0basset_names\
    \x18\x02\x20\x03(\tR\nassetNames\x12J\n\x0ccontent_type\x18\x03\x20\x01(\
    \x0e2\".google.cloud.asset.v1.ContentTypeR\x0bcontentTypeB\x03\xe0A\x01\
    \x12P\n\x10read_time_window\x18\x04\x20\x01(\x0b2!.google.cloud.asset.v1\
    .TimeWindowR\x0ereadTimeWindowB\x03\xe0A\x01\x122\n\x12relationship_type\
    s\x18\x05\x20\x03(\tR\x11relationshipTypesB\x03\xe0A\x01\"]\n\x1dBatchGe\
    tAssetsHistoryResponse\x12<\n\x06assets\x18\x01\x20\x03(\x0b2$.google.cl\
    oud.asset.v1.TemporalAssetR\x06assets\"\x84\x01\n\x11CreateFeedRequest\
    \x12\x1b\n\x06parent\x18\x01\x20\x01(\tR\x06parentB\x03\xe0A\x02\x12\x1c\
    \n\x07feed_id\x18\x02\x20\x01(\tR\x06feedIdB\x03\xe0A\x02\x124\n\x04feed\
    \x18\x03\x20\x01(\x0b2\x1b.google.cloud.asset.v1.FeedR\x04feedB\x03\xe0A\
    \x02\"L\n\x0eGetFeedRequest\x12:\n\x04name\x18\x01\x20\x01(\tR\x04nameB&\
    \xfaA\x20\n\x1ecloudasset.googleapis.com/Feed\xe0A\x02\"/\n\x10ListFeeds\
    Request\x12\x1b\n\x06parent\x18\x01\x20\x01(\tR\x06parentB\x03\xe0A\x02\
    \"F\n\x11ListFeedsResponse\x121\n\x05feeds\x18\x01\x20\x03(\x0b2\x1b.goo\
    gle.cloud.asset.v1.FeedR\x05feeds\"\x8b\x01\n\x11UpdateFeedRequest\x124\
    \n\x04feed\x18\x01\x20\x01(\x0b2\x1b.google.cloud.asset.v1.FeedR\x04feed\
    B\x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.pr\
    otobuf.FieldMaskR\nupdateMaskB\x03\xe0A\x02\"O\n\x11DeleteFeedRequest\
    \x12:\n\x04name\x18\x01\x20\x01(\tR\x04nameB&\xfaA\x20\n\x1ecloudasset.g\
    oogleapis.com/Feed\xe0A\x02\"\xd0\x01\n\x0cOutputConfig\x12P\n\x0fgcs_de\
    stination\x18\x01\x20\x01(\x0b2%.google.cloud.asset.v1.GcsDestinationH\0\
    R\x0egcsDestination\x12_\n\x14bigquery_destination\x18\x02\x20\x01(\x0b2\
    *.google.cloud.asset.v1.BigQueryDestinationH\0R\x13bigqueryDestinationB\
    \r\n\x0bdestination\"a\n\x0cOutputResult\x12G\n\ngcs_result\x18\x01\x20\
    \x01(\x0b2&.google.cloud.asset.v1.GcsOutputResultH\0R\tgcsResultB\x08\n\
    \x06result\"%\n\x0fGcsOutputResult\x12\x12\n\x04uris\x18\x01\x20\x03(\tR\
    \x04uris\"S\n\x0eGcsDestination\x12\x12\n\x03uri\x18\x01\x20\x01(\tH\0R\
    \x03uri\x12\x1f\n\nuri_prefix\x18\x02\x20\x01(\tH\0R\turiPrefixB\x0c\n\n\
    object_uri\"\xf6\x01\n\x13BigQueryDestination\x12\x1d\n\x07dataset\x18\
    \x01\x20\x01(\tR\x07datasetB\x03\xe0A\x02\x12\x19\n\x05table\x18\x02\x20\
    \x01(\tR\x05tableB\x03\xe0A\x02\x12\x14\n\x05force\x18\x03\x20\x01(\x08R\
    \x05force\x12K\n\x0epartition_spec\x18\x04\x20\x01(\x0b2$.google.cloud.a\
    sset.v1.PartitionSpecR\rpartitionSpec\x12B\n\x1eseparate_tables_per_asse\
    t_type\x18\x05\x20\x01(\x08R\x1aseparateTablesPerAssetType\"\xb7\x01\n\r\
    PartitionSpec\x12V\n\rpartition_key\x18\x01\x20\x01(\x0e21.google.cloud.\
    asset.v1.PartitionSpec.PartitionKeyR\x0cpartitionKey\"N\n\x0cPartitionKe\
    y\x12\x1d\n\x19PARTITION_KEY_UNSPECIFIED\x10\0\x12\r\n\tREAD_TIME\x10\
    \x01\x12\x10\n\x0cREQUEST_TIME\x10\x02\")\n\x11PubsubDestination\x12\x14\
    \n\x05topic\x18\x01\x20\x01(\tR\x05topic\"|\n\x10FeedOutputConfig\x12Y\n\
    \x12pubsub_destination\x18\x01\x20\x01(\x0b2(.google.cloud.asset.v1.Pubs\
    ubDestinationH\0R\x11pubsubDestinationB\r\n\x0bdestination\"\xf8\x03\n\
    \x04Feed\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x03\xe0A\x02\x12\
    \x1f\n\x0basset_names\x18\x02\x20\x03(\tR\nassetNames\x12\x1f\n\x0basset\
    _types\x18\x03\x20\x03(\tR\nassetTypes\x12E\n\x0ccontent_type\x18\x04\
    \x20\x01(\x0e2\".google.cloud.asset.v1.ContentTypeR\x0bcontentType\x12Z\
    \n\x12feed_output_config\x18\x05\x20\x01(\x0b2'.google.cloud.asset.v1.Fe\
    edOutputConfigR\x10feedOutputConfigB\x03\xe0A\x02\x12/\n\tcondition\x18\
    \x06\x20\x01(\x0b2\x11.google.type.ExprR\tcondition\x12-\n\x12relationsh\
    ip_types\x18\x07\x20\x03(\tR\x11relationshipTypes:\x91\x01\xeaA\x8d\x01\
    \n\x1ecloudasset.googleapis.com/Feed\x12\x1fprojects/{project}/feeds/{fe\
    ed}\x12\x1dfolders/{folder}/feeds/{feed}\x12)organizations/{organization\
    }/feeds/{feed}\x20\x01\"\x9b\x02\n\x19SearchAllResourcesRequest\x12\x19\
    \n\x05scope\x18\x01\x20\x01(\tR\x05scopeB\x03\xe0A\x02\x12\x19\n\x05quer\
    y\x18\x02\x20\x01(\tR\x05queryB\x03\xe0A\x01\x12$\n\x0basset_types\x18\
    \x03\x20\x03(\tR\nassetTypesB\x03\xe0A\x01\x12\x20\n\tpage_size\x18\x04\
    \x20\x01(\x05R\x08pageSizeB\x03\xe0A\x01\x12\"\n\npage_token\x18\x05\x20\
    \x01(\tR\tpageTokenB\x03\xe0A\x01\x12\x1e\n\x08order_by\x18\x06\x20\x01(\
    \tR\x07orderByB\x03\xe0A\x01\x12<\n\tread_mask\x18\x08\x20\x01(\x0b2\x1a\
    .google.protobuf.FieldMaskR\x08readMaskB\x03\xe0A\x01\"\x8b\x01\n\x1aSea\
    rchAllResourcesResponse\x12E\n\x07results\x18\x01\x20\x03(\x0b2+.google.\
    cloud.asset.v1.ResourceSearchResultR\x07results\x12&\n\x0fnext_page_toke\
    n\x18\x02\x20\x01(\tR\rnextPageToken\"\xdf\x01\n\x1bSearchAllIamPolicies\
    Request\x12\x19\n\x05scope\x18\x01\x20\x01(\tR\x05scopeB\x03\xe0A\x02\
    \x12\x19\n\x05query\x18\x02\x20\x01(\tR\x05queryB\x03\xe0A\x01\x12\x20\n\
    \tpage_size\x18\x03\x20\x01(\x05R\x08pageSizeB\x03\xe0A\x01\x12\"\n\npag\
    e_token\x18\x04\x20\x01(\tR\tpageTokenB\x03\xe0A\x01\x12$\n\x0basset_typ\
    es\x18\x05\x20\x03(\tR\nassetTypesB\x03\xe0A\x01\x12\x1e\n\x08order_by\
    \x18\x07\x20\x01(\tR\x07orderByB\x03\xe0A\x01\"\x8e\x01\n\x1cSearchAllIa\
    mPoliciesResponse\x12F\n\x07results\x18\x01\x20\x03(\x0b2,.google.cloud.\
    asset.v1.IamPolicySearchResultR\x07results\x12&\n\x0fnext_page_token\x18\
    \x02\x20\x01(\tR\rnextPageToken\"\xcf\t\n\x16IamPolicyAnalysisQuery\x12\
    \x19\n\x05scope\x18\x01\x20\x01(\tR\x05scopeB\x03\xe0A\x02\x12p\n\x11res\
    ource_selector\x18\x02\x20\x01(\x0b2>.google.cloud.asset.v1.IamPolicyAna\
    lysisQuery.ResourceSelectorR\x10resourceSelectorB\x03\xe0A\x01\x12p\n\
    \x11identity_selector\x18\x03\x20\x01(\x0b2>.google.cloud.asset.v1.IamPo\
    licyAnalysisQuery.IdentitySelectorR\x10identitySelectorB\x03\xe0A\x01\
    \x12j\n\x0faccess_selector\x18\x04\x20\x01(\x0b2<.google.cloud.asset.v1.\
    IamPolicyAnalysisQuery.AccessSelectorR\x0eaccessSelectorB\x03\xe0A\x01\
    \x12T\n\x07options\x18\x05\x20\x01(\x0b25.google.cloud.asset.v1.IamPolic\
    yAnalysisQuery.OptionsR\x07optionsB\x03\xe0A\x01\x12p\n\x11condition_con\
    text\x18\x06\x20\x01(\x0b2>.google.cloud.asset.v1.IamPolicyAnalysisQuery\
    .ConditionContextR\x10conditionContextB\x03\xe0A\x01\x1aE\n\x10ResourceS\
    elector\x121\n\x12full_resource_name\x18\x01\x20\x01(\tR\x10fullResource\
    NameB\x03\xe0A\x02\x1a3\n\x10IdentitySelector\x12\x1f\n\x08identity\x18\
    \x01\x20\x01(\tR\x08identityB\x03\xe0A\x02\x1aR\n\x0eAccessSelector\x12\
    \x19\n\x05roles\x18\x01\x20\x03(\tR\x05rolesB\x03\xe0A\x01\x12%\n\x0bper\
    missions\x18\x02\x20\x03(\tR\x0bpermissionsB\x03\xe0A\x01\x1a\xcf\x02\n\
    \x07Options\x12(\n\rexpand_groups\x18\x01\x20\x01(\x08R\x0cexpandGroupsB\
    \x03\xe0A\x01\x12&\n\x0cexpand_roles\x18\x02\x20\x01(\x08R\x0bexpandRole\
    sB\x03\xe0A\x01\x12.\n\x10expand_resources\x18\x03\x20\x01(\x08R\x0fexpa\
    ndResourcesB\x03\xe0A\x01\x127\n\x15output_resource_edges\x18\x04\x20\
    \x01(\x08R\x13outputResourceEdgesB\x03\xe0A\x01\x121\n\x12output_group_e\
    dges\x18\x05\x20\x01(\x08R\x10outputGroupEdgesB\x03\xe0A\x01\x12V\n%anal\
    yze_service_account_impersonation\x18\x06\x20\x01(\x08R\"analyzeServiceA\
    ccountImpersonationB\x03\xe0A\x01\x1a`\n\x10ConditionContext\x12=\n\x0ba\
    ccess_time\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\0R\nacce\
    ssTimeB\r\n\x0bTimeContext\"\xf8\x01\n\x17AnalyzeIamPolicyRequest\x12Y\n\
    \x0eanalysis_query\x18\x01\x20\x01(\x0b2-.google.cloud.asset.v1.IamPolic\
    yAnalysisQueryR\ranalysisQueryB\x03\xe0A\x02\x125\n\x14saved_analysis_qu\
    ery\x18\x03\x20\x01(\tR\x12savedAnalysisQueryB\x03\xe0A\x01\x12K\n\x11ex\
    ecution_timeout\x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\x10e\
    xecutionTimeoutB\x03\xe0A\x01\"\x8f\x05\n\x18AnalyzeIamPolicyResponse\
    \x12f\n\rmain_analysis\x18\x01\x20\x01(\x0b2A.google.cloud.asset.v1.Anal\
    yzeIamPolicyResponse.IamPolicyAnalysisR\x0cmainAnalysis\x12\x96\x01\n&se\
    rvice_account_impersonation_analysis\x18\x02\x20\x03(\x0b2A.google.cloud\
    .asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysisR#serviceAccountImpe\
    rsonationAnalysis\x12%\n\x0efully_explored\x18\x03\x20\x01(\x08R\rfullyE\
    xplored\x1a\xca\x02\n\x11IamPolicyAnalysis\x12T\n\x0eanalysis_query\x18\
    \x01\x20\x01(\x0b2-.google.cloud.asset.v1.IamPolicyAnalysisQueryR\ranaly\
    sisQuery\x12Y\n\x10analysis_results\x18\x02\x20\x03(\x0b2..google.cloud.\
    asset.v1.IamPolicyAnalysisResultR\x0fanalysisResults\x12%\n\x0efully_exp\
    lored\x18\x03\x20\x01(\x08R\rfullyExplored\x12]\n\x13non_critical_errors\
    \x18\x05\x20\x03(\x0b2-.google.cloud.asset.v1.IamPolicyAnalysisStateR\
    \x11nonCriticalErrors\"\x94\x05\n\x1dIamPolicyAnalysisOutputConfig\x12n\
    \n\x0fgcs_destination\x18\x01\x20\x01(\x0b2C.google.cloud.asset.v1.IamPo\
    licyAnalysisOutputConfig.GcsDestinationH\0R\x0egcsDestination\x12}\n\x14\
    bigquery_destination\x18\x02\x20\x01(\x0b2H.google.cloud.asset.v1.IamPol\
    icyAnalysisOutputConfig.BigQueryDestinationH\0R\x13bigqueryDestination\
    \x1a'\n\x0eGcsDestination\x12\x15\n\x03uri\x18\x01\x20\x01(\tR\x03uriB\
    \x03\xe0A\x02\x1a\xcb\x02\n\x13BigQueryDestination\x12\x1d\n\x07dataset\
    \x18\x01\x20\x01(\tR\x07datasetB\x03\xe0A\x02\x12&\n\x0ctable_prefix\x18\
    \x02\x20\x01(\tR\x0btablePrefixB\x03\xe0A\x02\x12z\n\rpartition_key\x18\
    \x03\x20\x01(\x0e2U.google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.\
    BigQueryDestination.PartitionKeyR\x0cpartitionKey\x120\n\x11write_dispos\
    ition\x18\x04\x20\x01(\tR\x10writeDispositionB\x03\xe0A\x01\"?\n\x0cPart\
    itionKey\x12\x1d\n\x19PARTITION_KEY_UNSPECIFIED\x10\0\x12\x10\n\x0cREQUE\
    ST_TIME\x10\x01B\r\n\x0bdestination\"\x96\x02\n\"AnalyzeIamPolicyLongrun\
    ningRequest\x12Y\n\x0eanalysis_query\x18\x01\x20\x01(\x0b2-.google.cloud\
    .asset.v1.IamPolicyAnalysisQueryR\ranalysisQueryB\x03\xe0A\x02\x125\n\
    \x14saved_analysis_query\x18\x03\x20\x01(\tR\x12savedAnalysisQueryB\x03\
    \xe0A\x01\x12^\n\routput_config\x18\x02\x20\x01(\x0b24.google.cloud.asse\
    t.v1.IamPolicyAnalysisOutputConfigR\x0coutputConfigB\x03\xe0A\x02\"%\n#A\
    nalyzeIamPolicyLongrunningResponse\"\xb2\x06\n\nSavedQuery\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\
    \x01(\tR\x0bdescription\x12@\n\x0bcreate_time\x18\x03\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\ncreateTimeB\x03\xe0A\x03\x12\x1d\n\x07creato\
    r\x18\x04\x20\x01(\tR\x07creatorB\x03\xe0A\x03\x12I\n\x10last_update_tim\
    e\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0elastUpdateTime\
    B\x03\xe0A\x03\x12&\n\x0clast_updater\x18\x06\x20\x01(\tR\x0blastUpdater\
    B\x03\xe0A\x03\x12E\n\x06labels\x18\x07\x20\x03(\x0b2-.google.cloud.asse\
    t.v1.SavedQuery.LabelsEntryR\x06labels\x12H\n\x07content\x18\x08\x20\x01\
    (\x0b2..google.cloud.asset.v1.SavedQuery.QueryContentR\x07content\x1a\
    \x8b\x01\n\x0cQueryContent\x12j\n\x19iam_policy_analysis_query\x18\x01\
    \x20\x01(\x0b2-.google.cloud.asset.v1.IamPolicyAnalysisQueryH\0R\x16iamP\
    olicyAnalysisQueryB\x0f\n\rquery_content\x1a9\n\x0bLabelsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01:\xbf\x01\xeaA\xbb\x01\n$cloudasset.googleapis.com/S\
    avedQuery\x12-projects/{project}/savedQueries/{saved_query}\x12+folders/\
    {folder}/savedQueries/{saved_query}\x127organizations/{organization}/sav\
    edQueries/{saved_query}\"\xd3\x01\n\x17CreateSavedQueryRequest\x12D\n\
    \x06parent\x18\x01\x20\x01(\tR\x06parentB,\xfaA&\x12$cloudasset.googleap\
    is.com/SavedQuery\xe0A\x02\x12G\n\x0bsaved_query\x18\x02\x20\x01(\x0b2!.\
    google.cloud.asset.v1.SavedQueryR\nsavedQueryB\x03\xe0A\x02\x12)\n\x0esa\
    ved_query_id\x18\x03\x20\x01(\tR\x0csavedQueryIdB\x03\xe0A\x02\"X\n\x14G\
    etSavedQueryRequest\x12@\n\x04name\x18\x01\x20\x01(\tR\x04nameB,\xfaA&\n\
    $cloudasset.googleapis.com/SavedQuery\xe0A\x02\"\xc2\x01\n\x17ListSavedQ\
    ueriesRequest\x12D\n\x06parent\x18\x01\x20\x01(\tR\x06parentB,\xfaA&\x12\
    $cloudasset.googleapis.com/SavedQuery\xe0A\x02\x12\x1b\n\x06filter\x18\
    \x04\x20\x01(\tR\x06filterB\x03\xe0A\x01\x12\x20\n\tpage_size\x18\x02\
    \x20\x01(\x05R\x08pageSizeB\x03\xe0A\x01\x12\"\n\npage_token\x18\x03\x20\
    \x01(\tR\tpageTokenB\x03\xe0A\x01\"\x8a\x01\n\x18ListSavedQueriesRespons\
    e\x12F\n\rsaved_queries\x18\x01\x20\x03(\x0b2!.google.cloud.asset.v1.Sav\
    edQueryR\x0csavedQueries\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\r\
    nextPageToken\"\xa4\x01\n\x17UpdateSavedQueryRequest\x12G\n\x0bsaved_que\
    ry\x18\x01\x20\x01(\x0b2!.google.cloud.asset.v1.SavedQueryR\nsavedQueryB\
    \x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.pro\
    tobuf.FieldMaskR\nupdateMaskB\x03\xe0A\x02\"[\n\x17DeleteSavedQueryReque\
    st\x12@\n\x04name\x18\x01\x20\x01(\tR\x04nameB,\xfaA&\n$cloudasset.googl\
    eapis.com/SavedQuery\xe0A\x02\"\xf9\x01\n\x12AnalyzeMoveRequest\x12\x1f\
    \n\x08resource\x18\x01\x20\x01(\tR\x08resourceB\x03\xe0A\x02\x122\n\x12d\
    estination_parent\x18\x02\x20\x01(\tR\x11destinationParentB\x03\xe0A\x02\
    \x12J\n\x04view\x18\x03\x20\x01(\x0e26.google.cloud.asset.v1.AnalyzeMove\
    Request.AnalysisViewR\x04view\"B\n\x0cAnalysisView\x12\x1d\n\x19ANALYSIS\
    _VIEW_UNSPECIFIED\x10\0\x12\x08\n\x04FULL\x10\x01\x12\t\n\x05BASIC\x10\
    \x02\"_\n\x13AnalyzeMoveResponse\x12H\n\rmove_analysis\x18\x01\x20\x03(\
    \x0b2#.google.cloud.asset.v1.MoveAnalysisR\x0cmoveAnalysis\"\xb0\x01\n\
    \x0cMoveAnalysis\x12!\n\x0cdisplay_name\x18\x01\x20\x01(\tR\x0bdisplayNa\
    me\x12G\n\x08analysis\x18\x02\x20\x01(\x0b2).google.cloud.asset.v1.MoveA\
    nalysisResultH\0R\x08analysis\x12*\n\x05error\x18\x03\x20\x01(\x0b2\x12.\
    google.rpc.StatusH\0R\x05errorB\x08\n\x06result\"\x92\x01\n\x12MoveAnaly\
    sisResult\x12=\n\x08blockers\x18\x01\x20\x03(\x0b2!.google.cloud.asset.v\
    1.MoveImpactR\x08blockers\x12=\n\x08warnings\x18\x02\x20\x03(\x0b2!.goog\
    le.cloud.asset.v1.MoveImpactR\x08warnings\"$\n\nMoveImpact\x12\x16\n\x06\
    detail\x18\x01\x20\x01(\tR\x06detail\"\x8e\x02\n\x17QueryAssetsOutputCon\
    fig\x12u\n\x14bigquery_destination\x18\x01\x20\x01(\x0b2B.google.cloud.a\
    sset.v1.QueryAssetsOutputConfig.BigQueryDestinationR\x13bigqueryDestinat\
    ion\x1a|\n\x13BigQueryDestination\x12\x1d\n\x07dataset\x18\x01\x20\x01(\
    \tR\x07datasetB\x03\xe0A\x02\x12\x19\n\x05table\x18\x02\x20\x01(\tR\x05t\
    ableB\x03\xe0A\x02\x12+\n\x11write_disposition\x18\x03\x20\x01(\tR\x10wr\
    iteDisposition\"\xa5\x04\n\x12QueryAssetsRequest\x12?\n\x06parent\x18\
    \x01\x20\x01(\tR\x06parentB'\xfaA!\x12\x1fcloudasset.googleapis.com/Asse\
    t\xe0A\x02\x12#\n\tstatement\x18\x02\x20\x01(\tH\0R\tstatementB\x03\xe0A\
    \x01\x12*\n\rjob_reference\x18\x03\x20\x01(\tH\0R\x0cjobReferenceB\x03\
    \xe0A\x01\x12\x20\n\tpage_size\x18\x04\x20\x01(\x05R\x08pageSizeB\x03\
    \xe0A\x01\x12\"\n\npage_token\x18\x05\x20\x01(\tR\tpageTokenB\x03\xe0A\
    \x01\x128\n\x07timeout\x18\x06\x20\x01(\x0b2\x19.google.protobuf.Duratio\
    nR\x07timeoutB\x03\xe0A\x01\x12R\n\x10read_time_window\x18\x07\x20\x01(\
    \x0b2!.google.cloud.asset.v1.TimeWindowH\x01R\x0ereadTimeWindowB\x03\xe0\
    A\x01\x12>\n\tread_time\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampH\x01R\x08readTimeB\x03\xe0A\x01\x12X\n\routput_config\x18\t\x20\x01(\
    \x0b2..google.cloud.asset.v1.QueryAssetsOutputConfigR\x0coutputConfigB\
    \x03\xe0A\x01B\x07\n\x05queryB\x06\n\x04time\"\xa6\x02\n\x13QueryAssetsR\
    esponse\x12#\n\rjob_reference\x18\x01\x20\x01(\tR\x0cjobReference\x12\
    \x12\n\x04done\x18\x02\x20\x01(\x08R\x04done\x12*\n\x05error\x18\x03\x20\
    \x01(\x0b2\x12.google.rpc.StatusH\0R\x05error\x12G\n\x0cquery_result\x18\
    \x04\x20\x01(\x0b2\".google.cloud.asset.v1.QueryResultH\0R\x0bqueryResul\
    t\x12U\n\routput_config\x18\x05\x20\x01(\x0b2..google.cloud.asset.v1.Que\
    ryAssetsOutputConfigH\0R\x0coutputConfigB\n\n\x08response\"\xbd\x01\n\
    \x0bQueryResult\x12+\n\x04rows\x18\x01\x20\x03(\x0b2\x17.google.protobuf\
    .StructR\x04rows\x12:\n\x06schema\x18\x02\x20\x01(\x0b2\".google.cloud.a\
    sset.v1.TableSchemaR\x06schema\x12&\n\x0fnext_page_token\x18\x03\x20\x01\
    (\tR\rnextPageToken\x12\x1d\n\ntotal_rows\x18\x04\x20\x01(\x03R\ttotalRo\
    ws\"N\n\x0bTableSchema\x12?\n\x06fields\x18\x01\x20\x03(\x0b2'.google.cl\
    oud.asset.v1.TableFieldSchemaR\x06fields\"\x91\x01\n\x10TableFieldSchema\
    \x12\x14\n\x05field\x18\x01\x20\x01(\tR\x05field\x12\x12\n\x04type\x18\
    \x02\x20\x01(\tR\x04type\x12\x12\n\x04mode\x18\x03\x20\x01(\tR\x04mode\
    \x12?\n\x06fields\x18\x04\x20\x03(\x0b2'.google.cloud.asset.v1.TableFiel\
    dSchemaR\x06fields\"g\n#BatchGetEffectiveIamPoliciesRequest\x12\x1f\n\
    \x05scope\x18\x01\x20\x01(\tR\x05scopeB\t\xfaA\x03\x12\x01*\xe0A\x02\x12\
    \x1f\n\x05names\x18\x03\x20\x03(\tR\x05namesB\t\xfaA\x03\n\x01*\xe0A\x02\
    \"\xc3\x03\n$BatchGetEffectiveIamPoliciesResponse\x12u\n\x0epolicy_resul\
    ts\x18\x02\x20\x03(\x0b2N.google.cloud.asset.v1.BatchGetEffectiveIamPoli\
    ciesResponse.EffectiveIamPolicyR\rpolicyResults\x1a\xa3\x02\n\x12Effecti\
    veIamPolicy\x12,\n\x12full_resource_name\x18\x01\x20\x01(\tR\x10fullReso\
    urceName\x12u\n\x08policies\x18\x02\x20\x03(\x0b2Y.google.cloud.asset.v1\
    .BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfoR\x08\
    policies\x1ah\n\nPolicyInfo\x12+\n\x11attached_resource\x18\x01\x20\x01(\
    \tR\x10attachedResource\x12-\n\x06policy\x18\x02\x20\x01(\x0b2\x15.googl\
    e.iam.v1.PolicyR\x06policy\"\xc2\x04\n\x11AnalyzerOrgPolicy\x12+\n\x11at\
    tached_resource\x18\x01\x20\x01(\tR\x10attachedResource\x12)\n\x10applie\
    d_resource\x18\x05\x20\x01(\tR\x0fappliedResource\x12C\n\x05rules\x18\
    \x02\x20\x03(\x0b2-.google.cloud.asset.v1.AnalyzerOrgPolicy.RuleR\x05rul\
    es\x12.\n\x13inherit_from_parent\x18\x03\x20\x01(\x08R\x11inheritFromPar\
    ent\x12\x14\n\x05reset\x18\x04\x20\x01(\x08R\x05reset\x1a\xc9\x02\n\x04R\
    ule\x12T\n\x06values\x18\x03\x20\x01(\x0b2:.google.cloud.asset.v1.Analyz\
    erOrgPolicy.Rule.StringValuesH\0R\x06values\x12\x1d\n\tallow_all\x18\x04\
    \x20\x01(\x08H\0R\x08allowAll\x12\x1b\n\x08deny_all\x18\x05\x20\x01(\x08\
    H\0R\x07denyAll\x12\x1a\n\x07enforce\x18\x06\x20\x01(\x08H\0R\x07enforce\
    \x12/\n\tcondition\x18\x07\x20\x01(\x0b2\x11.google.type.ExprR\tconditio\
    n\x1aZ\n\x0cStringValues\x12%\n\x0eallowed_values\x18\x01\x20\x03(\tR\ra\
    llowedValues\x12#\n\rdenied_values\x18\x02\x20\x03(\tR\x0cdeniedValuesB\
    \x06\n\x04kind\"\x81\x0c\n\x1bAnalyzerOrgPolicyConstraint\x12{\n\x19goog\
    le_defined_constraint\x18\x01\x20\x01(\x0b2=.google.cloud.asset.v1.Analy\
    zerOrgPolicyConstraint.ConstraintH\0R\x17googleDefinedConstraint\x12r\n\
    \x11custom_constraint\x18\x02\x20\x01(\x0b2C.google.cloud.asset.v1.Analy\
    zerOrgPolicyConstraint.CustomConstraintH\0R\x10customConstraint\x1a\xb1\
    \x05\n\nConstraint\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\
    \x0cdisplay_name\x18\x02\x20\x01(\tR\x0bdisplayName\x12\x20\n\x0bdescrip\
    tion\x18\x03\x20\x01(\tR\x0bdescription\x12~\n\x12constraint_default\x18\
    \x04\x20\x01(\x0e2O.google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Co\
    nstraint.ConstraintDefaultR\x11constraintDefault\x12w\n\x0flist_constrai\
    nt\x18\x05\x20\x01(\x0b2L.google.cloud.asset.v1.AnalyzerOrgPolicyConstra\
    int.Constraint.ListConstraintH\0R\x0elistConstraint\x12\x80\x01\n\x12boo\
    lean_constraint\x18\x06\x20\x01(\x0b2O.google.cloud.asset.v1.AnalyzerOrg\
    PolicyConstraint.Constraint.BooleanConstraintH\0R\x11booleanConstraint\
    \x1aX\n\x0eListConstraint\x12\x1f\n\x0bsupports_in\x18\x01\x20\x01(\x08R\
    \nsupportsIn\x12%\n\x0esupports_under\x18\x02\x20\x01(\x08R\rsupportsUnd\
    er\x1a\x13\n\x11BooleanConstraint\"L\n\x11ConstraintDefault\x12\"\n\x1eC\
    ONSTRAINT_DEFAULT_UNSPECIFIED\x10\0\x12\t\n\x05ALLOW\x10\x01\x12\x08\n\
    \x04DENY\x10\x02B\x11\n\x0fconstraint_type\x1a\xa3\x04\n\x10CustomConstr\
    aint\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12%\n\x0eresource_ty\
    pes\x18\x02\x20\x03(\tR\rresourceTypes\x12q\n\x0cmethod_types\x18\x03\
    \x20\x03(\x0e2N.google.cloud.asset.v1.AnalyzerOrgPolicyConstraint.Custom\
    Constraint.MethodTypeR\x0bmethodTypes\x12\x1c\n\tcondition\x18\x04\x20\
    \x01(\tR\tcondition\x12o\n\x0baction_type\x18\x05\x20\x01(\x0e2N.google.\
    cloud.asset.v1.AnalyzerOrgPolicyConstraint.CustomConstraint.ActionTypeR\
    \nactionType\x12!\n\x0cdisplay_name\x18\x06\x20\x01(\tR\x0bdisplayName\
    \x12\x20\n\x0bdescription\x18\x07\x20\x01(\tR\x0bdescription\"M\n\nMetho\
    dType\x12\x1b\n\x17METHOD_TYPE_UNSPECIFIED\x10\0\x12\n\n\x06CREATE\x10\
    \x01\x12\n\n\x06UPDATE\x10\x02\x12\n\n\x06DELETE\x10\x03\">\n\nActionTyp\
    e\x12\x1b\n\x17ACTION_TYPE_UNSPECIFIED\x10\0\x12\t\n\x05ALLOW\x10\x01\
    \x12\x08\n\x04DENY\x10\x02B\x17\n\x15constraint_definition\"\xc2\x01\n\
    \x19AnalyzeOrgPoliciesRequest\x12\x19\n\x05scope\x18\x01\x20\x01(\tR\x05\
    scopeB\x03\xe0A\x02\x12#\n\nconstraint\x18\x02\x20\x01(\tR\nconstraintB\
    \x03\xe0A\x02\x12\x16\n\x06filter\x18\x03\x20\x01(\tR\x06filter\x12\x20\
    \n\tpage_size\x18\x04\x20\x01(\x05H\0R\x08pageSize\x88\x01\x01\x12\x1d\n\
    \npage_token\x18\x05\x20\x01(\tR\tpageTokenB\x0c\n\n_page_size\"\xc7\x03\
    \n\x1aAnalyzeOrgPoliciesResponse\x12o\n\x12org_policy_results\x18\x01\
    \x20\x03(\x0b2A.google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.OrgPoli\
    cyResultR\x10orgPolicyResults\x12R\n\nconstraint\x18\x02\x20\x01(\x0b22.\
    google.cloud.asset.v1.AnalyzerOrgPolicyConstraintR\nconstraint\x12&\n\
    \x0fnext_page_token\x18\x03\x20\x01(\tR\rnextPageToken\x1a\xbb\x01\n\x0f\
    OrgPolicyResult\x12Y\n\x13consolidated_policy\x18\x01\x20\x01(\x0b2(.goo\
    gle.cloud.asset.v1.AnalyzerOrgPolicyR\x12consolidatedPolicy\x12M\n\rpoli\
    cy_bundle\x18\x02\x20\x03(\x0b2(.google.cloud.asset.v1.AnalyzerOrgPolicy\
    R\x0cpolicyBundle\"\xd2\x01\n)AnalyzeOrgPolicyGovernedContainersRequest\
    \x12\x19\n\x05scope\x18\x01\x20\x01(\tR\x05scopeB\x03\xe0A\x02\x12#\n\nc\
    onstraint\x18\x02\x20\x01(\tR\nconstraintB\x03\xe0A\x02\x12\x16\n\x06fil\
    ter\x18\x03\x20\x01(\tR\x06filter\x12\x20\n\tpage_size\x18\x04\x20\x01(\
    \x05H\0R\x08pageSize\x88\x01\x01\x12\x1d\n\npage_token\x18\x05\x20\x01(\
    \tR\tpageTokenB\x0c\n\n_page_size\"\xb5\x04\n*AnalyzeOrgPolicyGovernedCo\
    ntainersResponse\x12\x84\x01\n\x13governed_containers\x18\x01\x20\x03(\
    \x0b2S.google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.\
    GovernedContainerR\x12governedContainers\x12R\n\nconstraint\x18\x02\x20\
    \x01(\x0b22.google.cloud.asset.v1.AnalyzerOrgPolicyConstraintR\nconstrai\
    nt\x12&\n\x0fnext_page_token\x18\x03\x20\x01(\tR\rnextPageToken\x1a\x83\
    \x02\n\x11GovernedContainer\x12,\n\x12full_resource_name\x18\x01\x20\x01\
    (\tR\x10fullResourceName\x12\x16\n\x06parent\x18\x02\x20\x01(\tR\x06pare\
    nt\x12Y\n\x13consolidated_policy\x18\x03\x20\x01(\x0b2(.google.cloud.ass\
    et.v1.AnalyzerOrgPolicyR\x12consolidatedPolicy\x12M\n\rpolicy_bundle\x18\
    \x04\x20\x03(\x0b2(.google.cloud.asset.v1.AnalyzerOrgPolicyR\x0cpolicyBu\
    ndle\"\xce\x01\n%AnalyzeOrgPolicyGovernedAssetsRequest\x12\x19\n\x05scop\
    e\x18\x01\x20\x01(\tR\x05scopeB\x03\xe0A\x02\x12#\n\nconstraint\x18\x02\
    \x20\x01(\tR\nconstraintB\x03\xe0A\x02\x12\x16\n\x06filter\x18\x03\x20\
    \x01(\tR\x06filter\x12\x20\n\tpage_size\x18\x04\x20\x01(\x05H\0R\x08page\
    Size\x88\x01\x01\x12\x1d\n\npage_token\x18\x05\x20\x01(\tR\tpageTokenB\
    \x0c\n\n_page_size\"\xe8\x08\n&AnalyzeOrgPolicyGovernedAssetsResponse\
    \x12t\n\x0fgoverned_assets\x18\x01\x20\x03(\x0b2K.google.cloud.asset.v1.\
    AnalyzeOrgPolicyGovernedAssetsResponse.GovernedAssetR\x0egovernedAssets\
    \x12R\n\nconstraint\x18\x02\x20\x01(\x0b22.google.cloud.asset.v1.Analyze\
    rOrgPolicyConstraintR\nconstraint\x12&\n\x0fnext_page_token\x18\x03\x20\
    \x01(\tR\rnextPageToken\x1a\xb0\x01\n\x10GovernedResource\x12,\n\x12full\
    _resource_name\x18\x01\x20\x01(\tR\x10fullResourceName\x12\x16\n\x06pare\
    nt\x18\x02\x20\x01(\tR\x06parent\x12\x18\n\x07project\x18\x05\x20\x01(\t\
    R\x07project\x12\x18\n\x07folders\x18\x06\x20\x03(\tR\x07folders\x12\"\n\
    \x0corganization\x18\x07\x20\x01(\tR\x0corganization\x1a\xc7\x01\n\x11Go\
    vernedIamPolicy\x12+\n\x11attached_resource\x18\x01\x20\x01(\tR\x10attac\
    hedResource\x12-\n\x06policy\x18\x02\x20\x01(\x0b2\x15.google.iam.v1.Pol\
    icyR\x06policy\x12\x18\n\x07project\x18\x05\x20\x01(\tR\x07project\x12\
    \x18\n\x07folders\x18\x06\x20\x03(\tR\x07folders\x12\"\n\x0corganization\
    \x18\x07\x20\x01(\tR\x0corganization\x1a\xce\x03\n\rGovernedAsset\x12}\n\
    \x11governed_resource\x18\x01\x20\x01(\x0b2N.google.cloud.asset.v1.Analy\
    zeOrgPolicyGovernedAssetsResponse.GovernedResourceH\0R\x10governedResour\
    ce\x12\x81\x01\n\x13governed_iam_policy\x18\x02\x20\x01(\x0b2O.google.cl\
    oud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedIamPolicyH\0\
    R\x11governedIamPolicy\x12Y\n\x13consolidated_policy\x18\x03\x20\x01(\
    \x0b2(.google.cloud.asset.v1.AnalyzerOrgPolicyR\x12consolidatedPolicy\
    \x12M\n\rpolicy_bundle\x18\x04\x20\x03(\x0b2(.google.cloud.asset.v1.Anal\
    yzerOrgPolicyR\x0cpolicyBundleB\x10\n\x0egoverned_asset*\x90\x01\n\x0bCo\
    ntentType\x12\x1c\n\x18CONTENT_TYPE_UNSPECIFIED\x10\0\x12\x0c\n\x08RESOU\
    RCE\x10\x01\x12\x0e\n\nIAM_POLICY\x10\x02\x12\x0e\n\nORG_POLICY\x10\x04\
    \x12\x11\n\rACCESS_POLICY\x10\x05\x12\x10\n\x0cOS_INVENTORY\x10\x06\x12\
    \x10\n\x0cRELATIONSHIP\x10\x072\xd1\x20\n\x0cAssetService\x12\xde\x01\n\
    \x0cExportAssets\x12*.google.cloud.asset.v1.ExportAssetsRequest\x1a\x1d.\
    google.longrunning.Operation\"\x82\x01\xcaAW\n*google.cloud.asset.v1.Exp\
    ortAssetsResponse\x12)google.cloud.asset.v1.ExportAssetsRequest\x82\xd3\
    \xe4\x93\x02\"\"\x1d/v1/{parent=*/*}:exportAssets:\x01*\x12\x8b\x01\n\nL\
    istAssets\x12(.google.cloud.asset.v1.ListAssetsRequest\x1a).google.cloud\
    .asset.v1.ListAssetsResponse\"(\x82\xd3\xe4\x93\x02\x19\x12\x17/v1/{pare\
    nt=*/*}/assets\xdaA\x06parent\x12\xb2\x01\n\x15BatchGetAssetsHistory\x12\
    3.google.cloud.asset.v1.BatchGetAssetsHistoryRequest\x1a4.google.cloud.a\
    sset.v1.BatchGetAssetsHistoryResponse\".\x82\xd3\xe4\x93\x02(\x12&/v1/{p\
    arent=*/*}:batchGetAssetsHistory\x12\x7f\n\nCreateFeed\x12(.google.cloud\
    .asset.v1.CreateFeedRequest\x1a\x1b.google.cloud.asset.v1.Feed\"*\x82\
    \xd3\xe4\x93\x02\x1b\"\x16/v1/{parent=*/*}/feeds:\x01*\xdaA\x06parent\
    \x12t\n\x07GetFeed\x12%.google.cloud.asset.v1.GetFeedRequest\x1a\x1b.goo\
    gle.cloud.asset.v1.Feed\"%\x82\xd3\xe4\x93\x02\x18\x12\x16/v1/{name=*/*/\
    feeds/*}\xdaA\x04name\x12\x87\x01\n\tListFeeds\x12'.google.cloud.asset.v\
    1.ListFeedsRequest\x1a(.google.cloud.asset.v1.ListFeedsResponse\"'\x82\
    \xd3\xe4\x93\x02\x18\x12\x16/v1/{parent=*/*}/feeds\xdaA\x06parent\x12\
    \x82\x01\n\nUpdateFeed\x12(.google.cloud.asset.v1.UpdateFeedRequest\x1a\
    \x1b.google.cloud.asset.v1.Feed\"-\x82\xd3\xe4\x93\x02\x202\x1b/v1/{feed\
    .name=*/*/feeds/*}:\x01*\xdaA\x04feed\x12u\n\nDeleteFeed\x12(.google.clo\
    ud.asset.v1.DeleteFeedRequest\x1a\x16.google.protobuf.Empty\"%\x82\xd3\
    \xe4\x93\x02\x18*\x16/v1/{name=*/*/feeds/*}\xdaA\x04name\x12\xbf\x01\n\
    \x12SearchAllResources\x120.google.cloud.asset.v1.SearchAllResourcesRequ\
    est\x1a1.google.cloud.asset.v1.SearchAllResourcesResponse\"D\x82\xd3\xe4\
    \x93\x02$\x12\"/v1/{scope=*/*}:searchAllResources\xdaA\x17scope,query,as\
    set_types\x12\xbb\x01\n\x14SearchAllIamPolicies\x122.google.cloud.asset.\
    v1.SearchAllIamPoliciesRequest\x1a3.google.cloud.asset.v1.SearchAllIamPo\
    liciesResponse\":\x82\xd3\xe4\x93\x02&\x12$/v1/{scope=*/*}:searchAllIamP\
    olicies\xdaA\x0bscope,query\x12\xac\x01\n\x10AnalyzeIamPolicy\x12..googl\
    e.cloud.asset.v1.AnalyzeIamPolicyRequest\x1a/.google.cloud.asset.v1.Anal\
    yzeIamPolicyResponse\"7\x82\xd3\xe4\x93\x021\x12//v1/{analysis_query.sco\
    pe=*/*}:analyzeIamPolicy\x12\xb8\x02\n\x1bAnalyzeIamPolicyLongrunning\
    \x129.google.cloud.asset.v1.AnalyzeIamPolicyLongrunningRequest\x1a\x1d.g\
    oogle.longrunning.Operation\"\xbe\x01\xcaAv\n9google.cloud.asset.v1.Anal\
    yzeIamPolicyLongrunningResponse\x129google.cloud.asset.v1.AnalyzeIamPoli\
    cyLongrunningMetadata\x82\xd3\xe4\x93\x02?\":/v1/{analysis_query.scope=*\
    /*}:analyzeIamPolicyLongrunning:\x01*\x12\x8c\x01\n\x0bAnalyzeMove\x12).\
    google.cloud.asset.v1.AnalyzeMoveRequest\x1a*.google.cloud.asset.v1.Anal\
    yzeMoveResponse\"&\x82\xd3\xe4\x93\x02\x20\x12\x1e/v1/{resource=*/*}:ana\
    lyzeMove\x12\x8d\x01\n\x0bQueryAssets\x12).google.cloud.asset.v1.QueryAs\
    setsRequest\x1a*.google.cloud.asset.v1.QueryAssetsResponse\"'\x82\xd3\
    \xe4\x93\x02!\"\x1c/v1/{parent=*/*}:queryAssets:\x01*\x12\xbd\x01\n\x10C\
    reateSavedQuery\x12..google.cloud.asset.v1.CreateSavedQueryRequest\x1a!.\
    google.cloud.asset.v1.SavedQuery\"V\x82\xd3\xe4\x93\x02,\"\x1d/v1/{paren\
    t=*/*}/savedQueries:\x0bsaved_query\xdaA!parent,saved_query,saved_query_\
    id\x12\x8d\x01\n\rGetSavedQuery\x12+.google.cloud.asset.v1.GetSavedQuery\
    Request\x1a!.google.cloud.asset.v1.SavedQuery\",\x82\xd3\xe4\x93\x02\x1f\
    \x12\x1d/v1/{name=*/*/savedQueries/*}\xdaA\x04name\x12\xa3\x01\n\x10List\
    SavedQueries\x12..google.cloud.asset.v1.ListSavedQueriesRequest\x1a/.goo\
    gle.cloud.asset.v1.ListSavedQueriesResponse\".\x82\xd3\xe4\x93\x02\x1f\
    \x12\x1d/v1/{parent=*/*}/savedQueries\xdaA\x06parent\x12\xbf\x01\n\x10Up\
    dateSavedQuery\x12..google.cloud.asset.v1.UpdateSavedQueryRequest\x1a!.g\
    oogle.cloud.asset.v1.SavedQuery\"X\x82\xd3\xe4\x93\x0282)/v1/{saved_quer\
    y.name=*/*/savedQueries/*}:\x0bsaved_query\xdaA\x17saved_query,update_ma\
    sk\x12\x88\x01\n\x10DeleteSavedQuery\x12..google.cloud.asset.v1.DeleteSa\
    vedQueryRequest\x1a\x16.google.protobuf.Empty\",\x82\xd3\xe4\x93\x02\x1f\
    *\x1d/v1/{name=*/*/savedQueries/*}\xdaA\x04name\x12\xce\x01\n\x1cBatchGe\
    tEffectiveIamPolicies\x12:.google.cloud.asset.v1.BatchGetEffectiveIamPol\
    iciesRequest\x1a;.google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResp\
    onse\"5\x82\xd3\xe4\x93\x02/\x12-/v1/{scope=*/*}/effectiveIamPolicies:ba\
    tchGet\x12\xbf\x01\n\x12AnalyzeOrgPolicies\x120.google.cloud.asset.v1.An\
    alyzeOrgPoliciesRequest\x1a1.google.cloud.asset.v1.AnalyzeOrgPoliciesRes\
    ponse\"D\x82\xd3\xe4\x93\x02$\x12\"/v1/{scope=*/*}:analyzeOrgPolicies\
    \xdaA\x17scope,constraint,filter\x12\xff\x01\n\"AnalyzeOrgPolicyGoverned\
    Containers\x12@.google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainers\
    Request\x1aA.google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersRes\
    ponse\"T\x82\xd3\xe4\x93\x024\x122/v1/{scope=*/*}:analyzeOrgPolicyGovern\
    edContainers\xdaA\x17scope,constraint,filter\x12\xef\x01\n\x1eAnalyzeOrg\
    PolicyGovernedAssets\x12<.google.cloud.asset.v1.AnalyzeOrgPolicyGoverned\
    AssetsRequest\x1a=.google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsR\
    esponse\"P\x82\xd3\xe4\x93\x020\x12./v1/{scope=*/*}:analyzeOrgPolicyGove\
    rnedAssets\xdaA\x17scope,constraint,filter\x1aM\xd2A.https://www.googlea\
    pis.com/auth/cloud-platform\xcaA\x19cloudasset.googleapis.comB\x91\x01\n\
    \x19com.google.cloud.asset.v1B\x11AssetServiceProtoP\x01Z/cloud.google.c\
    om/go/asset/apiv1/assetpb;assetpb\xaa\x02\x15Google.Cloud.Asset.V1\xca\
    \x02\x15Google\\Cloud\\Asset\\V1J\xbc\xee\x06\n\x07\x12\x05\x0e\0\xdf\
    \x14\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x20\
    2023\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20Licen\
    se,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\
    \x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20\
    License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\
    \n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0\x1e\
    \n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\x03\x13\0!\n\t\n\
    \x02\x03\x02\x12\x03\x14\0)\n\t\n\x02\x03\x03\x12\x03\x15\0#\n\t\n\x02\
    \x03\x04\x12\x03\x16\0,\n\t\n\x02\x03\x05\x12\x03\x17\0$\n\t\n\x02\x03\
    \x06\x12\x03\x18\0-\n\t\n\x02\x03\x07\x12\x03\x19\0(\n\t\n\x02\x03\x08\
    \x12\x03\x1a\0%\n\t\n\x02\x03\t\x12\x03\x1b\0*\n\t\n\x02\x03\n\x12\x03\
    \x1c\0&\n\t\n\x02\x03\x0b\x12\x03\x1d\0)\n\t\n\x02\x03\x0c\x12\x03\x1e\0\
    !\n\t\n\x02\x03\r\x12\x03\x1f\0\x20\n\x08\n\x01\x08\x12\x03!\02\n\t\n\
    \x02\x08%\x12\x03!\02\n\x08\n\x01\x08\x12\x03\"\0F\n\t\n\x02\x08\x0b\x12\
    \x03\"\0F\n\x08\n\x01\x08\x12\x03#\0\"\n\t\n\x02\x08\n\x12\x03#\0\"\n\
    \x08\n\x01\x08\x12\x03$\02\n\t\n\x02\x08\x08\x12\x03$\02\n\x08\n\x01\x08\
    \x12\x03%\02\n\t\n\x02\x08\x01\x12\x03%\02\n\x08\n\x01\x08\x12\x03&\02\n\
    \t\n\x02\x08)\x12\x03&\02\n(\n\x02\x06\0\x12\x05)\0\xbd\x02\x01\x1a\x1b\
    \x20Asset\x20service\x20definition.\n\n\n\n\x03\x06\0\x01\x12\x03)\x08\
    \x14\n\n\n\x03\x06\0\x03\x12\x03*\x02A\n\x0c\n\x05\x06\0\x03\x99\x08\x12\
    \x03*\x02A\n\x0b\n\x03\x06\0\x03\x12\x04+\x02,7\n\r\n\x05\x06\0\x03\x9a\
    \x08\x12\x04+\x02,7\n\xe1\x05\n\x04\x06\0\x02\0\x12\x049\x02B\x03\x1a\
    \xd2\x05\x20Exports\x20assets\x20with\x20time\x20and\x20resource\x20type\
    s\x20to\x20a\x20given\x20Cloud\x20Storage\n\x20location/BigQuery\x20tabl\
    e.\x20For\x20Cloud\x20Storage\x20location\x20destinations,\x20the\n\x20o\
    utput\x20format\x20is\x20newline-delimited\x20JSON.\x20Each\x20line\x20r\
    epresents\x20a\n\x20[google.cloud.asset.v1.Asset][google.cloud.asset.v1.\
    Asset]\x20in\x20the\x20JSON\n\x20format;\x20for\x20BigQuery\x20table\x20\
    destinations,\x20the\x20output\x20table\x20stores\x20the\x20fields\n\x20\
    in\x20asset\x20Protobuf\x20as\x20columns.\x20This\x20API\x20implements\
    \x20the\n\x20[google.longrunning.Operation][google.longrunning.Operation\
    ]\x20API,\x20which\n\x20allows\x20you\x20to\x20keep\x20track\x20of\x20th\
    e\x20export.\x20We\x20recommend\x20intervals\x20of\x20at\x20least\n\x202\
    \x20seconds\x20with\x20exponential\x20retry\x20to\x20poll\x20the\x20expo\
    rt\x20operation\x20result.\x20For\n\x20regular-size\x20resource\x20paren\
    t,\x20the\x20export\x20operation\x20usually\x20finishes\x20within\n\x205\
    \x20minutes.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x039\x06\x12\n\x0c\n\x05\
    \x06\0\x02\0\x02\x12\x039\x13&\n\x0c\n\x05\x06\0\x02\0\x03\x12\x0391M\n\
    \r\n\x05\x06\0\x02\0\x04\x12\x04:\x04=\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\
    \xca\xbc\"\x12\x04:\x04=\x06\n\r\n\x05\x06\0\x02\0\x04\x12\x04>\x04A\x06\
    \n\x0f\n\x07\x06\0\x02\0\x04\x99\x08\x12\x04>\x04A\x06\na\n\x04\x06\0\
    \x02\x01\x12\x04F\x02K\x03\x1aS\x20Lists\x20assets\x20with\x20time\x20an\
    d\x20resource\x20types\x20and\x20returns\x20paged\x20results\x20in\n\x20\
    response.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03F\x06\x10\n\x0c\n\x05\
    \x06\0\x02\x01\x02\x12\x03F\x11\"\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03F\
    -?\n\r\n\x05\x06\0\x02\x01\x04\x12\x04G\x04I\x06\n\x11\n\t\x06\0\x02\x01\
    \x04\xb0\xca\xbc\"\x12\x04G\x04I\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\
    \x03J\x044\n\x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\x12\x03J\x044\n\x94\
    \x03\n\x04\x06\0\x02\x02\x12\x04T\x02Y\x03\x1a\x85\x03\x20Batch\x20gets\
    \x20the\x20update\x20history\x20of\x20assets\x20that\x20overlap\x20a\x20\
    time\x20window.\n\x20For\x20IAM_POLICY\x20content,\x20this\x20API\x20out\
    puts\x20history\x20when\x20the\x20asset\x20and\x20its\n\x20attached\x20I\
    AM\x20POLICY\x20both\x20exist.\x20This\x20can\x20create\x20gaps\x20in\
    \x20the\x20output\x20history.\n\x20Otherwise,\x20this\x20API\x20outputs\
    \x20history\x20with\x20asset\x20in\x20both\x20non-delete\x20or\n\x20dele\
    ted\x20status.\n\x20If\x20a\x20specified\x20asset\x20does\x20not\x20exis\
    t,\x20this\x20API\x20returns\x20an\x20INVALID_ARGUMENT\n\x20error.\n\n\
    \x0c\n\x05\x06\0\x02\x02\x01\x12\x03T\x06\x1b\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x03T\x1c8\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03U\x0f,\n\r\n\x05\
    \x06\0\x02\x02\x04\x12\x04V\x04X\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\
    \xbc\"\x12\x04V\x04X\x06\ng\n\x04\x06\0\x02\x03\x12\x04]\x02c\x03\x1aY\
    \x20Creates\x20a\x20feed\x20in\x20a\x20parent\x20project/folder/organiza\
    tion\x20to\x20listen\x20to\x20its\n\x20asset\x20updates.\n\n\x0c\n\x05\
    \x06\0\x02\x03\x01\x12\x03]\x06\x10\n\x0c\n\x05\x06\0\x02\x03\x02\x12\
    \x03]\x11\"\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03]-1\n\r\n\x05\x06\0\x02\
    \x03\x04\x12\x04^\x04a\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\
    \x04^\x04a\x06\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03b\x044\n\x0f\n\x08\
    \x06\0\x02\x03\x04\x9b\x08\0\x12\x03b\x044\n1\n\x04\x06\0\x02\x04\x12\
    \x04f\x02k\x03\x1a#\x20Gets\x20details\x20about\x20an\x20asset\x20feed.\
    \n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03f\x06\r\n\x0c\n\x05\x06\0\x02\
    \x04\x02\x12\x03f\x0e\x1c\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03f'+\n\r\n\
    \x05\x06\0\x02\x04\x04\x12\x04g\x04i\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\
    \xca\xbc\"\x12\x04g\x04i\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03j\x042\
    \n\x0f\n\x08\x06\0\x02\x04\x04\x9b\x08\0\x12\x03j\x042\nN\n\x04\x06\0\
    \x02\x05\x12\x04n\x02s\x03\x1a@\x20Lists\x20all\x20asset\x20feeds\x20in\
    \x20a\x20parent\x20project/folder/organization.\n\n\x0c\n\x05\x06\0\x02\
    \x05\x01\x12\x03n\x06\x0f\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03n\x10\x20\
    \n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03n+<\n\r\n\x05\x06\0\x02\x05\x04\
    \x12\x04o\x04q\x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x04o\
    \x04q\x06\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03r\x044\n\x0f\n\x08\x06\0\
    \x02\x05\x04\x9b\x08\0\x12\x03r\x044\n4\n\x04\x06\0\x02\x06\x12\x04v\x02\
    |\x03\x1a&\x20Updates\x20an\x20asset\x20feed\x20configuration.\n\n\x0c\n\
    \x05\x06\0\x02\x06\x01\x12\x03v\x06\x10\n\x0c\n\x05\x06\0\x02\x06\x02\
    \x12\x03v\x11\"\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03v-1\n\r\n\x05\x06\0\
    \x02\x06\x04\x12\x04w\x04z\x06\n\x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\
    \x12\x04w\x04z\x06\n\x0c\n\x05\x06\0\x02\x06\x04\x12\x03{\x042\n\x0f\n\
    \x08\x06\0\x02\x06\x04\x9b\x08\0\x12\x03{\x042\n'\n\x04\x06\0\x02\x07\
    \x12\x05\x7f\x02\x84\x01\x03\x1a\x18\x20Deletes\x20an\x20asset\x20feed.\
    \n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03\x7f\x06\x10\n\x0c\n\x05\x06\0\
    \x02\x07\x02\x12\x03\x7f\x11\"\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03\x7f\
    -B\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x80\x01\x04\x82\x01\x06\n\x13\n\
    \t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\x80\x01\x04\x82\x01\x06\n\r\n\
    \x05\x06\0\x02\x07\x04\x12\x04\x83\x01\x042\n\x10\n\x08\x06\0\x02\x07\
    \x04\x9b\x08\0\x12\x04\x83\x01\x042\n\x90\x02\n\x04\x06\0\x02\x08\x12\
    \x06\x8a\x01\x02\x90\x01\x03\x1a\xff\x01\x20Searches\x20all\x20Google\
    \x20Cloud\x20resources\x20within\x20the\x20specified\x20scope,\x20such\
    \x20as\x20a\n\x20project,\x20folder,\x20or\x20organization.\x20The\x20ca\
    ller\x20must\x20be\x20granted\x20the\n\x20`cloudasset.assets.searchAllRe\
    sources`\x20permission\x20on\x20the\x20desired\x20scope,\n\x20otherwise\
    \x20the\x20request\x20will\x20be\x20rejected.\n\n\r\n\x05\x06\0\x02\x08\
    \x01\x12\x04\x8a\x01\x06\x18\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\x8a\x01\
    \x192\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\x8b\x01\x0f)\n\x0f\n\x05\x06\0\
    \x02\x08\x04\x12\x06\x8c\x01\x04\x8e\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\
    \xb0\xca\xbc\"\x12\x06\x8c\x01\x04\x8e\x01\x06\n\r\n\x05\x06\0\x02\x08\
    \x04\x12\x04\x8f\x01\x04E\n\x10\n\x08\x06\0\x02\x08\x04\x9b\x08\0\x12\
    \x04\x8f\x01\x04E\n\x88\x02\n\x04\x06\0\x02\t\x12\x06\x96\x01\x02\x9c\
    \x01\x03\x1a\xf7\x01\x20Searches\x20all\x20IAM\x20policies\x20within\x20\
    the\x20specified\x20scope,\x20such\x20as\x20a\x20project,\n\x20folder,\
    \x20or\x20organization.\x20The\x20caller\x20must\x20be\x20granted\x20the\
    \n\x20`cloudasset.assets.searchAllIamPolicies`\x20permission\x20on\x20th\
    e\x20desired\x20scope,\n\x20otherwise\x20the\x20request\x20will\x20be\
    \x20rejected.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\x96\x01\x06\x1a\n\r\n\
    \x05\x06\0\x02\t\x02\x12\x04\x96\x01\x1b6\n\r\n\x05\x06\0\x02\t\x03\x12\
    \x04\x97\x01\x0f+\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\x98\x01\x04\x9a\
    \x01\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\x98\x01\x04\x9a\
    \x01\x06\n\r\n\x05\x06\0\x02\t\x04\x12\x04\x9b\x01\x049\n\x10\n\x08\x06\
    \0\x02\t\x04\x9b\x08\0\x12\x04\x9b\x01\x049\nj\n\x04\x06\0\x02\n\x12\x06\
    \xa0\x01\x02\xa5\x01\x03\x1aZ\x20Analyzes\x20IAM\x20policies\x20to\x20an\
    swer\x20which\x20identities\x20have\x20what\x20accesses\x20on\n\x20which\
    \x20resources.\n\n\r\n\x05\x06\0\x02\n\x01\x12\x04\xa0\x01\x06\x16\n\r\n\
    \x05\x06\0\x02\n\x02\x12\x04\xa0\x01\x17.\n\r\n\x05\x06\0\x02\n\x03\x12\
    \x04\xa1\x01\x0f'\n\x0f\n\x05\x06\0\x02\n\x04\x12\x06\xa2\x01\x04\xa4\
    \x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\x06\xa2\x01\x04\xa4\
    \x01\x06\n\xaf\x05\n\x04\x06\0\x02\x0b\x12\x06\xb1\x01\x02\xbb\x01\x03\
    \x1a\x9e\x05\x20Analyzes\x20IAM\x20policies\x20asynchronously\x20to\x20a\
    nswer\x20which\x20identities\x20have\x20what\n\x20accesses\x20on\x20whic\
    h\x20resources,\x20and\x20writes\x20the\x20analysis\x20results\x20to\x20\
    a\x20Google\n\x20Cloud\x20Storage\x20or\x20a\x20BigQuery\x20destination.\
    \x20For\x20Cloud\x20Storage\x20destination,\x20the\n\x20output\x20format\
    \x20is\x20the\x20JSON\x20format\x20that\x20represents\x20a\n\x20[Analyze\
    IamPolicyResponse][google.cloud.asset.v1.AnalyzeIamPolicyResponse].\n\
    \x20This\x20method\x20implements\x20the\n\x20[google.longrunning.Operati\
    on][google.longrunning.Operation],\x20which\x20allows\n\x20you\x20to\x20\
    track\x20the\x20operation\x20status.\x20We\x20recommend\x20intervals\x20\
    of\x20at\x20least\x202\n\x20seconds\x20with\x20exponential\x20backoff\
    \x20retry\x20to\x20poll\x20the\x20operation\x20result.\x20The\n\x20metad\
    ata\x20contains\x20the\x20metadata\x20for\x20the\x20long-running\x20oper\
    ation.\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\xb1\x01\x06!\n\r\n\x05\x06\
    \0\x02\x0b\x02\x12\x04\xb1\x01\"D\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\
    \xb2\x01\x0f+\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xb3\x01\x04\xb6\x01\
    \x06\n\x13\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xb3\x01\x04\xb6\
    \x01\x06\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xb7\x01\x04\xba\x01\x06\n\
    \x11\n\x07\x06\0\x02\x0b\x04\x99\x08\x12\x06\xb7\x01\x04\xba\x01\x06\n\
    \xd6\x02\n\x04\x06\0\x02\x0c\x12\x06\xc2\x01\x02\xc6\x01\x03\x1a\xc5\x02\
    \x20Analyze\x20moving\x20a\x20resource\x20to\x20a\x20specified\x20destin\
    ation\x20without\x20kicking\x20off\n\x20the\x20actual\x20move.\x20The\
    \x20analysis\x20is\x20best\x20effort\x20depending\x20on\x20the\x20user's\
    \n\x20permissions\x20of\x20viewing\x20different\x20hierarchical\x20polic\
    ies\x20and\x20configurations.\n\x20The\x20policies\x20and\x20configurati\
    on\x20are\x20subject\x20to\x20change\x20before\x20the\x20actual\n\x20res\
    ource\x20migration\x20takes\x20place.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\
    \x04\xc2\x01\x06\x11\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xc2\x01\x12$\n\
    \r\n\x05\x06\0\x02\x0c\x03\x12\x04\xc2\x01/B\n\x0f\n\x05\x06\0\x02\x0c\
    \x04\x12\x06\xc3\x01\x04\xc5\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\
    \xbc\"\x12\x06\xc3\x01\x04\xc5\x01\x06\n\x96\x05\n\x04\x06\0\x02\r\x12\
    \x06\xd4\x01\x02\xd9\x01\x03\x1a\x85\x05\x20Issue\x20a\x20job\x20that\
    \x20queries\x20assets\x20using\x20a\x20SQL\x20statement\x20compatible\
    \x20with\n\x20[BigQuery\x20SQL](https://cloud.google.com/bigquery/docs/i\
    ntroduction-sql).\n\n\x20If\x20the\x20query\x20execution\x20finishes\x20\
    within\x20timeout\x20and\x20there's\x20no\x20pagination,\n\x20the\x20ful\
    l\x20query\x20results\x20will\x20be\x20returned\x20in\x20the\x20`QueryAs\
    setsResponse`.\n\n\x20Otherwise,\x20full\x20query\x20results\x20can\x20b\
    e\x20obtained\x20by\x20issuing\x20extra\x20requests\n\x20with\x20the\x20\
    `job_reference`\x20from\x20the\x20a\x20previous\x20`QueryAssets`\x20call\
    .\n\n\x20Note,\x20the\x20query\x20result\x20has\x20approximately\x2010\
    \x20GB\x20limitation\x20enforced\x20by\n\x20[BigQuery](https://cloud.goo\
    gle.com/bigquery/docs/best-practices-performance-output).\n\x20Queries\
    \x20return\x20larger\x20results\x20will\x20result\x20in\x20errors.\n\n\r\
    \n\x05\x06\0\x02\r\x01\x12\x04\xd4\x01\x06\x11\n\r\n\x05\x06\0\x02\r\x02\
    \x12\x04\xd4\x01\x12$\n\r\n\x05\x06\0\x02\r\x03\x12\x04\xd4\x01/B\n\x0f\
    \n\x05\x06\0\x02\r\x04\x12\x06\xd5\x01\x04\xd8\x01\x06\n\x13\n\t\x06\0\
    \x02\r\x04\xb0\xca\xbc\"\x12\x06\xd5\x01\x04\xd8\x01\x06\nP\n\x04\x06\0\
    \x02\x0e\x12\x06\xdc\x01\x02\xe2\x01\x03\x1a@\x20Creates\x20a\x20saved\
    \x20query\x20in\x20a\x20parent\x20project/folder/organization.\n\n\r\n\
    \x05\x06\0\x02\x0e\x01\x12\x04\xdc\x01\x06\x16\n\r\n\x05\x06\0\x02\x0e\
    \x02\x12\x04\xdc\x01\x17.\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\xdc\x019C\
    \n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\xdd\x01\x04\xe0\x01\x06\n\x13\n\t\
    \x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\xdd\x01\x04\xe0\x01\x06\n\r\n\
    \x05\x06\0\x02\x0e\x04\x12\x04\xe1\x01\x04O\n\x10\n\x08\x06\0\x02\x0e\
    \x04\x9b\x08\0\x12\x04\xe1\x01\x04O\n3\n\x04\x06\0\x02\x0f\x12\x06\xe5\
    \x01\x02\xea\x01\x03\x1a#\x20Gets\x20details\x20about\x20a\x20saved\x20q\
    uery.\n\n\r\n\x05\x06\0\x02\x0f\x01\x12\x04\xe5\x01\x06\x13\n\r\n\x05\
    \x06\0\x02\x0f\x02\x12\x04\xe5\x01\x14(\n\r\n\x05\x06\0\x02\x0f\x03\x12\
    \x04\xe5\x013=\n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\xe6\x01\x04\xe8\x01\
    \x06\n\x13\n\t\x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\xe6\x01\x04\xe8\
    \x01\x06\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\xe9\x01\x042\n\x10\n\x08\
    \x06\0\x02\x0f\x04\x9b\x08\0\x12\x04\xe9\x01\x042\nR\n\x04\x06\0\x02\x10\
    \x12\x06\xed\x01\x02\xf3\x01\x03\x1aB\x20Lists\x20all\x20saved\x20querie\
    s\x20in\x20a\x20parent\x20project/folder/organization.\n\n\r\n\x05\x06\0\
    \x02\x10\x01\x12\x04\xed\x01\x06\x16\n\r\n\x05\x06\0\x02\x10\x02\x12\x04\
    \xed\x01\x17.\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\xee\x01\x0f'\n\x0f\n\
    \x05\x06\0\x02\x10\x04\x12\x06\xef\x01\x04\xf1\x01\x06\n\x13\n\t\x06\0\
    \x02\x10\x04\xb0\xca\xbc\"\x12\x06\xef\x01\x04\xf1\x01\x06\n\r\n\x05\x06\
    \0\x02\x10\x04\x12\x04\xf2\x01\x044\n\x10\n\x08\x06\0\x02\x10\x04\x9b\
    \x08\0\x12\x04\xf2\x01\x044\n(\n\x04\x06\0\x02\x11\x12\x06\xf6\x01\x02\
    \xfc\x01\x03\x1a\x18\x20Updates\x20a\x20saved\x20query.\n\n\r\n\x05\x06\
    \0\x02\x11\x01\x12\x04\xf6\x01\x06\x16\n\r\n\x05\x06\0\x02\x11\x02\x12\
    \x04\xf6\x01\x17.\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\xf6\x019C\n\x0f\n\
    \x05\x06\0\x02\x11\x04\x12\x06\xf7\x01\x04\xfa\x01\x06\n\x13\n\t\x06\0\
    \x02\x11\x04\xb0\xca\xbc\"\x12\x06\xf7\x01\x04\xfa\x01\x06\n\r\n\x05\x06\
    \0\x02\x11\x04\x12\x04\xfb\x01\x04E\n\x10\n\x08\x06\0\x02\x11\x04\x9b\
    \x08\0\x12\x04\xfb\x01\x04E\n(\n\x04\x06\0\x02\x12\x12\x06\xff\x01\x02\
    \x85\x02\x03\x1a\x18\x20Deletes\x20a\x20saved\x20query.\n\n\r\n\x05\x06\
    \0\x02\x12\x01\x12\x04\xff\x01\x06\x16\n\r\n\x05\x06\0\x02\x12\x02\x12\
    \x04\xff\x01\x17.\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\x80\x02\x0f$\n\x0f\
    \n\x05\x06\0\x02\x12\x04\x12\x06\x81\x02\x04\x83\x02\x06\n\x13\n\t\x06\0\
    \x02\x12\x04\xb0\xca\xbc\"\x12\x06\x81\x02\x04\x83\x02\x06\n\r\n\x05\x06\
    \0\x02\x12\x04\x12\x04\x84\x02\x042\n\x10\n\x08\x06\0\x02\x12\x04\x9b\
    \x08\0\x12\x04\x84\x02\x042\nG\n\x04\x06\0\x02\x13\x12\x06\x88\x02\x02\
    \x8d\x02\x03\x1a7\x20Gets\x20effective\x20IAM\x20policies\x20for\x20a\
    \x20batch\x20of\x20resources.\n\n\r\n\x05\x06\0\x02\x13\x01\x12\x04\x88\
    \x02\x06\"\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\x88\x02#F\n\r\n\x05\x06\0\
    \x02\x13\x03\x12\x04\x89\x02\x0f3\n\x0f\n\x05\x06\0\x02\x13\x04\x12\x06\
    \x8a\x02\x04\x8c\x02\x06\n\x13\n\t\x06\0\x02\x13\x04\xb0\xca\xbc\"\x12\
    \x06\x8a\x02\x04\x8c\x02\x06\n?\n\x04\x06\0\x02\x14\x12\x06\x90\x02\x02\
    \x96\x02\x03\x1a/\x20Analyzes\x20organization\x20policies\x20under\x20a\
    \x20scope.\n\n\r\n\x05\x06\0\x02\x14\x01\x12\x04\x90\x02\x06\x18\n\r\n\
    \x05\x06\0\x02\x14\x02\x12\x04\x90\x02\x192\n\r\n\x05\x06\0\x02\x14\x03\
    \x12\x04\x91\x02\x0f)\n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\x92\x02\x04\
    \x94\x02\x06\n\x13\n\t\x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\x92\x02\
    \x04\x94\x02\x06\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\x95\x02\x04E\n\x10\
    \n\x08\x06\0\x02\x14\x04\x9b\x08\0\x12\x04\x95\x02\x04E\nx\n\x04\x06\0\
    \x02\x15\x12\x06\x9a\x02\x02\xa1\x02\x03\x1ah\x20Analyzes\x20organizatio\
    n\x20policies\x20governed\x20containers\x20(projects,\x20folders\x20or\n\
    \x20organization)\x20under\x20a\x20scope.\n\n\r\n\x05\x06\0\x02\x15\x01\
    \x12\x04\x9a\x02\x06(\n\r\n\x05\x06\0\x02\x15\x02\x12\x04\x9b\x02\x06/\n\
    \r\n\x05\x06\0\x02\x15\x03\x12\x04\x9c\x02\x0f9\n\x0f\n\x05\x06\0\x02\
    \x15\x04\x12\x06\x9d\x02\x04\x9f\x02\x06\n\x13\n\t\x06\0\x02\x15\x04\xb0\
    \xca\xbc\"\x12\x06\x9d\x02\x04\x9f\x02\x06\n\r\n\x05\x06\0\x02\x15\x04\
    \x12\x04\xa0\x02\x04E\n\x10\n\x08\x06\0\x02\x15\x04\x9b\x08\0\x12\x04\
    \xa0\x02\x04E\n\xe8\x05\n\x04\x06\0\x02\x16\x12\x06\xb6\x02\x02\xbc\x02\
    \x03\x1a\xd7\x05\x20Analyzes\x20organization\x20policies\x20governed\x20\
    assets\x20(Google\x20Cloud\x20resources\x20or\n\x20policies)\x20under\
    \x20a\x20scope.\x20This\x20RPC\x20supports\x20custom\x20constraints\x20a\
    nd\x20the\n\x20following\x2010\x20canned\x20constraints:\n\n\x20*\x20sto\
    rage.uniformBucketLevelAccess\n\x20*\x20iam.disableServiceAccountKeyCrea\
    tion\n\x20*\x20iam.allowedPolicyMemberDomains\n\x20*\x20compute.vmExtern\
    alIpAccess\n\x20*\x20appengine.enforceServiceAccountActAsCheck\n\x20*\
    \x20gcp.resourceLocations\n\x20*\x20compute.trustedImageProjects\n\x20*\
    \x20compute.skipDefaultNetworkCreation\n\x20*\x20compute.requireOsLogin\
    \n\x20*\x20compute.disableNestedVirtualization\n\n\x20This\x20RPC\x20onl\
    y\x20returns\x20either\x20resources\x20of\x20types\x20supported\x20by\
    \x20[searchable\n\x20asset\n\x20types](https://cloud.google.com/asset-in\
    ventory/docs/supported-asset-types#searchable_asset_types),\n\x20or\x20I\
    AM\x20policies.\n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\xb6\x02\x06$\n\r\n\
    \x05\x06\0\x02\x16\x02\x12\x04\xb6\x02%J\n\r\n\x05\x06\0\x02\x16\x03\x12\
    \x04\xb7\x02\x0f5\n\x0f\n\x05\x06\0\x02\x16\x04\x12\x06\xb8\x02\x04\xba\
    \x02\x06\n\x13\n\t\x06\0\x02\x16\x04\xb0\xca\xbc\"\x12\x06\xb8\x02\x04\
    \xba\x02\x06\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\xbb\x02\x04E\n\x10\n\
    \x08\x06\0\x02\x16\x04\x9b\x08\0\x12\x04\xbb\x02\x04E\nn\n\x02\x04\0\x12\
    \x06\xc1\x02\0\xc5\x02\x01\x1a`\x20Represents\x20the\x20metadata\x20of\
    \x20the\x20longrunning\x20operation\x20for\x20the\n\x20AnalyzeIamPolicyL\
    ongrunning\x20RPC.\n\n\x0b\n\x03\x04\0\x01\x12\x04\xc1\x02\x08+\nB\n\x04\
    \x04\0\x02\0\x12\x06\xc3\x02\x02\xc4\x022\x1a2\x20Output\x20only.\x20The\
    \x20time\x20the\x20operation\x20was\x20created.\n\n\r\n\x05\x04\0\x02\0\
    \x06\x12\x04\xc3\x02\x02\x1b\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xc3\x02\
    \x1c'\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xc3\x02*+\n\r\n\x05\x04\0\x02\0\
    \x08\x12\x04\xc4\x02\x061\n\x10\n\x08\x04\0\x02\0\x08\x9c\x08\0\x12\x04\
    \xc4\x02\x070\n%\n\x02\x04\x01\x12\x06\xc8\x02\0\x87\x03\x01\x1a\x17\x20\
    Export\x20asset\x20request.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xc8\x02\
    \x08\x1b\n\x98\x02\n\x04\x04\x01\x02\0\x12\x06\xcd\x02\x02\xd2\x02\x04\
    \x1a\x87\x02\x20Required.\x20The\x20relative\x20name\x20of\x20the\x20roo\
    t\x20asset.\x20This\x20can\x20only\x20be\x20an\n\x20organization\x20numb\
    er\x20(such\x20as\x20\"organizations/123\"),\x20a\x20project\x20ID\x20(s\
    uch\x20as\n\x20\"projects/my-project-id\"),\x20or\x20a\x20project\x20num\
    ber\x20(such\x20as\x20\"projects/12345\"),\n\x20or\x20a\x20folder\x20num\
    ber\x20(such\x20as\x20\"folders/123\").\n\n\r\n\x05\x04\x01\x02\0\x05\
    \x12\x04\xcd\x02\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xcd\x02\t\
    \x0f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xcd\x02\x12\x13\n\x0f\n\x05\x04\
    \x01\x02\0\x08\x12\x06\xcd\x02\x14\xd2\x02\x03\n\x10\n\x08\x04\x01\x02\0\
    \x08\x9c\x08\0\x12\x04\xce\x02\x04*\n\x11\n\x07\x04\x01\x02\0\x08\x9f\
    \x08\x12\x06\xcf\x02\x04\xd1\x02\x05\n\xe9\x02\n\x04\x04\x01\x02\x01\x12\
    \x04\xd9\x02\x02*\x1a\xda\x02\x20Timestamp\x20to\x20take\x20an\x20asset\
    \x20snapshot.\x20This\x20can\x20only\x20be\x20set\x20to\x20a\x20timestam\
    p\n\x20between\x20the\x20current\x20time\x20and\x20the\x20current\x20tim\
    e\x20minus\x2035\x20days\x20(inclusive).\n\x20If\x20not\x20specified,\
    \x20the\x20current\x20time\x20will\x20be\x20used.\x20Due\x20to\x20delays\
    \x20in\x20resource\n\x20data\x20collection\x20and\x20indexing,\x20there\
    \x20is\x20a\x20volatile\x20window\x20during\x20which\n\x20running\x20the\
    \x20same\x20query\x20may\x20get\x20different\x20results.\n\n\r\n\x05\x04\
    \x01\x02\x01\x06\x12\x04\xd9\x02\x02\x1b\n\r\n\x05\x04\x01\x02\x01\x01\
    \x12\x04\xd9\x02\x1c%\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xd9\x02()\n\
    \xe3\x06\n\x04\x04\x01\x02\x02\x12\x04\xed\x02\x02\"\x1a\xd4\x06\x20A\
    \x20list\x20of\x20asset\x20types\x20to\x20take\x20a\x20snapshot\x20for.\
    \x20For\x20example:\n\x20\"compute.googleapis.com/Disk\".\n\n\x20Regular\
    \x20expressions\x20are\x20also\x20supported.\x20For\x20example:\n\n\x20*\
    \x20\"compute.googleapis.com.*\"\x20snapshots\x20resources\x20whose\x20a\
    sset\x20type\x20starts\n\x20with\x20\"compute.googleapis.com\".\n\x20*\
    \x20\".*Instance\"\x20snapshots\x20resources\x20whose\x20asset\x20type\
    \x20ends\x20with\x20\"Instance\".\n\x20*\x20\".*Instance.*\"\x20snapshot\
    s\x20resources\x20whose\x20asset\x20type\x20contains\x20\"Instance\".\n\
    \n\x20See\x20[RE2](https://github.com/google/re2/wiki/Syntax)\x20for\x20\
    all\x20supported\n\x20regular\x20expression\x20syntax.\x20If\x20the\x20r\
    egular\x20expression\x20does\x20not\x20match\x20any\n\x20supported\x20as\
    set\x20type,\x20an\x20INVALID_ARGUMENT\x20error\x20will\x20be\x20returne\
    d.\n\n\x20If\x20specified,\x20only\x20matching\x20assets\x20will\x20be\
    \x20returned,\x20otherwise,\x20it\x20will\n\x20snapshot\x20all\x20asset\
    \x20types.\x20See\x20[Introduction\x20to\x20Cloud\x20Asset\n\x20Inventor\
    y](https://cloud.google.com/asset-inventory/docs/overview)\n\x20for\x20a\
    ll\x20supported\x20asset\x20types.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\
    \x04\xed\x02\x02\n\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xed\x02\x0b\x11\
    \n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xed\x02\x12\x1d\n\r\n\x05\x04\x01\
    \x02\x02\x03\x12\x04\xed\x02\x20!\nf\n\x04\x04\x01\x02\x03\x12\x04\xf1\
    \x02\x02\x1f\x1aX\x20Asset\x20content\x20type.\x20If\x20not\x20specified\
    ,\x20no\x20content\x20but\x20the\x20asset\x20name\x20will\x20be\n\x20ret\
    urned.\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\xf1\x02\x02\r\n\r\n\x05\
    \x04\x01\x02\x03\x01\x12\x04\xf1\x02\x0e\x1a\n\r\n\x05\x04\x01\x02\x03\
    \x03\x12\x04\xf1\x02\x1d\x1e\n_\n\x04\x04\x01\x02\x04\x12\x04\xf5\x02\
    \x02J\x1aQ\x20Required.\x20Output\x20configuration\x20indicating\x20wher\
    e\x20the\x20results\x20will\x20be\x20output\n\x20to.\n\n\r\n\x05\x04\x01\
    \x02\x04\x06\x12\x04\xf5\x02\x02\x0e\n\r\n\x05\x04\x01\x02\x04\x01\x12\
    \x04\xf5\x02\x0f\x1c\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\xf5\x02\x1f\
    \x20\n\r\n\x05\x04\x01\x02\x04\x08\x12\x04\xf5\x02!I\n\x10\n\x08\x04\x01\
    \x02\x04\x08\x9c\x08\0\x12\x04\xf5\x02\"H\n\xbb\x06\n\x04\x04\x01\x02\
    \x05\x12\x04\x86\x03\x02)\x1a\xac\x06\x20A\x20list\x20of\x20relationship\
    \x20types\x20to\x20export,\x20for\x20example:\n\x20`INSTANCE_TO_INSTANCE\
    GROUP`.\x20This\x20field\x20should\x20only\x20be\x20specified\x20if\n\
    \x20content_type=RELATIONSHIP.\n\x20*\x20If\x20specified:\n\x20it\x20sna\
    pshots\x20specified\x20relationships.\x20It\x20returns\x20an\x20error\
    \x20if\n\x20any\x20of\x20the\x20[relationship_types]\x20doesn't\x20belon\
    g\x20to\x20the\x20supported\n\x20relationship\x20types\x20of\x20the\x20[\
    asset_types]\x20or\x20if\x20any\x20of\x20the\x20[asset_types]\n\x20doesn\
    't\x20belong\x20to\x20the\x20source\x20types\x20of\x20the\x20[relationsh\
    ip_types].\n\x20*\x20Otherwise:\n\x20it\x20snapshots\x20the\x20supported\
    \x20relationships\x20for\x20all\x20[asset_types]\x20or\x20returns\n\x20a\
    n\x20error\x20if\x20any\x20of\x20the\x20[asset_types]\x20has\x20no\x20re\
    lationship\x20support.\n\x20An\x20unspecified\x20asset\x20types\x20field\
    \x20means\x20all\x20supported\x20asset_types.\n\x20See\x20[Introduction\
    \x20to\x20Cloud\x20Asset\n\x20Inventory](https://cloud.google.com/asset-\
    inventory/docs/overview)\x20for\x20all\n\x20supported\x20asset\x20types\
    \x20and\x20relationship\x20types.\n\n\r\n\x05\x04\x01\x02\x05\x04\x12\
    \x04\x86\x03\x02\n\n\r\n\x05\x04\x01\x02\x05\x05\x12\x04\x86\x03\x0b\x11\
    \n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\x86\x03\x12$\n\r\n\x05\x04\x01\
    \x02\x05\x03\x12\x04\x86\x03'(\n\x95\x02\n\x02\x04\x02\x12\x06\x8e\x03\0\
    \x9b\x03\x01\x1a\x86\x02\x20The\x20export\x20asset\x20response.\x20This\
    \x20message\x20is\x20returned\x20by\x20the\n\x20[google.longrunning.Oper\
    ations.GetOperation][google.longrunning.Operations.GetOperation]\n\x20me\
    thod\x20in\x20the\x20returned\n\x20[google.longrunning.Operation.respons\
    e][google.longrunning.Operation.response]\n\x20field.\n\n\x0b\n\x03\x04\
    \x02\x01\x12\x04\x8e\x03\x08\x1c\n,\n\x04\x04\x02\x02\0\x12\x04\x90\x03\
    \x02*\x1a\x1e\x20Time\x20the\x20snapshot\x20was\x20taken.\n\n\r\n\x05\
    \x04\x02\x02\0\x06\x12\x04\x90\x03\x02\x1b\n\r\n\x05\x04\x02\x02\0\x01\
    \x12\x04\x90\x03\x1c%\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x90\x03()\nQ\n\
    \x04\x04\x02\x02\x01\x12\x04\x93\x03\x02!\x1aC\x20Output\x20configuratio\
    n\x20indicating\x20where\x20the\x20results\x20were\x20output\x20to.\n\n\
    \r\n\x05\x04\x02\x02\x01\x06\x12\x04\x93\x03\x02\x0e\n\r\n\x05\x04\x02\
    \x02\x01\x01\x12\x04\x93\x03\x0f\x1c\n\r\n\x05\x04\x02\x02\x01\x03\x12\
    \x04\x93\x03\x1f\x20\n\xe0\x02\n\x04\x04\x02\x02\x02\x12\x04\x9a\x03\x02\
    !\x1a\xd1\x02\x20Output\x20result\x20indicating\x20where\x20the\x20asset\
    s\x20were\x20exported\x20to.\x20For\x20example,\x20a\n\x20set\x20of\x20a\
    ctual\x20Cloud\x20Storage\x20object\x20URIs\x20where\x20the\x20assets\
    \x20are\x20exported\x20to.\n\x20The\x20URIs\x20can\x20be\x20different\
    \x20from\x20what\x20[output_config]\x20has\x20specified,\x20as\x20the\n\
    \x20service\x20will\x20split\x20the\x20output\x20object\x20into\x20multi\
    ple\x20ones\x20once\x20it\x20exceeds\x20a\n\x20single\x20Cloud\x20Storag\
    e\x20object\x20limit.\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\x9a\x03\
    \x02\x0e\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x9a\x03\x0f\x1c\n\r\n\x05\
    \x04\x02\x02\x02\x03\x12\x04\x9a\x03\x1f\x20\n#\n\x02\x04\x03\x12\x06\
    \x9e\x03\0\xe3\x03\x01\x1a\x15\x20ListAssets\x20request.\n\n\x0b\n\x03\
    \x04\x03\x01\x12\x04\x9e\x03\x08\x19\n\xdc\x02\n\x04\x04\x03\x02\0\x12\
    \x06\xa4\x03\x02\xa9\x03\x04\x1a\xcb\x02\x20Required.\x20Name\x20of\x20t\
    he\x20organization,\x20folder,\x20or\x20project\x20the\x20assets\x20belo\
    ng\n\x20to.\x20Format:\x20\"organizations/[organization-number]\"\x20(su\
    ch\x20as\n\x20\"organizations/123\"),\x20\"projects/[project-id]\"\x20(s\
    uch\x20as\n\x20\"projects/my-project-id\"),\x20\"projects/[project-numbe\
    r]\"\x20(such\x20as\n\x20\"projects/12345\"),\x20or\x20\"folders/[folder\
    -number]\"\x20(such\x20as\x20\"folders/12345\").\n\n\r\n\x05\x04\x03\x02\
    \0\x05\x12\x04\xa4\x03\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xa4\
    \x03\t\x0f\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xa4\x03\x12\x13\n\x0f\n\
    \x05\x04\x03\x02\0\x08\x12\x06\xa4\x03\x14\xa9\x03\x03\n\x10\n\x08\x04\
    \x03\x02\0\x08\x9c\x08\0\x12\x04\xa5\x03\x04*\n\x11\n\x07\x04\x03\x02\0\
    \x08\x9f\x08\x12\x06\xa6\x03\x04\xa8\x03\x05\n\xe9\x02\n\x04\x04\x03\x02\
    \x01\x12\x04\xb0\x03\x02*\x1a\xda\x02\x20Timestamp\x20to\x20take\x20an\
    \x20asset\x20snapshot.\x20This\x20can\x20only\x20be\x20set\x20to\x20a\
    \x20timestamp\n\x20between\x20the\x20current\x20time\x20and\x20the\x20cu\
    rrent\x20time\x20minus\x2035\x20days\x20(inclusive).\n\x20If\x20not\x20s\
    pecified,\x20the\x20current\x20time\x20will\x20be\x20used.\x20Due\x20to\
    \x20delays\x20in\x20resource\n\x20data\x20collection\x20and\x20indexing,\
    \x20there\x20is\x20a\x20volatile\x20window\x20during\x20which\n\x20runni\
    ng\x20the\x20same\x20query\x20may\x20get\x20different\x20results.\n\n\r\
    \n\x05\x04\x03\x02\x01\x06\x12\x04\xb0\x03\x02\x1b\n\r\n\x05\x04\x03\x02\
    \x01\x01\x12\x04\xb0\x03\x1c%\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xb0\
    \x03()\n\xe1\x06\n\x04\x04\x03\x02\x02\x12\x04\xc4\x03\x02\"\x1a\xd2\x06\
    \x20A\x20list\x20of\x20asset\x20types\x20to\x20take\x20a\x20snapshot\x20\
    for.\x20For\x20example:\n\x20\"compute.googleapis.com/Disk\".\n\n\x20Reg\
    ular\x20expression\x20is\x20also\x20supported.\x20For\x20example:\n\n\
    \x20*\x20\"compute.googleapis.com.*\"\x20snapshots\x20resources\x20whose\
    \x20asset\x20type\x20starts\n\x20with\x20\"compute.googleapis.com\".\n\
    \x20*\x20\".*Instance\"\x20snapshots\x20resources\x20whose\x20asset\x20t\
    ype\x20ends\x20with\x20\"Instance\".\n\x20*\x20\".*Instance.*\"\x20snaps\
    hots\x20resources\x20whose\x20asset\x20type\x20contains\x20\"Instance\".\
    \n\n\x20See\x20[RE2](https://github.com/google/re2/wiki/Syntax)\x20for\
    \x20all\x20supported\n\x20regular\x20expression\x20syntax.\x20If\x20the\
    \x20regular\x20expression\x20does\x20not\x20match\x20any\n\x20supported\
    \x20asset\x20type,\x20an\x20INVALID_ARGUMENT\x20error\x20will\x20be\x20r\
    eturned.\n\n\x20If\x20specified,\x20only\x20matching\x20assets\x20will\
    \x20be\x20returned,\x20otherwise,\x20it\x20will\n\x20snapshot\x20all\x20\
    asset\x20types.\x20See\x20[Introduction\x20to\x20Cloud\x20Asset\n\x20Inv\
    entory](https://cloud.google.com/asset-inventory/docs/overview)\n\x20for\
    \x20all\x20supported\x20asset\x20types.\n\n\r\n\x05\x04\x03\x02\x02\x04\
    \x12\x04\xc4\x03\x02\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xc4\x03\x0b\
    \x11\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xc4\x03\x12\x1d\n\r\n\x05\x04\
    \x03\x02\x02\x03\x12\x04\xc4\x03\x20!\nf\n\x04\x04\x03\x02\x03\x12\x04\
    \xc8\x03\x02\x1f\x1aX\x20Asset\x20content\x20type.\x20If\x20not\x20speci\
    fied,\x20no\x20content\x20but\x20the\x20asset\x20name\x20will\n\x20be\
    \x20returned.\n\n\r\n\x05\x04\x03\x02\x03\x06\x12\x04\xc8\x03\x02\r\n\r\
    \n\x05\x04\x03\x02\x03\x01\x12\x04\xc8\x03\x0e\x1a\n\r\n\x05\x04\x03\x02\
    \x03\x03\x12\x04\xc8\x03\x1d\x1e\n\x85\x01\n\x04\x04\x03\x02\x04\x12\x04\
    \xcc\x03\x02\x16\x1aw\x20The\x20maximum\x20number\x20of\x20assets\x20to\
    \x20be\x20returned\x20in\x20a\x20single\x20response.\x20Default\n\x20is\
    \x20100,\x20minimum\x20is\x201,\x20and\x20maximum\x20is\x201000.\n\n\r\n\
    \x05\x04\x03\x02\x04\x05\x12\x04\xcc\x03\x02\x07\n\r\n\x05\x04\x03\x02\
    \x04\x01\x12\x04\xcc\x03\x08\x11\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\
    \xcc\x03\x14\x15\n\xf1\x01\n\x04\x04\x03\x02\x05\x12\x04\xd1\x03\x02\x18\
    \x1a\xe2\x01\x20The\x20`next_page_token`\x20returned\x20from\x20the\x20p\
    revious\x20`ListAssetsResponse`,\x20or\n\x20unspecified\x20for\x20the\
    \x20first\x20`ListAssetsRequest`.\x20It\x20is\x20a\x20continuation\x20of\
    \x20a\n\x20prior\x20`ListAssets`\x20call,\x20and\x20the\x20API\x20should\
    \x20return\x20the\x20next\x20page\x20of\x20assets.\n\n\r\n\x05\x04\x03\
    \x02\x05\x05\x12\x04\xd1\x03\x02\x08\n\r\n\x05\x04\x03\x02\x05\x01\x12\
    \x04\xd1\x03\t\x13\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\xd1\x03\x16\x17\
    \n\xbb\x06\n\x04\x04\x03\x02\x06\x12\x04\xe2\x03\x02)\x1a\xac\x06\x20A\
    \x20list\x20of\x20relationship\x20types\x20to\x20output,\x20for\x20examp\
    le:\n\x20`INSTANCE_TO_INSTANCEGROUP`.\x20This\x20field\x20should\x20only\
    \x20be\x20specified\x20if\n\x20content_type=RELATIONSHIP.\n\x20*\x20If\
    \x20specified:\n\x20it\x20snapshots\x20specified\x20relationships.\x20It\
    \x20returns\x20an\x20error\x20if\n\x20any\x20of\x20the\x20[relationship_\
    types]\x20doesn't\x20belong\x20to\x20the\x20supported\n\x20relationship\
    \x20types\x20of\x20the\x20[asset_types]\x20or\x20if\x20any\x20of\x20the\
    \x20[asset_types]\n\x20doesn't\x20belong\x20to\x20the\x20source\x20types\
    \x20of\x20the\x20[relationship_types].\n\x20*\x20Otherwise:\n\x20it\x20s\
    napshots\x20the\x20supported\x20relationships\x20for\x20all\x20[asset_ty\
    pes]\x20or\x20returns\n\x20an\x20error\x20if\x20any\x20of\x20the\x20[ass\
    et_types]\x20has\x20no\x20relationship\x20support.\n\x20An\x20unspecifie\
    d\x20asset\x20types\x20field\x20means\x20all\x20supported\x20asset_types\
    .\n\x20See\x20[Introduction\x20to\x20Cloud\x20Asset\n\x20Inventory](http\
    s://cloud.google.com/asset-inventory/docs/overview)\n\x20for\x20all\x20s\
    upported\x20asset\x20types\x20and\x20relationship\x20types.\n\n\r\n\x05\
    \x04\x03\x02\x06\x04\x12\x04\xe2\x03\x02\n\n\r\n\x05\x04\x03\x02\x06\x05\
    \x12\x04\xe2\x03\x0b\x11\n\r\n\x05\x04\x03\x02\x06\x01\x12\x04\xe2\x03\
    \x12$\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\xe2\x03'(\n$\n\x02\x04\x04\
    \x12\x06\xe6\x03\0\xf1\x03\x01\x1a\x16\x20ListAssets\x20response.\n\n\
    \x0b\n\x03\x04\x04\x01\x12\x04\xe6\x03\x08\x1a\n,\n\x04\x04\x04\x02\0\
    \x12\x04\xe8\x03\x02*\x1a\x1e\x20Time\x20the\x20snapshot\x20was\x20taken\
    .\n\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xe8\x03\x02\x1b\n\r\n\x05\x04\
    \x04\x02\0\x01\x12\x04\xe8\x03\x1c%\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \xe8\x03()\n\x17\n\x04\x04\x04\x02\x01\x12\x04\xeb\x03\x02\x1c\x1a\t\x20\
    Assets.\n\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xeb\x03\x02\n\n\r\n\x05\
    \x04\x04\x02\x01\x06\x12\x04\xeb\x03\x0b\x10\n\r\n\x05\x04\x04\x02\x01\
    \x01\x12\x04\xeb\x03\x11\x17\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xeb\
    \x03\x1a\x1b\n\xb8\x01\n\x04\x04\x04\x02\x02\x12\x04\xf0\x03\x02\x1d\x1a\
    \xa9\x01\x20Token\x20to\x20retrieve\x20the\x20next\x20page\x20of\x20resu\
    lts.\x20It\x20expires\x2072\x20hours\x20after\x20the\n\x20page\x20token\
    \x20for\x20the\x20first\x20page\x20is\x20generated.\x20Set\x20to\x20empt\
    y\x20if\x20there\x20are\x20no\n\x20remaining\x20results.\n\n\r\n\x05\x04\
    \x04\x02\x02\x05\x12\x04\xf0\x03\x02\x08\n\r\n\x05\x04\x04\x02\x02\x01\
    \x12\x04\xf0\x03\t\x18\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xf0\x03\x1b\
    \x1c\n1\n\x02\x04\x05\x12\x06\xf4\x03\0\xa6\x04\x01\x1a#\x20Batch\x20get\
    \x20assets\x20history\x20request.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xf4\
    \x03\x08$\n\xea\x01\n\x04\x04\x05\x02\0\x12\x06\xf8\x03\x02\xfd\x03\x04\
    \x1a\xd9\x01\x20Required.\x20The\x20relative\x20name\x20of\x20the\x20roo\
    t\x20asset.\x20It\x20can\x20only\x20be\x20an\n\x20organization\x20number\
    \x20(such\x20as\x20\"organizations/123\"),\x20a\x20project\x20ID\x20(suc\
    h\x20as\n\x20\"projects/my-project-id\")\",\x20or\x20a\x20project\x20num\
    ber\x20(such\x20as\x20\"projects/12345\").\n\n\r\n\x05\x04\x05\x02\0\x05\
    \x12\x04\xf8\x03\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xf8\x03\t\
    \x0f\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xf8\x03\x12\x13\n\x0f\n\x05\x04\
    \x05\x02\0\x08\x12\x06\xf8\x03\x14\xfd\x03\x03\n\x10\n\x08\x04\x05\x02\0\
    \x08\x9c\x08\0\x12\x04\xf9\x03\x04*\n\x11\n\x07\x04\x05\x02\0\x08\x9f\
    \x08\x12\x06\xfa\x03\x04\xfc\x03\x05\n\xe0\x02\n\x04\x04\x05\x02\x01\x12\
    \x04\x87\x04\x02\"\x1a\xd1\x02\x20A\x20list\x20of\x20the\x20full\x20name\
    s\x20of\x20the\x20assets.\n\x20See:\x20https://cloud.google.com/asset-in\
    ventory/docs/resource-name-format\n\x20Example:\n\n\x20`//compute.google\
    apis.com/projects/my_project_123/zones/zone1/instances/instance1`.\n\n\
    \x20The\x20request\x20becomes\x20a\x20no-op\x20if\x20the\x20asset\x20nam\
    e\x20list\x20is\x20empty,\x20and\x20the\x20max\n\x20size\x20of\x20the\
    \x20asset\x20name\x20list\x20is\x20100\x20in\x20one\x20request.\n\n\r\n\
    \x05\x04\x05\x02\x01\x04\x12\x04\x87\x04\x02\n\n\r\n\x05\x04\x05\x02\x01\
    \x05\x12\x04\x87\x04\x0b\x11\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x87\
    \x04\x12\x1d\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x87\x04\x20!\n+\n\x04\
    \x04\x05\x02\x02\x12\x04\x8a\x04\x02H\x1a\x1d\x20Optional.\x20The\x20con\
    tent\x20type.\n\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\x8a\x04\x02\r\n\r\
    \n\x05\x04\x05\x02\x02\x01\x12\x04\x8a\x04\x0e\x1a\n\r\n\x05\x04\x05\x02\
    \x02\x03\x12\x04\x8a\x04\x1d\x1e\n\r\n\x05\x04\x05\x02\x02\x08\x12\x04\
    \x8a\x04\x1fG\n\x10\n\x08\x04\x05\x02\x02\x08\x9c\x08\0\x12\x04\x8a\x04\
    \x20F\n\x9e\x03\n\x04\x04\x05\x02\x03\x12\x04\x92\x04\x02K\x1a\x8f\x03\
    \x20Optional.\x20The\x20time\x20window\x20for\x20the\x20asset\x20history\
    .\x20Both\x20start_time\x20and\n\x20end_time\x20are\x20optional\x20and\
    \x20if\x20set,\x20it\x20must\x20be\x20after\x20the\x20current\x20time\
    \x20minus\n\x2035\x20days.\x20If\x20end_time\x20is\x20not\x20set,\x20it\
    \x20is\x20default\x20to\x20current\x20timestamp.\n\x20If\x20start_time\
    \x20is\x20not\x20set,\x20the\x20snapshot\x20of\x20the\x20assets\x20at\
    \x20end_time\x20will\x20be\n\x20returned.\x20The\x20returned\x20results\
    \x20contain\x20all\x20temporal\x20assets\x20whose\x20time\n\x20window\
    \x20overlap\x20with\x20read_time_window.\n\n\r\n\x05\x04\x05\x02\x03\x06\
    \x12\x04\x92\x04\x02\x0c\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\x92\x04\r\
    \x1d\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x92\x04\x20!\n\r\n\x05\x04\
    \x05\x02\x03\x08\x12\x04\x92\x04\"J\n\x10\n\x08\x04\x05\x02\x03\x08\x9c\
    \x08\0\x12\x04\x92\x04#I\n\xb8\x06\n\x04\x04\x05\x02\x04\x12\x06\xa4\x04\
    \x02\xa5\x04/\x1a\xa7\x06\x20Optional.\x20A\x20list\x20of\x20relationshi\
    p\x20types\x20to\x20output,\x20for\x20example:\n\x20`INSTANCE_TO_INSTANC\
    EGROUP`.\x20This\x20field\x20should\x20only\x20be\x20specified\x20if\n\
    \x20content_type=RELATIONSHIP.\n\x20*\x20If\x20specified:\n\x20it\x20out\
    puts\x20specified\x20relationships'\x20history\x20on\x20the\x20[asset_na\
    mes].\x20It\n\x20returns\x20an\x20error\x20if\x20any\x20of\x20the\x20[re\
    lationship_types]\x20doesn't\x20belong\x20to\x20the\n\x20supported\x20re\
    lationship\x20types\x20of\x20the\x20[asset_names]\x20or\x20if\x20any\x20\
    of\x20the\n\x20[asset_names]'s\x20types\x20doesn't\x20belong\x20to\x20th\
    e\x20source\x20types\x20of\x20the\n\x20[relationship_types].\n\x20*\x20O\
    therwise:\n\x20it\x20outputs\x20the\x20supported\x20relationships'\x20hi\
    story\x20on\x20the\x20[asset_names]\x20or\n\x20returns\x20an\x20error\
    \x20if\x20any\x20of\x20the\x20[asset_names]'s\x20types\x20has\x20no\x20r\
    elationship\n\x20support.\n\x20See\x20[Introduction\x20to\x20Cloud\x20As\
    set\n\x20Inventory](https://cloud.google.com/asset-inventory/docs/overvi\
    ew)\x20for\x20all\n\x20supported\x20asset\x20types\x20and\x20relationshi\
    p\x20types.\n\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04\xa4\x04\x02\n\n\r\n\
    \x05\x04\x05\x02\x04\x05\x12\x04\xa4\x04\x0b\x11\n\r\n\x05\x04\x05\x02\
    \x04\x01\x12\x04\xa4\x04\x12$\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\xa4\
    \x04'(\n\r\n\x05\x04\x05\x02\x04\x08\x12\x04\xa5\x04\x06.\n\x10\n\x08\
    \x04\x05\x02\x04\x08\x9c\x08\0\x12\x04\xa5\x04\x07-\n2\n\x02\x04\x06\x12\
    \x06\xa9\x04\0\xac\x04\x01\x1a$\x20Batch\x20get\x20assets\x20history\x20\
    response.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xa9\x04\x08%\n9\n\x04\x04\
    \x06\x02\0\x12\x04\xab\x04\x02$\x1a+\x20A\x20list\x20of\x20assets\x20wit\
    h\x20valid\x20time\x20windows.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xab\
    \x04\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xab\x04\x0b\x18\n\r\n\x05\
    \x04\x06\x02\0\x01\x12\x04\xab\x04\x19\x1f\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\xab\x04\"#\n*\n\x02\x04\x07\x12\x06\xaf\x04\0\xc0\x04\x01\x1a\
    \x1c\x20Create\x20asset\x20feed\x20request.\n\n\x0b\n\x03\x04\x07\x01\
    \x12\x04\xaf\x04\x08\x19\n\xbf\x02\n\x04\x04\x07\x02\0\x12\x04\xb5\x04\
    \x02=\x1a\xb0\x02\x20Required.\x20The\x20name\x20of\x20the\x20project/fo\
    lder/organization\x20where\x20this\x20feed\n\x20should\x20be\x20created\
    \x20in.\x20It\x20can\x20only\x20be\x20an\x20organization\x20number\x20(s\
    uch\x20as\n\x20\"organizations/123\"),\x20a\x20folder\x20number\x20(such\
    \x20as\x20\"folders/123\"),\x20a\x20project\x20ID\n\x20(such\x20as\x20\"\
    projects/my-project-id\"),\x20or\x20a\x20project\x20number\x20(such\x20a\
    s\n\x20\"projects/12345\").\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xb5\
    \x04\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb5\x04\t\x0f\n\r\n\x05\
    \x04\x07\x02\0\x03\x12\x04\xb5\x04\x12\x13\n\r\n\x05\x04\x07\x02\0\x08\
    \x12\x04\xb5\x04\x14<\n\x10\n\x08\x04\x07\x02\0\x08\x9c\x08\0\x12\x04\
    \xb5\x04\x15;\n\x9c\x01\n\x04\x04\x07\x02\x01\x12\x04\xb9\x04\x02>\x1a\
    \x8d\x01\x20Required.\x20This\x20is\x20the\x20client-assigned\x20asset\
    \x20feed\x20identifier\x20and\x20it\x20needs\x20to\n\x20be\x20unique\x20\
    under\x20a\x20specific\x20parent\x20project/folder/organization.\n\n\r\n\
    \x05\x04\x07\x02\x01\x05\x12\x04\xb9\x04\x02\x08\n\r\n\x05\x04\x07\x02\
    \x01\x01\x12\x04\xb9\x04\t\x10\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xb9\
    \x04\x13\x14\n\r\n\x05\x04\x07\x02\x01\x08\x12\x04\xb9\x04\x15=\n\x10\n\
    \x08\x04\x07\x02\x01\x08\x9c\x08\0\x12\x04\xb9\x04\x16<\n\xf3\x01\n\x04\
    \x04\x07\x02\x02\x12\x04\xbf\x04\x029\x1a\xe4\x01\x20Required.\x20The\
    \x20feed\x20details.\x20The\x20field\x20`name`\x20must\x20be\x20empty\
    \x20and\x20it\x20will\x20be\n\x20generated\x20in\x20the\x20format\x20of:\
    \x20projects/project_number/feeds/feed_id\n\x20folders/folder_number/fee\
    ds/feed_id\n\x20organizations/organization_number/feeds/feed_id\n\n\r\n\
    \x05\x04\x07\x02\x02\x06\x12\x04\xbf\x04\x02\x06\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\xbf\x04\x07\x0b\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\
    \xbf\x04\x0e\x0f\n\r\n\x05\x04\x07\x02\x02\x08\x12\x04\xbf\x04\x108\n\
    \x10\n\x08\x04\x07\x02\x02\x08\x9c\x08\0\x12\x04\xbf\x04\x117\n'\n\x02\
    \x04\x08\x12\x06\xc3\x04\0\xcc\x04\x01\x1a\x19\x20Get\x20asset\x20feed\
    \x20request.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xc3\x04\x08\x16\n\xcf\x01\
    \n\x04\x04\x08\x02\0\x12\x06\xc8\x04\x02\xcb\x04\x04\x1a\xbe\x01\x20Requ\
    ired.\x20The\x20name\x20of\x20the\x20Feed\x20and\x20it\x20must\x20be\x20\
    in\x20the\x20format\x20of:\n\x20projects/project_number/feeds/feed_id\n\
    \x20folders/folder_number/feeds/feed_id\n\x20organizations/organization_\
    number/feeds/feed_id\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xc8\x04\x02\
    \x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xc8\x04\t\r\n\r\n\x05\x04\x08\
    \x02\0\x03\x12\x04\xc8\x04\x10\x11\n\x0f\n\x05\x04\x08\x02\0\x08\x12\x06\
    \xc8\x04\x12\xcb\x04\x03\n\x10\n\x08\x04\x08\x02\0\x08\x9c\x08\0\x12\x04\
    \xc9\x04\x04*\n\x0f\n\x07\x04\x08\x02\0\x08\x9f\x08\x12\x04\xca\x04\x04P\
    \n)\n\x02\x04\t\x12\x06\xcf\x04\0\xd4\x04\x01\x1a\x1b\x20List\x20asset\
    \x20feeds\x20request.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xcf\x04\x08\x18\n\
    \xe9\x01\n\x04\x04\t\x02\0\x12\x04\xd3\x04\x02=\x1a\xda\x01\x20Required.\
    \x20The\x20parent\x20project/folder/organization\x20whose\x20feeds\x20ar\
    e\x20to\x20be\n\x20listed.\x20It\x20can\x20only\x20be\x20using\x20projec\
    t/folder/organization\x20number\x20(such\x20as\n\x20\"folders/12345\")\"\
    ,\x20or\x20a\x20project\x20ID\x20(such\x20as\x20\"projects/my-project-id\
    \").\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xd3\x04\x02\x08\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\xd3\x04\t\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xd3\
    \x04\x12\x13\n\r\n\x05\x04\t\x02\0\x08\x12\x04\xd3\x04\x14<\n\x10\n\x08\
    \x04\t\x02\0\x08\x9c\x08\0\x12\x04\xd3\x04\x15;\n\x0c\n\x02\x04\n\x12\
    \x06\xd6\x04\0\xd9\x04\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xd6\x04\x08\x19\
    \n\x20\n\x04\x04\n\x02\0\x12\x04\xd8\x04\x02\x1a\x1a\x12\x20A\x20list\
    \x20of\x20feeds.\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xd8\x04\x02\n\n\r\n\
    \x05\x04\n\x02\0\x06\x12\x04\xd8\x04\x0b\x0f\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\xd8\x04\x10\x15\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xd8\x04\x18\
    \x19\n*\n\x02\x04\x0b\x12\x06\xdc\x04\0\xe9\x04\x01\x1a\x1c\x20Update\
    \x20asset\x20feed\x20request.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xdc\x04\
    \x08\x19\n\x8d\x02\n\x04\x04\x0b\x02\0\x12\x04\xe2\x04\x029\x1a\xfe\x01\
    \x20Required.\x20The\x20new\x20values\x20of\x20feed\x20details.\x20It\
    \x20must\x20match\x20an\x20existing\x20feed\n\x20and\x20the\x20field\x20\
    `name`\x20must\x20be\x20in\x20the\x20format\x20of:\n\x20projects/project\
    _number/feeds/feed_id\x20or\n\x20folders/folder_number/feeds/feed_id\x20\
    or\n\x20organizations/organization_number/feeds/feed_id.\n\n\r\n\x05\x04\
    \x0b\x02\0\x06\x12\x04\xe2\x04\x02\x06\n\r\n\x05\x04\x0b\x02\0\x01\x12\
    \x04\xe2\x04\x07\x0b\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xe2\x04\x0e\x0f\
    \n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\xe2\x04\x108\n\x10\n\x08\x04\x0b\
    \x02\0\x08\x9c\x08\0\x12\x04\xe2\x04\x117\n\xc4\x01\n\x04\x04\x0b\x02\
    \x01\x12\x06\xe7\x04\x02\xe8\x04/\x1a\xb3\x01\x20Required.\x20Only\x20up\
    dates\x20the\x20`feed`\x20fields\x20indicated\x20by\x20this\x20mask.\n\
    \x20The\x20field\x20mask\x20must\x20not\x20be\x20empty,\x20and\x20it\x20\
    must\x20not\x20contain\x20fields\x20that\n\x20are\x20immutable\x20or\x20\
    only\x20set\x20by\x20the\x20server.\n\n\r\n\x05\x04\x0b\x02\x01\x06\x12\
    \x04\xe7\x04\x02\x1b\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xe7\x04\x1c'\
    \n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xe7\x04*+\n\r\n\x05\x04\x0b\x02\
    \x01\x08\x12\x04\xe8\x04\x06.\n\x10\n\x08\x04\x0b\x02\x01\x08\x9c\x08\0\
    \x12\x04\xe8\x04\x07-\n\x0c\n\x02\x04\x0c\x12\x06\xeb\x04\0\xf4\x04\x01\
    \n\x0b\n\x03\x04\x0c\x01\x12\x04\xeb\x04\x08\x19\n\xcf\x01\n\x04\x04\x0c\
    \x02\0\x12\x06\xf0\x04\x02\xf3\x04\x04\x1a\xbe\x01\x20Required.\x20The\
    \x20name\x20of\x20the\x20feed\x20and\x20it\x20must\x20be\x20in\x20the\
    \x20format\x20of:\n\x20projects/project_number/feeds/feed_id\n\x20folder\
    s/folder_number/feeds/feed_id\n\x20organizations/organization_number/fee\
    ds/feed_id\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xf0\x04\x02\x08\n\r\n\
    \x05\x04\x0c\x02\0\x01\x12\x04\xf0\x04\t\r\n\r\n\x05\x04\x0c\x02\0\x03\
    \x12\x04\xf0\x04\x10\x11\n\x0f\n\x05\x04\x0c\x02\0\x08\x12\x06\xf0\x04\
    \x12\xf3\x04\x03\n\x10\n\x08\x04\x0c\x02\0\x08\x9c\x08\0\x12\x04\xf1\x04\
    \x04*\n\x0f\n\x07\x04\x0c\x02\0\x08\x9f\x08\x12\x04\xf2\x04\x04P\nC\n\
    \x02\x04\r\x12\x06\xf7\x04\0\x81\x05\x01\x1a5\x20Output\x20configuration\
    \x20for\x20export\x20assets\x20destination.\n\n\x0b\n\x03\x04\r\x01\x12\
    \x04\xf7\x04\x08\x14\n+\n\x04\x04\r\x08\0\x12\x06\xf9\x04\x02\x80\x05\
    \x03\x1a\x1b\x20Asset\x20export\x20destination.\n\n\r\n\x05\x04\r\x08\0\
    \x01\x12\x04\xf9\x04\x08\x13\n-\n\x04\x04\r\x02\0\x12\x04\xfb\x04\x04'\
    \x1a\x1f\x20Destination\x20on\x20Cloud\x20Storage.\n\n\r\n\x05\x04\r\x02\
    \0\x06\x12\x04\xfb\x04\x04\x12\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xfb\x04\
    \x13\"\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xfb\x04%&\nv\n\x04\x04\r\x02\
    \x01\x12\x04\xff\x04\x041\x1ah\x20Destination\x20on\x20BigQuery.\x20The\
    \x20output\x20table\x20stores\x20the\x20fields\x20in\x20asset\n\x20Proto\
    buf\x20as\x20columns\x20in\x20BigQuery.\n\n\r\n\x05\x04\r\x02\x01\x06\
    \x12\x04\xff\x04\x04\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xff\x04\x18\
    ,\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xff\x04/0\n/\n\x02\x04\x0e\x12\x06\
    \x84\x05\0\x8a\x05\x01\x1a!\x20Output\x20result\x20of\x20export\x20asset\
    s.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x84\x05\x08\x14\n&\n\x04\x04\x0e\
    \x08\0\x12\x06\x86\x05\x02\x89\x05\x03\x1a\x16\x20Asset\x20export\x20res\
    ult.\n\n\r\n\x05\x04\x0e\x08\0\x01\x12\x04\x86\x05\x08\x0e\n/\n\x04\x04\
    \x0e\x02\0\x12\x04\x88\x05\x04#\x1a!\x20Export\x20result\x20on\x20Cloud\
    \x20Storage.\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\x88\x05\x04\x13\n\r\n\
    \x05\x04\x0e\x02\0\x01\x12\x04\x88\x05\x14\x1e\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\x88\x05!\"\n.\n\x02\x04\x0f\x12\x06\x8d\x05\0\x91\x05\x01\
    \x1a\x20\x20A\x20Cloud\x20Storage\x20output\x20result.\n\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\x8d\x05\x08\x17\nd\n\x04\x04\x0f\x02\0\x12\x04\x90\x05\
    \x02\x1b\x1aV\x20List\x20of\x20URIs\x20of\x20the\x20Cloud\x20Storage\x20\
    objects.\x20Example:\n\x20\"gs://bucket_name/object_name\".\n\n\r\n\x05\
    \x04\x0f\x02\0\x04\x12\x04\x90\x05\x02\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\
    \x04\x90\x05\x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x90\x05\x12\x16\
    \n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x90\x05\x19\x1a\n)\n\x02\x04\x10\
    \x12\x06\x94\x05\0\xad\x05\x01\x1a\x1b\x20A\x20Cloud\x20Storage\x20locat\
    ion.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x94\x05\x08\x16\n\x1b\n\x04\x04\
    \x10\x08\0\x12\x06\x96\x05\x02\xac\x05\x03\x1a\x0b\x20Required.\n\n\r\n\
    \x05\x04\x10\x08\0\x01\x12\x04\x96\x05\x08\x12\n\xc2\x03\n\x04\x04\x10\
    \x02\0\x12\x04\xa0\x05\x04\x13\x1a\xb3\x03\x20The\x20URI\x20of\x20the\
    \x20Cloud\x20Storage\x20object.\x20It's\x20the\x20same\x20URI\x20that\
    \x20is\x20used\x20by\n\x20gsutil.\x20Example:\x20\"gs://bucket_name/obje\
    ct_name\".\x20See\x20[Viewing\x20and\n\x20Editing\x20Object\n\x20Metadat\
    a](https://cloud.google.com/storage/docs/viewing-editing-metadata)\n\x20\
    for\x20more\x20information.\n\n\x20If\x20the\x20specified\x20Cloud\x20St\
    orage\x20object\x20already\x20exists\x20and\x20there\x20is\x20no\n\x20[h\
    old](https://cloud.google.com/storage/docs/object-holds),\x20it\x20will\
    \x20be\n\x20overwritten\x20with\x20the\x20exported\x20result.\n\n\r\n\
    \x05\x04\x10\x02\0\x05\x12\x04\xa0\x05\x04\n\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\xa0\x05\x0b\x0e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa0\x05\x11\
    \x12\n\xc5\x04\n\x04\x04\x10\x02\x01\x12\x04\xab\x05\x04\x1a\x1a\xb6\x04\
    \x20The\x20URI\x20prefix\x20of\x20all\x20generated\x20Cloud\x20Storage\
    \x20objects.\x20Example:\n\x20\"gs://bucket_name/object_name_prefix\".\
    \x20Each\x20object\x20URI\x20is\x20in\x20format:\n\x20\"gs://bucket_name\
    /object_name_prefix/<asset\x20type>/<shard\x20number>\x20and\x20only\n\
    \x20contains\x20assets\x20for\x20that\x20type.\x20<shard\x20number>\x20s\
    tarts\x20from\x200.\x20Example:\n\x20\"gs://bucket_name/object_name_pref\
    ix/compute.googleapis.com/Disk/0\"\x20is\n\x20the\x20first\x20shard\x20o\
    f\x20output\x20objects\x20containing\x20all\n\x20compute.googleapis.com/\
    Disk\x20assets.\x20An\x20INVALID_ARGUMENT\x20error\x20will\x20be\n\x20re\
    turned\x20if\x20file\x20with\x20the\x20same\x20name\x20\"gs://bucket_nam\
    e/object_name_prefix\"\n\x20already\x20exists.\n\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\xab\x05\x04\n\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xab\
    \x05\x0b\x15\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xab\x05\x18\x19\n?\n\
    \x02\x04\x11\x12\x06\xb0\x05\0\xf5\x05\x01\x1a1\x20A\x20BigQuery\x20dest\
    ination\x20for\x20exporting\x20assets\x20to.\n\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\xb0\x05\x08\x1b\n\xd1\x03\n\x04\x04\x11\x02\0\x12\x04\xb9\x05\
    \x02>\x1a\xc2\x03\x20Required.\x20The\x20BigQuery\x20dataset\x20in\x20fo\
    rmat\n\x20\"projects/projectId/datasets/datasetId\",\x20to\x20which\x20t\
    he\x20snapshot\x20result\n\x20should\x20be\x20exported.\x20If\x20this\
    \x20dataset\x20does\x20not\x20exist,\x20the\x20export\x20call\x20returns\
    \n\x20an\x20INVALID_ARGUMENT\x20error.\x20Setting\x20the\x20`contentType\
    `\x20for\x20`exportAssets`\n\x20determines\x20the\n\x20[schema](/asset-i\
    nventory/docs/exporting-to-bigquery#bigquery-schema)\n\x20of\x20the\x20B\
    igQuery\x20table.\x20Setting\x20`separateTablesPerAssetType`\x20to\x20`T\
    RUE`\x20also\n\x20influences\x20the\x20schema.\n\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xb9\x05\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb9\x05\
    \t\x10\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb9\x05\x13\x14\n\r\n\x05\x04\
    \x11\x02\0\x08\x12\x04\xb9\x05\x15=\n\x10\n\x08\x04\x11\x02\0\x08\x9c\
    \x08\0\x12\x04\xb9\x05\x16<\n\xae\x01\n\x04\x04\x11\x02\x01\x12\x04\xbe\
    \x05\x02<\x1a\x9f\x01\x20Required.\x20The\x20BigQuery\x20table\x20to\x20\
    which\x20the\x20snapshot\x20result\x20should\x20be\n\x20written.\x20If\
    \x20this\x20table\x20does\x20not\x20exist,\x20a\x20new\x20table\x20with\
    \x20the\x20given\x20name\n\x20will\x20be\x20created.\n\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\xbe\x05\x02\x08\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xbe\x05\t\x0e\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xbe\x05\x11\x12\
    \n\r\n\x05\x04\x11\x02\x01\x08\x12\x04\xbe\x05\x13;\n\x10\n\x08\x04\x11\
    \x02\x01\x08\x9c\x08\0\x12\x04\xbe\x05\x14:\n\x93\x02\n\x04\x04\x11\x02\
    \x02\x12\x04\xc4\x05\x02\x11\x1a\x84\x02\x20If\x20the\x20destination\x20\
    table\x20already\x20exists\x20and\x20this\x20flag\x20is\x20`TRUE`,\x20th\
    e\n\x20table\x20will\x20be\x20overwritten\x20by\x20the\x20contents\x20of\
    \x20assets\x20snapshot.\x20If\x20the\x20flag\n\x20is\x20`FALSE`\x20or\
    \x20unset\x20and\x20the\x20destination\x20table\x20already\x20exists,\
    \x20the\x20export\n\x20call\x20returns\x20an\x20INVALID_ARGUMEMT\x20erro\
    r.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xc4\x05\x02\x06\n\r\n\x05\x04\
    \x11\x02\x02\x01\x12\x04\xc4\x05\x07\x0c\n\r\n\x05\x04\x11\x02\x02\x03\
    \x12\x04\xc4\x05\x0f\x10\n\xf6\x07\n\x04\x04\x11\x02\x03\x12\x04\xd7\x05\
    \x02#\x1a\xe7\x07\x20[partition_spec]\x20determines\x20whether\x20to\x20\
    export\x20to\x20partitioned\x20table(s)\x20and\n\x20how\x20to\x20partiti\
    on\x20the\x20data.\n\n\x20If\x20[partition_spec]\x20is\x20unset\x20or\
    \x20[partition_spec.partition_key]\x20is\x20unset\x20or\n\x20`PARTITION_\
    KEY_UNSPECIFIED`,\x20the\x20snapshot\x20results\x20will\x20be\x20exporte\
    d\x20to\n\x20non-partitioned\x20table(s).\x20[force]\x20will\x20decide\
    \x20whether\x20to\x20overwrite\x20existing\n\x20table(s).\n\n\x20If\x20[\
    partition_spec]\x20is\x20specified.\x20First,\x20the\x20snapshot\x20resu\
    lts\x20will\x20be\n\x20written\x20to\x20partitioned\x20table(s)\x20with\
    \x20two\x20additional\x20timestamp\x20columns,\n\x20readTime\x20and\x20r\
    equestTime,\x20one\x20of\x20which\x20will\x20be\x20the\x20partition\x20k\
    ey.\x20Secondly,\n\x20in\x20the\x20case\x20when\x20any\x20destination\
    \x20table\x20already\x20exists,\x20it\x20will\x20first\x20try\x20to\n\
    \x20update\x20existing\x20table's\x20schema\x20as\x20necessary\x20by\x20\
    appending\x20additional\n\x20columns.\x20Then,\x20if\x20[force]\x20is\
    \x20`TRUE`,\x20the\x20corresponding\x20partition\x20will\x20be\n\x20over\
    written\x20by\x20the\x20snapshot\x20results\x20(data\x20in\x20different\
    \x20partitions\x20will\n\x20remain\x20intact);\x20if\x20[force]\x20is\
    \x20unset\x20or\x20`FALSE`,\x20it\x20will\x20append\x20the\x20data.\x20A\
    n\n\x20error\x20will\x20be\x20returned\x20if\x20the\x20schema\x20update\
    \x20or\x20data\x20appension\x20fails.\n\n\r\n\x05\x04\x11\x02\x03\x06\
    \x12\x04\xd7\x05\x02\x0f\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xd7\x05\
    \x10\x1e\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xd7\x05!\"\n\xcd\x0c\n\
    \x04\x04\x11\x02\x04\x12\x04\xf4\x05\x02*\x1a\xbe\x0c\x20If\x20this\x20f\
    lag\x20is\x20`TRUE`,\x20the\x20snapshot\x20results\x20will\x20be\x20writ\
    ten\x20to\x20one\x20or\n\x20multiple\x20tables,\x20each\x20of\x20which\
    \x20contains\x20results\x20of\x20one\x20asset\x20type.\x20The\n\x20[forc\
    e]\x20and\x20[partition_spec]\x20fields\x20will\x20apply\x20to\x20each\
    \x20of\x20them.\n\n\x20Field\x20[table]\x20will\x20be\x20concatenated\
    \x20with\x20\"_\"\x20and\x20the\x20asset\x20type\x20names\x20(see\n\x20h\
    ttps://cloud.google.com/asset-inventory/docs/supported-asset-types\x20fo\
    r\n\x20supported\x20asset\x20types)\x20to\x20construct\x20per-asset-type\
    \x20table\x20names,\x20in\x20which\n\x20all\x20non-alphanumeric\x20chara\
    cters\x20like\x20\".\"\x20and\x20\"/\"\x20will\x20be\x20substituted\x20b\
    y\n\x20\"_\".\x20Example:\x20if\x20field\x20[table]\x20is\x20\"mytable\"\
    \x20and\x20snapshot\x20results\n\x20contain\x20\"storage.googleapis.com/\
    Bucket\"\x20assets,\x20the\x20corresponding\x20table\n\x20name\x20will\
    \x20be\x20\"mytable_storage_googleapis_com_Bucket\".\x20If\x20any\x20of\
    \x20these\n\x20tables\x20does\x20not\x20exist,\x20a\x20new\x20table\x20w\
    ith\x20the\x20concatenated\x20name\x20will\x20be\n\x20created.\n\n\x20Wh\
    en\x20[content_type]\x20in\x20the\x20ExportAssetsRequest\x20is\x20`RESOU\
    RCE`,\x20the\x20schema\x20of\n\x20each\x20table\x20will\x20include\x20RE\
    CORD-type\x20columns\x20mapped\x20to\x20the\x20nested\x20fields\x20in\n\
    \x20the\x20Asset.resource.data\x20field\x20of\x20that\x20asset\x20type\
    \x20(up\x20to\x20the\x2015\x20nested\x20level\n\x20BigQuery\x20supports\
    \n\x20(https://cloud.google.com/bigquery/docs/nested-repeated#limitation\
    s)).\x20The\n\x20fields\x20in\x20>15\x20nested\x20levels\x20will\x20be\
    \x20stored\x20in\x20JSON\x20format\x20string\x20as\x20a\x20child\n\x20co\
    lumn\x20of\x20its\x20parent\x20RECORD\x20column.\n\n\x20If\x20error\x20o\
    ccurs\x20when\x20exporting\x20to\x20any\x20table,\x20the\x20whole\x20exp\
    ort\x20call\x20will\n\x20return\x20an\x20error\x20but\x20the\x20export\
    \x20results\x20that\x20already\x20succeed\x20will\x20persist.\n\x20Examp\
    le:\x20if\x20exporting\x20to\x20table_type_A\x20succeeds\x20when\x20expo\
    rting\x20to\n\x20table_type_B\x20fails\x20during\x20one\x20export\x20cal\
    l,\x20the\x20results\x20in\x20table_type_A\x20will\n\x20persist\x20and\
    \x20there\x20will\x20not\x20be\x20partial\x20results\x20persisting\x20in\
    \x20a\x20table.\n\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xf4\x05\x02\x06\
    \n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xf4\x05\x07%\n\r\n\x05\x04\x11\
    \x02\x04\x03\x12\x04\xf4\x05()\nS\n\x02\x04\x12\x12\x06\xf8\x05\0\x92\
    \x06\x01\x1aE\x20Specifications\x20of\x20BigQuery\x20partitioned\x20tabl\
    e\x20as\x20export\x20destination.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xf8\
    \x05\x08\x15\n\xed\x02\n\x04\x04\x12\x04\0\x12\x06\xfe\x05\x02\x8e\x06\
    \x03\x1a\xdc\x02\x20This\x20enum\x20is\x20used\x20to\x20determine\x20the\
    \x20partition\x20key\x20column\x20when\x20exporting\n\x20assets\x20to\
    \x20BigQuery\x20partitioned\x20table(s).\x20Note\x20that,\x20if\x20the\
    \x20partition\x20key\x20is\n\x20a\x20timestamp\x20column,\x20the\x20actu\
    al\x20partition\x20is\x20based\x20on\x20its\x20date\x20value\n\x20(expre\
    ssed\x20in\x20UTC.\x20see\x20details\x20in\n\x20https://cloud.google.com\
    /bigquery/docs/partitioned-tables#date_timestamp_partitioned_tables).\n\
    \n\r\n\x05\x04\x12\x04\0\x01\x12\x04\xfe\x05\x07\x13\n[\n\x06\x04\x12\
    \x04\0\x02\0\x12\x04\x80\x06\x04\"\x1aK\x20Unspecified\x20partition\x20k\
    ey.\x20If\x20used,\x20it\x20means\x20using\x20non-partitioned\x20table.\
    \n\n\x0f\n\x07\x04\x12\x04\0\x02\0\x01\x12\x04\x80\x06\x04\x1d\n\x0f\n\
    \x07\x04\x12\x04\0\x02\0\x02\x12\x04\x80\x06\x20!\n\xe3\x02\n\x06\x04\
    \x12\x04\0\x02\x01\x12\x04\x87\x06\x04\x12\x1a\xd2\x02\x20The\x20time\
    \x20when\x20the\x20snapshot\x20is\x20taken.\x20If\x20specified\x20as\x20\
    partition\x20key,\x20the\n\x20result\x20table(s)\x20is\x20partitoned\x20\
    by\x20the\x20additional\x20timestamp\x20column,\n\x20readTime.\x20If\x20\
    [read_time]\x20in\x20ExportAssetsRequest\x20is\x20specified,\x20the\n\
    \x20readTime\x20column's\x20value\x20will\x20be\x20the\x20same\x20as\x20\
    it.\x20Otherwise,\x20its\x20value\x20will\n\x20be\x20the\x20current\x20t\
    ime\x20that\x20is\x20used\x20to\x20take\x20the\x20snapshot.\n\n\x0f\n\
    \x07\x04\x12\x04\0\x02\x01\x01\x12\x04\x87\x06\x04\r\n\x0f\n\x07\x04\x12\
    \x04\0\x02\x01\x02\x12\x04\x87\x06\x10\x11\n\xff\x01\n\x06\x04\x12\x04\0\
    \x02\x02\x12\x04\x8d\x06\x04\x15\x1a\xee\x01\x20The\x20time\x20when\x20t\
    he\x20request\x20is\x20received\x20and\x20started\x20to\x20be\x20process\
    ed.\x20If\n\x20specified\x20as\x20partition\x20key,\x20the\x20result\x20\
    table(s)\x20is\x20partitoned\x20by\x20the\n\x20requestTime\x20column,\
    \x20an\x20additional\x20timestamp\x20column\x20representing\x20when\x20t\
    he\n\x20request\x20was\x20received.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x02\
    \x01\x12\x04\x8d\x06\x04\x10\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x02\x12\
    \x04\x8d\x06\x13\x14\nA\n\x04\x04\x12\x02\0\x12\x04\x91\x06\x02!\x1a3\
    \x20The\x20partition\x20key\x20for\x20BigQuery\x20partitioned\x20table.\
    \n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\x91\x06\x02\x0e\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\x91\x06\x0f\x1c\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \x91\x06\x1f\x20\n&\n\x02\x04\x13\x12\x06\x95\x06\0\x99\x06\x01\x1a\x18\
    \x20A\x20Pub/Sub\x20destination.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x95\
    \x06\x08\x19\nm\n\x04\x04\x13\x02\0\x12\x04\x98\x06\x02\x13\x1a_\x20The\
    \x20name\x20of\x20the\x20Pub/Sub\x20topic\x20to\x20publish\x20to.\n\x20E\
    xample:\x20`projects/PROJECT_ID/topics/TOPIC_ID`.\n\n\r\n\x05\x04\x13\
    \x02\0\x05\x12\x04\x98\x06\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \x98\x06\t\x0e\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x98\x06\x11\x12\n@\n\
    \x02\x04\x14\x12\x06\x9c\x06\0\xa2\x06\x01\x1a2\x20Output\x20configurati\
    on\x20for\x20asset\x20feed\x20destination.\n\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\x9c\x06\x08\x18\n)\n\x04\x04\x14\x08\0\x12\x06\x9e\x06\x02\xa1\x06\
    \x03\x1a\x19\x20Asset\x20feed\x20destination.\n\n\r\n\x05\x04\x14\x08\0\
    \x01\x12\x04\x9e\x06\x08\x13\n'\n\x04\x04\x14\x02\0\x12\x04\xa0\x06\x04-\
    \x1a\x19\x20Destination\x20on\x20Pub/Sub.\n\n\r\n\x05\x04\x14\x02\0\x06\
    \x12\x04\xa0\x06\x04\x15\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xa0\x06\x16\
    (\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xa0\x06+,\n\x81\x02\n\x02\x04\x15\
    \x12\x06\xa9\x06\0\xf5\x06\x01\x1a\xf2\x01\x20An\x20asset\x20feed\x20use\
    d\x20to\x20export\x20asset\x20updates\x20to\x20a\x20destinations.\n\x20A\
    n\x20asset\x20feed\x20filter\x20controls\x20what\x20updates\x20are\x20ex\
    ported.\n\x20The\x20asset\x20feed\x20must\x20be\x20created\x20within\x20\
    a\x20project,\x20organization,\x20or\n\x20folder.\x20Supported\x20destin\
    ations\x20are:\n\x20Pub/Sub\x20topics.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\
    \xa9\x06\x08\x0c\n\r\n\x03\x04\x15\x07\x12\x06\xaa\x06\x02\xb0\x06\x04\n\
    \x0f\n\x05\x04\x15\x07\x9d\x08\x12\x06\xaa\x06\x02\xb0\x06\x04\n\xe9\x02\
    \n\x04\x04\x15\x02\0\x12\x04\xb9\x06\x02;\x1a\xda\x02\x20Required.\x20Th\
    e\x20format\x20will\x20be\n\x20projects/{project_number}/feeds/{client-a\
    ssigned_feed_identifier}\x20or\n\x20folders/{folder_number}/feeds/{clien\
    t-assigned_feed_identifier}\x20or\n\x20organizations/{organization_numbe\
    r}/feeds/{client-assigned_feed_identifier}\n\n\x20The\x20client-assigned\
    \x20feed\x20identifier\x20must\x20be\x20unique\x20within\x20the\x20paren\
    t\n\x20project/folder/organization.\n\n\r\n\x05\x04\x15\x02\0\x05\x12\
    \x04\xb9\x06\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xb9\x06\t\r\n\r\
    \n\x05\x04\x15\x02\0\x03\x12\x04\xb9\x06\x10\x11\n\r\n\x05\x04\x15\x02\0\
    \x08\x12\x04\xb9\x06\x12:\n\x10\n\x08\x04\x15\x02\0\x08\x9c\x08\0\x12\
    \x04\xb9\x06\x139\n\xc9\x03\n\x04\x04\x15\x02\x01\x12\x04\xc2\x06\x02\"\
    \x1a\xba\x03\x20A\x20list\x20of\x20the\x20full\x20names\x20of\x20the\x20\
    assets\x20to\x20receive\x20updates.\x20You\x20must\x20specify\n\x20eithe\
    r\x20or\x20both\x20of\x20asset_names\x20and\x20asset_types.\x20Only\x20a\
    sset\x20updates\x20matching\n\x20specified\x20asset_names\x20or\x20asset\
    _types\x20are\x20exported\x20to\x20the\x20feed.\n\x20Example:\n\x20`//co\
    mpute.googleapis.com/projects/my_project_123/zones/zone1/instances/insta\
    nce1`.\n\x20For\x20a\x20list\x20of\x20the\x20full\x20names\x20for\x20sup\
    ported\x20asset\x20types,\x20see\x20[Resource\n\x20name\x20format](/asse\
    t-inventory/docs/resource-name-format).\n\n\r\n\x05\x04\x15\x02\x01\x04\
    \x12\x04\xc2\x06\x02\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xc2\x06\x0b\
    \x11\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xc2\x06\x12\x1d\n\r\n\x05\x04\
    \x15\x02\x01\x03\x12\x04\xc2\x06\x20!\n\xff\x02\n\x04\x04\x15\x02\x02\
    \x12\x04\xcb\x06\x02\"\x1a\xf0\x02\x20A\x20list\x20of\x20types\x20of\x20\
    the\x20assets\x20to\x20receive\x20updates.\x20You\x20must\x20specify\x20\
    either\n\x20or\x20both\x20of\x20asset_names\x20and\x20asset_types.\x20On\
    ly\x20asset\x20updates\x20matching\n\x20specified\x20asset_names\x20or\
    \x20asset_types\x20are\x20exported\x20to\x20the\x20feed.\n\x20Example:\
    \x20`\"compute.googleapis.com/Disk\"`\n\n\x20For\x20a\x20list\x20of\x20a\
    ll\x20supported\x20asset\x20types,\x20see\n\x20[Supported\x20asset\x20ty\
    pes](/asset-inventory/docs/supported-asset-types).\n\n\r\n\x05\x04\x15\
    \x02\x02\x04\x12\x04\xcb\x06\x02\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\
    \xcb\x06\x0b\x11\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xcb\x06\x12\x1d\n\
    \r\n\x05\x04\x15\x02\x02\x03\x12\x04\xcb\x06\x20!\no\n\x04\x04\x15\x02\
    \x03\x12\x04\xcf\x06\x02\x1f\x1aa\x20Asset\x20content\x20type.\x20If\x20\
    not\x20specified,\x20no\x20content\x20but\x20the\x20asset\x20name\x20and\
    \n\x20type\x20will\x20be\x20returned.\n\n\r\n\x05\x04\x15\x02\x03\x06\
    \x12\x04\xcf\x06\x02\r\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xcf\x06\x0e\
    \x1a\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xcf\x06\x1d\x1e\ni\n\x04\x04\
    \x15\x02\x04\x12\x06\xd3\x06\x02\xd4\x06/\x1aY\x20Required.\x20Feed\x20o\
    utput\x20configuration\x20defining\x20where\x20the\x20asset\x20updates\
    \x20are\n\x20published\x20to.\n\n\r\n\x05\x04\x15\x02\x04\x06\x12\x04\
    \xd3\x06\x02\x12\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xd3\x06\x13%\n\r\
    \n\x05\x04\x15\x02\x04\x03\x12\x04\xd3\x06()\n\r\n\x05\x04\x15\x02\x04\
    \x08\x12\x04\xd4\x06\x06.\n\x10\n\x08\x04\x15\x02\x04\x08\x9c\x08\0\x12\
    \x04\xd4\x06\x07-\n\xeb\x04\n\x04\x04\x15\x02\x05\x12\x04\xe2\x06\x02!\
    \x1a\xdc\x04\x20A\x20condition\x20which\x20determines\x20whether\x20an\
    \x20asset\x20update\x20should\x20be\x20published.\n\x20If\x20specified,\
    \x20an\x20asset\x20will\x20be\x20returned\x20only\x20when\x20the\x20expr\
    ession\x20evaluates\n\x20to\x20true.\n\x20When\x20set,\x20`expression`\
    \x20field\x20in\x20the\x20`Expr`\x20must\x20be\x20a\x20valid\x20[CEL\x20\
    expression]\n\x20(https://github.com/google/cel-spec)\x20on\x20a\x20Temp\
    oralAsset\x20with\x20name\n\x20`temporal_asset`.\x20Example:\x20a\x20Fee\
    d\x20with\x20expression\x20(\"temporal_asset.deleted\n\x20==\x20true\")\
    \x20will\x20only\x20publish\x20Asset\x20deletions.\x20Other\x20fields\
    \x20of\x20`Expr`\x20are\n\x20optional.\n\n\x20See\x20our\x20[user\n\x20g\
    uide](https://cloud.google.com/asset-inventory/docs/monitoring-asset-cha\
    nges-with-condition)\n\x20for\x20detailed\x20instructions.\n\n\r\n\x05\
    \x04\x15\x02\x05\x06\x12\x04\xe2\x06\x02\x12\n\r\n\x05\x04\x15\x02\x05\
    \x01\x12\x04\xe2\x06\x13\x1c\n\r\n\x05\x04\x15\x02\x05\x03\x12\x04\xe2\
    \x06\x1f\x20\n\xfb\x06\n\x04\x04\x15\x02\x06\x12\x04\xf4\x06\x02)\x1a\
    \xec\x06\x20A\x20list\x20of\x20relationship\x20types\x20to\x20output,\
    \x20for\x20example:\n\x20`INSTANCE_TO_INSTANCEGROUP`.\x20This\x20field\
    \x20should\x20only\x20be\x20specified\x20if\n\x20content_type=RELATIONSH\
    IP.\n\x20*\x20If\x20specified:\n\x20it\x20outputs\x20specified\x20relati\
    onship\x20updates\x20on\x20the\x20[asset_names]\x20or\x20the\n\x20[asset\
    _types].\x20It\x20returns\x20an\x20error\x20if\x20any\x20of\x20the\x20[r\
    elationship_types]\n\x20doesn't\x20belong\x20to\x20the\x20supported\x20r\
    elationship\x20types\x20of\x20the\x20[asset_names]\x20or\n\x20[asset_typ\
    es],\x20or\x20any\x20of\x20the\x20[asset_names]\x20or\x20the\x20[asset_t\
    ypes]\x20doesn't\n\x20belong\x20to\x20the\x20source\x20types\x20of\x20th\
    e\x20[relationship_types].\n\x20*\x20Otherwise:\n\x20it\x20outputs\x20th\
    e\x20supported\x20relationships\x20of\x20the\x20types\x20of\x20[asset_na\
    mes]\x20and\n\x20[asset_types]\x20or\x20returns\x20an\x20error\x20if\x20\
    any\x20of\x20the\x20[asset_names]\x20or\x20the\n\x20[asset_types]\x20has\
    \x20no\x20replationship\x20support.\n\x20See\x20[Introduction\x20to\x20C\
    loud\x20Asset\n\x20Inventory](https://cloud.google.com/asset-inventory/d\
    ocs/overview)\n\x20for\x20all\x20supported\x20asset\x20types\x20and\x20r\
    elationship\x20types.\n\n\r\n\x05\x04\x15\x02\x06\x04\x12\x04\xf4\x06\
    \x02\n\n\r\n\x05\x04\x15\x02\x06\x05\x12\x04\xf4\x06\x0b\x11\n\r\n\x05\
    \x04\x15\x02\x06\x01\x12\x04\xf4\x06\x12$\n\r\n\x05\x04\x15\x02\x06\x03\
    \x12\x04\xf4\x06'(\n-\n\x02\x04\x16\x12\x06\xf8\x06\0\xa6\x08\x01\x1a\
    \x1f\x20Search\x20all\x20resources\x20request.\n\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\xf8\x06\x08!\n\xd0\x04\n\x04\x04\x16\x02\0\x12\x04\x85\x07\x02<\
    \x1a\xc1\x04\x20Required.\x20A\x20scope\x20can\x20be\x20a\x20project,\
    \x20a\x20folder,\x20or\x20an\x20organization.\x20The\n\x20search\x20is\
    \x20limited\x20to\x20the\x20resources\x20within\x20the\x20`scope`.\x20Th\
    e\x20caller\x20must\x20be\n\x20granted\x20the\n\x20[`cloudasset.assets.s\
    earchAllResources`](https://cloud.google.com/asset-inventory/docs/access\
    -control#required_permissions)\n\x20permission\x20on\x20the\x20desired\
    \x20scope.\n\n\x20The\x20allowed\x20values\x20are:\n\n\x20*\x20projects/\
    {PROJECT_ID}\x20(e.g.,\x20\"projects/foo-bar\")\n\x20*\x20projects/{PROJ\
    ECT_NUMBER}\x20(e.g.,\x20\"projects/12345678\")\n\x20*\x20folders/{FOLDE\
    R_NUMBER}\x20(e.g.,\x20\"folders/1234567\")\n\x20*\x20organizations/{ORG\
    ANIZATION_NUMBER}\x20(e.g.,\x20\"organizations/123456\")\n\n\r\n\x05\x04\
    \x16\x02\0\x05\x12\x04\x85\x07\x02\x08\n\r\n\x05\x04\x16\x02\0\x01\x12\
    \x04\x85\x07\t\x0e\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x85\x07\x11\x12\n\
    \r\n\x05\x04\x16\x02\0\x08\x12\x04\x85\x07\x13;\n\x10\n\x08\x04\x16\x02\
    \0\x08\x9c\x08\0\x12\x04\x85\x07\x14:\n\xb4#\n\x04\x04\x16\x02\x01\x12\
    \x04\xd3\x07\x02<\x1a\xa5#\x20Optional.\x20The\x20query\x20statement.\
    \x20See\x20[how\x20to\x20construct\x20a\n\x20query](https://cloud.google\
    .com/asset-inventory/docs/searching-resources#how_to_construct_a_query)\
    \n\x20for\x20more\x20information.\x20If\x20not\x20specified\x20or\x20emp\
    ty,\x20it\x20will\x20search\x20all\x20the\n\x20resources\x20within\x20th\
    e\x20specified\x20`scope`.\n\n\x20Examples:\n\n\x20*\x20`name:Important`\
    \x20to\x20find\x20Google\x20Cloud\x20resources\x20whose\x20name\x20conta\
    ins\n\x20\x20\x20`Important`\x20as\x20a\x20word.\n\x20*\x20`name=Importa\
    nt`\x20to\x20find\x20the\x20Google\x20Cloud\x20resource\x20whose\x20name\
    \x20is\x20exactly\n\x20\x20\x20`Important`.\n\x20*\x20`displayName:Impor\
    *`\x20to\x20find\x20Google\x20Cloud\x20resources\x20whose\x20display\x20\
    name\n\x20\x20\x20contains\x20`Impor`\x20as\x20a\x20prefix\x20of\x20any\
    \x20word\x20in\x20the\x20field.\n\x20*\x20`location:us-west*`\x20to\x20f\
    ind\x20Google\x20Cloud\x20resources\x20whose\x20location\n\x20\x20\x20co\
    ntains\x20both\x20`us`\x20and\x20`west`\x20as\x20prefixes.\n\x20*\x20`la\
    bels:prod`\x20to\x20find\x20Google\x20Cloud\x20resources\x20whose\x20lab\
    els\x20contain\x20`prod`\n\x20\x20\x20as\x20a\x20key\x20or\x20value.\n\
    \x20*\x20`labels.env:prod`\x20to\x20find\x20Google\x20Cloud\x20resources\
    \x20that\x20have\x20a\x20label\x20`env`\n\x20\x20\x20and\x20its\x20value\
    \x20is\x20`prod`.\n\x20*\x20`labels.env:*`\x20to\x20find\x20Google\x20Cl\
    oud\x20resources\x20that\x20have\x20a\x20label\x20`env`.\n\x20*\x20`tagK\
    eys:env`\x20to\x20find\x20Google\x20Cloud\x20resources\x20that\x20have\
    \x20directly\n\x20\x20\x20attached\x20tags\x20where\x20the\n\x20\x20\x20\
    [`TagKey`](https://cloud.google.com/resource-manager/reference/rest/v3/t\
    agKeys#resource:-tagkey)\n\x20\x20\x20.`namespacedName`\x20contains\x20`\
    env`.\n\x20*\x20`tagValues:prod*`\x20to\x20find\x20Google\x20Cloud\x20re\
    sources\x20that\x20have\x20directly\n\x20\x20\x20attached\x20tags\x20whe\
    re\x20the\n\x20\x20\x20[`TagValue`](https://cloud.google.com/resource-ma\
    nager/reference/rest/v3/tagValues#resource:-tagvalue)\n\x20\x20\x20.`nam\
    espacedName`\x20contains\x20a\x20word\x20prefixed\x20by\x20`prod`.\n\x20\
    *\x20`tagValueIds=tagValues/123`\x20to\x20find\x20Google\x20Cloud\x20res\
    ources\x20that\x20have\n\x20\x20\x20directly\x20attached\x20tags\x20wher\
    e\x20the\n\x20\x20\x20[`TagValue`](https://cloud.google.com/resource-man\
    ager/reference/rest/v3/tagValues#resource:-tagvalue)\n\x20\x20\x20.`name\
    `\x20is\x20exactly\x20`tagValues/123`.\n\x20*\x20`effectiveTagKeys:env`\
    \x20to\x20find\x20Google\x20Cloud\x20resources\x20that\x20have\n\x20\x20\
    \x20directly\x20attached\x20or\x20inherited\x20tags\x20where\x20the\n\
    \x20\x20\x20[`TagKey`](https://cloud.google.com/resource-manager/referen\
    ce/rest/v3/tagKeys#resource:-tagkey)\n\x20\x20\x20.`namespacedName`\x20c\
    ontains\x20`env`.\n\x20*\x20`effectiveTagValues:prod*`\x20to\x20find\x20\
    Google\x20Cloud\x20resources\x20that\x20have\n\x20\x20\x20directly\x20at\
    tached\x20or\x20inherited\x20tags\x20where\x20the\n\x20\x20\x20[`TagValu\
    e`](https://cloud.google.com/resource-manager/reference/rest/v3/tagValue\
    s#resource:-tagvalue)\n\x20\x20\x20.`namespacedName`\x20contains\x20a\
    \x20word\x20prefixed\x20by\x20`prod`.\n\x20*\x20`effectiveTagValueIds=ta\
    gValues/123`\x20to\x20find\x20Google\x20Cloud\x20resources\x20that\n\x20\
    \x20\x20\x20have\x20directly\x20attached\x20or\x20inherited\x20tags\x20w\
    here\x20the\n\x20\x20\x20[`TagValue`](https://cloud.google.com/resource-\
    manager/reference/rest/v3/tagValues#resource:-tagvalue)\n\x20\x20\x20.`n\
    ame`\x20is\x20exactly\x20`tagValues/123`.\n\x20*\x20`kmsKey:key`\x20to\
    \x20find\x20Google\x20Cloud\x20resources\x20encrypted\x20with\x20a\n\x20\
    \x20\x20customer-managed\x20encryption\x20key\x20whose\x20name\x20contai\
    ns\x20`key`\x20as\x20a\x20word.\x20This\n\x20\x20\x20field\x20is\x20depr\
    ecated.\x20Please\x20use\x20the\x20`kmsKeys`\x20field\x20to\x20retrieve\
    \x20Cloud\x20KMS\n\x20\x20\x20key\x20information.\n\x20*\x20`kmsKeys:key\
    `\x20to\x20find\x20Google\x20Cloud\x20resources\x20encrypted\x20with\n\
    \x20\x20\x20customer-managed\x20encryption\x20keys\x20whose\x20name\x20c\
    ontains\x20the\x20word\x20`key`.\n\x20*\x20`relationships:instance-group\
    -1`\x20to\x20find\x20Google\x20Cloud\x20resources\x20that\x20have\n\x20\
    \x20\x20relationships\x20with\x20`instance-group-1`\x20in\x20the\x20rela\
    ted\x20resource\x20name.\n\x20*\x20`relationships:INSTANCE_TO_INSTANCEGR\
    OUP`\x20to\x20find\x20Compute\x20Engine\n\x20\x20\x20instances\x20that\
    \x20have\x20relationships\x20of\x20type\x20`INSTANCE_TO_INSTANCEGROUP`.\
    \n\x20*\x20`relationships.INSTANCE_TO_INSTANCEGROUP:instance-group-1`\
    \x20to\x20find\n\x20\x20\x20Compute\x20Engine\x20instances\x20that\x20ha\
    ve\x20relationships\x20with\x20`instance-group-1`\n\x20\x20\x20in\x20the\
    \x20Compute\x20Engine\x20instance\x20group\x20resource\x20name,\x20for\
    \x20relationship\x20type\n\x20\x20\x20`INSTANCE_TO_INSTANCEGROUP`.\n\x20\
    *\x20`state:ACTIVE`\x20to\x20find\x20Google\x20Cloud\x20resources\x20who\
    se\x20state\x20contains\n\x20\x20\x20`ACTIVE`\x20as\x20a\x20word.\n\x20*\
    \x20`NOT\x20state:ACTIVE`\x20to\x20find\x20Google\x20Cloud\x20resources\
    \x20whose\x20state\x20doesn't\n\x20\x20\x20contain\x20`ACTIVE`\x20as\x20\
    a\x20word.\n\x20*\x20`createTime<1609459200`\x20to\x20find\x20Google\x20\
    Cloud\x20resources\x20that\x20were\x20created\n\x20\x20\x20before\x20`20\
    21-01-01\x2000:00:00\x20UTC`.\x20`1609459200`\x20is\x20the\x20epoch\x20t\
    imestamp\x20of\n\x20\x20\x20`2021-01-01\x2000:00:00\x20UTC`\x20in\x20sec\
    onds.\n\x20*\x20`updateTime>1609459200`\x20to\x20find\x20Google\x20Cloud\
    \x20resources\x20that\x20were\x20updated\n\x20\x20\x20after\x20`2021-01-\
    01\x2000:00:00\x20UTC`.\x20`1609459200`\x20is\x20the\x20epoch\x20timesta\
    mp\x20of\n\x20\x20\x20`2021-01-01\x2000:00:00\x20UTC`\x20in\x20seconds.\
    \n\x20*\x20`Important`\x20to\x20find\x20Google\x20Cloud\x20resources\x20\
    that\x20contain\x20`Important`\x20as\x20a\n\x20\x20\x20word\x20in\x20any\
    \x20of\x20the\x20searchable\x20fields.\n\x20*\x20`Impor*`\x20to\x20find\
    \x20Google\x20Cloud\x20resources\x20that\x20contain\x20`Impor`\x20as\x20\
    a\x20prefix\n\x20\x20\x20of\x20any\x20word\x20in\x20any\x20of\x20the\x20\
    searchable\x20fields.\n\x20*\x20`Important\x20location:(us-west1\x20OR\
    \x20global)`\x20to\x20find\x20Google\x20Cloud\n\x20\x20\x20resources\x20\
    that\x20contain\x20`Important`\x20as\x20a\x20word\x20in\x20any\x20of\x20\
    the\x20searchable\n\x20\x20\x20fields\x20and\x20are\x20also\x20located\
    \x20in\x20the\x20`us-west1`\x20region\x20or\x20the\x20`global`\n\x20\x20\
    \x20location.\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xd3\x07\x02\x08\n\
    \r\n\x05\x04\x16\x02\x01\x01\x12\x04\xd3\x07\t\x0e\n\r\n\x05\x04\x16\x02\
    \x01\x03\x12\x04\xd3\x07\x11\x12\n\r\n\x05\x04\x16\x02\x01\x08\x12\x04\
    \xd3\x07\x13;\n\x10\n\x08\x04\x16\x02\x01\x08\x9c\x08\0\x12\x04\xd3\x07\
    \x14:\n\xf7\x05\n\x04\x04\x16\x02\x02\x12\x04\xe3\x07\x02K\x1a\xe8\x05\
    \x20Optional.\x20A\x20list\x20of\x20asset\x20types\x20that\x20this\x20re\
    quest\x20searches\x20for.\x20If\x20empty,\n\x20it\x20will\x20search\x20a\
    ll\x20the\x20[searchable\x20asset\n\x20types](https://cloud.google.com/a\
    sset-inventory/docs/supported-asset-types#searchable_asset_types).\n\n\
    \x20Regular\x20expressions\x20are\x20also\x20supported.\x20For\x20exampl\
    e:\n\n\x20*\x20\"compute.googleapis.com.*\"\x20snapshots\x20resources\
    \x20whose\x20asset\x20type\x20starts\n\x20with\x20\"compute.googleapis.c\
    om\".\n\x20*\x20\".*Instance\"\x20snapshots\x20resources\x20whose\x20ass\
    et\x20type\x20ends\x20with\x20\"Instance\".\n\x20*\x20\".*Instance.*\"\
    \x20snapshots\x20resources\x20whose\x20asset\x20type\x20contains\x20\"In\
    stance\".\n\n\x20See\x20[RE2](https://github.com/google/re2/wiki/Syntax)\
    \x20for\x20all\x20supported\n\x20regular\x20expression\x20syntax.\x20If\
    \x20the\x20regular\x20expression\x20does\x20not\x20match\x20any\n\x20sup\
    ported\x20asset\x20type,\x20an\x20INVALID_ARGUMENT\x20error\x20will\x20b\
    e\x20returned.\n\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xe3\x07\x02\n\n\r\
    \n\x05\x04\x16\x02\x02\x05\x12\x04\xe3\x07\x0b\x11\n\r\n\x05\x04\x16\x02\
    \x02\x01\x12\x04\xe3\x07\x12\x1d\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\
    \xe3\x07\x20!\n\r\n\x05\x04\x16\x02\x02\x08\x12\x04\xe3\x07\"J\n\x10\n\
    \x08\x04\x16\x02\x02\x08\x9c\x08\0\x12\x04\xe3\x07#I\n\xda\x02\n\x04\x04\
    \x16\x02\x03\x12\x04\xea\x07\x02?\x1a\xcb\x02\x20Optional.\x20The\x20pag\
    e\x20size\x20for\x20search\x20result\x20pagination.\x20Page\x20size\x20i\
    s\x20capped\n\x20at\x20500\x20even\x20if\x20a\x20larger\x20value\x20is\
    \x20given.\x20If\x20set\x20to\x20zero\x20or\x20a\x20negative\x20value,\n\
    \x20server\x20will\x20pick\x20an\x20appropriate\x20default.\x20Returned\
    \x20results\x20may\x20be\x20fewer\x20than\n\x20requested.\x20When\x20thi\
    s\x20happens,\x20there\x20could\x20be\x20more\x20results\x20as\x20long\
    \x20as\n\x20`next_page_token`\x20is\x20returned.\n\n\r\n\x05\x04\x16\x02\
    \x03\x05\x12\x04\xea\x07\x02\x07\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\
    \xea\x07\x08\x11\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xea\x07\x14\x15\n\
    \r\n\x05\x04\x16\x02\x03\x08\x12\x04\xea\x07\x16>\n\x10\n\x08\x04\x16\
    \x02\x03\x08\x9c\x08\0\x12\x04\xea\x07\x17=\n\xa5\x02\n\x04\x04\x16\x02\
    \x04\x12\x04\xf0\x07\x02A\x1a\x96\x02\x20Optional.\x20If\x20present,\x20\
    then\x20retrieve\x20the\x20next\x20batch\x20of\x20results\x20from\x20the\
    \n\x20preceding\x20call\x20to\x20this\x20method.\x20`page_token`\x20must\
    \x20be\x20the\x20value\x20of\n\x20`next_page_token`\x20from\x20the\x20pr\
    evious\x20response.\x20The\x20values\x20of\x20all\x20other\n\x20method\
    \x20parameters,\x20must\x20be\x20identical\x20to\x20those\x20in\x20the\
    \x20previous\x20call.\n\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\xf0\x07\
    \x02\x08\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\xf0\x07\t\x13\n\r\n\x05\
    \x04\x16\x02\x04\x03\x12\x04\xf0\x07\x16\x17\n\r\n\x05\x04\x16\x02\x04\
    \x08\x12\x04\xf0\x07\x18@\n\x10\n\x08\x04\x16\x02\x04\x08\x9c\x08\0\x12\
    \x04\xf0\x07\x19?\n\xfe\x03\n\x04\x04\x16\x02\x05\x12\x04\x83\x08\x02?\
    \x1a\xef\x03\x20Optional.\x20A\x20comma-separated\x20list\x20of\x20field\
    s\x20specifying\x20the\x20sorting\x20order\x20of\n\x20the\x20results.\
    \x20The\x20default\x20order\x20is\x20ascending.\x20Add\x20\"\x20DESC\"\
    \x20after\x20the\x20field\n\x20name\x20to\x20indicate\x20descending\x20o\
    rder.\x20Redundant\x20space\x20characters\x20are\x20ignored.\n\x20Exampl\
    e:\x20\"location\x20DESC,\x20name\".\n\x20Only\x20the\x20following\x20fi\
    elds\x20in\x20the\x20response\x20are\x20sortable:\n\n\x20\x20\x20*\x20na\
    me\n\x20\x20\x20*\x20assetType\n\x20\x20\x20*\x20project\n\x20\x20\x20*\
    \x20displayName\n\x20\x20\x20*\x20description\n\x20\x20\x20*\x20location\
    \n\x20\x20\x20*\x20createTime\n\x20\x20\x20*\x20updateTime\n\x20\x20\x20\
    *\x20state\n\x20\x20\x20*\x20parentFullResourceName\n\x20\x20\x20*\x20pa\
    rentAssetType\n\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\x83\x08\x02\x08\n\
    \r\n\x05\x04\x16\x02\x05\x01\x12\x04\x83\x08\t\x11\n\r\n\x05\x04\x16\x02\
    \x05\x03\x12\x04\x83\x08\x14\x15\n\r\n\x05\x04\x16\x02\x05\x08\x12\x04\
    \x83\x08\x16>\n\x10\n\x08\x04\x16\x02\x05\x08\x9c\x08\0\x12\x04\x83\x08\
    \x17=\n\x85\x08\n\x04\x04\x16\x02\x06\x12\x06\xa4\x08\x02\xa5\x08/\x1a\
    \xf4\x07\x20Optional.\x20A\x20comma-separated\x20list\x20of\x20fields\
    \x20that\x20you\x20want\x20returned\x20in\x20the\n\x20results.\x20The\
    \x20following\x20fields\x20are\x20returned\x20by\x20default\x20if\x20not\
    \x20specified:\n\n\x20\x20\x20*\x20`name`\n\x20\x20\x20*\x20`assetType`\
    \n\x20\x20\x20*\x20`project`\n\x20\x20\x20*\x20`folders`\n\x20\x20\x20*\
    \x20`organization`\n\x20\x20\x20*\x20`displayName`\n\x20\x20\x20*\x20`de\
    scription`\n\x20\x20\x20*\x20`location`\n\x20\x20\x20*\x20`labels`\n\x20\
    \x20\x20*\x20`tags`\n\x20\x20\x20*\x20`effectiveTags`\n\x20\x20\x20*\x20\
    `networkTags`\n\x20\x20\x20*\x20`kmsKeys`\n\x20\x20\x20*\x20`createTime`\
    \n\x20\x20\x20*\x20`updateTime`\n\x20\x20\x20*\x20`state`\n\x20\x20\x20*\
    \x20`additionalAttributes`\n\x20\x20\x20*\x20`parentFullResourceName`\n\
    \x20\x20\x20*\x20`parentAssetType`\n\n\x20Some\x20fields\x20of\x20large\
    \x20size,\x20such\x20as\x20`versionedResources`,\n\x20`attachedResources\
    `,\x20`effectiveTags`\x20etc.,\x20are\x20not\x20returned\x20by\x20defaul\
    t,\x20but\n\x20you\x20can\x20specify\x20them\x20in\x20the\x20`read_mask`\
    \x20parameter\x20if\x20you\x20want\x20to\x20include\n\x20them.\x20If\x20\
    `\"*\"`\x20is\x20specified,\x20all\x20[available\n\x20fields](https://cl\
    oud.google.com/asset-inventory/docs/reference/rest/v1/TopLevel/searchAll\
    Resources#resourcesearchresult)\n\x20are\x20returned.\n\x20Examples:\x20\
    `\"name,location\"`,\x20`\"name,versionedResources\"`,\x20`\"*\"`.\n\x20\
    Any\x20invalid\x20field\x20path\x20will\x20trigger\x20INVALID_ARGUMENT\
    \x20error.\n\n\r\n\x05\x04\x16\x02\x06\x06\x12\x04\xa4\x08\x02\x1b\n\r\n\
    \x05\x04\x16\x02\x06\x01\x12\x04\xa4\x08\x1c%\n\r\n\x05\x04\x16\x02\x06\
    \x03\x12\x04\xa4\x08()\n\r\n\x05\x04\x16\x02\x06\x08\x12\x04\xa5\x08\x06\
    .\n\x10\n\x08\x04\x16\x02\x06\x08\x9c\x08\0\x12\x04\xa5\x08\x07-\n.\n\
    \x02\x04\x17\x12\x06\xa9\x08\0\xb2\x08\x01\x1a\x20\x20Search\x20all\x20r\
    esources\x20response.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xa9\x08\x08\"\ny\
    \n\x04\x04\x17\x02\0\x12\x04\xac\x08\x02,\x1ak\x20A\x20list\x20of\x20Res\
    ources\x20that\x20match\x20the\x20search\x20query.\x20It\x20contains\x20\
    the\x20resource\n\x20standard\x20metadata\x20information.\n\n\r\n\x05\
    \x04\x17\x02\0\x04\x12\x04\xac\x08\x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\
    \x04\xac\x08\x0b\x1f\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xac\x08\x20'\n\
    \r\n\x05\x04\x17\x02\0\x03\x12\x04\xac\x08*+\n\xe4\x01\n\x04\x04\x17\x02\
    \x01\x12\x04\xb1\x08\x02\x1d\x1a\xd5\x01\x20If\x20there\x20are\x20more\
    \x20results\x20than\x20those\x20appearing\x20in\x20this\x20response,\x20\
    then\n\x20`next_page_token`\x20is\x20included.\x20To\x20get\x20the\x20ne\
    xt\x20set\x20of\x20results,\x20call\x20this\n\x20method\x20again\x20usin\
    g\x20the\x20value\x20of\x20`next_page_token`\x20as\x20`page_token`.\n\n\
    \r\n\x05\x04\x17\x02\x01\x05\x12\x04\xb1\x08\x02\x08\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\xb1\x08\t\x18\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \xb1\x08\x1b\x1c\n0\n\x02\x04\x18\x12\x06\xb5\x08\0\x9b\t\x01\x1a\"\x20S\
    earch\x20all\x20IAM\x20policies\x20request.\n\n\x0b\n\x03\x04\x18\x01\
    \x12\x04\xb5\x08\x08#\n\xd5\x04\n\x04\x04\x18\x02\0\x12\x04\xc2\x08\x02<\
    \x1a\xc6\x04\x20Required.\x20A\x20scope\x20can\x20be\x20a\x20project,\
    \x20a\x20folder,\x20or\x20an\x20organization.\x20The\n\x20search\x20is\
    \x20limited\x20to\x20the\x20IAM\x20policies\x20within\x20the\x20`scope`.\
    \x20The\x20caller\x20must\n\x20be\x20granted\x20the\n\x20[`cloudasset.as\
    sets.searchAllIamPolicies`](https://cloud.google.com/asset-inventory/doc\
    s/access-control#required_permissions)\n\x20permission\x20on\x20the\x20d\
    esired\x20scope.\n\n\x20The\x20allowed\x20values\x20are:\n\n\x20*\x20pro\
    jects/{PROJECT_ID}\x20(e.g.,\x20\"projects/foo-bar\")\n\x20*\x20projects\
    /{PROJECT_NUMBER}\x20(e.g.,\x20\"projects/12345678\")\n\x20*\x20folders/\
    {FOLDER_NUMBER}\x20(e.g.,\x20\"folders/1234567\")\n\x20*\x20organization\
    s/{ORGANIZATION_NUMBER}\x20(e.g.,\x20\"organizations/123456\")\n\n\r\n\
    \x05\x04\x18\x02\0\x05\x12\x04\xc2\x08\x02\x08\n\r\n\x05\x04\x18\x02\0\
    \x01\x12\x04\xc2\x08\t\x0e\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc2\x08\
    \x11\x12\n\r\n\x05\x04\x18\x02\0\x08\x12\x04\xc2\x08\x13;\n\x10\n\x08\
    \x04\x18\x02\0\x08\x9c\x08\0\x12\x04\xc2\x08\x14:\n\xce\x12\n\x04\x04\
    \x18\x02\x01\x12\x04\xee\x08\x02<\x1a\xbf\x12\x20Optional.\x20The\x20que\
    ry\x20statement.\x20See\x20[how\x20to\x20construct\x20a\n\x20query](http\
    s://cloud.google.com/asset-inventory/docs/searching-iam-policies#how_to_\
    construct_a_query)\n\x20for\x20more\x20information.\x20If\x20not\x20spec\
    ified\x20or\x20empty,\x20it\x20will\x20search\x20all\x20the\n\x20IAM\x20\
    policies\x20within\x20the\x20specified\x20`scope`.\x20Note\x20that\x20th\
    e\x20query\x20string\x20is\n\x20compared\x20against\x20each\x20IAM\x20po\
    licy\x20binding,\x20including\x20its\x20principals,\n\x20roles,\x20and\
    \x20IAM\x20conditions.\x20The\x20returned\x20IAM\x20policies\x20will\x20\
    only\n\x20contain\x20the\x20bindings\x20that\x20match\x20your\x20query.\
    \x20To\x20learn\x20more\x20about\x20the\x20IAM\n\x20policy\x20structure,\
    \x20see\x20the\x20[IAM\x20policy\n\x20documentation](https://cloud.googl\
    e.com/iam/help/allow-policies/structure).\n\n\x20Examples:\n\n\x20*\x20`\
    policy:amy@gmail.com`\x20to\x20find\x20IAM\x20policy\x20bindings\x20that\
    \x20specify\x20user\n\x20\x20\x20\"amy@gmail.com\".\n\x20*\x20`policy:ro\
    les/compute.admin`\x20to\x20find\x20IAM\x20policy\x20bindings\x20that\
    \x20specify\n\x20\x20\x20the\x20Compute\x20Admin\x20role.\n\x20*\x20`pol\
    icy:comp*`\x20to\x20find\x20IAM\x20policy\x20bindings\x20that\x20contain\
    \x20\"comp\"\x20as\x20a\n\x20\x20\x20prefix\x20of\x20any\x20word\x20in\
    \x20the\x20binding.\n\x20*\x20`policy.role.permissions:storage.buckets.u\
    pdate`\x20to\x20find\x20IAM\x20policy\n\x20\x20\x20bindings\x20that\x20s\
    pecify\x20a\x20role\x20containing\x20\"storage.buckets.update\"\n\x20\
    \x20\x20permission.\x20Note\x20that\x20if\x20callers\x20don't\x20have\
    \x20`iam.roles.get`\x20access\x20to\x20a\n\x20\x20\x20role's\x20included\
    \x20permissions,\x20policy\x20bindings\x20that\x20specify\x20this\x20rol\
    e\x20will\n\x20\x20\x20be\x20dropped\x20from\x20the\x20search\x20results\
    .\n\x20*\x20`policy.role.permissions:upd*`\x20to\x20find\x20IAM\x20polic\
    y\x20bindings\x20that\x20specify\x20a\n\x20\x20\x20role\x20containing\
    \x20\"upd\"\x20as\x20a\x20prefix\x20of\x20any\x20word\x20in\x20the\x20ro\
    le\x20permission.\n\x20\x20\x20Note\x20that\x20if\x20callers\x20don't\
    \x20have\x20`iam.roles.get`\x20access\x20to\x20a\x20role's\n\x20\x20\x20\
    included\x20permissions,\x20policy\x20bindings\x20that\x20specify\x20thi\
    s\x20role\x20will\x20be\n\x20\x20\x20dropped\x20from\x20the\x20search\
    \x20results.\n\x20*\x20`resource:organizations/123456`\x20to\x20find\x20\
    IAM\x20policy\x20bindings\n\x20\x20\x20that\x20are\x20set\x20on\x20\"org\
    anizations/123456\".\n\x20*\x20`resource=//cloudresourcemanager.googleap\
    is.com/projects/myproject`\x20to\n\x20\x20\x20find\x20IAM\x20policy\x20b\
    indings\x20that\x20are\x20set\x20on\x20the\x20project\x20named\x20\"mypr\
    oject\".\n\x20*\x20`Important`\x20to\x20find\x20IAM\x20policy\x20binding\
    s\x20that\x20contain\x20\"Important\"\x20as\x20a\n\x20\x20\x20word\x20in\
    \x20any\x20of\x20the\x20searchable\x20fields\x20(except\x20for\x20the\
    \x20included\n\x20\x20\x20permissions).\n\x20*\x20`resource:(instance1\
    \x20OR\x20instance2)\x20policy:amy`\x20to\x20find\n\x20\x20\x20IAM\x20po\
    licy\x20bindings\x20that\x20are\x20set\x20on\x20resources\x20\"instance1\
    \"\x20or\n\x20\x20\x20\"instance2\"\x20and\x20also\x20specify\x20user\
    \x20\"amy\".\n\x20*\x20`roles:roles/compute.admin`\x20to\x20find\x20IAM\
    \x20policy\x20bindings\x20that\x20specify\x20the\n\x20\x20\x20Compute\
    \x20Admin\x20role.\n\x20*\x20`memberTypes:user`\x20to\x20find\x20IAM\x20\
    policy\x20bindings\x20that\x20contain\x20the\n\x20\x20\x20principal\x20t\
    ype\x20\"user\".\n\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xee\x08\x02\x08\
    \n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xee\x08\t\x0e\n\r\n\x05\x04\x18\
    \x02\x01\x03\x12\x04\xee\x08\x11\x12\n\r\n\x05\x04\x18\x02\x01\x08\x12\
    \x04\xee\x08\x13;\n\x10\n\x08\x04\x18\x02\x01\x08\x9c\x08\0\x12\x04\xee\
    \x08\x14:\n\xda\x02\n\x04\x04\x18\x02\x02\x12\x04\xf5\x08\x02?\x1a\xcb\
    \x02\x20Optional.\x20The\x20page\x20size\x20for\x20search\x20result\x20p\
    agination.\x20Page\x20size\x20is\x20capped\n\x20at\x20500\x20even\x20if\
    \x20a\x20larger\x20value\x20is\x20given.\x20If\x20set\x20to\x20zero\x20o\
    r\x20a\x20negative\x20value,\n\x20server\x20will\x20pick\x20an\x20approp\
    riate\x20default.\x20Returned\x20results\x20may\x20be\x20fewer\x20than\n\
    \x20requested.\x20When\x20this\x20happens,\x20there\x20could\x20be\x20mo\
    re\x20results\x20as\x20long\x20as\n\x20`next_page_token`\x20is\x20return\
    ed.\n\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xf5\x08\x02\x07\n\r\n\x05\
    \x04\x18\x02\x02\x01\x12\x04\xf5\x08\x08\x11\n\r\n\x05\x04\x18\x02\x02\
    \x03\x12\x04\xf5\x08\x14\x15\n\r\n\x05\x04\x18\x02\x02\x08\x12\x04\xf5\
    \x08\x16>\n\x10\n\x08\x04\x18\x02\x02\x08\x9c\x08\0\x12\x04\xf5\x08\x17=\
    \n\x9f\x02\n\x04\x04\x18\x02\x03\x12\x04\xfb\x08\x02A\x1a\x90\x02\x20Opt\
    ional.\x20If\x20present,\x20retrieve\x20the\x20next\x20batch\x20of\x20re\
    sults\x20from\x20the\x20preceding\n\x20call\x20to\x20this\x20method.\x20\
    `page_token`\x20must\x20be\x20the\x20value\x20of\x20`next_page_token`\n\
    \x20from\x20the\x20previous\x20response.\x20The\x20values\x20of\x20all\
    \x20other\x20method\x20parameters\x20must\n\x20be\x20identical\x20to\x20\
    those\x20in\x20the\x20previous\x20call.\n\n\r\n\x05\x04\x18\x02\x03\x05\
    \x12\x04\xfb\x08\x02\x08\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xfb\x08\t\
    \x13\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xfb\x08\x16\x17\n\r\n\x05\x04\
    \x18\x02\x03\x08\x12\x04\xfb\x08\x18@\n\x10\n\x08\x04\x18\x02\x03\x08\
    \x9c\x08\0\x12\x04\xfb\x08\x19?\n\xc2\x06\n\x04\x04\x18\x02\x04\x12\x04\
    \x8e\t\x02K\x1a\xb3\x06\x20Optional.\x20A\x20list\x20of\x20asset\x20type\
    s\x20that\x20the\x20IAM\x20policies\x20are\x20attached\x20to.\x20If\n\
    \x20empty,\x20it\x20will\x20search\x20the\x20IAM\x20policies\x20that\x20\
    are\x20attached\x20to\x20all\x20the\n\x20[searchable\x20asset\n\x20types\
    ](https://cloud.google.com/asset-inventory/docs/supported-asset-types#se\
    archable_asset_types).\n\n\x20Regular\x20expressions\x20are\x20also\x20s\
    upported.\x20For\x20example:\n\n\x20*\x20\"compute.googleapis.com.*\"\
    \x20snapshots\x20IAM\x20policies\x20attached\x20to\x20asset\x20type\n\
    \x20starts\x20with\x20\"compute.googleapis.com\".\n\x20*\x20\".*Instance\
    \"\x20snapshots\x20IAM\x20policies\x20attached\x20to\x20asset\x20type\
    \x20ends\x20with\n\x20\"Instance\".\n\x20*\x20\".*Instance.*\"\x20snapsh\
    ots\x20IAM\x20policies\x20attached\x20to\x20asset\x20type\x20contains\n\
    \x20\"Instance\".\n\n\x20See\x20[RE2](https://github.com/google/re2/wiki\
    /Syntax)\x20for\x20all\x20supported\n\x20regular\x20expression\x20syntax\
    .\x20If\x20the\x20regular\x20expression\x20does\x20not\x20match\x20any\n\
    \x20supported\x20asset\x20type,\x20an\x20INVALID_ARGUMENT\x20error\x20wi\
    ll\x20be\x20returned.\n\n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\x8e\t\x02\
    \n\n\r\n\x05\x04\x18\x02\x04\x05\x12\x04\x8e\t\x0b\x11\n\r\n\x05\x04\x18\
    \x02\x04\x01\x12\x04\x8e\t\x12\x1d\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\
    \x8e\t\x20!\n\r\n\x05\x04\x18\x02\x04\x08\x12\x04\x8e\t\"J\n\x10\n\x08\
    \x04\x18\x02\x04\x08\x9c\x08\0\x12\x04\x8e\t#I\n\xfd\x03\n\x04\x04\x18\
    \x02\x05\x12\x04\x9a\t\x02?\x1a\xee\x03\x20Optional.\x20A\x20comma-separ\
    ated\x20list\x20of\x20fields\x20specifying\x20the\x20sorting\x20order\
    \x20of\n\x20the\x20results.\x20The\x20default\x20order\x20is\x20ascendin\
    g.\x20Add\x20\"\x20DESC\"\x20after\x20the\x20field\n\x20name\x20to\x20in\
    dicate\x20descending\x20order.\x20Redundant\x20space\x20characters\x20ar\
    e\x20ignored.\n\x20Example:\x20\"assetType\x20DESC,\x20resource\".\n\x20\
    Only\x20singular\x20primitive\x20fields\x20in\x20the\x20response\x20are\
    \x20sortable:\n\x20\x20\x20*\x20resource\n\x20\x20\x20*\x20assetType\n\
    \x20\x20\x20*\x20project\n\x20All\x20the\x20other\x20fields\x20such\x20a\
    s\x20repeated\x20fields\x20(e.g.,\x20`folders`)\x20and\n\x20non-primitiv\
    e\x20fields\x20(e.g.,\x20`policy`)\x20are\x20not\x20supported.\n\n\r\n\
    \x05\x04\x18\x02\x05\x05\x12\x04\x9a\t\x02\x08\n\r\n\x05\x04\x18\x02\x05\
    \x01\x12\x04\x9a\t\t\x11\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\x9a\t\x14\
    \x15\n\r\n\x05\x04\x18\x02\x05\x08\x12\x04\x9a\t\x16>\n\x10\n\x08\x04\
    \x18\x02\x05\x08\x9c\x08\0\x12\x04\x9a\t\x17=\n1\n\x02\x04\x19\x12\x06\
    \x9e\t\0\xa7\t\x01\x1a#\x20Search\x20all\x20IAM\x20policies\x20response.\
    \n\n\x0b\n\x03\x04\x19\x01\x12\x04\x9e\t\x08$\n\x9c\x01\n\x04\x04\x19\
    \x02\0\x12\x04\xa1\t\x02-\x1a\x8d\x01\x20A\x20list\x20of\x20IAM\x20polic\
    ies\x20that\x20match\x20the\x20search\x20query.\x20Related\x20informatio\
    n\n\x20such\x20as\x20the\x20associated\x20resource\x20is\x20returned\x20\
    along\x20with\x20the\x20policy.\n\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\
    \xa1\t\x02\n\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xa1\t\x0b\x20\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xa1\t!(\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xa1\t+,\n\xb5\x01\n\x04\x04\x19\x02\x01\x12\x04\xa6\t\x02\x1d\x1a\xa6\
    \x01\x20Set\x20if\x20there\x20are\x20more\x20results\x20than\x20those\
    \x20appearing\x20in\x20this\x20response;\x20to\x20get\n\x20the\x20next\
    \x20set\x20of\x20results,\x20call\x20this\x20method\x20again,\x20using\
    \x20this\x20value\x20as\x20the\n\x20`page_token`.\n\n\r\n\x05\x04\x19\
    \x02\x01\x05\x12\x04\xa6\t\x02\x08\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\
    \xa6\t\t\x18\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xa6\t\x1b\x1c\n2\n\
    \x02\x04\x1a\x12\x06\xaa\t\0\xe8\n\x01\x1a$\x20IAM\x20policy\x20analysis\
    \x20query\x20message.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xaa\t\x08\x1e\n\
    \xb2\x01\n\x04\x04\x1a\x03\0\x12\x06\xae\t\x02\xb4\t\x03\x1a\xa1\x01\x20\
    Specifies\x20the\x20resource\x20to\x20analyze\x20for\x20access\x20polici\
    es,\x20which\x20may\x20be\x20set\n\x20directly\x20on\x20the\x20resource,\
    \x20or\x20on\x20ancestors\x20such\x20as\x20organizations,\x20folders\x20\
    or\n\x20projects.\n\n\r\n\x05\x04\x1a\x03\0\x01\x12\x04\xae\t\n\x1a\n\
    \x86\x02\n\x06\x04\x1a\x03\0\x02\0\x12\x04\xb3\t\x04K\x1a\xf5\x01\x20Req\
    uired.\x20The\x20[full\x20resource\x20name]\n\x20(https://cloud.google.c\
    om/asset-inventory/docs/resource-name-format)\n\x20of\x20a\x20resource\
    \x20of\x20[supported\x20resource\n\x20types](https://cloud.google.com/as\
    set-inventory/docs/supported-asset-types#analyzable_asset_types).\n\n\
    \x0f\n\x07\x04\x1a\x03\0\x02\0\x05\x12\x04\xb3\t\x04\n\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\0\x01\x12\x04\xb3\t\x0b\x1d\n\x0f\n\x07\x04\x1a\x03\0\x02\
    \0\x03\x12\x04\xb3\t\x20!\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x08\x12\x04\
    \xb3\t\"J\n\x12\n\n\x04\x1a\x03\0\x02\0\x08\x9c\x08\0\x12\x04\xb3\t#I\n\
    \xbb\x01\n\x04\x04\x1a\x03\x01\x12\x06\xb9\t\x02\xc7\t\x03\x1a\xaa\x01\
    \x20Specifies\x20an\x20identity\x20for\x20which\x20to\x20determine\x20re\
    source\x20access,\x20based\x20on\n\x20roles\x20assigned\x20either\x20dir\
    ectly\x20to\x20them\x20or\x20to\x20the\x20groups\x20they\x20belong\x20to\
    ,\n\x20directly\x20or\x20indirectly.\n\n\r\n\x05\x04\x1a\x03\x01\x01\x12\
    \x04\xb9\t\n\x1a\n\xb9\x03\n\x06\x04\x1a\x03\x01\x02\0\x12\x04\xc6\t\x04\
    A\x1a\xa8\x03\x20Required.\x20The\x20identity\x20appear\x20in\x20the\x20\
    form\x20of\x20principals\x20in\n\x20[IAM\x20policy\n\x20binding](https:/\
    /cloud.google.com/iam/reference/rest/v1/Binding).\n\n\x20The\x20examples\
    \x20of\x20supported\x20forms\x20are:\n\x20\"user:mike@example.com\",\n\
    \x20\"group:admins@example.com\",\n\x20\"domain:google.com\",\n\x20\"ser\
    viceAccount:my-project-id@appspot.gserviceaccount.com\".\n\n\x20Notice\
    \x20that\x20wildcard\x20characters\x20(such\x20as\x20*\x20and\x20?)\x20a\
    re\x20not\x20supported.\n\x20You\x20must\x20give\x20a\x20specific\x20ide\
    ntity.\n\n\x0f\n\x07\x04\x1a\x03\x01\x02\0\x05\x12\x04\xc6\t\x04\n\n\x0f\
    \n\x07\x04\x1a\x03\x01\x02\0\x01\x12\x04\xc6\t\x0b\x13\n\x0f\n\x07\x04\
    \x1a\x03\x01\x02\0\x03\x12\x04\xc6\t\x16\x17\n\x0f\n\x07\x04\x1a\x03\x01\
    \x02\0\x08\x12\x04\xc6\t\x18@\n\x12\n\n\x04\x1a\x03\x01\x02\0\x08\x9c\
    \x08\0\x12\x04\xc6\t\x19?\n\xc3\x02\n\x04\x04\x1a\x03\x02\x12\x06\xce\t\
    \x02\xd4\t\x03\x1a\xb2\x02\x20Specifies\x20roles\x20and/or\x20permission\
    s\x20to\x20analyze,\x20to\x20determine\x20both\x20the\n\x20identities\
    \x20possessing\x20them\x20and\x20the\x20resources\x20they\x20control.\
    \x20If\x20multiple\n\x20values\x20are\x20specified,\x20results\x20will\
    \x20include\x20roles\x20or\x20permissions\x20matching\n\x20any\x20of\x20\
    them.\x20The\x20total\x20number\x20of\x20roles\x20and\x20permissions\x20\
    should\x20be\x20equal\x20or\n\x20less\x20than\x2010.\n\n\r\n\x05\x04\x1a\
    \x03\x02\x01\x12\x04\xce\t\n\x18\n:\n\x06\x04\x1a\x03\x02\x02\0\x12\x04\
    \xd0\t\x04G\x1a*\x20Optional.\x20The\x20roles\x20to\x20appear\x20in\x20r\
    esult.\n\n\x0f\n\x07\x04\x1a\x03\x02\x02\0\x04\x12\x04\xd0\t\x04\x0c\n\
    \x0f\n\x07\x04\x1a\x03\x02\x02\0\x05\x12\x04\xd0\t\r\x13\n\x0f\n\x07\x04\
    \x1a\x03\x02\x02\0\x01\x12\x04\xd0\t\x14\x19\n\x0f\n\x07\x04\x1a\x03\x02\
    \x02\0\x03\x12\x04\xd0\t\x1c\x1d\n\x0f\n\x07\x04\x1a\x03\x02\x02\0\x08\
    \x12\x04\xd0\t\x1eF\n\x12\n\n\x04\x1a\x03\x02\x02\0\x08\x9c\x08\0\x12\
    \x04\xd0\t\x1fE\n@\n\x06\x04\x1a\x03\x02\x02\x01\x12\x04\xd3\t\x04M\x1a0\
    \x20Optional.\x20The\x20permissions\x20to\x20appear\x20in\x20result.\n\n\
    \x0f\n\x07\x04\x1a\x03\x02\x02\x01\x04\x12\x04\xd3\t\x04\x0c\n\x0f\n\x07\
    \x04\x1a\x03\x02\x02\x01\x05\x12\x04\xd3\t\r\x13\n\x0f\n\x07\x04\x1a\x03\
    \x02\x02\x01\x01\x12\x04\xd3\t\x14\x1f\n\x0f\n\x07\x04\x1a\x03\x02\x02\
    \x01\x03\x12\x04\xd3\t\"#\n\x0f\n\x07\x04\x1a\x03\x02\x02\x01\x08\x12\
    \x04\xd3\t$L\n\x12\n\n\x04\x1a\x03\x02\x02\x01\x08\x9c\x08\0\x12\x04\xd3\
    \t%K\n)\n\x04\x04\x1a\x03\x03\x12\x06\xd7\t\x02\xbc\n\x03\x1a\x19\x20Con\
    tains\x20query\x20options.\n\n\r\n\x05\x04\x1a\x03\x03\x01\x12\x04\xd7\t\
    \n\x11\n\xe4\x03\n\x06\x04\x1a\x03\x03\x02\0\x12\x04\xe4\t\x04D\x1a\xd3\
    \x03\x20Optional.\x20If\x20true,\x20the\x20identities\x20section\x20of\
    \x20the\x20result\x20will\x20expand\x20any\n\x20Google\x20groups\x20appe\
    aring\x20in\x20an\x20IAM\x20policy\x20binding.\n\n\x20If\n\x20[IamPolicy\
    AnalysisQuery.identity_selector][google.cloud.asset.v1.IamPolicyAnalysis\
    Query.identity_selector]\n\x20is\x20specified,\x20the\x20identity\x20in\
    \x20the\x20result\x20will\x20be\x20determined\x20by\x20the\n\x20selector\
    ,\x20and\x20this\x20flag\x20is\x20not\x20allowed\x20to\x20set.\n\n\x20If\
    \x20true,\x20the\x20default\x20max\x20expansion\x20per\x20group\x20is\
    \x201000\x20for\n\x20AssetService.AnalyzeIamPolicy][].\n\n\x20Default\
    \x20is\x20false.\n\n\x0f\n\x07\x04\x1a\x03\x03\x02\0\x05\x12\x04\xe4\t\
    \x04\x08\n\x0f\n\x07\x04\x1a\x03\x03\x02\0\x01\x12\x04\xe4\t\t\x16\n\x0f\
    \n\x07\x04\x1a\x03\x03\x02\0\x03\x12\x04\xe4\t\x19\x1a\n\x0f\n\x07\x04\
    \x1a\x03\x03\x02\0\x08\x12\x04\xe4\t\x1bC\n\x12\n\n\x04\x1a\x03\x03\x02\
    \0\x08\x9c\x08\0\x12\x04\xe4\t\x1cB\n\x93\x03\n\x06\x04\x1a\x03\x03\x02\
    \x01\x12\x04\xef\t\x04C\x1a\x82\x03\x20Optional.\x20If\x20true,\x20the\
    \x20access\x20section\x20of\x20result\x20will\x20expand\x20any\x20roles\
    \n\x20appearing\x20in\x20IAM\x20policy\x20bindings\x20to\x20include\x20t\
    heir\x20permissions.\n\n\x20If\n\x20[IamPolicyAnalysisQuery.access_selec\
    tor][google.cloud.asset.v1.IamPolicyAnalysisQuery.access_selector]\n\x20\
    is\x20specified,\x20the\x20access\x20section\x20of\x20the\x20result\x20w\
    ill\x20be\x20determined\x20by\x20the\n\x20selector,\x20and\x20this\x20fl\
    ag\x20is\x20not\x20allowed\x20to\x20set.\n\n\x20Default\x20is\x20false.\
    \n\n\x0f\n\x07\x04\x1a\x03\x03\x02\x01\x05\x12\x04\xef\t\x04\x08\n\x0f\n\
    \x07\x04\x1a\x03\x03\x02\x01\x01\x12\x04\xef\t\t\x15\n\x0f\n\x07\x04\x1a\
    \x03\x03\x02\x01\x03\x12\x04\xef\t\x18\x19\n\x0f\n\x07\x04\x1a\x03\x03\
    \x02\x01\x08\x12\x04\xef\t\x1aB\n\x12\n\n\x04\x1a\x03\x03\x02\x01\x08\
    \x9c\x08\0\x12\x04\xef\t\x1bA\n\xb0\n\n\x06\x04\x1a\x03\x03\x02\x02\x12\
    \x04\x8c\n\x04G\x1a\x9f\n\x20Optional.\x20If\x20true\x20and\n\x20[IamPol\
    icyAnalysisQuery.resource_selector][google.cloud.asset.v1.IamPolicyAnaly\
    sisQuery.resource_selector]\n\x20is\x20not\x20specified,\x20the\x20resou\
    rce\x20section\x20of\x20the\x20result\x20will\x20expand\x20any\n\x20reso\
    urce\x20attached\x20to\x20an\x20IAM\x20policy\x20to\x20include\x20resour\
    ces\x20lower\x20in\x20the\n\x20resource\x20hierarchy.\n\n\x20For\x20exam\
    ple,\x20if\x20the\x20request\x20analyzes\x20for\x20which\x20resources\
    \x20user\x20A\x20has\n\x20permission\x20P,\x20and\x20the\x20results\x20i\
    nclude\x20an\x20IAM\x20policy\x20with\x20P\x20on\x20a\x20Google\n\x20Clo\
    ud\x20folder,\x20the\x20results\x20will\x20also\x20include\x20resources\
    \x20in\x20that\x20folder\x20with\n\x20permission\x20P.\n\n\x20If\x20true\
    \x20and\n\x20[IamPolicyAnalysisQuery.resource_selector][google.cloud.ass\
    et.v1.IamPolicyAnalysisQuery.resource_selector]\n\x20is\x20specified,\
    \x20the\x20resource\x20section\x20of\x20the\x20result\x20will\x20expand\
    \x20the\n\x20specified\x20resource\x20to\x20include\x20resources\x20lowe\
    r\x20in\x20the\x20resource\x20hierarchy.\n\x20Only\x20project\x20or\x20l\
    ower\x20resources\x20are\x20supported.\x20Folder\x20and\x20organization\
    \n\x20resources\x20cannot\x20be\x20used\x20together\x20with\x20this\x20o\
    ption.\n\n\x20For\x20example,\x20if\x20the\x20request\x20analyzes\x20for\
    \x20which\x20users\x20have\x20permission\x20P\x20on\n\x20a\x20Google\x20\
    Cloud\x20project\x20with\x20this\x20option\x20enabled,\x20the\x20results\
    \x20will\x20include\n\x20all\x20users\x20who\x20have\x20permission\x20P\
    \x20on\x20that\x20project\x20or\x20any\x20lower\x20resource.\n\n\x20If\
    \x20true,\x20the\x20default\x20max\x20expansion\x20per\x20resource\x20is\
    \x201000\x20for\n\x20AssetService.AnalyzeIamPolicy][]\x20and\x20100000\
    \x20for\n\x20AssetService.AnalyzeIamPolicyLongrunning][].\n\n\x20Default\
    \x20is\x20false.\n\n\x0f\n\x07\x04\x1a\x03\x03\x02\x02\x05\x12\x04\x8c\n\
    \x04\x08\n\x0f\n\x07\x04\x1a\x03\x03\x02\x02\x01\x12\x04\x8c\n\t\x19\n\
    \x0f\n\x07\x04\x1a\x03\x03\x02\x02\x03\x12\x04\x8c\n\x1c\x1d\n\x0f\n\x07\
    \x04\x1a\x03\x03\x02\x02\x08\x12\x04\x8c\n\x1eF\n\x12\n\n\x04\x1a\x03\
    \x03\x02\x02\x08\x9c\x08\0\x12\x04\x8c\n\x1fE\n\x89\x01\n\x06\x04\x1a\
    \x03\x03\x02\x03\x12\x04\x90\n\x04L\x1ay\x20Optional.\x20If\x20true,\x20\
    the\x20result\x20will\x20output\x20the\x20relevant\x20parent/child\n\x20\
    relationships\x20between\x20resources.\x20Default\x20is\x20false.\n\n\
    \x0f\n\x07\x04\x1a\x03\x03\x02\x03\x05\x12\x04\x90\n\x04\x08\n\x0f\n\x07\
    \x04\x1a\x03\x03\x02\x03\x01\x12\x04\x90\n\t\x1e\n\x0f\n\x07\x04\x1a\x03\
    \x03\x02\x03\x03\x12\x04\x90\n!\"\n\x0f\n\x07\x04\x1a\x03\x03\x02\x03\
    \x08\x12\x04\x90\n#K\n\x12\n\n\x04\x1a\x03\x03\x02\x03\x08\x9c\x08\0\x12\
    \x04\x90\n$J\n\xba\x01\n\x06\x04\x1a\x03\x03\x02\x04\x12\x04\x95\n\x04I\
    \x1a\xa9\x01\x20Optional.\x20If\x20true,\x20the\x20result\x20will\x20out\
    put\x20the\x20relevant\x20membership\n\x20relationships\x20between\x20gr\
    oups\x20and\x20other\x20groups,\x20and\x20between\x20groups\x20and\n\x20\
    principals.\x20Default\x20is\x20false.\n\n\x0f\n\x07\x04\x1a\x03\x03\x02\
    \x04\x05\x12\x04\x95\n\x04\x08\n\x0f\n\x07\x04\x1a\x03\x03\x02\x04\x01\
    \x12\x04\x95\n\t\x1b\n\x0f\n\x07\x04\x1a\x03\x03\x02\x04\x03\x12\x04\x95\
    \n\x1e\x1f\n\x0f\n\x07\x04\x1a\x03\x03\x02\x04\x08\x12\x04\x95\n\x20H\n\
    \x12\n\n\x04\x1a\x03\x03\x02\x04\x08\x9c\x08\0\x12\x04\x95\n!G\n\xc5\x0e\
    \n\x06\x04\x1a\x03\x03\x02\x05\x12\x06\xba\n\x04\xbb\n1\x1a\xb2\x0e\x20O\
    ptional.\x20If\x20true,\x20the\x20response\x20will\x20include\x20access\
    \x20analysis\x20from\n\x20identities\x20to\x20resources\x20via\x20servic\
    e\x20account\x20impersonation.\x20This\x20is\x20a\x20very\n\x20expensive\
    \x20operation,\x20because\x20many\x20derived\x20queries\x20will\x20be\
    \x20executed.\x20We\n\x20highly\x20recommend\x20you\x20use\n\x20[AssetSe\
    rvice.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.An\
    alyzeIamPolicyLongrunning]\n\x20RPC\x20instead.\n\n\x20For\x20example,\
    \x20if\x20the\x20request\x20analyzes\x20for\x20which\x20resources\x20use\
    r\x20A\x20has\n\x20permission\x20P,\x20and\x20there's\x20an\x20IAM\x20po\
    licy\x20states\x20user\x20A\x20has\n\x20iam.serviceAccounts.getAccessTok\
    en\x20permission\x20to\x20a\x20service\x20account\x20SA,\n\x20and\x20the\
    re's\x20another\x20IAM\x20policy\x20states\x20service\x20account\x20SA\
    \x20has\x20permission\x20P\n\x20to\x20a\x20Google\x20Cloud\x20folder\x20\
    F,\x20then\x20user\x20A\x20potentially\x20has\x20access\x20to\x20the\n\
    \x20Google\x20Cloud\x20folder\x20F.\x20And\x20those\x20advanced\x20analy\
    sis\x20results\x20will\x20be\n\x20included\x20in\n\x20[AnalyzeIamPolicyR\
    esponse.service_account_impersonation_analysis][google.cloud.asset.v1.An\
    alyzeIamPolicyResponse.service_account_impersonation_analysis].\n\n\x20A\
    nother\x20example,\x20if\x20the\x20request\x20analyzes\x20for\x20who\x20\
    has\n\x20permission\x20P\x20to\x20a\x20Google\x20Cloud\x20folder\x20F,\
    \x20and\x20there's\x20an\x20IAM\x20policy\x20states\n\x20user\x20A\x20ha\
    s\x20iam.serviceAccounts.actAs\x20permission\x20to\x20a\x20service\x20ac\
    count\x20SA,\n\x20and\x20there's\x20another\x20IAM\x20policy\x20states\
    \x20service\x20account\x20SA\x20has\x20permission\x20P\n\x20to\x20the\
    \x20Google\x20Cloud\x20folder\x20F,\x20then\x20user\x20A\x20potentially\
    \x20has\x20access\x20to\x20the\n\x20Google\x20Cloud\x20folder\x20F.\x20A\
    nd\x20those\x20advanced\x20analysis\x20results\x20will\x20be\n\x20includ\
    ed\x20in\n\x20[AnalyzeIamPolicyResponse.service_account_impersonation_an\
    alysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_i\
    mpersonation_analysis].\n\n\x20Only\x20the\x20following\x20permissions\
    \x20are\x20considered\x20in\x20this\x20analysis:\n\n\x20*\x20`iam.servic\
    eAccounts.actAs`\n\x20*\x20`iam.serviceAccounts.signBlob`\n\x20*\x20`iam\
    .serviceAccounts.signJwt`\n\x20*\x20`iam.serviceAccounts.getAccessToken`\
    \n\x20*\x20`iam.serviceAccounts.getOpenIdToken`\n\x20*\x20`iam.serviceAc\
    counts.implicitDelegation`\n\n\x20Default\x20is\x20false.\n\n\x0f\n\x07\
    \x04\x1a\x03\x03\x02\x05\x05\x12\x04\xba\n\x04\x08\n\x0f\n\x07\x04\x1a\
    \x03\x03\x02\x05\x01\x12\x04\xba\n\t.\n\x0f\n\x07\x04\x1a\x03\x03\x02\
    \x05\x03\x12\x04\xba\n12\n\x0f\n\x07\x04\x1a\x03\x03\x02\x05\x08\x12\x04\
    \xbb\n\x080\n\x12\n\n\x04\x1a\x03\x03\x02\x05\x08\x9c\x08\0\x12\x04\xbb\
    \n\t/\n-\n\x04\x04\x1a\x03\x04\x12\x06\xbf\n\x02\xc7\n\x03\x1a\x1d\x20Th\
    e\x20IAM\x20conditions\x20context.\n\n\r\n\x05\x04\x1a\x03\x04\x01\x12\
    \x04\xbf\n\n\x1a\n4\n\x06\x04\x1a\x03\x04\x08\0\x12\x06\xc1\n\x04\xc6\n\
    \x05\x1a\"\x20The\x20IAM\x20conditions\x20time\x20context.\n\n\x0f\n\x07\
    \x04\x1a\x03\x04\x08\0\x01\x12\x04\xc1\n\n\x15\n\xc9\x01\n\x06\x04\x1a\
    \x03\x04\x02\0\x12\x04\xc5\n\x060\x1a\xb8\x01\x20The\x20hypothetical\x20\
    access\x20timestamp\x20to\x20evaluate\x20IAM\x20conditions.\x20Note\x20t\
    hat\n\x20this\x20value\x20must\x20not\x20be\x20earlier\x20than\x20the\
    \x20current\x20time;\x20otherwise,\x20an\n\x20INVALID_ARGUMENT\x20error\
    \x20will\x20be\x20returned.\n\n\x0f\n\x07\x04\x1a\x03\x04\x02\0\x06\x12\
    \x04\xc5\n\x06\x1f\n\x0f\n\x07\x04\x1a\x03\x04\x02\0\x01\x12\x04\xc5\n\
    \x20+\n\x0f\n\x07\x04\x1a\x03\x04\x02\0\x03\x12\x04\xc5\n./\n\xaa\x05\n\
    \x04\x04\x1a\x02\0\x12\x04\xd5\n\x02<\x1a\x9b\x05\x20Required.\x20The\
    \x20relative\x20name\x20of\x20the\x20root\x20asset.\x20Only\x20resources\
    \x20and\x20IAM\n\x20policies\x20within\x20the\x20scope\x20will\x20be\x20\
    analyzed.\n\n\x20This\x20can\x20only\x20be\x20an\x20organization\x20numb\
    er\x20(such\x20as\x20\"organizations/123\"),\x20a\n\x20folder\x20number\
    \x20(such\x20as\x20\"folders/123\"),\x20a\x20project\x20ID\x20(such\x20a\
    s\n\x20\"projects/my-project-id\"),\x20or\x20a\x20project\x20number\x20(\
    such\x20as\x20\"projects/12345\").\n\n\x20To\x20know\x20how\x20to\x20get\
    \x20organization\x20id,\x20visit\x20[here\n\x20](https://cloud.google.co\
    m/resource-manager/docs/creating-managing-organization#retrieving_your_o\
    rganization_id).\n\n\x20To\x20know\x20how\x20to\x20get\x20folder\x20or\
    \x20project\x20id,\x20visit\x20[here\n\x20](https://cloud.google.com/res\
    ource-manager/docs/creating-managing-folders#viewing_or_listing_folders_\
    and_projects).\n\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xd5\n\x02\x08\n\r\n\
    \x05\x04\x1a\x02\0\x01\x12\x04\xd5\n\t\x0e\n\r\n\x05\x04\x1a\x02\0\x03\
    \x12\x04\xd5\n\x11\x12\n\r\n\x05\x04\x1a\x02\0\x08\x12\x04\xd5\n\x13;\n\
    \x10\n\x08\x04\x1a\x02\0\x08\x9c\x08\0\x12\x04\xd5\n\x14:\n>\n\x04\x04\
    \x1a\x02\x01\x12\x06\xd8\n\x02\xd9\n/\x1a.\x20Optional.\x20Specifies\x20\
    a\x20resource\x20for\x20analysis.\n\n\r\n\x05\x04\x1a\x02\x01\x06\x12\
    \x04\xd8\n\x02\x12\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xd8\n\x13$\n\r\
    \n\x05\x04\x1a\x02\x01\x03\x12\x04\xd8\n'(\n\r\n\x05\x04\x1a\x02\x01\x08\
    \x12\x04\xd9\n\x06.\n\x10\n\x08\x04\x1a\x02\x01\x08\x9c\x08\0\x12\x04\
    \xd9\n\x07-\n?\n\x04\x04\x1a\x02\x02\x12\x06\xdc\n\x02\xdd\n/\x1a/\x20Op\
    tional.\x20Specifies\x20an\x20identity\x20for\x20analysis.\n\n\r\n\x05\
    \x04\x1a\x02\x02\x06\x12\x04\xdc\n\x02\x12\n\r\n\x05\x04\x1a\x02\x02\x01\
    \x12\x04\xdc\n\x13$\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xdc\n'(\n\r\n\
    \x05\x04\x1a\x02\x02\x08\x12\x04\xdd\n\x06.\n\x10\n\x08\x04\x1a\x02\x02\
    \x08\x9c\x08\0\x12\x04\xdd\n\x07-\nX\n\x04\x04\x1a\x02\x03\x12\x04\xe0\n\
    \x02N\x1aJ\x20Optional.\x20Specifies\x20roles\x20or\x20permissions\x20fo\
    r\x20analysis.\x20This\x20is\x20optional.\n\n\r\n\x05\x04\x1a\x02\x03\
    \x06\x12\x04\xe0\n\x02\x10\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xe0\n\
    \x11\x20\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xe0\n#$\n\r\n\x05\x04\x1a\
    \x02\x03\x08\x12\x04\xe0\n%M\n\x10\n\x08\x04\x1a\x02\x03\x08\x9c\x08\0\
    \x12\x04\xe0\n&L\n,\n\x04\x04\x1a\x02\x04\x12\x04\xe3\n\x02?\x1a\x1e\x20\
    Optional.\x20The\x20query\x20options.\n\n\r\n\x05\x04\x1a\x02\x04\x06\
    \x12\x04\xe3\n\x02\t\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xe3\n\n\x11\n\
    \r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xe3\n\x14\x15\n\r\n\x05\x04\x1a\x02\
    \x04\x08\x12\x04\xe3\n\x16>\n\x10\n\x08\x04\x1a\x02\x04\x08\x9c\x08\0\
    \x12\x04\xe3\n\x17=\nS\n\x04\x04\x1a\x02\x05\x12\x06\xe6\n\x02\xe7\n/\
    \x1aC\x20Optional.\x20The\x20hypothetical\x20context\x20for\x20IAM\x20co\
    nditions\x20evaluation.\n\n\r\n\x05\x04\x1a\x02\x05\x06\x12\x04\xe6\n\
    \x02\x12\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xe6\n\x13$\n\r\n\x05\x04\
    \x1a\x02\x05\x03\x12\x04\xe6\n'(\n\r\n\x05\x04\x1a\x02\x05\x08\x12\x04\
    \xe7\n\x06.\n\x10\n\x08\x04\x1a\x02\x05\x08\x9c\x08\0\x12\x04\xe7\n\x07-\
    \n|\n\x02\x04\x1b\x12\x06\xec\n\0\x90\x0b\x01\x1an\x20A\x20request\x20me\
    ssage\x20for\n\x20[AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.\
    AssetService.AnalyzeIamPolicy].\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xec\n\
    \x08\x1f\n.\n\x04\x04\x1b\x02\0\x12\x06\xee\n\x02\xef\n/\x1a\x1e\x20Requ\
    ired.\x20The\x20request\x20query.\n\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\
    \xee\n\x02\x18\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xee\n\x19'\n\r\n\x05\
    \x04\x1b\x02\0\x03\x12\x04\xee\n*+\n\r\n\x05\x04\x1b\x02\0\x08\x12\x04\
    \xef\n\x06.\n\x10\n\x08\x04\x1b\x02\0\x08\x9c\x08\0\x12\x04\xef\n\x07-\n\
    \xa4\x06\n\x04\x04\x1b\x02\x01\x12\x04\x81\x0b\x02K\x1a\x95\x06\x20Optio\
    nal.\x20The\x20name\x20of\x20a\x20saved\x20query,\x20which\x20must\x20be\
    \x20in\x20the\x20format\x20of:\n\n\x20*\x20projects/project_number/saved\
    Queries/saved_query_id\n\x20*\x20folders/folder_number/savedQueries/save\
    d_query_id\n\x20*\x20organizations/organization_number/savedQueries/save\
    d_query_id\n\n\x20If\x20both\x20`analysis_query`\x20and\x20`saved_analys\
    is_query`\x20are\x20provided,\x20they\n\x20will\x20be\x20merged\x20toget\
    her\x20with\x20the\x20`saved_analysis_query`\x20as\x20base\x20and\n\x20t\
    he\x20`analysis_query`\x20as\x20overrides.\x20For\x20more\x20details\x20\
    of\x20the\x20merge\x20behavior,\n\x20please\x20refer\x20to\x20the\n\x20[\
    MergeFrom](https://developers.google.com/protocol-buffers/docs/reference\
    /cpp/google.protobuf.message#Message.MergeFrom.details)\n\x20page.\n\n\
    \x20Note\x20that\x20you\x20cannot\x20override\x20primitive\x20fields\x20\
    with\x20default\x20value,\x20such\x20as\n\x200\x20or\x20empty\x20string,\
    \x20etc.,\x20because\x20we\x20use\x20proto3,\x20which\x20doesn't\x20supp\
    ort\x20field\n\x20presence\x20yet.\n\n\r\n\x05\x04\x1b\x02\x01\x05\x12\
    \x04\x81\x0b\x02\x08\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\x81\x0b\t\x1d\
    \n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\x81\x0b\x20!\n\r\n\x05\x04\x1b\
    \x02\x01\x08\x12\x04\x81\x0b\"J\n\x10\n\x08\x04\x1b\x02\x01\x08\x9c\x08\
    \0\x12\x04\x81\x0b#I\n\x9e\x04\n\x04\x04\x1b\x02\x02\x12\x06\x8e\x0b\x02\
    \x8f\x0b/\x1a\x8d\x04\x20Optional.\x20Amount\x20of\x20time\x20executable\
    \x20has\x20to\x20complete.\x20\x20See\x20JSON\n\x20representation\x20of\
    \n\x20[Duration](https://developers.google.com/protocol-buffers/docs/pro\
    to3#json).\n\n\x20If\x20this\x20field\x20is\x20set\x20with\x20a\x20value\
    \x20less\x20than\x20the\x20RPC\x20deadline,\x20and\x20the\n\x20execution\
    \x20of\x20your\x20query\x20hasn't\x20finished\x20in\x20the\x20specified\
    \n\x20execution\x20timeout,\x20\x20you\x20will\x20get\x20a\x20response\
    \x20with\x20partial\x20result.\n\x20Otherwise,\x20your\x20query's\x20exe\
    cution\x20will\x20continue\x20until\x20the\x20RPC\x20deadline.\n\x20If\
    \x20it's\x20not\x20finished\x20until\x20then,\x20you\x20will\x20get\x20a\
    \x20\x20DEADLINE_EXCEEDED\x20error.\n\n\x20Default\x20is\x20empty.\n\n\r\
    \n\x05\x04\x1b\x02\x02\x06\x12\x04\x8e\x0b\x02\x1a\n\r\n\x05\x04\x1b\x02\
    \x02\x01\x12\x04\x8e\x0b\x1b,\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\x8e\
    \x0b/0\n\r\n\x05\x04\x1b\x02\x02\x08\x12\x04\x8f\x0b\x06.\n\x10\n\x08\
    \x04\x1b\x02\x02\x08\x9c\x08\0\x12\x04\x8f\x0b\x07-\n}\n\x02\x04\x1c\x12\
    \x06\x94\x0b\0\xb6\x0b\x01\x1ao\x20A\x20response\x20message\x20for\n\x20\
    [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.Analy\
    zeIamPolicy].\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\x94\x0b\x08\x20\nE\n\x04\
    \x04\x1c\x03\0\x12\x06\x96\x0b\x02\xa6\x0b\x03\x1a5\x20An\x20analysis\
    \x20message\x20to\x20group\x20the\x20query\x20and\x20results.\n\n\r\n\
    \x05\x04\x1c\x03\0\x01\x12\x04\x96\x0b\n\x1b\n%\n\x06\x04\x1c\x03\0\x02\
    \0\x12\x04\x98\x0b\x04.\x1a\x15\x20The\x20analysis\x20query.\n\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\0\x06\x12\x04\x98\x0b\x04\x1a\n\x0f\n\x07\x04\x1c\
    \x03\0\x02\0\x01\x12\x04\x98\x0b\x1b)\n\x0f\n\x07\x04\x1c\x03\0\x02\0\
    \x03\x12\x04\x98\x0b,-\n\xa8\x01\n\x06\x04\x1c\x03\0\x02\x01\x12\x04\x9d\
    \x0b\x04:\x1a\x97\x01\x20A\x20list\x20of\n\x20[IamPolicyAnalysisResult][\
    google.cloud.asset.v1.IamPolicyAnalysisResult]\n\x20that\x20matches\x20t\
    he\x20analysis\x20query,\x20or\x20empty\x20if\x20no\x20result\x20is\x20f\
    ound.\n\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\x04\x9d\x0b\x04\x0c\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x01\x06\x12\x04\x9d\x0b\r$\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x01\x01\x12\x04\x9d\x0b%5\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x01\x03\x12\x04\x9d\x0b89\n\xce\x01\n\x06\x04\x1c\x03\0\x02\x02\x12\x04\
    \xa2\x0b\x04\x1c\x1a\xbd\x01\x20Represents\x20whether\x20all\x20entries\
    \x20in\x20the\n\x20[analysis_results][google.cloud.asset.v1.AnalyzeIamPo\
    licyResponse.IamPolicyAnalysis.analysis_results]\n\x20have\x20been\x20fu\
    lly\x20explored\x20to\x20answer\x20the\x20query.\n\n\x0f\n\x07\x04\x1c\
    \x03\0\x02\x02\x05\x12\x04\xa2\x0b\x04\x08\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x02\x01\x12\x04\xa2\x0b\t\x17\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x03\x12\
    \x04\xa2\x0b\x1a\x1b\nS\n\x06\x04\x1c\x03\0\x02\x03\x12\x04\xa5\x0b\x04<\
    \x1aC\x20A\x20list\x20of\x20non-critical\x20errors\x20happened\x20during\
    \x20the\x20query\x20handling.\n\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x04\
    \x12\x04\xa5\x0b\x04\x0c\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x06\x12\x04\
    \xa5\x0b\r#\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x01\x12\x04\xa5\x0b$7\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x03\x03\x12\x04\xa5\x0b:;\nD\n\x04\x04\x1c\
    \x02\0\x12\x04\xa9\x0b\x02&\x1a6\x20The\x20main\x20analysis\x20that\x20m\
    atches\x20the\x20original\x20request.\n\n\r\n\x05\x04\x1c\x02\0\x06\x12\
    \x04\xa9\x0b\x02\x13\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xa9\x0b\x14!\n\
    \r\n\x05\x04\x1c\x02\0\x03\x12\x04\xa9\x0b$%\n\x8d\x01\n\x04\x04\x1c\x02\
    \x01\x12\x04\xae\x0b\x02H\x1a\x7f\x20The\x20service\x20account\x20impers\
    onation\x20analysis\x20if\n\x20[AnalyzeIamPolicyRequest.analyze_service_\
    account_impersonation][]\x20is\n\x20enabled.\n\n\r\n\x05\x04\x1c\x02\x01\
    \x04\x12\x04\xae\x0b\x02\n\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xae\x0b\
    \x0b\x1c\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xae\x0b\x1dC\n\r\n\x05\
    \x04\x1c\x02\x01\x03\x12\x04\xae\x0bFG\n\xc9\x02\n\x04\x04\x1c\x02\x02\
    \x12\x04\xb5\x0b\x02\x1a\x1a\xba\x02\x20Represents\x20whether\x20all\x20\
    entries\x20in\x20the\n\x20[main_analysis][google.cloud.asset.v1.AnalyzeI\
    amPolicyResponse.main_analysis]\n\x20and\n\x20[service_account_impersona\
    tion_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_ac\
    count_impersonation_analysis]\n\x20have\x20been\x20fully\x20explored\x20\
    to\x20answer\x20the\x20query\x20in\x20the\x20request.\n\n\r\n\x05\x04\
    \x1c\x02\x02\x05\x12\x04\xb5\x0b\x02\x06\n\r\n\x05\x04\x1c\x02\x02\x01\
    \x12\x04\xb5\x0b\x07\x15\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xb5\x0b\
    \x18\x19\nP\n\x02\x04\x1d\x12\x06\xb9\x0b\0\x84\x0c\x01\x1aB\x20Output\
    \x20configuration\x20for\x20export\x20IAM\x20policy\x20analysis\x20desti\
    nation.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xb9\x0b\x08%\n+\n\x04\x04\x1d\
    \x03\0\x12\x06\xbb\x0b\x02\xc6\x0b\x03\x1a\x1b\x20A\x20Cloud\x20Storage\
    \x20location.\n\n\r\n\x05\x04\x1d\x03\0\x01\x12\x04\xbb\x0b\n\x18\n\xce\
    \x03\n\x06\x04\x1d\x03\0\x02\0\x12\x04\xc5\x0b\x04<\x1a\xbd\x03\x20Requi\
    red.\x20The\x20URI\x20of\x20the\x20Cloud\x20Storage\x20object.\x20It's\
    \x20the\x20same\x20URI\x20that\x20is\n\x20used\x20by\x20gsutil.\x20Examp\
    le:\x20\"gs://bucket_name/object_name\".\x20See\x20[Viewing\x20and\n\x20\
    Editing\x20Object\n\x20Metadata](https://cloud.google.com/storage/docs/v\
    iewing-editing-metadata)\n\x20for\x20more\x20information.\n\n\x20If\x20t\
    he\x20specified\x20Cloud\x20Storage\x20object\x20already\x20exists\x20an\
    d\x20there\x20is\x20no\n\x20[hold](https://cloud.google.com/storage/docs\
    /object-holds),\x20it\x20will\x20be\n\x20overwritten\x20with\x20the\x20a\
    nalysis\x20result.\n\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\xc5\x0b\
    \x04\n\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x01\x12\x04\xc5\x0b\x0b\x0e\n\x0f\
    \n\x07\x04\x1d\x03\0\x02\0\x03\x12\x04\xc5\x0b\x11\x12\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\0\x08\x12\x04\xc5\x0b\x13;\n\x12\n\n\x04\x1d\x03\0\x02\0\
    \x08\x9c\x08\0\x12\x04\xc5\x0b\x14:\n)\n\x04\x04\x1d\x03\x01\x12\x06\xc9\
    \x0b\x02\xfa\x0b\x03\x1a\x19\x20A\x20BigQuery\x20destination.\n\n\r\n\
    \x05\x04\x1d\x03\x01\x01\x12\x04\xc9\x0b\n\x1d\n\x88\x02\n\x06\x04\x1d\
    \x03\x01\x04\0\x12\x06\xce\x0b\x04\xd7\x0b\x05\x1a\xf5\x01\x20This\x20en\
    um\x20determines\x20the\x20partition\x20key\x20column\x20for\x20the\x20b\
    igquery\x20tables.\n\x20Partitioning\x20can\x20improve\x20query\x20perfo\
    rmance\x20and\x20reduce\x20query\x20cost\x20by\n\x20filtering\x20partiti\
    ons.\x20Refer\x20to\n\x20https://cloud.google.com/bigquery/docs/partitio\
    ned-tables\x20for\x20details.\n\n\x0f\n\x07\x04\x1d\x03\x01\x04\0\x01\
    \x12\x04\xce\x0b\t\x15\n^\n\x08\x04\x1d\x03\x01\x04\0\x02\0\x12\x04\xd1\
    \x0b\x06$\x1aL\x20Unspecified\x20partition\x20key.\x20Tables\x20won't\
    \x20be\x20partitioned\x20using\x20this\n\x20option.\n\n\x11\n\t\x04\x1d\
    \x03\x01\x04\0\x02\0\x01\x12\x04\xd1\x0b\x06\x1f\n\x11\n\t\x04\x1d\x03\
    \x01\x04\0\x02\0\x02\x12\x04\xd1\x0b\"#\n\xe4\x01\n\x08\x04\x1d\x03\x01\
    \x04\0\x02\x01\x12\x04\xd6\x0b\x06\x17\x1a\xd1\x01\x20The\x20time\x20whe\
    n\x20the\x20request\x20is\x20received.\x20If\x20specified\x20as\x20parti\
    tion\x20key,\n\x20the\x20result\x20table(s)\x20is\x20partitoned\x20by\
    \x20the\x20RequestTime\x20column,\x20an\n\x20additional\x20timestamp\x20\
    column\x20representing\x20when\x20the\x20request\x20was\x20received.\n\n\
    \x11\n\t\x04\x1d\x03\x01\x04\0\x02\x01\x01\x12\x04\xd6\x0b\x06\x12\n\x11\
    \n\t\x04\x1d\x03\x01\x04\0\x02\x01\x02\x12\x04\xd6\x0b\x15\x16\n\xf0\x01\
    \n\x06\x04\x1d\x03\x01\x02\0\x12\x04\xdd\x0b\x04@\x1a\xdf\x01\x20Require\
    d.\x20The\x20BigQuery\x20dataset\x20in\x20format\n\x20\"projects/project\
    Id/datasets/datasetId\",\x20to\x20which\x20the\x20analysis\x20results\n\
    \x20should\x20be\x20exported.\x20If\x20this\x20dataset\x20does\x20not\
    \x20exist,\x20the\x20export\x20call\x20will\n\x20return\x20an\x20INVALID\
    _ARGUMENT\x20error.\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\0\x05\x12\x04\xdd\
    \x0b\x04\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\0\x01\x12\x04\xdd\x0b\x0b\x12\
    \n\x0f\n\x07\x04\x1d\x03\x01\x02\0\x03\x12\x04\xdd\x0b\x15\x16\n\x0f\n\
    \x07\x04\x1d\x03\x01\x02\0\x08\x12\x04\xdd\x0b\x17?\n\x12\n\n\x04\x1d\
    \x03\x01\x02\0\x08\x9c\x08\0\x12\x04\xdd\x0b\x18>\n\xe1\x03\n\x06\x04\
    \x1d\x03\x01\x02\x01\x12\x04\xe7\x0b\x04E\x1a\xd0\x03\x20Required.\x20Th\
    e\x20prefix\x20of\x20the\x20BigQuery\x20tables\x20to\x20which\x20the\x20\
    analysis\x20results\n\x20will\x20be\x20written.\x20Tables\x20will\x20be\
    \x20created\x20based\x20on\x20this\x20table_prefix\x20if\x20not\n\x20exi\
    st:\n\x20*\x20<table_prefix>_analysis\x20table\x20will\x20contain\x20exp\
    ort\x20operation's\x20metadata.\n\x20*\x20<table_prefix>_analysis_result\
    \x20will\x20contain\x20all\x20the\n\x20\x20\x20[IamPolicyAnalysisResult]\
    [google.cloud.asset.v1.IamPolicyAnalysisResult].\n\x20When\x20[partition\
    _key]\x20is\x20specified,\x20both\x20tables\x20will\x20be\x20partitioned\
    \x20based\n\x20on\x20the\x20[partition_key].\n\n\x0f\n\x07\x04\x1d\x03\
    \x01\x02\x01\x05\x12\x04\xe7\x0b\x04\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\
    \x01\x01\x12\x04\xe7\x0b\x0b\x17\n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x03\
    \x12\x04\xe7\x0b\x1a\x1b\n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x08\x12\x04\
    \xe7\x0b\x1cD\n\x12\n\n\x04\x1d\x03\x01\x02\x01\x08\x9c\x08\0\x12\x04\
    \xe7\x0b\x1dC\nC\n\x06\x04\x1d\x03\x01\x02\x02\x12\x04\xea\x0b\x04#\x1a3\
    \x20The\x20partition\x20key\x20for\x20BigQuery\x20partitioned\x20table.\
    \n\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x06\x12\x04\xea\x0b\x04\x10\n\x0f\
    \n\x07\x04\x1d\x03\x01\x02\x02\x01\x12\x04\xea\x0b\x11\x1e\n\x0f\n\x07\
    \x04\x1d\x03\x01\x02\x02\x03\x12\x04\xea\x0b!\"\n\xee\x05\n\x06\x04\x1d\
    \x03\x01\x02\x03\x12\x04\xf9\x0b\x04J\x1a\xdd\x05\x20Optional.\x20Specif\
    ies\x20the\x20action\x20that\x20occurs\x20if\x20the\x20destination\x20ta\
    ble\x20or\n\x20partition\x20already\x20exists.\x20The\x20following\x20va\
    lues\x20are\x20supported:\n\n\x20*\x20WRITE_TRUNCATE:\x20If\x20the\x20ta\
    ble\x20or\x20partition\x20already\x20exists,\x20BigQuery\n\x20overwrites\
    \x20the\x20entire\x20table\x20or\x20all\x20the\x20partitions\x20data.\n\
    \x20*\x20WRITE_APPEND:\x20If\x20the\x20table\x20or\x20partition\x20alrea\
    dy\x20exists,\x20BigQuery\n\x20appends\x20the\x20data\x20to\x20the\x20ta\
    ble\x20or\x20the\x20latest\x20partition.\n\x20*\x20WRITE_EMPTY:\x20If\
    \x20the\x20table\x20already\x20exists\x20and\x20contains\x20data,\x20an\
    \x20error\x20is\n\x20returned.\n\n\x20The\x20default\x20value\x20is\x20W\
    RITE_APPEND.\x20Each\x20action\x20is\x20atomic\x20and\x20only\x20occurs\
    \n\x20if\x20BigQuery\x20is\x20able\x20to\x20complete\x20the\x20job\x20su\
    ccessfully.\x20Details\x20are\x20at\n\x20https://cloud.google.com/bigque\
    ry/docs/loading-data-local#appending_to_or_overwriting_a_table_using_a_l\
    ocal_file.\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\x03\x05\x12\x04\xf9\x0b\x04\
    \n\n\x0f\n\x07\x04\x1d\x03\x01\x02\x03\x01\x12\x04\xf9\x0b\x0b\x1c\n\x0f\
    \n\x07\x04\x1d\x03\x01\x02\x03\x03\x12\x04\xf9\x0b\x1f\x20\n\x0f\n\x07\
    \x04\x1d\x03\x01\x02\x03\x08\x12\x04\xf9\x0b!I\n\x12\n\n\x04\x1d\x03\x01\
    \x02\x03\x08\x9c\x08\0\x12\x04\xf9\x0b\"H\n9\n\x04\x04\x1d\x08\0\x12\x06\
    \xfd\x0b\x02\x83\x0c\x03\x1a)\x20IAM\x20policy\x20analysis\x20export\x20\
    destination.\n\n\r\n\x05\x04\x1d\x08\0\x01\x12\x04\xfd\x0b\x08\x13\n-\n\
    \x04\x04\x1d\x02\0\x12\x04\xff\x0b\x04'\x1a\x1f\x20Destination\x20on\x20\
    Cloud\x20Storage.\n\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xff\x0b\x04\x12\
    \n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xff\x0b\x13\"\n\r\n\x05\x04\x1d\x02\
    \0\x03\x12\x04\xff\x0b%&\n(\n\x04\x04\x1d\x02\x01\x12\x04\x82\x0c\x041\
    \x1a\x1a\x20Destination\x20on\x20BigQuery.\n\n\r\n\x05\x04\x1d\x02\x01\
    \x06\x12\x04\x82\x0c\x04\x17\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\x82\
    \x0c\x18,\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\x82\x0c/0\n\x93\x01\n\
    \x02\x04\x1e\x12\x06\x88\x0c\0\xa3\x0c\x01\x1a\x84\x01\x20A\x20request\
    \x20message\x20for\n\x20[AssetService.AnalyzeIamPolicyLongrunning][googl\
    e.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning].\n\n\x0b\n\
    \x03\x04\x1e\x01\x12\x04\x88\x0c\x08*\n.\n\x04\x04\x1e\x02\0\x12\x06\x8a\
    \x0c\x02\x8b\x0c/\x1a\x1e\x20Required.\x20The\x20request\x20query.\n\n\r\
    \n\x05\x04\x1e\x02\0\x06\x12\x04\x8a\x0c\x02\x18\n\r\n\x05\x04\x1e\x02\0\
    \x01\x12\x04\x8a\x0c\x19'\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x8a\x0c*+\
    \n\r\n\x05\x04\x1e\x02\0\x08\x12\x04\x8b\x0c\x06.\n\x10\n\x08\x04\x1e\
    \x02\0\x08\x9c\x08\0\x12\x04\x8b\x0c\x07-\n\xa3\x06\n\x04\x04\x1e\x02\
    \x01\x12\x04\x9d\x0c\x02K\x1a\x94\x06\x20Optional.\x20The\x20name\x20of\
    \x20a\x20saved\x20query,\x20which\x20must\x20be\x20in\x20the\x20format\
    \x20of:\n\n\x20*\x20projects/project_number/savedQueries/saved_query_id\
    \n\x20*\x20folders/folder_number/savedQueries/saved_query_id\n\x20*\x20o\
    rganizations/organization_number/savedQueries/saved_query_id\n\n\x20If\
    \x20both\x20`analysis_query`\x20and\x20`saved_analysis_query`\x20are\x20\
    provided,\x20they\n\x20will\x20be\x20merged\x20together\x20with\x20the\
    \x20`saved_analysis_query`\x20as\x20base\x20and\n\x20the\x20`analysis_qu\
    ery`\x20as\x20overrides.\x20For\x20more\x20details\x20of\x20the\x20merge\
    \x20behavior,\n\x20please\x20refer\x20to\x20the\n\x20[MergeFrom](https:/\
    /developers.google.com/protocol-buffers/docs/reference/cpp/google.protob\
    uf.message#Message.MergeFrom.details)\n\x20doc.\n\n\x20Note\x20that\x20y\
    ou\x20cannot\x20override\x20primitive\x20fields\x20with\x20default\x20va\
    lue,\x20such\x20as\n\x200\x20or\x20empty\x20string,\x20etc.,\x20because\
    \x20we\x20use\x20proto3,\x20which\x20doesn't\x20support\x20field\n\x20pr\
    esence\x20yet.\n\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\x9d\x0c\x02\x08\n\
    \r\n\x05\x04\x1e\x02\x01\x01\x12\x04\x9d\x0c\t\x1d\n\r\n\x05\x04\x1e\x02\
    \x01\x03\x12\x04\x9d\x0c\x20!\n\r\n\x05\x04\x1e\x02\x01\x08\x12\x04\x9d\
    \x0c\"J\n\x10\n\x08\x04\x1e\x02\x01\x08\x9c\x08\0\x12\x04\x9d\x0c#I\na\n\
    \x04\x04\x1e\x02\x02\x12\x06\xa1\x0c\x02\xa2\x0c/\x1aQ\x20Required.\x20O\
    utput\x20configuration\x20indicating\x20where\x20the\x20results\x20will\
    \x20be\x20output\n\x20to.\n\n\r\n\x05\x04\x1e\x02\x02\x06\x12\x04\xa1\
    \x0c\x02\x1f\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xa1\x0c\x20-\n\r\n\
    \x05\x04\x1e\x02\x02\x03\x12\x04\xa1\x0c01\n\r\n\x05\x04\x1e\x02\x02\x08\
    \x12\x04\xa2\x0c\x06.\n\x10\n\x08\x04\x1e\x02\x02\x08\x9c\x08\0\x12\x04\
    \xa2\x0c\x07-\n\x92\x01\n\x02\x04\x1f\x12\x04\xa7\x0c\0.\x1a\x85\x01\x20\
    A\x20response\x20message\x20for\n\x20[AssetService.AnalyzeIamPolicyLongr\
    unning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning].\
    \n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xa7\x0c\x08+\nL\n\x02\x04\x20\x12\x06\
    \xaa\x0c\0\xe0\x0c\x01\x1a>\x20A\x20saved\x20query\x20which\x20can\x20be\
    \x20shared\x20with\x20others\x20or\x20used\x20later.\n\n\x0b\n\x03\x04\
    \x20\x01\x12\x04\xaa\x0c\x08\x12\n\r\n\x03\x04\x20\x07\x12\x06\xab\x0c\
    \x02\xb0\x0c\x04\n\x0f\n\x05\x04\x20\x07\x9d\x08\x12\x06\xab\x0c\x02\xb0\
    \x0c\x04\n$\n\x04\x04\x20\x03\0\x12\x06\xb3\x0c\x02\xbd\x0c\x03\x1a\x14\
    \x20The\x20query\x20content.\n\n\r\n\x05\x04\x20\x03\0\x01\x12\x04\xb3\
    \x0c\n\x16\n\x10\n\x06\x04\x20\x03\0\x08\0\x12\x06\xb4\x0c\x04\xbc\x0c\
    \x05\n\x0f\n\x07\x04\x20\x03\0\x08\0\x01\x12\x04\xb4\x0c\n\x17\n\xa0\x02\
    \n\x06\x04\x20\x03\0\x02\0\x12\x04\xbb\x0c\x06;\x1a\x8f\x02\x20An\x20IAM\
    \x20Policy\x20Analysis\x20query,\x20which\x20could\x20be\x20used\x20in\n\
    \x20the\n\x20[AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.Asset\
    Service.AnalyzeIamPolicy]\n\x20RPC\x20or\x20the\n\x20[AssetService.Analy\
    zeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPol\
    icyLongrunning]\n\x20RPC.\n\n\x0f\n\x07\x04\x20\x03\0\x02\0\x06\x12\x04\
    \xbb\x0c\x06\x1c\n\x0f\n\x07\x04\x20\x03\0\x02\0\x01\x12\x04\xbb\x0c\x1d\
    6\n\x0f\n\x07\x04\x20\x03\0\x02\0\x03\x12\x04\xbb\x0c9:\n\xf8\x01\n\x04\
    \x04\x20\x02\0\x12\x04\xc4\x0c\x02\x12\x1a\xe9\x01\x20The\x20resource\
    \x20name\x20of\x20the\x20saved\x20query.\x20The\x20format\x20must\x20be:\
    \n\n\x20*\x20projects/project_number/savedQueries/saved_query_id\n\x20*\
    \x20folders/folder_number/savedQueries/saved_query_id\n\x20*\x20organiza\
    tions/organization_number/savedQueries/saved_query_id\n\n\r\n\x05\x04\
    \x20\x02\0\x05\x12\x04\xc4\x0c\x02\x08\n\r\n\x05\x04\x20\x02\0\x01\x12\
    \x04\xc4\x0c\t\r\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xc4\x0c\x10\x11\ne\
    \n\x04\x04\x20\x02\x01\x12\x04\xc8\x0c\x02\x19\x1aW\x20The\x20descriptio\
    n\x20of\x20this\x20saved\x20query.\x20This\x20value\x20should\x20be\x20f\
    ewer\x20than\x20255\n\x20characters.\n\n\r\n\x05\x04\x20\x02\x01\x05\x12\
    \x04\xc8\x0c\x02\x08\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xc8\x0c\t\x14\
    \n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xc8\x0c\x17\x18\nC\n\x04\x04\x20\
    \x02\x02\x12\x06\xcb\x0c\x02\xcc\x0c2\x1a3\x20Output\x20only.\x20The\x20\
    create\x20time\x20of\x20this\x20saved\x20query.\n\n\r\n\x05\x04\x20\x02\
    \x02\x06\x12\x04\xcb\x0c\x02\x1b\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\
    \xcb\x0c\x1c'\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xcb\x0c*+\n\r\n\x05\
    \x04\x20\x02\x02\x08\x12\x04\xcc\x0c\x061\n\x10\n\x08\x04\x20\x02\x02\
    \x08\x9c\x08\0\x12\x04\xcc\x0c\x070\nZ\n\x04\x04\x20\x02\x03\x12\x04\xcf\
    \x0c\x02A\x1aL\x20Output\x20only.\x20The\x20account's\x20email\x20addres\
    s\x20who\x20has\x20created\x20this\x20saved\x20query.\n\n\r\n\x05\x04\
    \x20\x02\x03\x05\x12\x04\xcf\x0c\x02\x08\n\r\n\x05\x04\x20\x02\x03\x01\
    \x12\x04\xcf\x0c\t\x10\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\xcf\x0c\x13\
    \x14\n\r\n\x05\x04\x20\x02\x03\x08\x12\x04\xcf\x0c\x15@\n\x10\n\x08\x04\
    \x20\x02\x03\x08\x9c\x08\0\x12\x04\xcf\x0c\x16?\nH\n\x04\x04\x20\x02\x04\
    \x12\x06\xd2\x0c\x02\xd3\x0c2\x1a8\x20Output\x20only.\x20The\x20last\x20\
    update\x20time\x20of\x20this\x20saved\x20query.\n\n\r\n\x05\x04\x20\x02\
    \x04\x06\x12\x04\xd2\x0c\x02\x1b\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\
    \xd2\x0c\x1c,\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\xd2\x0c/0\n\r\n\x05\
    \x04\x20\x02\x04\x08\x12\x04\xd3\x0c\x061\n\x10\n\x08\x04\x20\x02\x04\
    \x08\x9c\x08\0\x12\x04\xd3\x0c\x070\ni\n\x04\x04\x20\x02\x05\x12\x04\xd7\
    \x0c\x02F\x1a[\x20Output\x20only.\x20The\x20account's\x20email\x20addres\
    s\x20who\x20has\x20updated\x20this\x20saved\x20query\n\x20most\x20recent\
    ly.\n\n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\xd7\x0c\x02\x08\n\r\n\x05\
    \x04\x20\x02\x05\x01\x12\x04\xd7\x0c\t\x15\n\r\n\x05\x04\x20\x02\x05\x03\
    \x12\x04\xd7\x0c\x18\x19\n\r\n\x05\x04\x20\x02\x05\x08\x12\x04\xd7\x0c\
    \x1aE\n\x10\n\x08\x04\x20\x02\x05\x08\x9c\x08\0\x12\x04\xd7\x0c\x1bD\n\
    \xb6\x01\n\x04\x04\x20\x02\x06\x12\x04\xdc\x0c\x02!\x1a\xa7\x01\x20Label\
    s\x20applied\x20on\x20the\x20resource.\n\x20This\x20value\x20should\x20n\
    ot\x20contain\x20more\x20than\x2010\x20entries.\x20The\x20key\x20and\x20\
    value\x20of\n\x20each\x20entry\x20must\x20be\x20non-empty\x20and\x20fewe\
    r\x20than\x2064\x20characters.\n\n\r\n\x05\x04\x20\x02\x06\x06\x12\x04\
    \xdc\x0c\x02\x15\n\r\n\x05\x04\x20\x02\x06\x01\x12\x04\xdc\x0c\x16\x1c\n\
    \r\n\x05\x04\x20\x02\x06\x03\x12\x04\xdc\x0c\x1f\x20\n\"\n\x04\x04\x20\
    \x02\x07\x12\x04\xdf\x0c\x02\x1b\x1a\x14\x20The\x20query\x20content.\n\n\
    \r\n\x05\x04\x20\x02\x07\x06\x12\x04\xdf\x0c\x02\x0e\n\r\n\x05\x04\x20\
    \x02\x07\x01\x12\x04\xdf\x0c\x0f\x16\n\r\n\x05\x04\x20\x02\x07\x03\x12\
    \x04\xdf\x0c\x19\x1a\n0\n\x02\x04!\x12\x06\xe3\x0c\0\xfe\x0c\x01\x1a\"\
    \x20Request\x20to\x20create\x20a\x20saved\x20query.\n\n\x0b\n\x03\x04!\
    \x01\x12\x04\xe3\x0c\x08\x1f\n\xc8\x02\n\x04\x04!\x02\0\x12\x06\xe9\x0c\
    \x02\xee\x0c\x04\x1a\xb7\x02\x20Required.\x20The\x20name\x20of\x20the\
    \x20project/folder/organization\x20where\x20this\n\x20saved_query\x20sho\
    uld\x20be\x20created\x20in.\x20It\x20can\x20only\x20be\x20an\x20organiza\
    tion\x20number\n\x20(such\x20as\x20\"organizations/123\"),\x20a\x20folde\
    r\x20number\x20(such\x20as\x20\"folders/123\"),\x20a\n\x20project\x20ID\
    \x20(such\x20as\x20\"projects/my-project-id\"),\x20or\x20a\x20project\
    \x20number\x20(such\x20as\n\x20\"projects/12345\").\n\n\r\n\x05\x04!\x02\
    \0\x05\x12\x04\xe9\x0c\x02\x08\n\r\n\x05\x04!\x02\0\x01\x12\x04\xe9\x0c\
    \t\x0f\n\r\n\x05\x04!\x02\0\x03\x12\x04\xe9\x0c\x12\x13\n\x0f\n\x05\x04!\
    \x02\0\x08\x12\x06\xe9\x0c\x14\xee\x0c\x03\n\x10\n\x08\x04!\x02\0\x08\
    \x9c\x08\0\x12\x04\xea\x0c\x04*\n\x11\n\x07\x04!\x02\0\x08\x9f\x08\x12\
    \x06\xeb\x0c\x04\xed\x0c\x05\n\x93\x01\n\x04\x04!\x02\x01\x12\x04\xf2\
    \x0c\x02F\x1a\x84\x01\x20Required.\x20The\x20saved_query\x20details.\x20\
    The\x20`name`\x20field\x20must\x20be\x20empty\x20as\x20it\n\x20will\x20b\
    e\x20generated\x20based\x20on\x20the\x20parent\x20and\x20saved_query_id.\
    \n\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xf2\x0c\x02\x0c\n\r\n\x05\x04!\x02\
    \x01\x01\x12\x04\xf2\x0c\r\x18\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xf2\
    \x0c\x1b\x1c\n\r\n\x05\x04!\x02\x01\x08\x12\x04\xf2\x0c\x1dE\n\x10\n\x08\
    \x04!\x02\x01\x08\x9c\x08\0\x12\x04\xf2\x0c\x1eD\n\x83\x03\n\x04\x04!\
    \x02\x02\x12\x04\xfd\x0c\x02E\x1a\xf4\x02\x20Required.\x20The\x20ID\x20t\
    o\x20use\x20for\x20the\x20saved\x20query,\x20which\x20must\x20be\x20uniq\
    ue\x20in\x20the\n\x20specified\x20parent.\x20It\x20will\x20become\x20the\
    \x20final\x20component\x20of\x20the\x20saved\x20query's\n\x20resource\
    \x20name.\n\n\x20This\x20value\x20should\x20be\x204-63\x20characters,\
    \x20and\x20valid\x20characters\n\x20are\x20`[a-z][0-9]-`.\n\n\x20Notice\
    \x20that\x20this\x20field\x20is\x20required\x20in\x20the\x20saved\x20que\
    ry\x20creation,\x20and\x20the\n\x20`name`\x20field\x20of\x20the\x20`save\
    d_query`\x20will\x20be\x20ignored.\n\n\r\n\x05\x04!\x02\x02\x05\x12\x04\
    \xfd\x0c\x02\x08\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xfd\x0c\t\x17\n\r\n\
    \x05\x04!\x02\x02\x03\x12\x04\xfd\x0c\x1a\x1b\n\r\n\x05\x04!\x02\x02\x08\
    \x12\x04\xfd\x0c\x1cD\n\x10\n\x08\x04!\x02\x02\x08\x9c\x08\0\x12\x04\xfd\
    \x0c\x1dC\n-\n\x02\x04\"\x12\x06\x81\r\0\x8d\r\x01\x1a\x1f\x20Request\
    \x20to\x20get\x20a\x20saved\x20query.\n\n\x0b\n\x03\x04\"\x01\x12\x04\
    \x81\r\x08\x1c\n\x87\x02\n\x04\x04\"\x02\0\x12\x06\x87\r\x02\x8c\r\x04\
    \x1a\xf6\x01\x20Required.\x20The\x20name\x20of\x20the\x20saved\x20query\
    \x20and\x20it\x20must\x20be\x20in\x20the\x20format\x20of:\n\n\x20*\x20pr\
    ojects/project_number/savedQueries/saved_query_id\n\x20*\x20folders/fold\
    er_number/savedQueries/saved_query_id\n\x20*\x20organizations/organizati\
    on_number/savedQueries/saved_query_id\n\n\r\n\x05\x04\"\x02\0\x05\x12\
    \x04\x87\r\x02\x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x87\r\t\r\n\r\n\x05\
    \x04\"\x02\0\x03\x12\x04\x87\r\x10\x11\n\x0f\n\x05\x04\"\x02\0\x08\x12\
    \x06\x87\r\x12\x8c\r\x03\n\x10\n\x08\x04\"\x02\0\x08\x9c\x08\0\x12\x04\
    \x88\r\x04*\n\x11\n\x07\x04\"\x02\0\x08\x9f\x08\x12\x06\x89\r\x04\x8b\r\
    \x05\n.\n\x02\x04#\x12\x06\x90\r\0\xb0\r\x01\x1a\x20\x20Request\x20to\
    \x20list\x20saved\x20queries.\n\n\x0b\n\x03\x04#\x01\x12\x04\x90\r\x08\
    \x1f\n\xf2\x01\n\x04\x04#\x02\0\x12\x06\x94\r\x02\x99\r\x04\x1a\xe1\x01\
    \x20Required.\x20The\x20parent\x20project/folder/organization\x20whose\
    \x20savedQueries\x20are\x20to\n\x20be\x20listed.\x20It\x20can\x20only\
    \x20be\x20using\x20project/folder/organization\x20number\x20(such\x20as\
    \n\x20\"folders/12345\")\",\x20or\x20a\x20project\x20ID\x20(such\x20as\
    \x20\"projects/my-project-id\").\n\n\r\n\x05\x04#\x02\0\x05\x12\x04\x94\
    \r\x02\x08\n\r\n\x05\x04#\x02\0\x01\x12\x04\x94\r\t\x0f\n\r\n\x05\x04#\
    \x02\0\x03\x12\x04\x94\r\x12\x13\n\x0f\n\x05\x04#\x02\0\x08\x12\x06\x94\
    \r\x14\x99\r\x03\n\x10\n\x08\x04#\x02\0\x08\x9c\x08\0\x12\x04\x95\r\x04*\
    \n\x11\n\x07\x04#\x02\0\x08\x9f\x08\x12\x06\x96\r\x04\x98\r\x05\n\x99\
    \x03\n\x04\x04#\x02\x01\x12\x04\xa2\r\x02=\x1a\x8a\x03\x20Optional.\x20T\
    he\x20expression\x20to\x20filter\x20resources.\n\x20The\x20expression\
    \x20is\x20a\x20list\x20of\x20zero\x20or\x20more\x20restrictions\x20combi\
    ned\x20via\x20logical\n\x20operators\x20`AND`\x20and\x20`OR`.\x20When\
    \x20`AND`\x20and\x20`OR`\x20are\x20both\x20used\x20in\x20the\n\x20expres\
    sion,\x20parentheses\x20must\x20be\x20appropriately\x20used\x20to\x20gro\
    up\x20the\n\x20combinations.\x20The\x20expression\x20may\x20also\x20cont\
    ain\x20regular\x20expressions.\n\n\x20See\x20https://google.aip.dev/160\
    \x20for\x20more\x20information\x20on\x20the\x20grammar.\n\n\r\n\x05\x04#\
    \x02\x01\x05\x12\x04\xa2\r\x02\x08\n\r\n\x05\x04#\x02\x01\x01\x12\x04\
    \xa2\r\t\x0f\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xa2\r\x12\x13\n\r\n\x05\
    \x04#\x02\x01\x08\x12\x04\xa2\r\x14<\n\x10\n\x08\x04#\x02\x01\x08\x9c\
    \x08\0\x12\x04\xa2\r\x15;\n\xf6\x01\n\x04\x04#\x02\x02\x12\x04\xa8\r\x02\
    ?\x1a\xe7\x01\x20Optional.\x20The\x20maximum\x20number\x20of\x20saved\
    \x20queries\x20to\x20return\x20per\x20page.\x20The\n\x20service\x20may\
    \x20return\x20fewer\x20than\x20this\x20value.\x20If\x20unspecified,\x20a\
    t\x20most\x2050\x20will\n\x20be\x20returned.\x20The\x20maximum\x20value\
    \x20is\x201000;\x20values\x20above\x201000\x20will\x20be\x20coerced\n\
    \x20to\x201000.\n\n\r\n\x05\x04#\x02\x02\x05\x12\x04\xa8\r\x02\x07\n\r\n\
    \x05\x04#\x02\x02\x01\x12\x04\xa8\r\x08\x11\n\r\n\x05\x04#\x02\x02\x03\
    \x12\x04\xa8\r\x14\x15\n\r\n\x05\x04#\x02\x02\x08\x12\x04\xa8\r\x16>\n\
    \x10\n\x08\x04#\x02\x02\x08\x9c\x08\0\x12\x04\xa8\r\x17=\n\x83\x02\n\x04\
    \x04#\x02\x03\x12\x04\xaf\r\x02A\x1a\xf4\x01\x20Optional.\x20A\x20page\
    \x20token,\x20received\x20from\x20a\x20previous\x20`ListSavedQueries`\
    \x20call.\n\x20Provide\x20this\x20to\x20retrieve\x20the\x20subsequent\
    \x20page.\n\n\x20When\x20paginating,\x20all\x20other\x20parameters\x20pr\
    ovided\x20to\x20`ListSavedQueries`\x20must\n\x20match\x20the\x20call\x20\
    that\x20provided\x20the\x20page\x20token.\n\n\r\n\x05\x04#\x02\x03\x05\
    \x12\x04\xaf\r\x02\x08\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xaf\r\t\x13\n\
    \r\n\x05\x04#\x02\x03\x03\x12\x04\xaf\r\x16\x17\n\r\n\x05\x04#\x02\x03\
    \x08\x12\x04\xaf\r\x18@\n\x10\n\x08\x04#\x02\x03\x08\x9c\x08\0\x12\x04\
    \xaf\r\x19?\n2\n\x02\x04$\x12\x06\xb3\r\0\xba\r\x01\x1a$\x20Response\x20\
    of\x20listing\x20saved\x20queries.\n\n\x0b\n\x03\x04$\x01\x12\x04\xb3\r\
    \x08\x20\n'\n\x04\x04$\x02\0\x12\x04\xb5\r\x02(\x1a\x19\x20A\x20list\x20\
    of\x20savedQueries.\n\n\r\n\x05\x04$\x02\0\x04\x12\x04\xb5\r\x02\n\n\r\n\
    \x05\x04$\x02\0\x06\x12\x04\xb5\r\x0b\x15\n\r\n\x05\x04$\x02\0\x01\x12\
    \x04\xb5\r\x16#\n\r\n\x05\x04$\x02\0\x03\x12\x04\xb5\r&'\n\x90\x01\n\x04\
    \x04$\x02\x01\x12\x04\xb9\r\x02\x1d\x1a\x81\x01\x20A\x20token,\x20which\
    \x20can\x20be\x20sent\x20as\x20`page_token`\x20to\x20retrieve\x20the\x20\
    next\x20page.\n\x20If\x20this\x20field\x20is\x20omitted,\x20there\x20are\
    \x20no\x20subsequent\x20pages.\n\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xb9\
    \r\x02\x08\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xb9\r\t\x18\n\r\n\x05\x04$\
    \x02\x01\x03\x12\x04\xb9\r\x1b\x1c\n0\n\x02\x04%\x12\x06\xbd\r\0\xcb\r\
    \x01\x1a\"\x20Request\x20to\x20update\x20a\x20saved\x20query.\n\n\x0b\n\
    \x03\x04%\x01\x12\x04\xbd\r\x08\x1f\n\xc7\x02\n\x04\x04%\x02\0\x12\x04\
    \xc6\r\x02F\x1a\xb8\x02\x20Required.\x20The\x20saved\x20query\x20to\x20u\
    pdate.\n\n\x20The\x20saved\x20query's\x20`name`\x20field\x20is\x20used\
    \x20to\x20identify\x20the\x20one\x20to\x20update,\n\x20which\x20has\x20f\
    ormat\x20as\x20below:\n\n\x20*\x20projects/project_number/savedQueries/s\
    aved_query_id\n\x20*\x20folders/folder_number/savedQueries/saved_query_i\
    d\n\x20*\x20organizations/organization_number/savedQueries/saved_query_i\
    d\n\n\r\n\x05\x04%\x02\0\x06\x12\x04\xc6\r\x02\x0c\n\r\n\x05\x04%\x02\0\
    \x01\x12\x04\xc6\r\r\x18\n\r\n\x05\x04%\x02\0\x03\x12\x04\xc6\r\x1b\x1c\
    \n\r\n\x05\x04%\x02\0\x08\x12\x04\xc6\r\x1dE\n\x10\n\x08\x04%\x02\0\x08\
    \x9c\x08\0\x12\x04\xc6\r\x1eD\n9\n\x04\x04%\x02\x01\x12\x06\xc9\r\x02\
    \xca\r/\x1a)\x20Required.\x20The\x20list\x20of\x20fields\x20to\x20update\
    .\n\n\r\n\x05\x04%\x02\x01\x06\x12\x04\xc9\r\x02\x1b\n\r\n\x05\x04%\x02\
    \x01\x01\x12\x04\xc9\r\x1c'\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xc9\r*+\n\
    \r\n\x05\x04%\x02\x01\x08\x12\x04\xca\r\x06.\n\x10\n\x08\x04%\x02\x01\
    \x08\x9c\x08\0\x12\x04\xca\r\x07-\n0\n\x02\x04&\x12\x06\xce\r\0\xdb\r\
    \x01\x1a\"\x20Request\x20to\x20delete\x20a\x20saved\x20query.\n\n\x0b\n\
    \x03\x04&\x01\x12\x04\xce\r\x08\x1f\n\x8f\x02\n\x04\x04&\x02\0\x12\x06\
    \xd5\r\x02\xda\r\x04\x1a\xfe\x01\x20Required.\x20The\x20name\x20of\x20th\
    e\x20saved\x20query\x20to\x20delete.\x20It\x20must\x20be\x20in\x20the\
    \x20format\n\x20of:\n\n\x20*\x20projects/project_number/savedQueries/sav\
    ed_query_id\n\x20*\x20folders/folder_number/savedQueries/saved_query_id\
    \n\x20*\x20organizations/organization_number/savedQueries/saved_query_id\
    \n\n\r\n\x05\x04&\x02\0\x05\x12\x04\xd5\r\x02\x08\n\r\n\x05\x04&\x02\0\
    \x01\x12\x04\xd5\r\t\r\n\r\n\x05\x04&\x02\0\x03\x12\x04\xd5\r\x10\x11\n\
    \x0f\n\x05\x04&\x02\0\x08\x12\x06\xd5\r\x12\xda\r\x03\n\x10\n\x08\x04&\
    \x02\0\x08\x9c\x08\0\x12\x04\xd6\r\x04*\n\x11\n\x07\x04&\x02\0\x08\x9f\
    \x08\x12\x06\xd7\r\x04\xd9\r\x05\nJ\n\x02\x04'\x12\x06\xde\r\0\xfe\r\x01\
    \x1a<\x20The\x20request\x20message\x20for\x20performing\x20resource\x20m\
    ove\x20analysis.\n\n\x0b\n\x03\x04'\x01\x12\x04\xde\r\x08\x1a\nF\n\x04\
    \x04'\x04\0\x12\x06\xe0\r\x02\xec\r\x03\x1a6\x20View\x20enum\x20for\x20s\
    upporting\x20partial\x20analysis\x20responses.\n\n\r\n\x05\x04'\x04\0\
    \x01\x12\x04\xe0\r\x07\x13\nR\n\x06\x04'\x04\0\x02\0\x12\x04\xe3\r\x04\"\
    \x1aB\x20The\x20default/unset\x20value.\n\x20The\x20API\x20will\x20defau\
    lt\x20to\x20the\x20FULL\x20view.\n\n\x0f\n\x07\x04'\x04\0\x02\0\x01\x12\
    \x04\xe3\r\x04\x1d\n\x0f\n\x07\x04'\x04\0\x02\0\x02\x12\x04\xe3\r\x20!\n\
    _\n\x06\x04'\x04\0\x02\x01\x12\x04\xe7\r\x04\r\x1aO\x20Full\x20analysis\
    \x20including\x20all\x20level\x20of\x20impacts\x20of\x20the\x20specified\
    \x20resource\n\x20move.\n\n\x0f\n\x07\x04'\x04\0\x02\x01\x01\x12\x04\xe7\
    \r\x04\x08\n\x0f\n\x07\x04'\x04\0\x02\x01\x02\x12\x04\xe7\r\x0b\x0c\nt\n\
    \x06\x04'\x04\0\x02\x02\x12\x04\xeb\r\x04\x0e\x1ad\x20Basic\x20analysis\
    \x20only\x20including\x20blockers\x20which\x20will\x20prevent\x20the\x20\
    specified\n\x20resource\x20move\x20at\x20runtime.\n\n\x0f\n\x07\x04'\x04\
    \0\x02\x02\x01\x12\x04\xeb\r\x04\t\n\x0f\n\x07\x04'\x04\0\x02\x02\x02\
    \x12\x04\xeb\r\x0c\r\n\x81\x02\n\x04\x04'\x02\0\x12\x04\xf2\r\x02?\x1a\
    \xf2\x01\x20Required.\x20Name\x20of\x20the\x20resource\x20to\x20perform\
    \x20the\x20analysis\x20against.\n\x20Only\x20Google\x20Cloud\x20projects\
    \x20are\x20supported\x20as\x20of\x20today.\x20Hence,\x20this\x20can\x20o\
    nly\n\x20be\x20a\x20project\x20ID\x20(such\x20as\x20\"projects/my-projec\
    t-id\")\x20or\x20a\x20project\x20number\n\x20(such\x20as\x20\"projects/1\
    2345\").\n\n\r\n\x05\x04'\x02\0\x05\x12\x04\xf2\r\x02\x08\n\r\n\x05\x04'\
    \x02\0\x01\x12\x04\xf2\r\t\x11\n\r\n\x05\x04'\x02\0\x03\x12\x04\xf2\r\
    \x14\x15\n\r\n\x05\x04'\x02\0\x08\x12\x04\xf2\r\x16>\n\x10\n\x08\x04'\
    \x02\0\x08\x9c\x08\0\x12\x04\xf2\r\x17=\n\xd2\x02\n\x04\x04'\x02\x01\x12\
    \x04\xf9\r\x02I\x1a\xc3\x02\x20Required.\x20Name\x20of\x20the\x20Google\
    \x20Cloud\x20folder\x20or\x20organization\x20to\x20reparent\x20the\n\x20\
    target\x20resource.\x20The\x20analysis\x20will\x20be\x20performed\x20aga\
    inst\x20hypothetically\n\x20moving\x20the\x20resource\x20to\x20this\x20s\
    pecified\x20desitination\x20parent.\x20This\x20can\x20only\x20be\n\x20a\
    \x20folder\x20number\x20(such\x20as\x20\"folders/123\")\x20or\x20an\x20o\
    rganization\x20number\x20(such\x20as\n\x20\"organizations/123\").\n\n\r\
    \n\x05\x04'\x02\x01\x05\x12\x04\xf9\r\x02\x08\n\r\n\x05\x04'\x02\x01\x01\
    \x12\x04\xf9\r\t\x1b\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xf9\r\x1e\x1f\n\
    \r\n\x05\x04'\x02\x01\x08\x12\x04\xf9\r\x20H\n\x10\n\x08\x04'\x02\x01\
    \x08\x9c\x08\0\x12\x04\xf9\r!G\n\x92\x01\n\x04\x04'\x02\x02\x12\x04\xfd\
    \r\x02\x18\x1a\x83\x01\x20Analysis\x20view\x20indicating\x20what\x20info\
    rmation\x20should\x20be\x20included\x20in\x20the\n\x20analysis\x20respon\
    se.\x20If\x20unspecified,\x20the\x20default\x20view\x20is\x20FULL.\n\n\r\
    \n\x05\x04'\x02\x02\x06\x12\x04\xfd\r\x02\x0e\n\r\n\x05\x04'\x02\x02\x01\
    \x12\x04\xfd\r\x0f\x13\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xfd\r\x16\x17\
    \n@\n\x02\x04(\x12\x06\x81\x0e\0\x85\x0e\x01\x1a2\x20The\x20response\x20\
    message\x20for\x20resource\x20move\x20analysis.\n\n\x0b\n\x03\x04(\x01\
    \x12\x04\x81\x0e\x08\x1b\n\xa0\x01\n\x04\x04(\x02\0\x12\x04\x84\x0e\x02*\
    \x1a\x91\x01\x20The\x20list\x20of\x20analyses\x20returned\x20from\x20per\
    forming\x20the\x20intended\x20resource\x20move\n\x20analysis.\x20The\x20\
    analysis\x20is\x20grouped\x20by\x20different\x20Google\x20Cloud\x20servi\
    ces.\n\n\r\n\x05\x04(\x02\0\x04\x12\x04\x84\x0e\x02\n\n\r\n\x05\x04(\x02\
    \0\x06\x12\x04\x84\x0e\x0b\x17\n\r\n\x05\x04(\x02\0\x01\x12\x04\x84\x0e\
    \x18%\n\r\n\x05\x04(\x02\0\x03\x12\x04\x84\x0e()\n<\n\x02\x04)\x12\x06\
    \x88\x0e\0\x94\x0e\x01\x1a.\x20A\x20message\x20to\x20group\x20the\x20ana\
    lysis\x20information.\n\n\x0b\n\x03\x04)\x01\x12\x04\x88\x0e\x08\x14\nc\
    \n\x04\x04)\x02\0\x12\x04\x8b\x0e\x02\x1a\x1aU\x20The\x20user\x20friendl\
    y\x20display\x20name\x20of\x20the\x20analysis.\x20E.g.\x20IAM,\x20organi\
    zation\n\x20policy\x20etc.\n\n\r\n\x05\x04)\x02\0\x05\x12\x04\x8b\x0e\
    \x02\x08\n\r\n\x05\x04)\x02\0\x01\x12\x04\x8b\x0e\t\x15\n\r\n\x05\x04)\
    \x02\0\x03\x12\x04\x8b\x0e\x18\x19\n\x0e\n\x04\x04)\x08\0\x12\x06\x8d\
    \x0e\x02\x93\x0e\x03\n\r\n\x05\x04)\x08\0\x01\x12\x04\x8d\x0e\x08\x0e\n>\
    \n\x04\x04)\x02\x01\x12\x04\x8f\x0e\x04$\x1a0\x20Analysis\x20result\x20o\
    f\x20moving\x20the\x20target\x20resource.\n\n\r\n\x05\x04)\x02\x01\x06\
    \x12\x04\x8f\x0e\x04\x16\n\r\n\x05\x04)\x02\x01\x01\x12\x04\x8f\x0e\x17\
    \x1f\n\r\n\x05\x04)\x02\x01\x03\x12\x04\x8f\x0e\"#\nN\n\x04\x04)\x02\x02\
    \x12\x04\x92\x0e\x04\x20\x1a@\x20Description\x20of\x20error\x20encounter\
    ed\x20when\x20performing\x20the\x20analysis.\n\n\r\n\x05\x04)\x02\x02\
    \x06\x12\x04\x92\x0e\x04\x15\n\r\n\x05\x04)\x02\x02\x01\x12\x04\x92\x0e\
    \x16\x1b\n\r\n\x05\x04)\x02\x02\x03\x12\x04\x92\x0e\x1e\x1f\nC\n\x02\x04\
    *\x12\x06\x97\x0e\0\xa0\x0e\x01\x1a5\x20An\x20analysis\x20result\x20incl\
    uding\x20blockers\x20and\x20warnings.\n\n\x0b\n\x03\x04*\x01\x12\x04\x97\
    \x0e\x08\x1a\n\x81\x01\n\x04\x04*\x02\0\x12\x04\x9a\x0e\x02#\x1as\x20Blo\
    cking\x20information\x20that\x20would\x20prevent\x20the\x20target\x20res\
    ource\x20from\x20moving\n\x20to\x20the\x20specified\x20destination\x20at\
    \x20runtime.\n\n\r\n\x05\x04*\x02\0\x04\x12\x04\x9a\x0e\x02\n\n\r\n\x05\
    \x04*\x02\0\x06\x12\x04\x9a\x0e\x0b\x15\n\r\n\x05\x04*\x02\0\x01\x12\x04\
    \x9a\x0e\x16\x1e\n\r\n\x05\x04*\x02\0\x03\x12\x04\x9a\x0e!\"\n\xed\x01\n\
    \x04\x04*\x02\x01\x12\x04\x9f\x0e\x02#\x1a\xde\x01\x20Warning\x20informa\
    tion\x20indicating\x20that\x20moving\x20the\x20target\x20resource\x20to\
    \x20the\n\x20specified\x20destination\x20might\x20be\x20unsafe.\x20This\
    \x20can\x20include\x20important\x20policy\n\x20information\x20and\x20con\
    figuration\x20changes,\x20but\x20will\x20not\x20block\x20moves\x20at\x20\
    runtime.\n\n\r\n\x05\x04*\x02\x01\x04\x12\x04\x9f\x0e\x02\n\n\r\n\x05\
    \x04*\x02\x01\x06\x12\x04\x9f\x0e\x0b\x15\n\r\n\x05\x04*\x02\x01\x01\x12\
    \x04\x9f\x0e\x16\x1e\n\r\n\x05\x04*\x02\x01\x03\x12\x04\x9f\x0e!\"\nI\n\
    \x02\x04+\x12\x06\xa3\x0e\0\xa6\x0e\x01\x1a;\x20A\x20message\x20to\x20gr\
    oup\x20impacts\x20of\x20moving\x20the\x20target\x20resource.\n\n\x0b\n\
    \x03\x04+\x01\x12\x04\xa3\x0e\x08\x12\nC\n\x04\x04+\x02\0\x12\x04\xa5\
    \x0e\x02\x14\x1a5\x20User\x20friendly\x20impact\x20detail\x20in\x20a\x20\
    free\x20form\x20message.\n\n\r\n\x05\x04+\x02\0\x05\x12\x04\xa5\x0e\x02\
    \x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\xa5\x0e\t\x0f\n\r\n\x05\x04+\x02\0\
    \x03\x12\x04\xa5\x0e\x12\x13\n2\n\x02\x04,\x12\x06\xa9\x0e\0\xc5\x0e\x01\
    \x1a$\x20Output\x20configuration\x20query\x20assets.\n\n\x0b\n\x03\x04,\
    \x01\x12\x04\xa9\x0e\x08\x1f\n'\n\x04\x04,\x03\0\x12\x06\xab\x0e\x02\xc1\
    \x0e\x03\x1a\x17\x20BigQuery\x20destination.\n\n\r\n\x05\x04,\x03\0\x01\
    \x12\x04\xab\x0e\n\x1d\n\x9b\x01\n\x06\x04,\x03\0\x02\0\x12\x04\xae\x0e\
    \x04@\x1a\x8a\x01\x20Required.\x20The\x20BigQuery\x20dataset\x20where\
    \x20the\x20query\x20results\x20will\x20be\x20saved.\x20It\n\x20has\x20th\
    e\x20format\x20of\x20\"projects/{projectId}/datasets/{datasetId}\".\n\n\
    \x0f\n\x07\x04,\x03\0\x02\0\x05\x12\x04\xae\x0e\x04\n\n\x0f\n\x07\x04,\
    \x03\0\x02\0\x01\x12\x04\xae\x0e\x0b\x12\n\x0f\n\x07\x04,\x03\0\x02\0\
    \x03\x12\x04\xae\x0e\x15\x16\n\x0f\n\x07\x04,\x03\0\x02\0\x08\x12\x04\
    \xae\x0e\x17?\n\x12\n\n\x04,\x03\0\x02\0\x08\x9c\x08\0\x12\x04\xae\x0e\
    \x18>\n\xa7\x01\n\x06\x04,\x03\0\x02\x01\x12\x04\xb3\x0e\x04>\x1a\x96\
    \x01\x20Required.\x20The\x20BigQuery\x20table\x20where\x20the\x20query\
    \x20results\x20will\x20be\x20saved.\x20If\n\x20this\x20table\x20does\x20\
    not\x20exist,\x20a\x20new\x20table\x20with\x20the\x20given\x20name\x20wi\
    ll\x20be\n\x20created.\n\n\x0f\n\x07\x04,\x03\0\x02\x01\x05\x12\x04\xb3\
    \x0e\x04\n\n\x0f\n\x07\x04,\x03\0\x02\x01\x01\x12\x04\xb3\x0e\x0b\x10\n\
    \x0f\n\x07\x04,\x03\0\x02\x01\x03\x12\x04\xb3\x0e\x13\x14\n\x0f\n\x07\
    \x04,\x03\0\x02\x01\x08\x12\x04\xb3\x0e\x15=\n\x12\n\n\x04,\x03\0\x02\
    \x01\x08\x9c\x08\0\x12\x04\xb3\x0e\x16<\n\xa1\x04\n\x06\x04,\x03\0\x02\
    \x02\x12\x04\xc0\x0e\x04!\x1a\x90\x04\x20Specifies\x20the\x20action\x20t\
    hat\x20occurs\x20if\x20the\x20destination\x20table\x20or\x20partition\n\
    \x20already\x20exists.\x20The\x20following\x20values\x20are\x20supported\
    :\n\n\x20*\x20WRITE_TRUNCATE:\x20If\x20the\x20table\x20or\x20partition\
    \x20already\x20exists,\x20BigQuery\n\x20overwrites\x20the\x20entire\x20t\
    able\x20or\x20all\x20the\x20partitions\x20data.\n\x20*\x20WRITE_APPEND:\
    \x20If\x20the\x20table\x20or\x20partition\x20already\x20exists,\x20BigQu\
    ery\n\x20appends\x20the\x20data\x20to\x20the\x20table\x20or\x20the\x20la\
    test\x20partition.\n\x20*\x20WRITE_EMPTY:\x20If\x20the\x20table\x20alrea\
    dy\x20exists\x20and\x20contains\x20data,\x20a\n\x20'duplicate'\x20error\
    \x20is\x20returned\x20in\x20the\x20job\x20result.\n\n\x20The\x20default\
    \x20value\x20is\x20WRITE_EMPTY.\n\n\x0f\n\x07\x04,\x03\0\x02\x02\x05\x12\
    \x04\xc0\x0e\x04\n\n\x0f\n\x07\x04,\x03\0\x02\x02\x01\x12\x04\xc0\x0e\
    \x0b\x1c\n\x0f\n\x07\x04,\x03\0\x02\x02\x03\x12\x04\xc0\x0e\x1f\x20\nK\n\
    \x04\x04,\x02\0\x12\x04\xc4\x0e\x02/\x1a=\x20BigQuery\x20destination\x20\
    where\x20the\x20query\x20results\x20will\x20be\x20saved.\n\n\r\n\x05\x04\
    ,\x02\0\x06\x12\x04\xc4\x0e\x02\x15\n\r\n\x05\x04,\x02\0\x01\x12\x04\xc4\
    \x0e\x16*\n\r\n\x05\x04,\x02\0\x03\x12\x04\xc4\x0e-.\n$\n\x02\x04-\x12\
    \x06\xc8\x0e\0\x9b\x0f\x01\x1a\x16\x20QueryAssets\x20request.\n\n\x0b\n\
    \x03\x04-\x01\x12\x04\xc8\x0e\x08\x1a\n\xd2\x02\n\x04\x04-\x02\0\x12\x06\
    \xcf\x0e\x02\xd4\x0e\x04\x1a\xc1\x02\x20Required.\x20The\x20relative\x20\
    name\x20of\x20the\x20root\x20asset.\x20This\x20can\x20only\x20be\x20an\n\
    \x20organization\x20number\x20(such\x20as\x20\"organizations/123\"),\x20\
    a\x20project\x20ID\x20(such\x20as\n\x20\"projects/my-project-id\"),\x20o\
    r\x20a\x20project\x20number\x20(such\x20as\x20\"projects/12345\"),\n\x20\
    or\x20a\x20folder\x20number\x20(such\x20as\x20\"folders/123\").\n\n\x20O\
    nly\x20assets\x20belonging\x20to\x20the\x20`parent`\x20will\x20be\x20ret\
    urned.\n\n\r\n\x05\x04-\x02\0\x05\x12\x04\xcf\x0e\x02\x08\n\r\n\x05\x04-\
    \x02\0\x01\x12\x04\xcf\x0e\t\x0f\n\r\n\x05\x04-\x02\0\x03\x12\x04\xcf\
    \x0e\x12\x13\n\x0f\n\x05\x04-\x02\0\x08\x12\x06\xcf\x0e\x14\xd4\x0e\x03\
    \n\x10\n\x08\x04-\x02\0\x08\x9c\x08\0\x12\x04\xd0\x0e\x04*\n\x11\n\x07\
    \x04-\x02\0\x08\x9f\x08\x12\x06\xd1\x0e\x04\xd3\x0e\x05\n\x0e\n\x04\x04-\
    \x08\0\x12\x06\xd6\x0e\x02\xde\x0e\x03\n\r\n\x05\x04-\x08\0\x01\x12\x04\
    \xd6\x0e\x08\r\n\x8a\x01\n\x04\x04-\x02\x01\x12\x04\xd9\x0e\x04B\x1a|\
    \x20Optional.\x20A\x20SQL\x20statement\x20that's\x20compatible\x20with\
    \x20[BigQuery\n\x20SQL](https://cloud.google.com/bigquery/docs/introduct\
    ion-sql).\n\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xd9\x0e\x04\n\n\r\n\x05\
    \x04-\x02\x01\x01\x12\x04\xd9\x0e\x0b\x14\n\r\n\x05\x04-\x02\x01\x03\x12\
    \x04\xd9\x0e\x17\x18\n\r\n\x05\x04-\x02\x01\x08\x12\x04\xd9\x0e\x19A\n\
    \x10\n\x08\x04-\x02\x01\x08\x9c\x08\0\x12\x04\xd9\x0e\x1a@\n~\n\x04\x04-\
    \x02\x02\x12\x04\xdd\x0e\x04F\x1ap\x20Optional.\x20Reference\x20to\x20th\
    e\x20query\x20job,\x20which\x20is\x20from\x20the\n\x20`QueryAssetsRespon\
    se`\x20of\x20previous\x20`QueryAssets`\x20call.\n\n\r\n\x05\x04-\x02\x02\
    \x05\x12\x04\xdd\x0e\x04\n\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xdd\x0e\
    \x0b\x18\n\r\n\x05\x04-\x02\x02\x03\x12\x04\xdd\x0e\x1b\x1c\n\r\n\x05\
    \x04-\x02\x02\x08\x12\x04\xdd\x0e\x1dE\n\x10\n\x08\x04-\x02\x02\x08\x9c\
    \x08\0\x12\x04\xdd\x0e\x1eD\n\xc9\x02\n\x04\x04-\x02\x03\x12\x04\xe7\x0e\
    \x02?\x1a\xba\x02\x20Optional.\x20The\x20maximum\x20number\x20of\x20rows\
    \x20to\x20return\x20in\x20the\x20results.\x20Responses\n\x20are\x20limit\
    ed\x20to\x2010\x20MB\x20and\x201000\x20rows.\n\n\x20By\x20default,\x20th\
    e\x20maximum\x20row\x20count\x20is\x201000.\x20When\x20the\x20byte\x20or\
    \x20row\x20count\x20limit\n\x20is\x20reached,\x20the\x20rest\x20of\x20th\
    e\x20query\x20results\x20will\x20be\x20paginated.\n\n\x20The\x20field\
    \x20will\x20be\x20ignored\x20when\x20[output_config]\x20is\x20specified.\
    \n\n\r\n\x05\x04-\x02\x03\x05\x12\x04\xe7\x0e\x02\x07\n\r\n\x05\x04-\x02\
    \x03\x01\x12\x04\xe7\x0e\x08\x11\n\r\n\x05\x04-\x02\x03\x03\x12\x04\xe7\
    \x0e\x14\x15\n\r\n\x05\x04-\x02\x03\x08\x12\x04\xe7\x0e\x16>\n\x10\n\x08\
    \x04-\x02\x03\x08\x9c\x08\0\x12\x04\xe7\x0e\x17=\n\x8b\x01\n\x04\x04-\
    \x02\x04\x12\x04\xec\x0e\x02A\x1a}\x20Optional.\x20A\x20page\x20token\
    \x20received\x20from\x20previous\x20`QueryAssets`.\n\n\x20The\x20field\
    \x20will\x20be\x20ignored\x20when\x20[output_config]\x20is\x20specified.\
    \n\n\r\n\x05\x04-\x02\x04\x05\x12\x04\xec\x0e\x02\x08\n\r\n\x05\x04-\x02\
    \x04\x01\x12\x04\xec\x0e\t\x13\n\r\n\x05\x04-\x02\x04\x03\x12\x04\xec\
    \x0e\x16\x17\n\r\n\x05\x04-\x02\x04\x08\x12\x04\xec\x0e\x18@\n\x10\n\x08\
    \x04-\x02\x04\x08\x9c\x08\0\x12\x04\xec\x0e\x19?\n\x9d\x05\n\x04\x04-\
    \x02\x05\x12\x04\xfb\x0e\x02P\x1a\x8e\x05\x20Optional.\x20Specifies\x20t\
    he\x20maximum\x20amount\x20of\x20time\x20that\x20the\x20client\x20is\x20\
    willing\n\x20to\x20wait\x20for\x20the\x20query\x20to\x20complete.\x20By\
    \x20default,\x20this\x20limit\x20is\x205\x20min\x20for\x20the\n\x20first\
    \x20query,\x20and\x201\x20minute\x20for\x20the\x20following\x20queries.\
    \x20If\x20the\x20query\x20is\n\x20complete,\x20the\x20`done`\x20field\
    \x20in\x20the\x20`QueryAssetsResponse`\x20is\x20true,\x20otherwise\n\x20\
    false.\n\n\x20Like\x20BigQuery\x20[jobs.query\n\x20API](https://cloud.go\
    ogle.com/bigquery/docs/reference/rest/v2/jobs/query#queryrequest)\n\x20T\
    he\x20call\x20is\x20not\x20guaranteed\x20to\x20wait\x20for\x20the\x20spe\
    cified\x20timeout;\x20it\x20typically\n\x20returns\x20after\x20around\
    \x20200\x20seconds\x20(200,000\x20milliseconds),\x20even\x20if\x20the\
    \x20query\n\x20is\x20not\x20complete.\n\n\x20The\x20field\x20will\x20be\
    \x20ignored\x20when\x20[output_config]\x20is\x20specified.\n\n\r\n\x05\
    \x04-\x02\x05\x06\x12\x04\xfb\x0e\x02\x1a\n\r\n\x05\x04-\x02\x05\x01\x12\
    \x04\xfb\x0e\x1b\"\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xfb\x0e%&\n\r\n\
    \x05\x04-\x02\x05\x08\x12\x04\xfb\x0e'O\n\x10\n\x08\x04-\x02\x05\x08\x9c\
    \x08\0\x12\x04\xfb\x0e(N\n\xbb\x03\n\x04\x04-\x08\x01\x12\x06\x84\x0f\
    \x02\x8e\x0f\x03\x1a\xaa\x03\x20Specifies\x20what\x20time\x20period\x20o\
    r\x20point\x20in\x20time\x20to\x20query\x20asset\x20metadata\x20at.\n\
    \x20*\x20unset\x20-\x20query\x20asset\x20metadata\x20as\x20it\x20is\x20r\
    ight\x20now\n\x20*\x20[read_time_window]\x20-\x20query\x20asset\x20metad\
    ata\x20as\x20it\x20was\x20at\x20any\x20point\x20in\x20time\n\x20between\
    \x20[start_time]\x20and\x20[end_time].\n\x20*\x20[read_time]\x20-\x20que\
    ry\x20asset\x20metadata\x20as\x20it\x20was\x20at\x20that\x20point\x20in\
    \x20time.\n\x20If\x20data\x20for\x20the\x20timestamp/date\x20range\x20se\
    lected\x20does\x20not\x20exist,\n\x20it\x20will\x20simply\x20return\x20a\
    \x20valid\x20response\x20with\x20no\x20rows.\n\n\r\n\x05\x04-\x08\x01\
    \x01\x12\x04\x84\x0f\x08\x0c\n\xd0\x01\n\x04\x04-\x02\x06\x12\x04\x88\
    \x0f\x04M\x1a\xc1\x01\x20Optional.\x20[start_time]\x20is\x20required.\
    \x20[start_time]\x20must\x20be\x20less\x20than\n\x20[end_time]\x20Defaul\
    ts\x20[end_time]\x20to\x20now\x20if\x20[start_time]\x20is\x20set\x20and\
    \n\x20[end_time]\x20isn't.\x20Maximum\x20permitted\x20time\x20range\x20i\
    s\x207\x20days.\n\n\r\n\x05\x04-\x02\x06\x06\x12\x04\x88\x0f\x04\x0e\n\r\
    \n\x05\x04-\x02\x06\x01\x12\x04\x88\x0f\x0f\x1f\n\r\n\x05\x04-\x02\x06\
    \x03\x12\x04\x88\x0f\"#\n\r\n\x05\x04-\x02\x06\x08\x12\x04\x88\x0f$L\n\
    \x10\n\x08\x04-\x02\x06\x08\x9c\x08\0\x12\x04\x88\x0f%K\nb\n\x04\x04-\
    \x02\x07\x12\x06\x8c\x0f\x04\x8d\x0f1\x1aR\x20Optional.\x20Queries\x20cl\
    oud\x20assets\x20as\x20they\x20appeared\x20at\x20the\x20specified\x20poi\
    nt\x20in\n\x20time.\n\n\r\n\x05\x04-\x02\x07\x06\x12\x04\x8c\x0f\x04\x1d\
    \n\r\n\x05\x04-\x02\x07\x01\x12\x04\x8c\x0f\x1e'\n\r\n\x05\x04-\x02\x07\
    \x03\x12\x04\x8c\x0f*+\n\r\n\x05\x04-\x02\x07\x08\x12\x04\x8d\x0f\x080\n\
    \x10\n\x08\x04-\x02\x07\x08\x9c\x08\0\x12\x04\x8d\x0f\t/\n\x9d\x03\n\x04\
    \x04-\x02\x08\x12\x06\x99\x0f\x02\x9a\x0f/\x1a\x8c\x03\x20Optional.\x20D\
    estination\x20where\x20the\x20query\x20results\x20will\x20be\x20saved.\n\
    \n\x20When\x20this\x20field\x20is\x20specified,\x20the\x20query\x20resul\
    ts\x20won't\x20be\x20saved\x20in\x20the\n\x20[QueryAssetsResponse.query_\
    result].\x20Instead\n\x20[QueryAssetsResponse.output_config]\x20will\x20\
    be\x20set.\n\n\x20Meanwhile,\x20[QueryAssetsResponse.job_reference]\x20w\
    ill\x20be\x20set\x20and\x20can\x20be\x20used\n\x20to\x20check\x20the\x20\
    status\x20of\x20the\x20query\x20job\x20when\x20passed\x20to\x20a\x20foll\
    owing\n\x20[QueryAssets]\x20API\x20call.\n\n\r\n\x05\x04-\x02\x08\x06\
    \x12\x04\x99\x0f\x02\x19\n\r\n\x05\x04-\x02\x08\x01\x12\x04\x99\x0f\x1a'\
    \n\r\n\x05\x04-\x02\x08\x03\x12\x04\x99\x0f*+\n\r\n\x05\x04-\x02\x08\x08\
    \x12\x04\x9a\x0f\x06.\n\x10\n\x08\x04-\x02\x08\x08\x9c\x08\0\x12\x04\x9a\
    \x0f\x07-\n%\n\x02\x04.\x12\x06\x9e\x0f\0\xb5\x0f\x01\x1a\x17\x20QueryAs\
    sets\x20response.\n\n\x0b\n\x03\x04.\x01\x12\x04\x9e\x0f\x08\x1b\n)\n\
    \x04\x04.\x02\0\x12\x04\xa0\x0f\x02\x1b\x1a\x1b\x20Reference\x20to\x20a\
    \x20query\x20job.\n\n\r\n\x05\x04.\x02\0\x05\x12\x04\xa0\x0f\x02\x08\n\r\
    \n\x05\x04.\x02\0\x01\x12\x04\xa0\x0f\t\x16\n\r\n\x05\x04.\x02\0\x03\x12\
    \x04\xa0\x0f\x19\x1a\n\xa6\x02\n\x04\x04.\x02\x01\x12\x04\xa8\x0f\x02\
    \x10\x1a\x97\x02\x20The\x20query\x20response,\x20which\x20can\x20be\x20e\
    ither\x20an\x20`error`\x20or\x20a\x20valid\x20`response`.\n\n\x20If\x20`\
    done`\x20==\x20`false`\x20and\x20the\x20query\x20result\x20is\x20being\
    \x20saved\x20in\x20a\x20output,\x20the\n\x20output_config\x20field\x20wi\
    ll\x20be\x20set.\n\x20If\x20`done`\x20==\x20`true`,\x20exactly\x20one\
    \x20of\n\x20`error`,\x20`query_result`\x20or\x20`output_config`\x20will\
    \x20be\x20set.\n\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xa8\x0f\x02\x06\n\r\
    \n\x05\x04.\x02\x01\x01\x12\x04\xa8\x0f\x07\x0b\n\r\n\x05\x04.\x02\x01\
    \x03\x12\x04\xa8\x0f\x0e\x0f\n\x0e\n\x04\x04.\x08\0\x12\x06\xaa\x0f\x02\
    \xb4\x0f\x03\n\r\n\x05\x04.\x08\0\x01\x12\x04\xaa\x0f\x08\x10\n\x1d\n\
    \x04\x04.\x02\x02\x12\x04\xac\x0f\x04\x20\x1a\x0f\x20Error\x20status.\n\
    \n\r\n\x05\x04.\x02\x02\x06\x12\x04\xac\x0f\x04\x15\n\r\n\x05\x04.\x02\
    \x02\x01\x12\x04\xac\x0f\x16\x1b\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xac\
    \x0f\x1e\x1f\n$\n\x04\x04.\x02\x03\x12\x04\xaf\x0f\x04!\x1a\x16\x20Resul\
    t\x20of\x20the\x20query.\n\n\r\n\x05\x04.\x02\x03\x06\x12\x04\xaf\x0f\
    \x04\x0f\n\r\n\x05\x04.\x02\x03\x01\x12\x04\xaf\x0f\x10\x1c\n\r\n\x05\
    \x04.\x02\x03\x03\x12\x04\xaf\x0f\x1f\x20\n\xa1\x01\n\x04\x04.\x02\x04\
    \x12\x04\xb3\x0f\x04.\x1a\x92\x01\x20Output\x20configuration\x20which\
    \x20indicates\x20instead\x20of\x20being\x20returned\x20in\x20API\n\x20re\
    sponse\x20on\x20the\x20fly,\x20the\x20query\x20result\x20will\x20be\x20s\
    aved\x20in\x20a\x20specific\x20output.\n\n\r\n\x05\x04.\x02\x04\x06\x12\
    \x04\xb3\x0f\x04\x1b\n\r\n\x05\x04.\x02\x04\x01\x12\x04\xb3\x0f\x1c)\n\r\
    \n\x05\x04.\x02\x04\x03\x12\x04\xb3\x0f,-\n\xeb\x01\n\x02\x04/\x12\x06\
    \xbc\x0f\0\xc8\x0f\x01\x1a\xdc\x01\x20Execution\x20results\x20of\x20the\
    \x20query.\n\n\x20The\x20result\x20is\x20formatted\x20as\x20rows\x20repr\
    esented\x20by\x20BigQuery\x20compatible\x20[schema].\n\x20When\x20pagina\
    tion\x20is\x20necessary,\x20it\x20will\x20contains\x20the\x20page\x20tok\
    en\x20to\x20retrieve\n\x20the\x20results\x20of\x20following\x20pages.\n\
    \n\x0b\n\x03\x04/\x01\x12\x04\xbc\x0f\x08\x13\nG\n\x04\x04/\x02\0\x12\
    \x04\xbe\x0f\x02+\x1a9\x20Each\x20row\x20hold\x20a\x20query\x20result\
    \x20in\x20the\x20format\x20of\x20`Struct`.\n\n\r\n\x05\x04/\x02\0\x04\
    \x12\x04\xbe\x0f\x02\n\n\r\n\x05\x04/\x02\0\x06\x12\x04\xbe\x0f\x0b!\n\r\
    \n\x05\x04/\x02\0\x01\x12\x04\xbe\x0f\"&\n\r\n\x05\x04/\x02\0\x03\x12\
    \x04\xbe\x0f)*\n3\n\x04\x04/\x02\x01\x12\x04\xc1\x0f\x02\x19\x1a%\x20Des\
    cribes\x20the\x20format\x20of\x20the\x20[rows].\n\n\r\n\x05\x04/\x02\x01\
    \x06\x12\x04\xc1\x0f\x02\r\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xc1\x0f\
    \x0e\x14\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xc1\x0f\x17\x18\n?\n\x04\x04\
    /\x02\x02\x12\x04\xc4\x0f\x02\x1d\x1a1\x20Token\x20to\x20retrieve\x20the\
    \x20next\x20page\x20of\x20the\x20results.\n\n\r\n\x05\x04/\x02\x02\x05\
    \x12\x04\xc4\x0f\x02\x08\n\r\n\x05\x04/\x02\x02\x01\x12\x04\xc4\x0f\t\
    \x18\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xc4\x0f\x1b\x1c\n6\n\x04\x04/\
    \x02\x03\x12\x04\xc7\x0f\x02\x17\x1a(\x20Total\x20rows\x20of\x20the\x20w\
    hole\x20query\x20results.\n\n\r\n\x05\x04/\x02\x03\x05\x12\x04\xc7\x0f\
    \x02\x07\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xc7\x0f\x08\x12\n\r\n\x05\
    \x04/\x02\x03\x03\x12\x04\xc7\x0f\x15\x16\n1\n\x02\x040\x12\x06\xcb\x0f\
    \0\xce\x0f\x01\x1a#\x20BigQuery\x20Compatible\x20table\x20schema.\n\n\
    \x0b\n\x03\x040\x01\x12\x04\xcb\x0f\x08\x13\n0\n\x04\x040\x02\0\x12\x04\
    \xcd\x0f\x02'\x1a\"\x20Describes\x20the\x20fields\x20in\x20a\x20table.\n\
    \n\r\n\x05\x040\x02\0\x04\x12\x04\xcd\x0f\x02\n\n\r\n\x05\x040\x02\0\x06\
    \x12\x04\xcd\x0f\x0b\x1b\n\r\n\x05\x040\x02\0\x01\x12\x04\xcd\x0f\x1c\"\
    \n\r\n\x05\x040\x02\0\x03\x12\x04\xcd\x0f%&\n'\n\x02\x041\x12\x06\xd1\
    \x0f\0\xef\x0f\x01\x1a\x19\x20A\x20field\x20in\x20TableSchema.\n\n\x0b\n\
    \x03\x041\x01\x12\x04\xd1\x0f\x08\x18\n\xc6\x01\n\x04\x041\x02\0\x12\x04\
    \xd5\x0f\x02\x13\x1a\xb7\x01\x20The\x20field\x20name.\x20The\x20name\x20\
    must\x20contain\x20only\x20letters\x20(a-z,\x20A-Z),\n\x20numbers\x20(0-\
    9),\x20or\x20underscores\x20(_),\x20and\x20must\x20start\x20with\x20a\
    \x20letter\x20or\n\x20underscore.\x20The\x20maximum\x20length\x20is\x201\
    28\x20characters.\n\n\r\n\x05\x041\x02\0\x05\x12\x04\xd5\x0f\x02\x08\n\r\
    \n\x05\x041\x02\0\x01\x12\x04\xd5\x0f\t\x0e\n\r\n\x05\x041\x02\0\x03\x12\
    \x04\xd5\x0f\x11\x12\n\x8e\x02\n\x04\x041\x02\x01\x12\x04\xe6\x0f\x02\
    \x12\x1a\xff\x01\x20The\x20field\x20data\x20type.\x20Possible\x20values\
    \x20include\n\x20*\x20STRING\n\x20*\x20BYTES\n\x20*\x20INTEGER\n\x20*\
    \x20FLOAT\n\x20*\x20BOOLEAN\n\x20*\x20TIMESTAMP\n\x20*\x20DATE\n\x20*\
    \x20TIME\n\x20*\x20DATETIME\n\x20*\x20GEOGRAPHY,\n\x20*\x20NUMERIC,\n\
    \x20*\x20BIGNUMERIC,\n\x20*\x20RECORD\n\x20(where\x20RECORD\x20indicates\
    \x20that\x20the\x20field\x20contains\x20a\x20nested\x20schema).\n\n\r\n\
    \x05\x041\x02\x01\x05\x12\x04\xe6\x0f\x02\x08\n\r\n\x05\x041\x02\x01\x01\
    \x12\x04\xe6\x0f\t\r\n\r\n\x05\x041\x02\x01\x03\x12\x04\xe6\x0f\x10\x11\
    \nx\n\x04\x041\x02\x02\x12\x04\xea\x0f\x02\x12\x1aj\x20The\x20field\x20m\
    ode.\x20Possible\x20values\x20include\x20NULLABLE,\x20REQUIRED\x20and\n\
    \x20REPEATED.\x20The\x20default\x20value\x20is\x20NULLABLE.\n\n\r\n\x05\
    \x041\x02\x02\x05\x12\x04\xea\x0f\x02\x08\n\r\n\x05\x041\x02\x02\x01\x12\
    \x04\xea\x0f\t\r\n\r\n\x05\x041\x02\x02\x03\x12\x04\xea\x0f\x10\x11\nZ\n\
    \x04\x041\x02\x03\x12\x04\xee\x0f\x02'\x1aL\x20Describes\x20the\x20neste\
    d\x20schema\x20fields\x20if\x20the\x20type\x20property\x20is\x20set\n\
    \x20to\x20RECORD.\n\n\r\n\x05\x041\x02\x03\x04\x12\x04\xee\x0f\x02\n\n\r\
    \n\x05\x041\x02\x03\x06\x12\x04\xee\x0f\x0b\x1b\n\r\n\x05\x041\x02\x03\
    \x01\x12\x04\xee\x0f\x1c\"\n\r\n\x05\x041\x02\x03\x03\x12\x04\xee\x0f%&\
    \n\x95\x01\n\x02\x042\x12\x06\xf3\x0f\0\x8d\x10\x01\x1a\x86\x01\x20A\x20\
    request\x20message\x20for\n\x20[AssetService.BatchGetEffectiveIamPolicie\
    s][google.cloud.asset.v1.AssetService.BatchGetEffectiveIamPolicies].\n\n\
    \x0b\n\x03\x042\x01\x12\x04\xf3\x0f\x08+\n\xfd\x04\n\x04\x042\x02\0\x12\
    \x06\xff\x0f\x02\x82\x10\x04\x1a\xec\x04\x20Required.\x20Only\x20IAM\x20\
    policies\x20on\x20or\x20below\x20the\x20scope\x20will\x20be\x20returned.\
    \n\n\x20This\x20can\x20only\x20be\x20an\x20organization\x20number\x20(su\
    ch\x20as\x20\"organizations/123\"),\x20a\n\x20folder\x20number\x20(such\
    \x20as\x20\"folders/123\"),\x20a\x20project\x20ID\x20(such\x20as\n\x20\"\
    projects/my-project-id\"),\x20or\x20a\x20project\x20number\x20(such\x20a\
    s\x20\"projects/12345\").\n\n\x20To\x20know\x20how\x20to\x20get\x20organ\
    ization\x20id,\x20visit\x20[here\n\x20](https://cloud.google.com/resourc\
    e-manager/docs/creating-managing-organization#retrieving_your_organizati\
    on_id).\n\n\x20To\x20know\x20how\x20to\x20get\x20folder\x20or\x20project\
    \x20id,\x20visit\x20[here\n\x20](https://cloud.google.com/resource-manag\
    er/docs/creating-managing-folders#viewing_or_listing_folders_and_project\
    s).\n\n\r\n\x05\x042\x02\0\x05\x12\x04\xff\x0f\x02\x08\n\r\n\x05\x042\
    \x02\0\x01\x12\x04\xff\x0f\t\x0e\n\r\n\x05\x042\x02\0\x03\x12\x04\xff\
    \x0f\x11\x12\n\x0f\n\x05\x042\x02\0\x08\x12\x06\xff\x0f\x13\x82\x10\x03\
    \n\x10\n\x08\x042\x02\0\x08\x9c\x08\0\x12\x04\x80\x10\x04*\n\x0f\n\x07\
    \x042\x02\0\x08\x9f\x08\x12\x04\x81\x10\x049\n\xd6\x02\n\x04\x042\x02\
    \x01\x12\x06\x89\x10\x02\x8c\x10\x04\x1a\xc5\x02\x20Required.\x20The\x20\
    names\x20refer\x20to\x20the\x20[full_resource_names]\n\x20(https://cloud\
    .google.com/asset-inventory/docs/resource-name-format)\n\x20of\x20[searc\
    hable\x20asset\n\x20types](https://cloud.google.com/asset-inventory/docs\
    /supported-asset-types#searchable_asset_types).\n\x20A\x20maximum\x20of\
    \x2020\x20resources'\x20effective\x20policies\x20can\x20be\x20retrieved\
    \x20in\x20a\x20batch.\n\n\r\n\x05\x042\x02\x01\x04\x12\x04\x89\x10\x02\n\
    \n\r\n\x05\x042\x02\x01\x05\x12\x04\x89\x10\x0b\x11\n\r\n\x05\x042\x02\
    \x01\x01\x12\x04\x89\x10\x12\x17\n\r\n\x05\x042\x02\x01\x03\x12\x04\x89\
    \x10\x1a\x1b\n\x0f\n\x05\x042\x02\x01\x08\x12\x06\x89\x10\x1c\x8c\x10\
    \x03\n\x10\n\x08\x042\x02\x01\x08\x9c\x08\0\x12\x04\x8a\x10\x04*\n\x0f\n\
    \x07\x042\x02\x01\x08\x9f\x08\x12\x04\x8b\x10\x043\n\x96\x01\n\x02\x043\
    \x12\x06\x91\x10\0\xc7\x10\x01\x1a\x87\x01\x20A\x20response\x20message\
    \x20for\n\x20[AssetService.BatchGetEffectiveIamPolicies][google.cloud.as\
    set.v1.AssetService.BatchGetEffectiveIamPolicies].\n\n\x0b\n\x03\x043\
    \x01\x12\x04\x91\x10\x08,\n=\n\x04\x043\x03\0\x12\x06\x93\x10\x02\xbe\
    \x10\x03\x1a-\x20The\x20effective\x20IAM\x20policies\x20on\x20one\x20res\
    ource.\n\n\r\n\x05\x043\x03\0\x01\x12\x04\x93\x10\n\x1c\n=\n\x06\x043\
    \x03\0\x03\0\x12\x06\x95\x10\x04\x9e\x10\x05\x1a+\x20The\x20IAM\x20polic\
    y\x20and\x20its\x20attached\x20resource.\n\n\x0f\n\x07\x043\x03\0\x03\0\
    \x01\x12\x04\x95\x10\x0c\x16\n\xb4\x01\n\x08\x043\x03\0\x03\0\x02\0\x12\
    \x04\x99\x10\x06#\x1a\xa1\x01\x20The\x20full\x20resource\x20name\x20the\
    \n\x20[policy][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesRespons\
    e.EffectiveIamPolicy.PolicyInfo.policy]\n\x20is\x20directly\x20attached\
    \x20to.\n\n\x11\n\t\x043\x03\0\x03\0\x02\0\x05\x12\x04\x99\x10\x06\x0c\n\
    \x11\n\t\x043\x03\0\x03\0\x02\0\x01\x12\x04\x99\x10\r\x1e\n\x11\n\t\x043\
    \x03\0\x03\0\x02\0\x03\x12\x04\x99\x10!\"\n\xc5\x01\n\x08\x043\x03\0\x03\
    \0\x02\x01\x12\x04\x9d\x10\x06&\x1a\xb2\x01\x20The\x20IAM\x20policy\x20t\
    hat's\x20directly\x20attached\x20to\x20the\n\x20[attached_resource][goog\
    le.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolic\
    y.PolicyInfo.attached_resource].\n\n\x11\n\t\x043\x03\0\x03\0\x02\x01\
    \x06\x12\x04\x9d\x10\x06\x1a\n\x11\n\t\x043\x03\0\x03\0\x02\x01\x01\x12\
    \x04\x9d\x10\x1b!\n\x11\n\t\x043\x03\0\x03\0\x02\x01\x03\x12\x04\x9d\x10\
    $%\n\x99\x03\n\x06\x043\x03\0\x02\0\x12\x04\xa7\x10\x04\"\x1a\x88\x03\
    \x20The\x20[full_resource_name]\n\x20(https://cloud.google.com/asset-inv\
    entory/docs/resource-name-format)\n\x20for\x20which\x20the\n\x20[policie\
    s][google.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveI\
    amPolicy.policies]\n\x20are\x20computed.\x20This\x20is\x20one\x20of\x20t\
    he\n\x20[BatchGetEffectiveIamPoliciesRequest.names][google.cloud.asset.v\
    1.BatchGetEffectiveIamPoliciesRequest.names]\n\x20the\x20caller\x20provi\
    des\x20in\x20the\x20request.\n\n\x0f\n\x07\x043\x03\0\x02\0\x05\x12\x04\
    \xa7\x10\x04\n\n\x0f\n\x07\x043\x03\0\x02\0\x01\x12\x04\xa7\x10\x0b\x1d\
    \n\x0f\n\x07\x043\x03\0\x02\0\x03\x12\x04\xa7\x10\x20!\n\x95\x0b\n\x06\
    \x043\x03\0\x02\x01\x12\x04\xbd\x10\x04%\x1a\x84\x0b\x20The\x20effective\
    \x20policies\x20for\x20the\n\x20[full_resource_name][google.cloud.asset.\
    v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full_resource\
    _name].\n\n\x20These\x20policies\x20include\x20the\x20policy\x20set\x20o\
    n\x20the\n\x20[full_resource_name][google.cloud.asset.v1.BatchGetEffecti\
    veIamPoliciesResponse.EffectiveIamPolicy.full_resource_name]\n\x20and\
    \x20those\x20set\x20on\x20its\x20parents\x20and\x20ancestors\x20up\x20to\
    \x20the\n\x20[BatchGetEffectiveIamPoliciesRequest.scope][google.cloud.as\
    set.v1.BatchGetEffectiveIamPoliciesRequest.scope].\n\x20Note\x20that\x20\
    these\x20policies\x20are\x20not\x20filtered\x20according\x20to\x20the\
    \x20resource\x20type\n\x20of\x20the\n\x20[full_resource_name][google.clo\
    ud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full\
    _resource_name].\n\n\x20These\x20policies\x20are\x20hierarchically\x20or\
    dered\x20by\n\x20[PolicyInfo.attached_resource][google.cloud.asset.v1.Ba\
    tchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attache\
    d_resource]\n\x20starting\x20from\n\x20[full_resource_name][google.cloud\
    .asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.full_r\
    esource_name]\n\x20itself\x20to\x20its\x20parents\x20and\x20ancestors,\
    \x20such\x20that\x20policies[i]'s\n\x20[PolicyInfo.attached_resource][go\
    ogle.cloud.asset.v1.BatchGetEffectiveIamPoliciesResponse.EffectiveIamPol\
    icy.PolicyInfo.attached_resource]\n\x20is\x20the\x20child\x20of\x20polic\
    ies[i+1]'s\n\x20[PolicyInfo.attached_resource][google.cloud.asset.v1.Bat\
    chGetEffectiveIamPoliciesResponse.EffectiveIamPolicy.PolicyInfo.attached\
    _resource],\n\x20if\x20policies[i+1]\x20exists.\n\n\x0f\n\x07\x043\x03\0\
    \x02\x01\x04\x12\x04\xbd\x10\x04\x0c\n\x0f\n\x07\x043\x03\0\x02\x01\x06\
    \x12\x04\xbd\x10\r\x17\n\x0f\n\x07\x043\x03\0\x02\x01\x01\x12\x04\xbd\
    \x10\x18\x20\n\x0f\n\x07\x043\x03\0\x02\x01\x03\x12\x04\xbd\x10#$\n\xd0\
    \x03\n\x04\x043\x02\0\x12\x04\xc6\x10\x021\x1a\xc1\x03\x20The\x20effecti\
    ve\x20policies\x20for\x20a\x20batch\x20of\x20resources.\x20Note\x20that\
    \x20the\x20results\n\x20order\x20is\x20the\x20same\x20as\x20the\x20order\
    \x20of\n\x20[BatchGetEffectiveIamPoliciesRequest.names][google.cloud.ass\
    et.v1.BatchGetEffectiveIamPoliciesRequest.names].\n\x20When\x20a\x20reso\
    urce\x20does\x20not\x20have\x20any\x20effective\x20IAM\x20policies,\x20i\
    ts\x20corresponding\n\x20policy_result\x20will\x20contain\x20empty\n\x20\
    [EffectiveIamPolicy.policies][google.cloud.asset.v1.BatchGetEffectiveIam\
    PoliciesResponse.EffectiveIamPolicy.policies].\n\n\r\n\x05\x043\x02\0\
    \x04\x12\x04\xc6\x10\x02\n\n\r\n\x05\x043\x02\0\x06\x12\x04\xc6\x10\x0b\
    \x1d\n\r\n\x05\x043\x02\0\x01\x12\x04\xc6\x10\x1e,\n\r\n\x05\x043\x02\0\
    \x03\x12\x04\xc6\x10/0\n\xfc\x01\n\x02\x044\x12\x06\xcd\x10\0\x95\x11\
    \x01\x1a\xed\x01\x20This\x20organization\x20policy\x20message\x20is\x20a\
    \x20modified\x20version\x20of\x20the\x20one\x20defined\x20in\n\x20the\
    \x20Organization\x20Policy\x20system.\x20This\x20message\x20contains\x20\
    several\x20fields\x20defined\n\x20in\x20the\x20original\x20organization\
    \x20policy\x20with\x20some\x20new\x20fields\x20for\x20analysis\n\x20purp\
    ose.\n\n\x0b\n\x03\x044\x01\x12\x04\xcd\x10\x08\x19\n\x96\x02\n\x04\x044\
    \x03\0\x12\x06\xd2\x10\x02\xf1\x10\x03\x1a\x85\x02\x20This\x20rule\x20me\
    ssage\x20is\x20a\x20customized\x20version\x20of\x20the\x20one\x20defined\
    \x20in\x20the\n\x20Organization\x20Policy\x20system.\x20In\x20addition\
    \x20to\x20the\x20fields\x20defined\x20in\x20the\n\x20original\x20organiz\
    ation\x20policy,\x20it\x20contains\x20additional\x20field(s)\x20under\n\
    \x20specific\x20circumstances\x20to\x20support\x20analysis\x20results.\n\
    \n\r\n\x05\x044\x03\0\x01\x12\x04\xd2\x10\n\x0e\n?\n\x06\x044\x03\0\x03\
    \0\x12\x06\xd4\x10\x04\xda\x10\x05\x1a-\x20The\x20string\x20values\x20fo\
    r\x20the\x20list\x20constraints.\n\n\x0f\n\x07\x044\x03\0\x03\0\x01\x12\
    \x04\xd4\x10\x0c\x18\n<\n\x08\x044\x03\0\x03\0\x02\0\x12\x04\xd6\x10\x06\
    )\x1a*\x20List\x20of\x20values\x20allowed\x20at\x20this\x20resource.\n\n\
    \x11\n\t\x044\x03\0\x03\0\x02\0\x04\x12\x04\xd6\x10\x06\x0e\n\x11\n\t\
    \x044\x03\0\x03\0\x02\0\x05\x12\x04\xd6\x10\x0f\x15\n\x11\n\t\x044\x03\0\
    \x03\0\x02\0\x01\x12\x04\xd6\x10\x16$\n\x11\n\t\x044\x03\0\x03\0\x02\0\
    \x03\x12\x04\xd6\x10'(\n;\n\x08\x044\x03\0\x03\0\x02\x01\x12\x04\xd9\x10\
    \x06(\x1a)\x20List\x20of\x20values\x20denied\x20at\x20this\x20resource.\
    \n\n\x11\n\t\x044\x03\0\x03\0\x02\x01\x04\x12\x04\xd9\x10\x06\x0e\n\x11\
    \n\t\x044\x03\0\x03\0\x02\x01\x05\x12\x04\xd9\x10\x0f\x15\n\x11\n\t\x044\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xd9\x10\x16#\n\x11\n\t\x044\x03\0\x03\0\
    \x02\x01\x03\x12\x04\xd9\x10&'\n\x10\n\x06\x044\x03\0\x08\0\x12\x06\xdc\
    \x10\x04\xed\x10\x05\n\x0f\n\x07\x044\x03\0\x08\0\x01\x12\x04\xdc\x10\n\
    \x0e\n~\n\x06\x044\x03\0\x02\0\x12\x04\xdf\x10\x06\x1e\x1an\x20List\x20o\
    f\x20values\x20to\x20be\x20used\x20for\x20this\x20PolicyRule.\x20This\
    \x20field\x20can\x20be\x20set\n\x20only\x20in\x20Policies\x20for\x20list\
    \x20constraints.\n\n\x0f\n\x07\x044\x03\0\x02\0\x06\x12\x04\xdf\x10\x06\
    \x12\n\x0f\n\x07\x044\x03\0\x02\0\x01\x12\x04\xdf\x10\x13\x19\n\x0f\n\
    \x07\x044\x03\0\x02\0\x03\x12\x04\xdf\x10\x1c\x1d\n\x87\x01\n\x06\x044\
    \x03\0\x02\x01\x12\x04\xe3\x10\x06\x19\x1aw\x20Setting\x20this\x20to\x20\
    true\x20means\x20that\x20all\x20values\x20are\x20allowed.\x20This\x20fie\
    ld\x20can\n\x20be\x20set\x20only\x20in\x20Policies\x20for\x20list\x20con\
    straints.\n\n\x0f\n\x07\x044\x03\0\x02\x01\x05\x12\x04\xe3\x10\x06\n\n\
    \x0f\n\x07\x044\x03\0\x02\x01\x01\x12\x04\xe3\x10\x0b\x14\n\x0f\n\x07\
    \x044\x03\0\x02\x01\x03\x12\x04\xe3\x10\x17\x18\n\x86\x01\n\x06\x044\x03\
    \0\x02\x02\x12\x04\xe7\x10\x06\x18\x1av\x20Setting\x20this\x20to\x20true\
    \x20means\x20that\x20all\x20values\x20are\x20denied.\x20This\x20field\
    \x20can\n\x20be\x20set\x20only\x20in\x20Policies\x20for\x20list\x20const\
    raints.\n\n\x0f\n\x07\x044\x03\0\x02\x02\x05\x12\x04\xe7\x10\x06\n\n\x0f\
    \n\x07\x044\x03\0\x02\x02\x01\x12\x04\xe7\x10\x0b\x13\n\x0f\n\x07\x044\
    \x03\0\x02\x02\x03\x12\x04\xe7\x10\x16\x17\n\xb0\x01\n\x06\x044\x03\0\
    \x02\x03\x12\x04\xec\x10\x06\x17\x1a\x9f\x01\x20If\x20`true`,\x20then\
    \x20the\x20`Policy`\x20is\x20enforced.\x20If\x20`false`,\x20then\x20any\
    \n\x20configuration\x20is\x20acceptable.\n\x20This\x20field\x20can\x20be\
    \x20set\x20only\x20in\x20Policies\x20for\x20boolean\x20constraints.\n\n\
    \x0f\n\x07\x044\x03\0\x02\x03\x05\x12\x04\xec\x10\x06\n\n\x0f\n\x07\x044\
    \x03\0\x02\x03\x01\x12\x04\xec\x10\x0b\x12\n\x0f\n\x07\x044\x03\0\x02\
    \x03\x03\x12\x04\xec\x10\x15\x16\n9\n\x06\x044\x03\0\x02\x04\x12\x04\xf0\
    \x10\x04#\x1a)\x20The\x20evaluating\x20condition\x20for\x20this\x20rule.\
    \n\n\x0f\n\x07\x044\x03\0\x02\x04\x06\x12\x04\xf0\x10\x04\x14\n\x0f\n\
    \x07\x044\x03\0\x02\x04\x01\x12\x04\xf0\x10\x15\x1e\n\x0f\n\x07\x044\x03\
    \0\x02\x04\x03\x12\x04\xf0\x10!\"\n\xaf\x02\n\x04\x044\x02\0\x12\x04\xfa\
    \x10\x02\x1f\x1a\xa0\x02\x20The\x20[full\x20resource\x20name]\n\x20(http\
    s://cloud.google.com/asset-inventory/docs/resource-name-format)\x20of\n\
    \x20an\x20organization/folder/project\x20resource\x20where\x20this\x20or\
    ganization\x20policy\x20is\n\x20set.\n\n\x20Notice\x20that\x20some\x20ty\
    pe\x20of\x20constraints\x20are\x20defined\x20with\x20default\x20policy.\
    \x20This\n\x20field\x20will\x20be\x20empty\x20for\x20them.\n\n\r\n\x05\
    \x044\x02\0\x05\x12\x04\xfa\x10\x02\x08\n\r\n\x05\x044\x02\0\x01\x12\x04\
    \xfa\x10\t\x1a\n\r\n\x05\x044\x02\0\x03\x12\x04\xfa\x10\x1d\x1e\n\xeb\
    \x02\n\x04\x044\x02\x01\x12\x04\x84\x11\x02\x1e\x1a\xdc\x02\x20The\x20[f\
    ull\x20resource\x20name]\n\x20(https://cloud.google.com/asset-inventory/\
    docs/resource-name-format)\x20of\n\x20an\x20organization/folder/project\
    \x20resource\x20where\x20this\x20organization\x20policy\n\x20applies\x20\
    to.\n\n\x20For\x20any\x20user\x20defined\x20org\x20policies,\x20this\x20\
    field\x20has\x20the\x20same\x20value\x20as\n\x20the\x20[attached_resourc\
    e]\x20field.\x20Only\x20for\x20default\x20policy,\x20this\x20field\x20ha\
    s\n\x20the\x20different\x20value.\n\n\r\n\x05\x044\x02\x01\x05\x12\x04\
    \x84\x11\x02\x08\n\r\n\x05\x044\x02\x01\x01\x12\x04\x84\x11\t\x19\n\r\n\
    \x05\x044\x02\x01\x03\x12\x04\x84\x11\x1c\x1d\n;\n\x04\x044\x02\x02\x12\
    \x04\x87\x11\x02\x1a\x1a-\x20List\x20of\x20rules\x20for\x20this\x20organ\
    ization\x20policy.\n\n\r\n\x05\x044\x02\x02\x04\x12\x04\x87\x11\x02\n\n\
    \r\n\x05\x044\x02\x02\x06\x12\x04\x87\x11\x0b\x0f\n\r\n\x05\x044\x02\x02\
    \x01\x12\x04\x87\x11\x10\x15\n\r\n\x05\x044\x02\x02\x03\x12\x04\x87\x11\
    \x18\x19\n\x8e\x02\n\x04\x044\x02\x03\x12\x04\x8d\x11\x02\x1f\x1a\xff\
    \x01\x20If\x20`inherit_from_parent`\x20is\x20true,\x20Rules\x20set\x20hi\
    gher\x20up\x20in\x20the\n\x20hierarchy\x20(up\x20to\x20the\x20closest\
    \x20root)\x20are\x20inherited\x20and\x20present\x20in\x20the\n\x20effect\
    ive\x20policy.\x20If\x20it\x20is\x20false,\x20then\x20no\x20rules\x20are\
    \x20inherited,\x20and\x20this\n\x20policy\x20becomes\x20the\x20effective\
    \x20root\x20for\x20evaluation.\n\n\r\n\x05\x044\x02\x03\x05\x12\x04\x8d\
    \x11\x02\x06\n\r\n\x05\x044\x02\x03\x01\x12\x04\x8d\x11\x07\x1a\n\r\n\
    \x05\x044\x02\x03\x03\x12\x04\x8d\x11\x1d\x1e\n\x9b\x02\n\x04\x044\x02\
    \x04\x12\x04\x94\x11\x02\x11\x1a\x8c\x02\x20Ignores\x20policies\x20set\
    \x20above\x20this\x20resource\x20and\x20restores\x20the\x20default\x20be\
    havior\n\x20of\x20the\x20constraint\x20at\x20this\x20resource.\n\x20This\
    \x20field\x20can\x20be\x20set\x20in\x20policies\x20for\x20either\x20list\
    \x20or\x20boolean\n\x20constraints.\x20If\x20set,\x20`rules`\x20must\x20\
    be\x20empty\x20and\x20`inherit_from_parent`\n\x20must\x20be\x20set\x20to\
    \x20false.\n\n\r\n\x05\x044\x02\x04\x05\x12\x04\x94\x11\x02\x06\n\r\n\
    \x05\x044\x02\x04\x01\x12\x04\x94\x11\x07\x0c\n\r\n\x05\x044\x02\x04\x03\
    \x12\x04\x94\x11\x0f\x10\n>\n\x02\x045\x12\x06\x98\x11\0\xa3\x12\x01\x1a\
    0\x20The\x20organization\x20policy\x20constraint\x20definition.\n\n\x0b\
    \n\x03\x045\x01\x12\x04\x98\x11\x08#\n1\n\x04\x045\x03\0\x12\x06\x9a\x11\
    \x02\xdb\x11\x03\x1a!\x20The\x20definition\x20of\x20a\x20constraint.\n\n\
    \r\n\x05\x045\x03\0\x01\x12\x04\x9a\x11\n\x14\n\x9c\x01\n\x06\x045\x03\0\
    \x04\0\x12\x06\x9d\x11\x04\xa9\x11\x05\x1a\x89\x01\x20Specifies\x20the\
    \x20default\x20behavior\x20in\x20the\x20absence\x20of\x20any\x20`Policy`\
    \x20for\x20the\n\x20`Constraint`.\x20This\x20must\x20not\x20be\x20`CONST\
    RAINT_DEFAULT_UNSPECIFIED`.\n\n\x0f\n\x07\x045\x03\0\x04\0\x01\x12\x04\
    \x9d\x11\t\x1a\n`\n\x08\x045\x03\0\x04\0\x02\0\x12\x04\xa0\x11\x06)\x1aN\
    \x20This\x20is\x20only\x20used\x20for\x20distinguishing\x20unset\x20valu\
    es\x20and\x20should\x20never\x20be\n\x20used.\n\n\x11\n\t\x045\x03\0\x04\
    \0\x02\0\x01\x12\x04\xa0\x11\x06$\n\x11\n\t\x045\x03\0\x04\0\x02\0\x02\
    \x12\x04\xa0\x11'(\n\x89\x01\n\x08\x045\x03\0\x04\0\x02\x01\x12\x04\xa4\
    \x11\x06\x10\x1aw\x20Indicate\x20that\x20all\x20values\x20are\x20allowed\
    \x20for\x20list\x20constraints.\n\x20Indicate\x20that\x20enforcement\x20\
    is\x20off\x20for\x20boolean\x20constraints.\n\n\x11\n\t\x045\x03\0\x04\0\
    \x02\x01\x01\x12\x04\xa4\x11\x06\x0b\n\x11\n\t\x045\x03\0\x04\0\x02\x01\
    \x02\x12\x04\xa4\x11\x0e\x0f\n\x87\x01\n\x08\x045\x03\0\x04\0\x02\x02\
    \x12\x04\xa8\x11\x06\x0f\x1au\x20Indicate\x20that\x20all\x20values\x20ar\
    e\x20denied\x20for\x20list\x20constraints.\n\x20Indicate\x20that\x20enfo\
    rcement\x20is\x20on\x20for\x20boolean\x20constraints.\n\n\x11\n\t\x045\
    \x03\0\x04\0\x02\x02\x01\x12\x04\xa8\x11\x06\n\n\x11\n\t\x045\x03\0\x04\
    \0\x02\x02\x02\x12\x04\xa8\x11\r\x0e\n\xa6\x01\n\x06\x045\x03\0\x03\0\
    \x12\x06\xad\x11\x04\xb8\x11\x05\x1a\x93\x01\x20A\x20`Constraint`\x20tha\
    t\x20allows\x20or\x20disallows\x20a\x20list\x20of\x20string\x20values,\
    \x20which\n\x20are\x20configured\x20by\x20an\x20organization's\x20policy\
    \x20administrator\x20with\x20a\x20`Policy`.\n\n\x0f\n\x07\x045\x03\0\x03\
    \0\x01\x12\x04\xad\x11\x0c\x1a\n\xd2\x01\n\x08\x045\x03\0\x03\0\x02\0\
    \x12\x04\xb1\x11\x06\x1b\x1a\xbf\x01\x20Indicates\x20whether\x20values\
    \x20grouped\x20into\x20categories\x20can\x20be\x20used\x20in\n\x20`Polic\
    y.allowed_values`\x20and\x20`Policy.denied_values`.\x20For\x20example,\n\
    \x20`\"in:Python\"`\x20would\x20match\x20any\x20value\x20in\x20the\x20'P\
    ython'\x20group.\n\n\x11\n\t\x045\x03\0\x03\0\x02\0\x05\x12\x04\xb1\x11\
    \x06\n\n\x11\n\t\x045\x03\0\x03\0\x02\0\x01\x12\x04\xb1\x11\x0b\x16\n\
    \x11\n\t\x045\x03\0\x03\0\x02\0\x03\x12\x04\xb1\x11\x19\x1a\n\xfe\x01\n\
    \x08\x045\x03\0\x03\0\x02\x01\x12\x04\xb7\x11\x06\x1e\x1a\xeb\x01\x20Ind\
    icates\x20whether\x20subtrees\x20of\x20Cloud\x20Resource\x20Manager\x20r\
    esource\x20hierarchy\n\x20can\x20be\x20used\x20in\x20`Policy.allowed_val\
    ues`\x20and\x20`Policy.denied_values`.\x20For\n\x20example,\x20`\"under:\
    folders/123\"`\x20would\x20match\x20any\x20resource\x20under\x20the\n\
    \x20'folders/123'\x20folder.\n\n\x11\n\t\x045\x03\0\x03\0\x02\x01\x05\
    \x12\x04\xb7\x11\x06\n\n\x11\n\t\x045\x03\0\x03\0\x02\x01\x01\x12\x04\
    \xb7\x11\x0b\x19\n\x11\n\t\x045\x03\0\x03\0\x02\x01\x03\x12\x04\xb7\x11\
    \x1c\x1d\n\xee\x01\n\x06\x045\x03\0\x03\x01\x12\x04\xbf\x11\x04\x20\x1a\
    \xdd\x01\x20A\x20`Constraint`\x20that\x20is\x20either\x20enforced\x20or\
    \x20not.\n\n\x20For\x20example\x20a\x20constraint\x20`constraints/comput\
    e.disableSerialPortAccess`.\n\x20If\x20it\x20is\x20enforced\x20on\x20a\
    \x20VM\x20instance,\x20serial\x20port\x20connections\x20will\x20not\x20b\
    e\n\x20opened\x20to\x20that\x20instance.\n\n\x0f\n\x07\x045\x03\0\x03\
    \x01\x01\x12\x04\xbf\x11\x0c\x1d\n\xb3\x01\n\x06\x045\x03\0\x02\0\x12\
    \x04\xc5\x11\x04\x14\x1a\xa2\x01\x20The\x20unique\x20name\x20of\x20the\
    \x20constraint.\x20Format\x20of\x20the\x20name\x20should\x20be\n\x20*\
    \x20`constraints/{constraint_name}`\n\n\x20For\x20example,\x20`constrain\
    ts/compute.disableSerialPortAccess`.\n\n\x0f\n\x07\x045\x03\0\x02\0\x05\
    \x12\x04\xc5\x11\x04\n\n\x0f\n\x07\x045\x03\0\x02\0\x01\x12\x04\xc5\x11\
    \x0b\x0f\n\x0f\n\x07\x045\x03\0\x02\0\x03\x12\x04\xc5\x11\x12\x13\n<\n\
    \x06\x045\x03\0\x02\x01\x12\x04\xc8\x11\x04\x1c\x1a,\x20The\x20human\x20\
    readable\x20name\x20of\x20the\x20constraint.\n\n\x0f\n\x07\x045\x03\0\
    \x02\x01\x05\x12\x04\xc8\x11\x04\n\n\x0f\n\x07\x045\x03\0\x02\x01\x01\
    \x12\x04\xc8\x11\x0b\x17\n\x0f\n\x07\x045\x03\0\x02\x01\x03\x12\x04\xc8\
    \x11\x1a\x1b\ns\n\x06\x045\x03\0\x02\x02\x12\x04\xcc\x11\x04\x1b\x1ac\
    \x20Detailed\x20description\x20of\x20what\x20this\x20`Constraint`\x20con\
    trols\x20as\x20well\x20as\x20how\n\x20and\x20where\x20it\x20is\x20enforc\
    ed.\n\n\x0f\n\x07\x045\x03\0\x02\x02\x05\x12\x04\xcc\x11\x04\n\n\x0f\n\
    \x07\x045\x03\0\x02\x02\x01\x12\x04\xcc\x11\x0b\x16\n\x0f\n\x07\x045\x03\
    \0\x02\x02\x03\x12\x04\xcc\x11\x19\x1a\nX\n\x06\x045\x03\0\x02\x03\x12\
    \x04\xcf\x11\x04-\x1aH\x20The\x20evaluation\x20behavior\x20of\x20this\
    \x20constraint\x20in\x20the\x20absence\x20of\x20'Policy'.\n\n\x0f\n\x07\
    \x045\x03\0\x02\x03\x06\x12\x04\xcf\x11\x04\x15\n\x0f\n\x07\x045\x03\0\
    \x02\x03\x01\x12\x04\xcf\x11\x16(\n\x0f\n\x07\x045\x03\0\x02\x03\x03\x12\
    \x04\xcf\x11+,\n_\n\x06\x045\x03\0\x08\0\x12\x06\xd4\x11\x04\xda\x11\x05\
    \x1aM\x20The\x20type\x20of\x20restrictions\x20for\x20this\x20`Constraint\
    `.\n\n\x20Immutable\x20after\x20creation.\n\n\x0f\n\x07\x045\x03\0\x08\0\
    \x01\x12\x04\xd4\x11\n\x19\nD\n\x06\x045\x03\0\x02\x04\x12\x04\xd6\x11\
    \x06)\x1a4\x20Defines\x20this\x20constraint\x20as\x20being\x20a\x20ListC\
    onstraint.\n\n\x0f\n\x07\x045\x03\0\x02\x04\x06\x12\x04\xd6\x11\x06\x14\
    \n\x0f\n\x07\x045\x03\0\x02\x04\x01\x12\x04\xd6\x11\x15$\n\x0f\n\x07\x04\
    5\x03\0\x02\x04\x03\x12\x04\xd6\x11'(\nG\n\x06\x045\x03\0\x02\x05\x12\
    \x04\xd9\x11\x06/\x1a7\x20Defines\x20this\x20constraint\x20as\x20being\
    \x20a\x20BooleanConstraint.\n\n\x0f\n\x07\x045\x03\0\x02\x05\x06\x12\x04\
    \xd9\x11\x06\x17\n\x0f\n\x07\x045\x03\0\x02\x05\x01\x12\x04\xd9\x11\x18*\
    \n\x0f\n\x07\x045\x03\0\x02\x05\x03\x12\x04\xd9\x11-.\n8\n\x04\x045\x03\
    \x01\x12\x06\xde\x11\x02\x9a\x12\x03\x1a(\x20The\x20definition\x20of\x20\
    a\x20custom\x20constraint.\n\n\r\n\x05\x045\x03\x01\x01\x12\x04\xde\x11\
    \n\x1a\n\x99\x02\n\x06\x045\x03\x01\x04\0\x12\x06\xe3\x11\x04\xef\x11\
    \x05\x1a\x86\x02\x20The\x20operation\x20in\x20which\x20this\x20constrain\
    t\x20will\x20be\x20applied.\x20For\x20example:\n\x20If\x20the\x20constra\
    int\x20applies\x20only\x20when\x20create\x20VMs,\x20the\x20method_types\
    \x20will\x20be\n\x20\"CREATE\"\x20only.\x20If\x20the\x20constraint\x20ap\
    plied\x20when\x20create\x20or\x20delete\x20VMs,\x20the\n\x20method_types\
    \x20will\x20be\x20\"CREATE\"\x20and\x20\"DELETE\".\n\n\x0f\n\x07\x045\
    \x03\x01\x04\0\x01\x12\x04\xe3\x11\t\x13\n<\n\x08\x045\x03\x01\x04\0\x02\
    \0\x12\x04\xe5\x11\x06\"\x1a*\x20Unspecified.\x20Will\x20results\x20in\
    \x20user\x20error.\n\n\x11\n\t\x045\x03\x01\x04\0\x02\0\x01\x12\x04\xe5\
    \x11\x06\x1d\n\x11\n\t\x045\x03\x01\x04\0\x02\0\x02\x12\x04\xe5\x11\x20!\
    \nB\n\x08\x045\x03\x01\x04\0\x02\x01\x12\x04\xe8\x11\x06\x11\x1a0\x20Con\
    straint\x20applied\x20when\x20creating\x20the\x20resource.\n\n\x11\n\t\
    \x045\x03\x01\x04\0\x02\x01\x01\x12\x04\xe8\x11\x06\x0c\n\x11\n\t\x045\
    \x03\x01\x04\0\x02\x01\x02\x12\x04\xe8\x11\x0f\x10\nB\n\x08\x045\x03\x01\
    \x04\0\x02\x02\x12\x04\xeb\x11\x06\x11\x1a0\x20Constraint\x20applied\x20\
    when\x20updating\x20the\x20resource.\n\n\x11\n\t\x045\x03\x01\x04\0\x02\
    \x02\x01\x12\x04\xeb\x11\x06\x0c\n\x11\n\t\x045\x03\x01\x04\0\x02\x02\
    \x02\x12\x04\xeb\x11\x0f\x10\nB\n\x08\x045\x03\x01\x04\0\x02\x03\x12\x04\
    \xee\x11\x06\x11\x1a0\x20Constraint\x20applied\x20when\x20deleting\x20th\
    e\x20resource.\n\n\x11\n\t\x045\x03\x01\x04\0\x02\x03\x01\x12\x04\xee\
    \x11\x06\x0c\n\x11\n\t\x045\x03\x01\x04\0\x02\x03\x02\x12\x04\xee\x11\
    \x0f\x10\n'\n\x06\x045\x03\x01\x04\x01\x12\x06\xf2\x11\x04\xfb\x11\x05\
    \x1a\x15\x20Allow\x20or\x20deny\x20type.\n\n\x0f\n\x07\x045\x03\x01\x04\
    \x01\x01\x12\x04\xf2\x11\t\x13\n<\n\x08\x045\x03\x01\x04\x01\x02\0\x12\
    \x04\xf4\x11\x06\"\x1a*\x20Unspecified.\x20Will\x20results\x20in\x20user\
    \x20error.\n\n\x11\n\t\x045\x03\x01\x04\x01\x02\0\x01\x12\x04\xf4\x11\
    \x06\x1d\n\x11\n\t\x045\x03\x01\x04\x01\x02\0\x02\x12\x04\xf4\x11\x20!\n\
    (\n\x08\x045\x03\x01\x04\x01\x02\x01\x12\x04\xf7\x11\x06\x10\x1a\x16\x20\
    Allowed\x20action\x20type.\n\n\x11\n\t\x045\x03\x01\x04\x01\x02\x01\x01\
    \x12\x04\xf7\x11\x06\x0b\n\x11\n\t\x045\x03\x01\x04\x01\x02\x01\x02\x12\
    \x04\xf7\x11\x0e\x0f\n%\n\x08\x045\x03\x01\x04\x01\x02\x02\x12\x04\xfa\
    \x11\x06\x0f\x1a\x13\x20Deny\x20action\x20type.\n\n\x11\n\t\x045\x03\x01\
    \x04\x01\x02\x02\x01\x12\x04\xfa\x11\x06\n\n\x11\n\t\x045\x03\x01\x04\
    \x01\x02\x02\x02\x12\x04\xfa\x11\r\x0e\n\x8c\x02\n\x06\x045\x03\x01\x02\
    \0\x12\x04\x83\x12\x04\x14\x1a\xfb\x01\x20Name\x20of\x20the\x20constrain\
    t.\x20This\x20is\x20unique\x20within\x20the\x20organization.\x20Format\
    \x20of\n\x20the\x20name\x20should\x20be\n\x20*\x20`organizations/{organi\
    zation_id}/customConstraints/{custom_constraint_id}`\n\n\x20Example\x20:\
    \n\x20\"organizations/123/customConstraints/custom.createOnlyE2TypeVms\"\
    \n\n\x0f\n\x07\x045\x03\x01\x02\0\x05\x12\x04\x83\x12\x04\n\n\x0f\n\x07\
    \x045\x03\x01\x02\0\x01\x12\x04\x83\x12\x0b\x0f\n\x0f\n\x07\x045\x03\x01\
    \x02\0\x03\x12\x04\x83\x12\x12\x13\n\xbe\x01\n\x06\x045\x03\x01\x02\x01\
    \x12\x04\x88\x12\x04'\x1a\xad\x01\x20The\x20Resource\x20Instance\x20type\
    \x20on\x20which\x20this\x20policy\x20applies\x20to.\x20Format\x20will\n\
    \x20be\x20of\x20the\x20form\x20:\x20\"<canonical\x20service\x20name>/<ty\
    pe>\"\x20Example:\n\x20\x20*\x20`compute.googleapis.com/Instance`.\n\n\
    \x0f\n\x07\x045\x03\x01\x02\x01\x04\x12\x04\x88\x12\x04\x0c\n\x0f\n\x07\
    \x045\x03\x01\x02\x01\x05\x12\x04\x88\x12\r\x13\n\x0f\n\x07\x045\x03\x01\
    \x02\x01\x01\x12\x04\x88\x12\x14\"\n\x0f\n\x07\x045\x03\x01\x02\x01\x03\
    \x12\x04\x88\x12%&\nG\n\x06\x045\x03\x01\x02\x02\x12\x04\x8b\x12\x04)\
    \x1a7\x20All\x20the\x20operations\x20being\x20applied\x20for\x20this\x20\
    constraint.\n\n\x0f\n\x07\x045\x03\x01\x02\x02\x04\x12\x04\x8b\x12\x04\
    \x0c\n\x0f\n\x07\x045\x03\x01\x02\x02\x06\x12\x04\x8b\x12\r\x17\n\x0f\n\
    \x07\x045\x03\x01\x02\x02\x01\x12\x04\x8b\x12\x18$\n\x0f\n\x07\x045\x03\
    \x01\x02\x02\x03\x12\x04\x8b\x12'(\n\xb9\x01\n\x06\x045\x03\x01\x02\x03\
    \x12\x04\x90\x12\x04\x19\x1a\xa8\x01\x20Organization\x20Policy\x20condit\
    ion/expression.\x20For\x20example:\n\x20`resource.instanceName.matches(\
    \"[production|test]_.*_(\\d)+\")'`\x20or,\n\x20`resource.management.auto\
    _upgrade\x20==\x20true`\n\n\x0f\n\x07\x045\x03\x01\x02\x03\x05\x12\x04\
    \x90\x12\x04\n\n\x0f\n\x07\x045\x03\x01\x02\x03\x01\x12\x04\x90\x12\x0b\
    \x14\n\x0f\n\x07\x045\x03\x01\x02\x03\x03\x12\x04\x90\x12\x17\x18\n%\n\
    \x06\x045\x03\x01\x02\x04\x12\x04\x93\x12\x04\x1f\x1a\x15\x20Allow\x20or\
    \x20deny\x20type.\n\n\x0f\n\x07\x045\x03\x01\x02\x04\x06\x12\x04\x93\x12\
    \x04\x0e\n\x0f\n\x07\x045\x03\x01\x02\x04\x01\x12\x04\x93\x12\x0f\x1a\n\
    \x0f\n\x07\x045\x03\x01\x02\x04\x03\x12\x04\x93\x12\x1d\x1e\n3\n\x06\x04\
    5\x03\x01\x02\x05\x12\x04\x96\x12\x04\x1c\x1a#\x20One\x20line\x20display\
    \x20name\x20for\x20the\x20UI.\n\n\x0f\n\x07\x045\x03\x01\x02\x05\x05\x12\
    \x04\x96\x12\x04\n\n\x0f\n\x07\x045\x03\x01\x02\x05\x01\x12\x04\x96\x12\
    \x0b\x17\n\x0f\n\x07\x045\x03\x01\x02\x05\x03\x12\x04\x96\x12\x1a\x1b\nK\
    \n\x06\x045\x03\x01\x02\x06\x12\x04\x99\x12\x04\x1b\x1a;\x20Detailed\x20\
    information\x20about\x20this\x20custom\x20policy\x20constraint.\n\n\x0f\
    \n\x07\x045\x03\x01\x02\x06\x05\x12\x04\x99\x12\x04\n\n\x0f\n\x07\x045\
    \x03\x01\x02\x06\x01\x12\x04\x99\x12\x0b\x16\n\x0f\n\x07\x045\x03\x01\
    \x02\x06\x03\x12\x04\x99\x12\x19\x1a\n\x0e\n\x04\x045\x08\0\x12\x06\x9c\
    \x12\x02\xa2\x12\x03\n\r\n\x05\x045\x08\0\x01\x12\x04\x9c\x12\x08\x1d\nJ\
    \n\x04\x045\x02\0\x12\x04\x9e\x12\x04-\x1a<\x20The\x20definition\x20of\
    \x20the\x20canned\x20constraint\x20defined\x20by\x20Google.\n\n\r\n\x05\
    \x045\x02\0\x06\x12\x04\x9e\x12\x04\x0e\n\r\n\x05\x045\x02\0\x01\x12\x04\
    \x9e\x12\x0f(\n\r\n\x05\x045\x02\0\x03\x12\x04\x9e\x12+,\n8\n\x04\x045\
    \x02\x01\x12\x04\xa1\x12\x04+\x1a*\x20The\x20definition\x20of\x20the\x20\
    custom\x20constraint.\n\n\r\n\x05\x045\x02\x01\x06\x12\x04\xa1\x12\x04\
    \x14\n\r\n\x05\x045\x02\x01\x01\x12\x04\xa1\x12\x15&\n\r\n\x05\x045\x02\
    \x01\x03\x12\x04\xa1\x12)*\n\x80\x01\n\x02\x046\x12\x06\xa7\x12\0\xc4\
    \x12\x01\x1ar\x20A\x20request\x20message\x20for\n\x20[AssetService.Analy\
    zeOrgPolicies][google.cloud.asset.v1.AssetService.AnalyzeOrgPolicies].\n\
    \n\x0b\n\x03\x046\x01\x12\x04\xa7\x12\x08!\n\xc7\x01\n\x04\x046\x02\0\
    \x12\x04\xac\x12\x02<\x1a\xb8\x01\x20Required.\x20The\x20organization\
    \x20to\x20scope\x20the\x20request.\x20Only\x20organization\n\x20policies\
    \x20within\x20the\x20scope\x20will\x20be\x20analyzed.\n\n\x20*\x20organi\
    zations/{ORGANIZATION_NUMBER}\x20(e.g.,\x20\"organizations/123456\")\n\n\
    \r\n\x05\x046\x02\0\x05\x12\x04\xac\x12\x02\x08\n\r\n\x05\x046\x02\0\x01\
    \x12\x04\xac\x12\t\x0e\n\r\n\x05\x046\x02\0\x03\x12\x04\xac\x12\x11\x12\
    \n\r\n\x05\x046\x02\0\x08\x12\x04\xac\x12\x13;\n\x10\n\x08\x046\x02\0\
    \x08\x9c\x08\0\x12\x04\xac\x12\x14:\n\xb4\x01\n\x04\x046\x02\x01\x12\x04\
    \xb1\x12\x02A\x1a\xa5\x01\x20Required.\x20The\x20name\x20of\x20the\x20co\
    nstraint\x20to\x20analyze\x20organization\x20policies\x20for.\n\x20The\
    \x20response\x20only\x20contains\x20analyzed\x20organization\x20policies\
    \x20for\x20the\x20provided\n\x20constraint.\n\n\r\n\x05\x046\x02\x01\x05\
    \x12\x04\xb1\x12\x02\x08\n\r\n\x05\x046\x02\x01\x01\x12\x04\xb1\x12\t\
    \x13\n\r\n\x05\x046\x02\x01\x03\x12\x04\xb1\x12\x16\x17\n\r\n\x05\x046\
    \x02\x01\x08\x12\x04\xb1\x12\x18@\n\x10\n\x08\x046\x02\x01\x08\x9c\x08\0\
    \x12\x04\xb1\x12\x19?\n\xaa\x03\n\x04\x046\x02\x02\x12\x04\xbb\x12\x02\
    \x14\x1a\x9b\x03\x20The\x20expression\x20to\x20filter\n\x20[AnalyzeOrgPo\
    liciesResponse.org_policy_results][google.cloud.asset.v1.AnalyzeOrgPolic\
    iesResponse.org_policy_results].\n\x20The\x20only\x20supported\x20field\
    \x20is\x20`consolidated_policy.attached_resource`,\x20and\n\x20the\x20on\
    ly\x20supported\x20operator\x20is\x20`=`.\n\n\x20Example:\n\x20consolida\
    ted_policy.attached_resource=\"//cloudresourcemanager.googleapis.com/fol\
    ders/001\"\n\x20will\x20return\x20the\x20org\x20policy\x20results\x20of\
    \"folders/001\".\n\n\r\n\x05\x046\x02\x02\x05\x12\x04\xbb\x12\x02\x08\n\
    \r\n\x05\x046\x02\x02\x01\x12\x04\xbb\x12\t\x0f\n\r\n\x05\x046\x02\x02\
    \x03\x12\x04\xbb\x12\x12\x13\n\xf4\x01\n\x04\x046\x02\x03\x12\x04\xc0\
    \x12\x02\x1f\x1a\xe5\x01\x20The\x20maximum\x20number\x20of\x20items\x20t\
    o\x20return\x20per\x20page.\x20If\x20unspecified,\n\x20[AnalyzeOrgPolici\
    esResponse.org_policy_results][google.cloud.asset.v1.AnalyzeOrgPoliciesR\
    esponse.org_policy_results]\n\x20will\x20contain\x2020\x20items\x20with\
    \x20a\x20maximum\x20of\x20200.\n\n\r\n\x05\x046\x02\x03\x04\x12\x04\xc0\
    \x12\x02\n\n\r\n\x05\x046\x02\x03\x05\x12\x04\xc0\x12\x0b\x10\n\r\n\x05\
    \x046\x02\x03\x01\x12\x04\xc0\x12\x11\x1a\n\r\n\x05\x046\x02\x03\x03\x12\
    \x04\xc0\x12\x1d\x1e\n?\n\x04\x046\x02\x04\x12\x04\xc3\x12\x02\x18\x1a1\
    \x20The\x20pagination\x20token\x20to\x20retrieve\x20the\x20next\x20page.\
    \n\n\r\n\x05\x046\x02\x04\x05\x12\x04\xc3\x12\x02\x08\n\r\n\x05\x046\x02\
    \x04\x01\x12\x04\xc3\x12\t\x13\n\r\n\x05\x046\x02\x04\x03\x12\x04\xc3\
    \x12\x16\x17\n\x83\x01\n\x02\x047\x12\x06\xc8\x12\0\xe7\x12\x01\x1au\x20\
    The\x20response\x20message\x20for\n\x20[AssetService.AnalyzeOrgPolicies]\
    [google.cloud.asset.v1.AssetService.AnalyzeOrgPolicies].\n\n\x0b\n\x03\
    \x047\x01\x12\x04\xc8\x12\x08\"\n>\n\x04\x047\x03\0\x12\x06\xca\x12\x02\
    \xd9\x12\x03\x1a.\x20The\x20organization\x20policy\x20result\x20to\x20th\
    e\x20query.\n\n\r\n\x05\x047\x03\0\x01\x12\x04\xca\x12\n\x19\n\xf2\x02\n\
    \x06\x047\x03\0\x02\0\x12\x04\xd0\x12\x04.\x1a\xe1\x02\x20The\x20consoli\
    dated\x20organization\x20policy\x20for\x20the\x20analyzed\x20resource.\
    \x20The\n\x20consolidated\x20organization\x20policy\x20is\x20computed\
    \x20by\x20merging\x20and\x20evaluating\n\x20[AnalyzeOrgPoliciesResponse.\
    policy_bundle][].\n\x20The\x20evaluation\x20will\x20respect\x20the\x20or\
    ganization\x20policy\x20[hierarchy\n\x20rules](https://cloud.google.com/\
    resource-manager/docs/organization-policy/understanding-hierarchy).\n\n\
    \x0f\n\x07\x047\x03\0\x02\0\x06\x12\x04\xd0\x12\x04\x15\n\x0f\n\x07\x047\
    \x03\0\x02\0\x01\x12\x04\xd0\x12\x16)\n\x0f\n\x07\x047\x03\0\x02\0\x03\
    \x12\x04\xd0\x12,-\n\x9e\x02\n\x06\x047\x03\0\x02\x01\x12\x04\xd8\x12\
    \x041\x1a\x8d\x02\x20The\x20ordered\x20list\x20of\x20all\x20organization\
    \x20policies\x20from\x20the\n\x20[AnalyzeOrgPoliciesResponse.OrgPolicyRe\
    sult.consolidated_policy.attached_resource][].\n\x20to\x20the\x20scope\
    \x20specified\x20in\x20the\x20request.\n\n\x20If\x20the\x20constraint\
    \x20is\x20defined\x20with\x20default\x20policy,\x20it\x20will\x20also\
    \x20appear\x20in\n\x20the\x20list.\n\n\x0f\n\x07\x047\x03\0\x02\x01\x04\
    \x12\x04\xd8\x12\x04\x0c\n\x0f\n\x07\x047\x03\0\x02\x01\x06\x12\x04\xd8\
    \x12\r\x1e\n\x0f\n\x07\x047\x03\0\x02\x01\x01\x12\x04\xd8\x12\x1f,\n\x0f\
    \n\x07\x047\x03\0\x02\x01\x03\x12\x04\xd8\x12/0\n\xfd\x01\n\x04\x047\x02\
    \0\x12\x04\xdf\x12\x022\x1a\xee\x01\x20The\x20organization\x20policies\
    \x20under\x20the\n\x20[AnalyzeOrgPoliciesRequest.scope][google.cloud.ass\
    et.v1.AnalyzeOrgPoliciesRequest.scope]\n\x20with\x20the\n\x20[AnalyzeOrg\
    PoliciesRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPoliciesRequ\
    est.constraint].\n\n\r\n\x05\x047\x02\0\x04\x12\x04\xdf\x12\x02\n\n\r\n\
    \x05\x047\x02\0\x06\x12\x04\xdf\x12\x0b\x1a\n\r\n\x05\x047\x02\0\x01\x12\
    \x04\xdf\x12\x1b-\n\r\n\x05\x047\x02\0\x03\x12\x04\xdf\x1201\n@\n\x04\
    \x047\x02\x01\x12\x04\xe2\x12\x02-\x1a2\x20The\x20definition\x20of\x20th\
    e\x20constraint\x20in\x20the\x20request.\n\n\r\n\x05\x047\x02\x01\x06\
    \x12\x04\xe2\x12\x02\x1d\n\r\n\x05\x047\x02\x01\x01\x12\x04\xe2\x12\x1e(\
    \n\r\n\x05\x047\x02\x01\x03\x12\x04\xe2\x12+,\n\xb1\x01\n\x04\x047\x02\
    \x02\x12\x04\xe6\x12\x02\x1d\x1a\xa2\x01\x20The\x20page\x20token\x20to\
    \x20fetch\x20the\x20next\x20page\x20for\n\x20[AnalyzeOrgPoliciesResponse\
    .org_policy_results][google.cloud.asset.v1.AnalyzeOrgPoliciesResponse.or\
    g_policy_results].\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xe6\x12\x02\x08\
    \n\r\n\x05\x047\x02\x02\x01\x12\x04\xe6\x12\t\x18\n\r\n\x05\x047\x02\x02\
    \x03\x12\x04\xe6\x12\x1b\x1c\n\xa1\x01\n\x02\x048\x12\x06\xeb\x12\0\x89\
    \x13\x01\x1a\x92\x01\x20A\x20request\x20message\x20for\n\x20[AssetServic\
    e.AnalyzeOrgPolicyGovernedContainers][google.cloud.asset.v1.AssetService\
    .AnalyzeOrgPolicyGovernedContainers].\n\n\x0b\n\x03\x048\x01\x12\x04\xeb\
    \x12\x081\n\xb2\x02\n\x04\x048\x02\0\x12\x04\xf2\x12\x02<\x1a\xa3\x02\
    \x20Required.\x20The\x20organization\x20to\x20scope\x20the\x20request.\
    \x20Only\x20organization\n\x20policies\x20within\x20the\x20scope\x20will\
    \x20be\x20analyzed.\x20The\x20output\x20containers\x20will\n\x20also\x20\
    be\x20limited\x20to\x20the\x20ones\x20governed\x20by\x20those\x20in-scop\
    e\x20organization\n\x20policies.\n\n\x20*\x20organizations/{ORGANIZATION\
    _NUMBER}\x20(e.g.,\x20\"organizations/123456\")\n\n\r\n\x05\x048\x02\0\
    \x05\x12\x04\xf2\x12\x02\x08\n\r\n\x05\x048\x02\0\x01\x12\x04\xf2\x12\t\
    \x0e\n\r\n\x05\x048\x02\0\x03\x12\x04\xf2\x12\x11\x12\n\r\n\x05\x048\x02\
    \0\x08\x12\x04\xf2\x12\x13;\n\x10\n\x08\x048\x02\0\x08\x9c\x08\0\x12\x04\
    \xf2\x12\x14:\n\xa9\x01\n\x04\x048\x02\x01\x12\x04\xf7\x12\x02A\x1a\x9a\
    \x01\x20Required.\x20The\x20name\x20of\x20the\x20constraint\x20to\x20ana\
    lyze\x20governed\x20containers\x20for.\n\x20The\x20analysis\x20only\x20c\
    ontains\x20organization\x20policies\x20for\x20the\x20provided\n\x20const\
    raint.\n\n\r\n\x05\x048\x02\x01\x05\x12\x04\xf7\x12\x02\x08\n\r\n\x05\
    \x048\x02\x01\x01\x12\x04\xf7\x12\t\x13\n\r\n\x05\x048\x02\x01\x03\x12\
    \x04\xf7\x12\x16\x17\n\r\n\x05\x048\x02\x01\x08\x12\x04\xf7\x12\x18@\n\
    \x10\n\x08\x048\x02\x01\x08\x9c\x08\0\x12\x04\xf7\x12\x19?\n\x94\x02\n\
    \x04\x048\x02\x02\x12\x04\x80\x13\x02\x14\x1a\x85\x02\x20The\x20expressi\
    on\x20to\x20filter\x20the\x20governed\x20containers\x20in\x20result.\n\
    \x20The\x20only\x20supported\x20field\x20is\x20`parent`,\x20and\x20the\
    \x20only\x20supported\x20operator\x20is\n\x20`=`.\n\n\x20Example:\n\x20p\
    arent=\"//cloudresourcemanager.googleapis.com/folders/001\"\x20will\x20r\
    eturn\x20all\n\x20containers\x20under\x20\"folders/001\".\n\n\r\n\x05\
    \x048\x02\x02\x05\x12\x04\x80\x13\x02\x08\n\r\n\x05\x048\x02\x02\x01\x12\
    \x04\x80\x13\t\x0f\n\r\n\x05\x048\x02\x02\x03\x12\x04\x80\x13\x12\x13\n\
    \x97\x02\n\x04\x048\x02\x03\x12\x04\x85\x13\x02\x1f\x1a\x88\x02\x20The\
    \x20maximum\x20number\x20of\x20items\x20to\x20return\x20per\x20page.\x20\
    If\x20unspecified,\n\x20[AnalyzeOrgPolicyGovernedContainersResponse.gove\
    rned_containers][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedContainer\
    sResponse.governed_containers]\n\x20will\x20contain\x20100\x20items\x20w\
    ith\x20a\x20maximum\x20of\x20200.\n\n\r\n\x05\x048\x02\x03\x04\x12\x04\
    \x85\x13\x02\n\n\r\n\x05\x048\x02\x03\x05\x12\x04\x85\x13\x0b\x10\n\r\n\
    \x05\x048\x02\x03\x01\x12\x04\x85\x13\x11\x1a\n\r\n\x05\x048\x02\x03\x03\
    \x12\x04\x85\x13\x1d\x1e\n?\n\x04\x048\x02\x04\x12\x04\x88\x13\x02\x18\
    \x1a1\x20The\x20pagination\x20token\x20to\x20retrieve\x20the\x20next\x20\
    page.\n\n\r\n\x05\x048\x02\x04\x05\x12\x04\x88\x13\x02\x08\n\r\n\x05\x04\
    8\x02\x04\x01\x12\x04\x88\x13\t\x13\n\r\n\x05\x048\x02\x04\x03\x12\x04\
    \x88\x13\x16\x17\n\xa4\x01\n\x02\x049\x12\x06\x8d\x13\0\xb6\x13\x01\x1a\
    \x95\x01\x20The\x20response\x20message\x20for\n\x20[AssetService.Analyze\
    OrgPolicyGovernedContainers][google.cloud.asset.v1.AssetService.AnalyzeO\
    rgPolicyGovernedContainers].\n\n\x0b\n\x03\x049\x01\x12\x04\x8d\x13\x082\
    \n\xe6\x01\n\x04\x049\x03\0\x12\x06\x91\x13\x02\xab\x13\x03\x1a\xd5\x01\
    \x20The\x20organization/folder/project\x20resource\x20governed\x20by\x20\
    organization\x20policies\n\x20of\n\x20[AnalyzeOrgPolicyGovernedContainer\
    sRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedConta\
    inersRequest.constraint].\n\n\r\n\x05\x049\x03\0\x01\x12\x04\x91\x13\n\
    \x1b\n\x9e\x01\n\x06\x049\x03\0\x02\0\x12\x04\x95\x13\x04\"\x1a\x8d\x01\
    \x20The\x20[full\x20resource\x20name]\n\x20(https://cloud.google.com/ass\
    et-inventory/docs/resource-name-format)\x20of\n\x20an\x20organization/fo\
    lder/project\x20resource.\n\n\x0f\n\x07\x049\x03\0\x02\0\x05\x12\x04\x95\
    \x13\x04\n\n\x0f\n\x07\x049\x03\0\x02\0\x01\x12\x04\x95\x13\x0b\x1d\n\
    \x0f\n\x07\x049\x03\0\x02\0\x03\x12\x04\x95\x13\x20!\n\xbe\x02\n\x06\x04\
    9\x03\0\x02\x01\x12\x04\x9b\x13\x04\x16\x1a\xad\x02\x20The\x20[full\x20r\
    esource\x20name]\n\x20(https://cloud.google.com/asset-inventory/docs/res\
    ource-name-format)\x20of\n\x20the\x20parent\x20of\n\x20[AnalyzeOrgPolicy\
    GovernedContainersResponse.GovernedContainer.full_resource_name][google.\
    cloud.asset.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContai\
    ner.full_resource_name].\n\n\x0f\n\x07\x049\x03\0\x02\x01\x05\x12\x04\
    \x9b\x13\x04\n\n\x0f\n\x07\x049\x03\0\x02\x01\x01\x12\x04\x9b\x13\x0b\
    \x11\n\x0f\n\x07\x049\x03\0\x02\x01\x03\x12\x04\x9b\x13\x14\x15\n\xf4\
    \x03\n\x06\x049\x03\0\x02\x02\x12\x04\xa2\x13\x04.\x1a\xe3\x03\x20The\
    \x20consolidated\x20organization\x20policy\x20for\x20the\x20analyzed\x20\
    resource.\x20The\n\x20consolidated\x20organization\x20policy\x20is\x20co\
    mputed\x20by\x20merging\x20and\x20evaluating\n\x20[AnalyzeOrgPolicyGover\
    nedContainersResponse.GovernedContainer.policy_bundle][google.cloud.asse\
    t.v1.AnalyzeOrgPolicyGovernedContainersResponse.GovernedContainer.policy\
    _bundle].\n\x20The\x20evaluation\x20will\x20respect\x20the\x20organizati\
    on\x20policy\x20[hierarchy\n\x20rules](https://cloud.google.com/resource\
    -manager/docs/organization-policy/understanding-hierarchy).\n\n\x0f\n\
    \x07\x049\x03\0\x02\x02\x06\x12\x04\xa2\x13\x04\x15\n\x0f\n\x07\x049\x03\
    \0\x02\x02\x01\x12\x04\xa2\x13\x16)\n\x0f\n\x07\x049\x03\0\x02\x02\x03\
    \x12\x04\xa2\x13,-\n\x9e\x02\n\x06\x049\x03\0\x02\x03\x12\x04\xaa\x13\
    \x041\x1a\x8d\x02\x20The\x20ordered\x20list\x20of\x20all\x20organization\
    \x20policies\x20from\x20the\n\x20[AnalyzeOrgPoliciesResponse.OrgPolicyRe\
    sult.consolidated_policy.attached_resource][].\n\x20to\x20the\x20scope\
    \x20specified\x20in\x20the\x20request.\n\n\x20If\x20the\x20constraint\
    \x20is\x20defined\x20with\x20default\x20policy,\x20it\x20will\x20also\
    \x20appear\x20in\n\x20the\x20list.\n\n\x0f\n\x07\x049\x03\0\x02\x03\x04\
    \x12\x04\xaa\x13\x04\x0c\n\x0f\n\x07\x049\x03\0\x02\x03\x06\x12\x04\xaa\
    \x13\r\x1e\n\x0f\n\x07\x049\x03\0\x02\x03\x01\x12\x04\xaa\x13\x1f,\n\x0f\
    \n\x07\x049\x03\0\x02\x03\x03\x12\x04\xaa\x13/0\n=\n\x04\x049\x02\0\x12\
    \x04\xae\x13\x025\x1a/\x20The\x20list\x20of\x20the\x20analyzed\x20govern\
    ed\x20containers.\n\n\r\n\x05\x049\x02\0\x04\x12\x04\xae\x13\x02\n\n\r\n\
    \x05\x049\x02\0\x06\x12\x04\xae\x13\x0b\x1c\n\r\n\x05\x049\x02\0\x01\x12\
    \x04\xae\x13\x1d0\n\r\n\x05\x049\x02\0\x03\x12\x04\xae\x1334\n@\n\x04\
    \x049\x02\x01\x12\x04\xb1\x13\x02-\x1a2\x20The\x20definition\x20of\x20th\
    e\x20constraint\x20in\x20the\x20request.\n\n\r\n\x05\x049\x02\x01\x06\
    \x12\x04\xb1\x13\x02\x1d\n\r\n\x05\x049\x02\x01\x01\x12\x04\xb1\x13\x1e(\
    \n\r\n\x05\x049\x02\x01\x03\x12\x04\xb1\x13+,\n\xd3\x01\n\x04\x049\x02\
    \x02\x12\x04\xb5\x13\x02\x1d\x1a\xc4\x01\x20The\x20page\x20token\x20to\
    \x20fetch\x20the\x20next\x20page\x20for\n\x20[AnalyzeOrgPolicyGovernedCo\
    ntainersResponse.governed_containers][google.cloud.asset.v1.AnalyzeOrgPo\
    licyGovernedContainersResponse.governed_containers].\n\n\r\n\x05\x049\
    \x02\x02\x05\x12\x04\xb5\x13\x02\x08\n\r\n\x05\x049\x02\x02\x01\x12\x04\
    \xb5\x13\t\x18\n\r\n\x05\x049\x02\x02\x03\x12\x04\xb5\x13\x1b\x1c\n\x99\
    \x01\n\x02\x04:\x12\x06\xba\x13\0\xdd\x13\x01\x1a\x8a\x01\x20A\x20reques\
    t\x20message\x20for\n\x20[AssetService.AnalyzeOrgPolicyGovernedAssets][g\
    oogle.cloud.asset.v1.AssetService.AnalyzeOrgPolicyGovernedAssets].\n\n\
    \x0b\n\x03\x04:\x01\x12\x04\xba\x13\x08-\n\xae\x02\n\x04\x04:\x02\0\x12\
    \x04\xc1\x13\x02<\x1a\x9f\x02\x20Required.\x20The\x20organization\x20to\
    \x20scope\x20the\x20request.\x20Only\x20organization\n\x20policies\x20wi\
    thin\x20the\x20scope\x20will\x20be\x20analyzed.\x20The\x20output\x20asse\
    ts\x20will\n\x20also\x20be\x20limited\x20to\x20the\x20ones\x20governed\
    \x20by\x20those\x20in-scope\x20organization\n\x20policies.\n\n\x20*\x20o\
    rganizations/{ORGANIZATION_NUMBER}\x20(e.g.,\x20\"organizations/123456\"\
    )\n\n\r\n\x05\x04:\x02\0\x05\x12\x04\xc1\x13\x02\x08\n\r\n\x05\x04:\x02\
    \0\x01\x12\x04\xc1\x13\t\x0e\n\r\n\x05\x04:\x02\0\x03\x12\x04\xc1\x13\
    \x11\x12\n\r\n\x05\x04:\x02\0\x08\x12\x04\xc1\x13\x13;\n\x10\n\x08\x04:\
    \x02\0\x08\x9c\x08\0\x12\x04\xc1\x13\x14:\n\xae\x01\n\x04\x04:\x02\x01\
    \x12\x04\xc6\x13\x02A\x1a\x9f\x01\x20Required.\x20The\x20name\x20of\x20t\
    he\x20constraint\x20to\x20analyze\x20governed\x20assets\x20for.\x20The\n\
    \x20analysis\x20only\x20contains\x20analyzed\x20organization\x20policies\
    \x20for\x20the\x20provided\n\x20constraint.\n\n\r\n\x05\x04:\x02\x01\x05\
    \x12\x04\xc6\x13\x02\x08\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xc6\x13\t\
    \x13\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xc6\x13\x16\x17\n\r\n\x05\x04:\
    \x02\x01\x08\x12\x04\xc6\x13\x18@\n\x10\n\x08\x04:\x02\x01\x08\x9c\x08\0\
    \x12\x04\xc6\x13\x19?\n\x98\x05\n\x04\x04:\x02\x02\x12\x04\xd4\x13\x02\
    \x14\x1a\x89\x05\x20The\x20expression\x20to\x20filter\x20the\x20governed\
    \x20assets\x20in\x20result.\x20The\x20only\x20supported\n\x20fields\x20f\
    or\x20governed\x20resources\x20are\x20`governed_resource.project`\x20and\
    \n\x20`governed_resource.folders`.\x20The\x20only\x20supported\x20fields\
    \x20for\x20governed\x20iam\n\x20policies\x20are\x20`governed_iam_policy.\
    project`\x20and\n\x20`governed_iam_policy.folders`.\x20The\x20only\x20su\
    pported\x20operator\x20is\x20`=`.\n\n\x20Example\x201:\x20governed_resou\
    rce.project=\"projects/12345678\"\x20filter\x20will\x20return\n\x20all\
    \x20governed\x20resources\x20under\x20projects/12345678\x20including\x20\
    the\x20project\n\x20ifself,\x20if\x20applicable.\n\n\x20Example\x202:\
    \x20governed_iam_policy.folders=\"folders/12345678\"\x20filter\x20will\n\
    \x20return\x20all\x20governed\x20iam\x20policies\x20under\x20folders/123\
    45678,\x20if\x20applicable.\n\n\r\n\x05\x04:\x02\x02\x05\x12\x04\xd4\x13\
    \x02\x08\n\r\n\x05\x04:\x02\x02\x01\x12\x04\xd4\x13\t\x0f\n\r\n\x05\x04:\
    \x02\x02\x03\x12\x04\xd4\x13\x12\x13\n\x87\x02\n\x04\x04:\x02\x03\x12\
    \x04\xd9\x13\x02\x1f\x1a\xf8\x01\x20The\x20maximum\x20number\x20of\x20it\
    ems\x20to\x20return\x20per\x20page.\x20If\x20unspecified,\n\x20[AnalyzeO\
    rgPolicyGovernedAssetsResponse.governed_assets][google.cloud.asset.v1.An\
    alyzeOrgPolicyGovernedAssetsResponse.governed_assets]\n\x20will\x20conta\
    in\x20100\x20items\x20with\x20a\x20maximum\x20of\x20200.\n\n\r\n\x05\x04\
    :\x02\x03\x04\x12\x04\xd9\x13\x02\n\n\r\n\x05\x04:\x02\x03\x05\x12\x04\
    \xd9\x13\x0b\x10\n\r\n\x05\x04:\x02\x03\x01\x12\x04\xd9\x13\x11\x1a\n\r\
    \n\x05\x04:\x02\x03\x03\x12\x04\xd9\x13\x1d\x1e\n?\n\x04\x04:\x02\x04\
    \x12\x04\xdc\x13\x02\x18\x1a1\x20The\x20pagination\x20token\x20to\x20ret\
    rieve\x20the\x20next\x20page.\n\n\r\n\x05\x04:\x02\x04\x05\x12\x04\xdc\
    \x13\x02\x08\n\r\n\x05\x04:\x02\x04\x01\x12\x04\xdc\x13\t\x13\n\r\n\x05\
    \x04:\x02\x04\x03\x12\x04\xdc\x13\x16\x17\n\x9c\x01\n\x02\x04;\x12\x06\
    \xe1\x13\0\xc7\x14\x01\x1a\x8d\x01\x20The\x20response\x20message\x20for\
    \n\x20[AssetService.AnalyzeOrgPolicyGovernedAssets][google.cloud.asset.v\
    1.AssetService.AnalyzeOrgPolicyGovernedAssets].\n\n\x0b\n\x03\x04;\x01\
    \x12\x04\xe1\x13\x08.\n\xd7\x01\n\x04\x04;\x03\0\x12\x06\xe4\x13\x02\xfe\
    \x13\x03\x1a\xc6\x01\x20The\x20Google\x20Cloud\x20resources\x20governed\
    \x20by\x20the\x20organization\x20policies\x20of\x20the\n\x20[AnalyzeOrgP\
    olicyGovernedAssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgP\
    olicyGovernedAssetsRequest.constraint].\n\n\r\n\x05\x04;\x03\0\x01\x12\
    \x04\xe4\x13\n\x1a\n\x8f\x01\n\x06\x04;\x03\0\x02\0\x12\x04\xe8\x13\x04\
    \"\x1a\x7f\x20The\x20[full\x20resource\x20name]\n\x20(https://cloud.goog\
    le.com/asset-inventory/docs/resource-name-format)\x20of\n\x20the\x20Goog\
    le\x20Cloud\x20resource.\n\n\x0f\n\x07\x04;\x03\0\x02\0\x05\x12\x04\xe8\
    \x13\x04\n\n\x0f\n\x07\x04;\x03\0\x02\0\x01\x12\x04\xe8\x13\x0b\x1d\n\
    \x0f\n\x07\x04;\x03\0\x02\0\x03\x12\x04\xe8\x13\x20!\n\xb4\x02\n\x06\x04\
    ;\x03\0\x02\x01\x12\x04\xee\x13\x04\x16\x1a\xa3\x02\x20The\x20[full\x20r\
    esource\x20name]\n\x20(https://cloud.google.com/asset-inventory/docs/res\
    ource-name-format)\x20of\n\x20the\x20parent\x20of\n\x20[AnalyzeOrgPolicy\
    GovernedAssetsResponse.GovernedResource.full_resource_name][google.cloud\
    .asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.GovernedResource.full_r\
    esource_name].\n\n\x0f\n\x07\x04;\x03\0\x02\x01\x05\x12\x04\xee\x13\x04\
    \n\n\x0f\n\x07\x04;\x03\0\x02\x01\x01\x12\x04\xee\x13\x0b\x11\n\x0f\n\
    \x07\x04;\x03\0\x02\x01\x03\x12\x04\xee\x13\x14\x15\n\xab\x01\n\x06\x04;\
    \x03\0\x02\x02\x12\x04\xf3\x13\x04\x17\x1a\x9a\x01\x20The\x20project\x20\
    that\x20this\x20resource\x20belongs\x20to,\x20in\x20the\x20format\x20of\
    \n\x20projects/{PROJECT_NUMBER}.\x20This\x20field\x20is\x20available\x20\
    when\x20the\x20resource\n\x20belongs\x20to\x20a\x20project.\n\n\x0f\n\
    \x07\x04;\x03\0\x02\x02\x05\x12\x04\xf3\x13\x04\n\n\x0f\n\x07\x04;\x03\0\
    \x02\x02\x01\x12\x04\xf3\x13\x0b\x12\n\x0f\n\x07\x04;\x03\0\x02\x02\x03\
    \x12\x04\xf3\x13\x15\x16\n\xcf\x01\n\x06\x04;\x03\0\x02\x03\x12\x04\xf8\
    \x13\x04\x20\x1a\xbe\x01\x20The\x20folder(s)\x20that\x20this\x20resource\
    \x20belongs\x20to,\x20in\x20the\x20format\x20of\n\x20folders/{FOLDER_NUM\
    BER}.\x20This\x20field\x20is\x20available\x20when\x20the\x20resource\n\
    \x20belongs\x20(directly\x20or\x20cascadingly)\x20to\x20one\x20or\x20mor\
    e\x20folders.\n\n\x0f\n\x07\x04;\x03\0\x02\x03\x04\x12\x04\xf8\x13\x04\
    \x0c\n\x0f\n\x07\x04;\x03\0\x02\x03\x05\x12\x04\xf8\x13\r\x13\n\x0f\n\
    \x07\x04;\x03\0\x02\x03\x01\x12\x04\xf8\x13\x14\x1b\n\x0f\n\x07\x04;\x03\
    \0\x02\x03\x03\x12\x04\xf8\x13\x1e\x1f\n\xda\x01\n\x06\x04;\x03\0\x02\
    \x04\x12\x04\xfd\x13\x04\x1c\x1a\xc9\x01\x20The\x20organization\x20that\
    \x20this\x20resource\x20belongs\x20to,\x20in\x20the\x20format\x20of\n\
    \x20organizations/{ORGANIZATION_NUMBER}.\x20This\x20field\x20is\x20avail\
    able\x20when\x20the\n\x20resource\x20belongs\x20(directly\x20or\x20casca\
    dingly)\x20to\x20an\x20organization.\n\n\x0f\n\x07\x04;\x03\0\x02\x04\
    \x05\x12\x04\xfd\x13\x04\n\n\x0f\n\x07\x04;\x03\0\x02\x04\x01\x12\x04\
    \xfd\x13\x0b\x17\n\x0f\n\x07\x04;\x03\0\x02\x04\x03\x12\x04\xfd\x13\x1a\
    \x1b\n\xcd\x01\n\x04\x04;\x03\x01\x12\x06\x82\x14\x02\x9c\x14\x03\x1a\
    \xbc\x01\x20The\x20IAM\x20policies\x20governed\x20by\x20the\x20organizat\
    ion\x20policies\x20of\x20the\n\x20[AnalyzeOrgPolicyGovernedAssetsRequest\
    .constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest\
    .constraint].\n\n\r\n\x05\x04;\x03\x01\x01\x12\x04\x82\x14\n\x1b\n\xc7\
    \x02\n\x06\x04;\x03\x01\x02\0\x12\x04\x89\x14\x04!\x1a\xb6\x02\x20The\
    \x20full\x20resource\x20name\x20of\x20the\x20resource\x20on\x20which\x20\
    this\x20IAM\x20policy\x20is\x20set.\n\x20Example:\n\x20`//compute.google\
    apis.com/projects/my_project_123/zones/zone1/instances/instance1`.\n\x20\
    See\x20[Cloud\x20Asset\x20Inventory\x20Resource\x20Name\n\x20Format](htt\
    ps://cloud.google.com/asset-inventory/docs/resource-name-format)\n\x20fo\
    r\x20more\x20information.\n\n\x0f\n\x07\x04;\x03\x01\x02\0\x05\x12\x04\
    \x89\x14\x04\n\n\x0f\n\x07\x04;\x03\x01\x02\0\x01\x12\x04\x89\x14\x0b\
    \x1c\n\x0f\n\x07\x04;\x03\x01\x02\0\x03\x12\x04\x89\x14\x1f\x20\nD\n\x06\
    \x04;\x03\x01\x02\x01\x12\x04\x8c\x14\x04$\x1a4\x20The\x20IAM\x20policy\
    \x20directly\x20set\x20on\x20the\x20given\x20resource.\n\n\x0f\n\x07\x04\
    ;\x03\x01\x02\x01\x06\x12\x04\x8c\x14\x04\x18\n\x0f\n\x07\x04;\x03\x01\
    \x02\x01\x01\x12\x04\x8c\x14\x19\x1f\n\x0f\n\x07\x04;\x03\x01\x02\x01\
    \x03\x12\x04\x8c\x14\"#\n\xaf\x01\n\x06\x04;\x03\x01\x02\x02\x12\x04\x91\
    \x14\x04\x17\x1a\x9e\x01\x20The\x20project\x20that\x20this\x20IAM\x20pol\
    icy\x20belongs\x20to,\x20in\x20the\x20format\x20of\n\x20projects/{PROJEC\
    T_NUMBER}.\x20This\x20field\x20is\x20available\x20when\x20the\x20IAM\x20\
    policy\n\x20belongs\x20to\x20a\x20project.\n\n\x0f\n\x07\x04;\x03\x01\
    \x02\x02\x05\x12\x04\x91\x14\x04\n\n\x0f\n\x07\x04;\x03\x01\x02\x02\x01\
    \x12\x04\x91\x14\x0b\x12\n\x0f\n\x07\x04;\x03\x01\x02\x02\x03\x12\x04\
    \x91\x14\x15\x16\n\xd3\x01\n\x06\x04;\x03\x01\x02\x03\x12\x04\x96\x14\
    \x04\x20\x1a\xc2\x01\x20The\x20folder(s)\x20that\x20this\x20IAM\x20polic\
    y\x20belongs\x20to,\x20in\x20the\x20format\x20of\n\x20folders/{FOLDER_NU\
    MBER}.\x20This\x20field\x20is\x20available\x20when\x20the\x20IAM\x20poli\
    cy\n\x20belongs\x20(directly\x20or\x20cascadingly)\x20to\x20one\x20or\
    \x20more\x20folders.\n\n\x0f\n\x07\x04;\x03\x01\x02\x03\x04\x12\x04\x96\
    \x14\x04\x0c\n\x0f\n\x07\x04;\x03\x01\x02\x03\x05\x12\x04\x96\x14\r\x13\
    \n\x0f\n\x07\x04;\x03\x01\x02\x03\x01\x12\x04\x96\x14\x14\x1b\n\x0f\n\
    \x07\x04;\x03\x01\x02\x03\x03\x12\x04\x96\x14\x1e\x1f\n\xde\x01\n\x06\
    \x04;\x03\x01\x02\x04\x12\x04\x9b\x14\x04\x1c\x1a\xcd\x01\x20The\x20orga\
    nization\x20that\x20this\x20IAM\x20policy\x20belongs\x20to,\x20in\x20the\
    \x20format\x20of\n\x20organizations/{ORGANIZATION_NUMBER}.\x20This\x20fi\
    eld\x20is\x20available\x20when\x20the\n\x20IAM\x20policy\x20belongs\x20(\
    directly\x20or\x20cascadingly)\x20to\x20an\x20organization.\n\n\x0f\n\
    \x07\x04;\x03\x01\x02\x04\x05\x12\x04\x9b\x14\x04\n\n\x0f\n\x07\x04;\x03\
    \x01\x02\x04\x01\x12\x04\x9b\x14\x0b\x17\n\x0f\n\x07\x04;\x03\x01\x02\
    \x04\x03\x12\x04\x9b\x14\x1a\x1b\n\xf5\x01\n\x04\x04;\x03\x02\x12\x06\
    \xa1\x14\x02\xbc\x14\x03\x1a\xe4\x01\x20Represents\x20a\x20Google\x20Clo\
    ud\x20asset(resource\x20or\x20IAM\x20policy)\x20governed\x20by\x20the\n\
    \x20organization\x20policies\x20of\x20the\n\x20[AnalyzeOrgPolicyGoverned\
    AssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolicyGoverned\
    AssetsRequest.constraint].\n\n\r\n\x05\x04;\x03\x02\x01\x12\x04\xa1\x14\
    \n\x17\n\x10\n\x06\x04;\x03\x02\x08\0\x12\x06\xa2\x14\x04\xac\x14\x05\n\
    \x0f\n\x07\x04;\x03\x02\x08\0\x01\x12\x04\xa2\x14\n\x18\n\xd5\x01\n\x06\
    \x04;\x03\x02\x02\0\x12\x04\xa6\x14\x06-\x1a\xc4\x01\x20A\x20Google\x20C\
    loud\x20resource\x20governed\x20by\x20the\x20organization\n\x20policies\
    \x20of\x20the\n\x20[AnalyzeOrgPolicyGovernedAssetsRequest.constraint][go\
    ogle.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsRequest.constraint].\n\
    \n\x0f\n\x07\x04;\x03\x02\x02\0\x06\x12\x04\xa6\x14\x06\x16\n\x0f\n\x07\
    \x04;\x03\x02\x02\0\x01\x12\x04\xa6\x14\x17(\n\x0f\n\x07\x04;\x03\x02\
    \x02\0\x03\x12\x04\xa6\x14+,\n\xcb\x01\n\x06\x04;\x03\x02\x02\x01\x12\
    \x04\xab\x14\x060\x1a\xba\x01\x20An\x20IAM\x20policy\x20governed\x20by\
    \x20the\x20organization\n\x20policies\x20of\x20the\n\x20[AnalyzeOrgPolic\
    yGovernedAssetsRequest.constraint][google.cloud.asset.v1.AnalyzeOrgPolic\
    yGovernedAssetsRequest.constraint].\n\n\x0f\n\x07\x04;\x03\x02\x02\x01\
    \x06\x12\x04\xab\x14\x06\x17\n\x0f\n\x07\x04;\x03\x02\x02\x01\x01\x12\
    \x04\xab\x14\x18+\n\x0f\n\x07\x04;\x03\x02\x02\x01\x03\x12\x04\xab\x14./\
    \n\xc7\x03\n\x06\x04;\x03\x02\x02\x02\x12\x04\xb3\x14\x04.\x1a\xb6\x03\
    \x20The\x20consolidated\x20policy\x20for\x20the\x20analyzed\x20asset.\
    \x20The\x20consolidated\n\x20policy\x20is\x20computed\x20by\x20merging\
    \x20and\x20evaluating\n\x20[AnalyzeOrgPolicyGovernedAssetsResponse.Gover\
    nedAsset.policy_bundle][google.cloud.asset.v1.AnalyzeOrgPolicyGovernedAs\
    setsResponse.GovernedAsset.policy_bundle].\n\x20The\x20evaluation\x20wil\
    l\x20respect\x20the\x20organization\x20policy\x20[hierarchy\n\x20rules](\
    https://cloud.google.com/resource-manager/docs/organization-policy/under\
    standing-hierarchy).\n\n\x0f\n\x07\x04;\x03\x02\x02\x02\x06\x12\x04\xb3\
    \x14\x04\x15\n\x0f\n\x07\x04;\x03\x02\x02\x02\x01\x12\x04\xb3\x14\x16)\n\
    \x0f\n\x07\x04;\x03\x02\x02\x02\x03\x12\x04\xb3\x14,-\n\x9d\x02\n\x06\
    \x04;\x03\x02\x02\x03\x12\x04\xbb\x14\x041\x1a\x8c\x02\x20The\x20ordered\
    \x20list\x20of\x20all\x20organization\x20policies\x20from\x20the\n\x20[A\
    nalyzeOrgPoliciesResponse.OrgPolicyResult.consolidated_policy.attached_r\
    esource][]\n\x20to\x20the\x20scope\x20specified\x20in\x20the\x20request.\
    \n\n\x20If\x20the\x20constraint\x20is\x20defined\x20with\x20default\x20p\
    olicy,\x20it\x20will\x20also\x20appear\x20in\n\x20the\x20list.\n\n\x0f\n\
    \x07\x04;\x03\x02\x02\x03\x04\x12\x04\xbb\x14\x04\x0c\n\x0f\n\x07\x04;\
    \x03\x02\x02\x03\x06\x12\x04\xbb\x14\r\x1e\n\x0f\n\x07\x04;\x03\x02\x02\
    \x03\x01\x12\x04\xbb\x14\x1f,\n\x0f\n\x07\x04;\x03\x02\x02\x03\x03\x12\
    \x04\xbb\x14/0\n9\n\x04\x04;\x02\0\x12\x04\xbf\x14\x02-\x1a+\x20The\x20l\
    ist\x20of\x20the\x20analyzed\x20governed\x20assets.\n\n\r\n\x05\x04;\x02\
    \0\x04\x12\x04\xbf\x14\x02\n\n\r\n\x05\x04;\x02\0\x06\x12\x04\xbf\x14\
    \x0b\x18\n\r\n\x05\x04;\x02\0\x01\x12\x04\xbf\x14\x19(\n\r\n\x05\x04;\
    \x02\0\x03\x12\x04\xbf\x14+,\n@\n\x04\x04;\x02\x01\x12\x04\xc2\x14\x02-\
    \x1a2\x20The\x20definition\x20of\x20the\x20constraint\x20in\x20the\x20re\
    quest.\n\n\r\n\x05\x04;\x02\x01\x06\x12\x04\xc2\x14\x02\x1d\n\r\n\x05\
    \x04;\x02\x01\x01\x12\x04\xc2\x14\x1e(\n\r\n\x05\x04;\x02\x01\x03\x12\
    \x04\xc2\x14+,\n\xc3\x01\n\x04\x04;\x02\x02\x12\x04\xc6\x14\x02\x1d\x1a\
    \xb4\x01\x20The\x20page\x20token\x20to\x20fetch\x20the\x20next\x20page\
    \x20for\n\x20[AnalyzeOrgPolicyGovernedAssetsResponse.governed_assets][go\
    ogle.cloud.asset.v1.AnalyzeOrgPolicyGovernedAssetsResponse.governed_asse\
    ts].\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\xc6\x14\x02\x08\n\r\n\x05\x04;\
    \x02\x02\x01\x12\x04\xc6\x14\t\x18\n\r\n\x05\x04;\x02\x02\x03\x12\x04\
    \xc6\x14\x1b\x1c\n#\n\x02\x05\0\x12\x06\xca\x14\0\xdf\x14\x01\x1a\x15\
    \x20Asset\x20content\x20type.\n\n\x0b\n\x03\x05\0\x01\x12\x04\xca\x14\
    \x05\x10\n)\n\x04\x05\0\x02\0\x12\x04\xcc\x14\x02\x1f\x1a\x1b\x20Unspeci\
    fied\x20content\x20type.\n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xcc\x14\x02\
    \x1a\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xcc\x14\x1d\x1e\n\"\n\x04\x05\0\
    \x02\x01\x12\x04\xcf\x14\x02\x0f\x1a\x14\x20Resource\x20metadata.\n\n\r\
    \n\x05\x05\0\x02\x01\x01\x12\x04\xcf\x14\x02\n\n\r\n\x05\x05\0\x02\x01\
    \x02\x12\x04\xcf\x14\r\x0e\n8\n\x04\x05\0\x02\x02\x12\x04\xd2\x14\x02\
    \x11\x1a*\x20The\x20actual\x20IAM\x20policy\x20set\x20on\x20a\x20resourc\
    e.\n\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xd2\x14\x02\x0c\n\r\n\x05\x05\0\
    \x02\x02\x02\x12\x04\xd2\x14\x0f\x10\n8\n\x04\x05\0\x02\x03\x12\x04\xd5\
    \x14\x02\x11\x1a*\x20The\x20organization\x20policy\x20set\x20on\x20an\
    \x20asset.\n\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\xd5\x14\x02\x0c\n\r\n\
    \x05\x05\0\x02\x03\x02\x12\x04\xd5\x14\x0f\x10\nB\n\x04\x05\0\x02\x04\
    \x12\x04\xd8\x14\x02\x14\x1a4\x20The\x20Access\x20Context\x20Manager\x20\
    policy\x20set\x20on\x20an\x20asset.\n\n\r\n\x05\x05\0\x02\x04\x01\x12\
    \x04\xd8\x14\x02\x0f\n\r\n\x05\x05\0\x02\x04\x02\x12\x04\xd8\x14\x12\x13\
    \n5\n\x04\x05\0\x02\x05\x12\x04\xdb\x14\x02\x13\x1a'\x20The\x20runtime\
    \x20OS\x20Inventory\x20information.\n\n\r\n\x05\x05\0\x02\x05\x01\x12\
    \x04\xdb\x14\x02\x0e\n\r\n\x05\x05\0\x02\x05\x02\x12\x04\xdb\x14\x11\x12\
    \n&\n\x04\x05\0\x02\x06\x12\x04\xde\x14\x02\x13\x1a\x18\x20The\x20relate\
    d\x20resources.\n\n\r\n\x05\x05\0\x02\x06\x01\x12\x04\xde\x14\x02\x0e\n\
    \r\n\x05\x05\0\x02\x06\x02\x12\x04\xde\x14\x11\x12b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
