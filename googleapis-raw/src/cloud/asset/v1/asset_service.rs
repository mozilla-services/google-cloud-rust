// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/asset/v1/asset_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyLongrunningMetadata {
    // message fields
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyLongrunningMetadata {
    fn default() -> &'a AnalyzeIamPolicyLongrunningMetadata {
        <AnalyzeIamPolicyLongrunningMetadata as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyLongrunningMetadata {
    pub fn new() -> AnalyzeIamPolicyLongrunningMetadata {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp create_time = 1;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyLongrunningMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyLongrunningMetadata {
        AnalyzeIamPolicyLongrunningMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &AnalyzeIamPolicyLongrunningMetadata| { &m.create_time },
                |m: &mut AnalyzeIamPolicyLongrunningMetadata| { &mut m.create_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyLongrunningMetadata>(
                "AnalyzeIamPolicyLongrunningMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyLongrunningMetadata {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyLongrunningMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyLongrunningMetadata::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyLongrunningMetadata {
    fn clear(&mut self) {
        self.create_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyLongrunningMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyLongrunningMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExportAssetsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportAssetsRequest {
    fn default() -> &'a ExportAssetsRequest {
        <ExportAssetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExportAssetsRequest {
    pub fn new() -> ExportAssetsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp read_time = 2;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 4;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // .google.cloud.asset.v1.OutputConfig output_config = 5;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }
}

impl ::protobuf::Message for ExportAssetsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.content_type);
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportAssetsRequest {
        ExportAssetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ExportAssetsRequest| { &m.parent },
                |m: &mut ExportAssetsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ExportAssetsRequest| { &m.read_time },
                |m: &mut ExportAssetsRequest| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &ExportAssetsRequest| { &m.asset_types },
                |m: &mut ExportAssetsRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &ExportAssetsRequest| { &m.content_type },
                |m: &mut ExportAssetsRequest| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &ExportAssetsRequest| { &m.output_config },
                |m: &mut ExportAssetsRequest| { &mut m.output_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExportAssetsRequest>(
                "ExportAssetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExportAssetsRequest {
        static instance: ::protobuf::rt::LazyV2<ExportAssetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExportAssetsRequest::new)
    }
}

impl ::protobuf::Clear for ExportAssetsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.read_time.clear();
        self.asset_types.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.output_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportAssetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportAssetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExportAssetsResponse {
    // message fields
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    pub output_result: ::protobuf::SingularPtrField<OutputResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportAssetsResponse {
    fn default() -> &'a ExportAssetsResponse {
        <ExportAssetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExportAssetsResponse {
    pub fn new() -> ExportAssetsResponse {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp read_time = 1;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.cloud.asset.v1.OutputConfig output_config = 2;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }

    // .google.cloud.asset.v1.OutputResult output_result = 3;


    pub fn get_output_result(&self) -> &OutputResult {
        self.output_result.as_ref().unwrap_or_else(|| <OutputResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_result(&mut self) {
        self.output_result.clear();
    }

    pub fn has_output_result(&self) -> bool {
        self.output_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_result(&mut self, v: OutputResult) {
        self.output_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_result(&mut self) -> &mut OutputResult {
        if self.output_result.is_none() {
            self.output_result.set_default();
        }
        self.output_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_result(&mut self) -> OutputResult {
        self.output_result.take().unwrap_or_else(|| OutputResult::new())
    }
}

impl ::protobuf::Message for ExportAssetsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportAssetsResponse {
        ExportAssetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ExportAssetsResponse| { &m.read_time },
                |m: &mut ExportAssetsResponse| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &ExportAssetsResponse| { &m.output_config },
                |m: &mut ExportAssetsResponse| { &mut m.output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputResult>>(
                "output_result",
                |m: &ExportAssetsResponse| { &m.output_result },
                |m: &mut ExportAssetsResponse| { &mut m.output_result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExportAssetsResponse>(
                "ExportAssetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExportAssetsResponse {
        static instance: ::protobuf::rt::LazyV2<ExportAssetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExportAssetsResponse::new)
    }
}

impl ::protobuf::Clear for ExportAssetsResponse {
    fn clear(&mut self) {
        self.read_time.clear();
        self.output_config.clear();
        self.output_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportAssetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportAssetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAssetsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAssetsRequest {
    fn default() -> &'a ListAssetsRequest {
        <ListAssetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAssetsRequest {
    pub fn new() -> ListAssetsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp read_time = 2;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 4;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // int32 page_size = 5;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 6;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAssetsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.content_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if self.page_size != 0 {
            os.write_int32(5, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(6, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAssetsRequest {
        ListAssetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListAssetsRequest| { &m.parent },
                |m: &mut ListAssetsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ListAssetsRequest| { &m.read_time },
                |m: &mut ListAssetsRequest| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &ListAssetsRequest| { &m.asset_types },
                |m: &mut ListAssetsRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &ListAssetsRequest| { &m.content_type },
                |m: &mut ListAssetsRequest| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListAssetsRequest| { &m.page_size },
                |m: &mut ListAssetsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListAssetsRequest| { &m.page_token },
                |m: &mut ListAssetsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAssetsRequest>(
                "ListAssetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAssetsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAssetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAssetsRequest::new)
    }
}

impl ::protobuf::Clear for ListAssetsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.read_time.clear();
        self.asset_types.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAssetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAssetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAssetsResponse {
    // message fields
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub assets: ::protobuf::RepeatedField<super::assets::Asset>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAssetsResponse {
    fn default() -> &'a ListAssetsResponse {
        <ListAssetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListAssetsResponse {
    pub fn new() -> ListAssetsResponse {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp read_time = 1;


    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .google.cloud.asset.v1.Asset assets = 2;


    pub fn get_assets(&self) -> &[super::assets::Asset] {
        &self.assets
    }
    pub fn clear_assets(&mut self) {
        self.assets.clear();
    }

    // Param is passed by value, moved
    pub fn set_assets(&mut self, v: ::protobuf::RepeatedField<super::assets::Asset>) {
        self.assets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assets(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::Asset> {
        &mut self.assets
    }

    // Take field
    pub fn take_assets(&mut self) -> ::protobuf::RepeatedField<super::assets::Asset> {
        ::std::mem::replace(&mut self.assets, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAssetsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assets)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.assets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.assets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAssetsResponse {
        ListAssetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_time",
                |m: &ListAssetsResponse| { &m.read_time },
                |m: &mut ListAssetsResponse| { &mut m.read_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::Asset>>(
                "assets",
                |m: &ListAssetsResponse| { &m.assets },
                |m: &mut ListAssetsResponse| { &mut m.assets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListAssetsResponse| { &m.next_page_token },
                |m: &mut ListAssetsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAssetsResponse>(
                "ListAssetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAssetsResponse {
        static instance: ::protobuf::rt::LazyV2<ListAssetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAssetsResponse::new)
    }
}

impl ::protobuf::Clear for ListAssetsResponse {
    fn clear(&mut self) {
        self.read_time.clear();
        self.assets.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAssetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAssetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetAssetsHistoryRequest {
    // message fields
    pub parent: ::std::string::String,
    pub asset_names: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub read_time_window: ::protobuf::SingularPtrField<super::assets::TimeWindow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetAssetsHistoryRequest {
    fn default() -> &'a BatchGetAssetsHistoryRequest {
        <BatchGetAssetsHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetAssetsHistoryRequest {
    pub fn new() -> BatchGetAssetsHistoryRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // repeated string asset_names = 2;


    pub fn get_asset_names(&self) -> &[::std::string::String] {
        &self.asset_names
    }
    pub fn clear_asset_names(&mut self) {
        self.asset_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_names
    }

    // Take field
    pub fn take_asset_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_names, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 3;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // .google.cloud.asset.v1.TimeWindow read_time_window = 4;


    pub fn get_read_time_window(&self) -> &super::assets::TimeWindow {
        self.read_time_window.as_ref().unwrap_or_else(|| <super::assets::TimeWindow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_time_window(&mut self) {
        self.read_time_window.clear();
    }

    pub fn has_read_time_window(&self) -> bool {
        self.read_time_window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time_window(&mut self, v: super::assets::TimeWindow) {
        self.read_time_window = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time_window(&mut self) -> &mut super::assets::TimeWindow {
        if self.read_time_window.is_none() {
            self.read_time_window.set_default();
        }
        self.read_time_window.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time_window(&mut self) -> super::assets::TimeWindow {
        self.read_time_window.take().unwrap_or_else(|| super::assets::TimeWindow::new())
    }
}

impl ::protobuf::Message for BatchGetAssetsHistoryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_time_window {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_names)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time_window)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        for value in &self.asset_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.content_type);
        }
        if let Some(ref v) = self.read_time_window.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        for v in &self.asset_names {
            os.write_string(2, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if let Some(ref v) = self.read_time_window.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetAssetsHistoryRequest {
        BatchGetAssetsHistoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &BatchGetAssetsHistoryRequest| { &m.parent },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_names",
                |m: &BatchGetAssetsHistoryRequest| { &m.asset_names },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.asset_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &BatchGetAssetsHistoryRequest| { &m.content_type },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::TimeWindow>>(
                "read_time_window",
                |m: &BatchGetAssetsHistoryRequest| { &m.read_time_window },
                |m: &mut BatchGetAssetsHistoryRequest| { &mut m.read_time_window },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetAssetsHistoryRequest>(
                "BatchGetAssetsHistoryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetAssetsHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<BatchGetAssetsHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetAssetsHistoryRequest::new)
    }
}

impl ::protobuf::Clear for BatchGetAssetsHistoryRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.asset_names.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.read_time_window.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetAssetsHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetAssetsHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetAssetsHistoryResponse {
    // message fields
    pub assets: ::protobuf::RepeatedField<super::assets::TemporalAsset>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetAssetsHistoryResponse {
    fn default() -> &'a BatchGetAssetsHistoryResponse {
        <BatchGetAssetsHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetAssetsHistoryResponse {
    pub fn new() -> BatchGetAssetsHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.TemporalAsset assets = 1;


    pub fn get_assets(&self) -> &[super::assets::TemporalAsset] {
        &self.assets
    }
    pub fn clear_assets(&mut self) {
        self.assets.clear();
    }

    // Param is passed by value, moved
    pub fn set_assets(&mut self, v: ::protobuf::RepeatedField<super::assets::TemporalAsset>) {
        self.assets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assets(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::TemporalAsset> {
        &mut self.assets
    }

    // Take field
    pub fn take_assets(&mut self) -> ::protobuf::RepeatedField<super::assets::TemporalAsset> {
        ::std::mem::replace(&mut self.assets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetAssetsHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.assets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.assets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.assets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetAssetsHistoryResponse {
        BatchGetAssetsHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::TemporalAsset>>(
                "assets",
                |m: &BatchGetAssetsHistoryResponse| { &m.assets },
                |m: &mut BatchGetAssetsHistoryResponse| { &mut m.assets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetAssetsHistoryResponse>(
                "BatchGetAssetsHistoryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetAssetsHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<BatchGetAssetsHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetAssetsHistoryResponse::new)
    }
}

impl ::protobuf::Clear for BatchGetAssetsHistoryResponse {
    fn clear(&mut self) {
        self.assets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetAssetsHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetAssetsHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFeedRequest {
    // message fields
    pub parent: ::std::string::String,
    pub feed_id: ::std::string::String,
    pub feed: ::protobuf::SingularPtrField<Feed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFeedRequest {
    fn default() -> &'a CreateFeedRequest {
        <CreateFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateFeedRequest {
    pub fn new() -> CreateFeedRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string feed_id = 2;


    pub fn get_feed_id(&self) -> &str {
        &self.feed_id
    }
    pub fn clear_feed_id(&mut self) {
        self.feed_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_id(&mut self, v: ::std::string::String) {
        self.feed_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_id(&mut self) -> &mut ::std::string::String {
        &mut self.feed_id
    }

    // Take field
    pub fn take_feed_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feed_id, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.Feed feed = 3;


    pub fn get_feed(&self) -> &Feed {
        self.feed.as_ref().unwrap_or_else(|| <Feed as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feed(&mut self) {
        self.feed.clear();
    }

    pub fn has_feed(&self) -> bool {
        self.feed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed(&mut self, v: Feed) {
        self.feed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed(&mut self) -> &mut Feed {
        if self.feed.is_none() {
            self.feed.set_default();
        }
        self.feed.as_mut().unwrap()
    }

    // Take field
    pub fn take_feed(&mut self) -> Feed {
        self.feed.take().unwrap_or_else(|| Feed::new())
    }
}

impl ::protobuf::Message for CreateFeedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.feed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feed_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.feed_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.feed_id);
        }
        if let Some(ref v) = self.feed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.feed_id.is_empty() {
            os.write_string(2, &self.feed_id)?;
        }
        if let Some(ref v) = self.feed.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFeedRequest {
        CreateFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateFeedRequest| { &m.parent },
                |m: &mut CreateFeedRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "feed_id",
                |m: &CreateFeedRequest| { &m.feed_id },
                |m: &mut CreateFeedRequest| { &mut m.feed_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feed>>(
                "feed",
                |m: &CreateFeedRequest| { &m.feed },
                |m: &mut CreateFeedRequest| { &mut m.feed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFeedRequest>(
                "CreateFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateFeedRequest {
        static instance: ::protobuf::rt::LazyV2<CreateFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateFeedRequest::new)
    }
}

impl ::protobuf::Clear for CreateFeedRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.feed_id.clear();
        self.feed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeedRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeedRequest {
    fn default() -> &'a GetFeedRequest {
        <GetFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFeedRequest {
    pub fn new() -> GetFeedRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFeedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeedRequest {
        GetFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetFeedRequest| { &m.name },
                |m: &mut GetFeedRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeedRequest>(
                "GetFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFeedRequest {
        static instance: ::protobuf::rt::LazyV2<GetFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFeedRequest::new)
    }
}

impl ::protobuf::Clear for GetFeedRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFeedsRequest {
    // message fields
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFeedsRequest {
    fn default() -> &'a ListFeedsRequest {
        <ListFeedsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListFeedsRequest {
    pub fn new() -> ListFeedsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListFeedsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFeedsRequest {
        ListFeedsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListFeedsRequest| { &m.parent },
                |m: &mut ListFeedsRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListFeedsRequest>(
                "ListFeedsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListFeedsRequest {
        static instance: ::protobuf::rt::LazyV2<ListFeedsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListFeedsRequest::new)
    }
}

impl ::protobuf::Clear for ListFeedsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFeedsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFeedsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFeedsResponse {
    // message fields
    pub feeds: ::protobuf::RepeatedField<Feed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFeedsResponse {
    fn default() -> &'a ListFeedsResponse {
        <ListFeedsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListFeedsResponse {
    pub fn new() -> ListFeedsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.Feed feeds = 1;


    pub fn get_feeds(&self) -> &[Feed] {
        &self.feeds
    }
    pub fn clear_feeds(&mut self) {
        self.feeds.clear();
    }

    // Param is passed by value, moved
    pub fn set_feeds(&mut self, v: ::protobuf::RepeatedField<Feed>) {
        self.feeds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feeds(&mut self) -> &mut ::protobuf::RepeatedField<Feed> {
        &mut self.feeds
    }

    // Take field
    pub fn take_feeds(&mut self) -> ::protobuf::RepeatedField<Feed> {
        ::std::mem::replace(&mut self.feeds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListFeedsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.feeds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.feeds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.feeds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.feeds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFeedsResponse {
        ListFeedsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feed>>(
                "feeds",
                |m: &ListFeedsResponse| { &m.feeds },
                |m: &mut ListFeedsResponse| { &mut m.feeds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListFeedsResponse>(
                "ListFeedsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListFeedsResponse {
        static instance: ::protobuf::rt::LazyV2<ListFeedsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListFeedsResponse::new)
    }
}

impl ::protobuf::Clear for ListFeedsResponse {
    fn clear(&mut self) {
        self.feeds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFeedsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFeedsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateFeedRequest {
    // message fields
    pub feed: ::protobuf::SingularPtrField<Feed>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateFeedRequest {
    fn default() -> &'a UpdateFeedRequest {
        <UpdateFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateFeedRequest {
    pub fn new() -> UpdateFeedRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.Feed feed = 1;


    pub fn get_feed(&self) -> &Feed {
        self.feed.as_ref().unwrap_or_else(|| <Feed as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feed(&mut self) {
        self.feed.clear();
    }

    pub fn has_feed(&self) -> bool {
        self.feed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed(&mut self, v: Feed) {
        self.feed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed(&mut self) -> &mut Feed {
        if self.feed.is_none() {
            self.feed.set_default();
        }
        self.feed.as_mut().unwrap()
    }

    // Take field
    pub fn take_feed(&mut self) -> Feed {
        self.feed.take().unwrap_or_else(|| Feed::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateFeedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.feed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.feed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.feed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateFeedRequest {
        UpdateFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feed>>(
                "feed",
                |m: &UpdateFeedRequest| { &m.feed },
                |m: &mut UpdateFeedRequest| { &mut m.feed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateFeedRequest| { &m.update_mask },
                |m: &mut UpdateFeedRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateFeedRequest>(
                "UpdateFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateFeedRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateFeedRequest::new)
    }
}

impl ::protobuf::Clear for UpdateFeedRequest {
    fn clear(&mut self) {
        self.feed.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteFeedRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteFeedRequest {
    fn default() -> &'a DeleteFeedRequest {
        <DeleteFeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteFeedRequest {
    pub fn new() -> DeleteFeedRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteFeedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteFeedRequest {
        DeleteFeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteFeedRequest| { &m.name },
                |m: &mut DeleteFeedRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteFeedRequest>(
                "DeleteFeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteFeedRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteFeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteFeedRequest::new)
    }
}

impl ::protobuf::Clear for DeleteFeedRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteFeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteFeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputConfig {
    // message oneof groups
    pub destination: ::std::option::Option<OutputConfig_oneof_destination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputConfig {
    fn default() -> &'a OutputConfig {
        <OutputConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OutputConfig_oneof_destination {
    gcs_destination(GcsDestination),
    bigquery_destination(BigQueryDestination),
}

impl OutputConfig {
    pub fn new() -> OutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.GcsDestination gcs_destination = 1;


    pub fn get_gcs_destination(&self) -> &GcsDestination {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(ref v)) => v,
            _ => <GcsDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_gcs_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_destination(&mut self, v: GcsDestination) {
        self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_destination(&mut self) -> &mut GcsDestination {
        if let ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(GcsDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_destination(&mut self) -> GcsDestination {
        if self.has_gcs_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            GcsDestination::new()
        }
    }

    // .google.cloud.asset.v1.BigQueryDestination bigquery_destination = 2;


    pub fn get_bigquery_destination(&self) -> &BigQueryDestination {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(ref v)) => v,
            _ => <BigQueryDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bigquery_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_bigquery_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bigquery_destination(&mut self, v: BigQueryDestination) {
        self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bigquery_destination(&mut self) -> &mut BigQueryDestination {
        if let ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(BigQueryDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bigquery_destination(&mut self) -> BigQueryDestination {
        if self.has_bigquery_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            BigQueryDestination::new()
        }
    }
}

impl ::protobuf::Message for OutputConfig {
    fn is_initialized(&self) -> bool {
        if let Some(OutputConfig_oneof_destination::gcs_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OutputConfig_oneof_destination::bigquery_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::gcs_destination(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(OutputConfig_oneof_destination::bigquery_destination(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &OutputConfig_oneof_destination::gcs_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &OutputConfig_oneof_destination::gcs_destination(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputConfig {
        OutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GcsDestination>(
                "gcs_destination",
                OutputConfig::has_gcs_destination,
                OutputConfig::get_gcs_destination,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BigQueryDestination>(
                "bigquery_destination",
                OutputConfig::has_bigquery_destination,
                OutputConfig::get_bigquery_destination,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputConfig>(
                "OutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputConfig {
        static instance: ::protobuf::rt::LazyV2<OutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputConfig::new)
    }
}

impl ::protobuf::Clear for OutputConfig {
    fn clear(&mut self) {
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputResult {
    // message oneof groups
    pub result: ::std::option::Option<OutputResult_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputResult {
    fn default() -> &'a OutputResult {
        <OutputResult as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OutputResult_oneof_result {
    gcs_result(GcsOutputResult),
}

impl OutputResult {
    pub fn new() -> OutputResult {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.GcsOutputResult gcs_result = 1;


    pub fn get_gcs_result(&self) -> &GcsOutputResult {
        match self.result {
            ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(ref v)) => v,
            _ => <GcsOutputResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_gcs_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_result(&mut self, v: GcsOutputResult) {
        self.result = ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_result(&mut self) -> &mut GcsOutputResult {
        if let ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(GcsOutputResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_result(&mut self) -> GcsOutputResult {
        if self.has_gcs_result() {
            match self.result.take() {
                ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GcsOutputResult::new()
        }
    }
}

impl ::protobuf::Message for OutputResult {
    fn is_initialized(&self) -> bool {
        if let Some(OutputResult_oneof_result::gcs_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(OutputResult_oneof_result::gcs_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &OutputResult_oneof_result::gcs_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &OutputResult_oneof_result::gcs_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputResult {
        OutputResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GcsOutputResult>(
                "gcs_result",
                OutputResult::has_gcs_result,
                OutputResult::get_gcs_result,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputResult>(
                "OutputResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputResult {
        static instance: ::protobuf::rt::LazyV2<OutputResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputResult::new)
    }
}

impl ::protobuf::Clear for OutputResult {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsOutputResult {
    // message fields
    pub uris: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsOutputResult {
    fn default() -> &'a GcsOutputResult {
        <GcsOutputResult as ::protobuf::Message>::default_instance()
    }
}

impl GcsOutputResult {
    pub fn new() -> GcsOutputResult {
        ::std::default::Default::default()
    }

    // repeated string uris = 1;


    pub fn get_uris(&self) -> &[::std::string::String] {
        &self.uris
    }
    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GcsOutputResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uris)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uris {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uris {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsOutputResult {
        GcsOutputResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uris",
                |m: &GcsOutputResult| { &m.uris },
                |m: &mut GcsOutputResult| { &mut m.uris },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsOutputResult>(
                "GcsOutputResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsOutputResult {
        static instance: ::protobuf::rt::LazyV2<GcsOutputResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsOutputResult::new)
    }
}

impl ::protobuf::Clear for GcsOutputResult {
    fn clear(&mut self) {
        self.uris.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsOutputResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsOutputResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsDestination {
    // message oneof groups
    pub object_uri: ::std::option::Option<GcsDestination_oneof_object_uri>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsDestination {
    fn default() -> &'a GcsDestination {
        <GcsDestination as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GcsDestination_oneof_object_uri {
    uri(::std::string::String),
    uri_prefix(::std::string::String),
}

impl GcsDestination {
    pub fn new() -> GcsDestination {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_uri(&mut self) {
        self.object_uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(_)) = self.object_uri {
        } else {
            self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(::std::string::String::new()));
        }
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        if self.has_uri() {
            match self.object_uri.take() {
                ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string uri_prefix = 2;


    pub fn get_uri_prefix(&self) -> &str {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_uri_prefix(&mut self) {
        self.object_uri = ::std::option::Option::None;
    }

    pub fn has_uri_prefix(&self) -> bool {
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri_prefix(&mut self, v: ::std::string::String) {
        self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri_prefix(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(_)) = self.object_uri {
        } else {
            self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(::std::string::String::new()));
        }
        match self.object_uri {
            ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri_prefix(&mut self) -> ::std::string::String {
        if self.has_uri_prefix() {
            match self.object_uri.take() {
                ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for GcsDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.object_uri = ::std::option::Option::Some(GcsDestination_oneof_object_uri::uri_prefix(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.object_uri {
            match v {
                &GcsDestination_oneof_object_uri::uri(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &GcsDestination_oneof_object_uri::uri_prefix(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.object_uri {
            match v {
                &GcsDestination_oneof_object_uri::uri(ref v) => {
                    os.write_string(1, v)?;
                },
                &GcsDestination_oneof_object_uri::uri_prefix(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsDestination {
        GcsDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "uri",
                GcsDestination::has_uri,
                GcsDestination::get_uri,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "uri_prefix",
                GcsDestination::has_uri_prefix,
                GcsDestination::get_uri_prefix,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsDestination>(
                "GcsDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsDestination {
        static instance: ::protobuf::rt::LazyV2<GcsDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsDestination::new)
    }
}

impl ::protobuf::Clear for GcsDestination {
    fn clear(&mut self) {
        self.object_uri = ::std::option::Option::None;
        self.object_uri = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BigQueryDestination {
    // message fields
    pub dataset: ::std::string::String,
    pub table: ::std::string::String,
    pub force: bool,
    pub partition_spec: ::protobuf::SingularPtrField<PartitionSpec>,
    pub separate_tables_per_asset_type: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BigQueryDestination {
    fn default() -> &'a BigQueryDestination {
        <BigQueryDestination as ::protobuf::Message>::default_instance()
    }
}

impl BigQueryDestination {
    pub fn new() -> BigQueryDestination {
        ::std::default::Default::default()
    }

    // string dataset = 1;


    pub fn get_dataset(&self) -> &str {
        &self.dataset
    }
    pub fn clear_dataset(&mut self) {
        self.dataset.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset(&mut self, v: ::std::string::String) {
        self.dataset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset(&mut self) -> &mut ::std::string::String {
        &mut self.dataset
    }

    // Take field
    pub fn take_dataset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset, ::std::string::String::new())
    }

    // string table = 2;


    pub fn get_table(&self) -> &str {
        &self.table
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }

    // bool force = 3;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    // .google.cloud.asset.v1.PartitionSpec partition_spec = 4;


    pub fn get_partition_spec(&self) -> &PartitionSpec {
        self.partition_spec.as_ref().unwrap_or_else(|| <PartitionSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_partition_spec(&mut self) {
        self.partition_spec.clear();
    }

    pub fn has_partition_spec(&self) -> bool {
        self.partition_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_spec(&mut self, v: PartitionSpec) {
        self.partition_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_spec(&mut self) -> &mut PartitionSpec {
        if self.partition_spec.is_none() {
            self.partition_spec.set_default();
        }
        self.partition_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_spec(&mut self) -> PartitionSpec {
        self.partition_spec.take().unwrap_or_else(|| PartitionSpec::new())
    }

    // bool separate_tables_per_asset_type = 5;


    pub fn get_separate_tables_per_asset_type(&self) -> bool {
        self.separate_tables_per_asset_type
    }
    pub fn clear_separate_tables_per_asset_type(&mut self) {
        self.separate_tables_per_asset_type = false;
    }

    // Param is passed by value, moved
    pub fn set_separate_tables_per_asset_type(&mut self, v: bool) {
        self.separate_tables_per_asset_type = v;
    }
}

impl ::protobuf::Message for BigQueryDestination {
    fn is_initialized(&self) -> bool {
        for v in &self.partition_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.partition_spec)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.separate_tables_per_asset_type = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataset.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset);
        }
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table);
        }
        if self.force != false {
            my_size += 2;
        }
        if let Some(ref v) = self.partition_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.separate_tables_per_asset_type != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dataset.is_empty() {
            os.write_string(1, &self.dataset)?;
        }
        if !self.table.is_empty() {
            os.write_string(2, &self.table)?;
        }
        if self.force != false {
            os.write_bool(3, self.force)?;
        }
        if let Some(ref v) = self.partition_spec.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.separate_tables_per_asset_type != false {
            os.write_bool(5, self.separate_tables_per_asset_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BigQueryDestination {
        BigQueryDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset",
                |m: &BigQueryDestination| { &m.dataset },
                |m: &mut BigQueryDestination| { &mut m.dataset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table",
                |m: &BigQueryDestination| { &m.table },
                |m: &mut BigQueryDestination| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force",
                |m: &BigQueryDestination| { &m.force },
                |m: &mut BigQueryDestination| { &mut m.force },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PartitionSpec>>(
                "partition_spec",
                |m: &BigQueryDestination| { &m.partition_spec },
                |m: &mut BigQueryDestination| { &mut m.partition_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "separate_tables_per_asset_type",
                |m: &BigQueryDestination| { &m.separate_tables_per_asset_type },
                |m: &mut BigQueryDestination| { &mut m.separate_tables_per_asset_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BigQueryDestination>(
                "BigQueryDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BigQueryDestination {
        static instance: ::protobuf::rt::LazyV2<BigQueryDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BigQueryDestination::new)
    }
}

impl ::protobuf::Clear for BigQueryDestination {
    fn clear(&mut self) {
        self.dataset.clear();
        self.table.clear();
        self.force = false;
        self.partition_spec.clear();
        self.separate_tables_per_asset_type = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BigQueryDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BigQueryDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartitionSpec {
    // message fields
    pub partition_key: PartitionSpec_PartitionKey,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PartitionSpec {
    fn default() -> &'a PartitionSpec {
        <PartitionSpec as ::protobuf::Message>::default_instance()
    }
}

impl PartitionSpec {
    pub fn new() -> PartitionSpec {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.PartitionSpec.PartitionKey partition_key = 1;


    pub fn get_partition_key(&self) -> PartitionSpec_PartitionKey {
        self.partition_key
    }
    pub fn clear_partition_key(&mut self) {
        self.partition_key = PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: PartitionSpec_PartitionKey) {
        self.partition_key = v;
    }
}

impl ::protobuf::Message for PartitionSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.partition_key, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.partition_key != PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.partition_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.partition_key != PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.partition_key))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartitionSpec {
        PartitionSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartitionSpec_PartitionKey>>(
                "partition_key",
                |m: &PartitionSpec| { &m.partition_key },
                |m: &mut PartitionSpec| { &mut m.partition_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PartitionSpec>(
                "PartitionSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PartitionSpec {
        static instance: ::protobuf::rt::LazyV2<PartitionSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PartitionSpec::new)
    }
}

impl ::protobuf::Clear for PartitionSpec {
    fn clear(&mut self) {
        self.partition_key = PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartitionSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartitionSpec_PartitionKey {
    PARTITION_KEY_UNSPECIFIED = 0,
    READ_TIME = 1,
    REQUEST_TIME = 2,
}

impl ::protobuf::ProtobufEnum for PartitionSpec_PartitionKey {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartitionSpec_PartitionKey> {
        match value {
            0 => ::std::option::Option::Some(PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED),
            1 => ::std::option::Option::Some(PartitionSpec_PartitionKey::READ_TIME),
            2 => ::std::option::Option::Some(PartitionSpec_PartitionKey::REQUEST_TIME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartitionSpec_PartitionKey] = &[
            PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED,
            PartitionSpec_PartitionKey::READ_TIME,
            PartitionSpec_PartitionKey::REQUEST_TIME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PartitionSpec_PartitionKey>("PartitionSpec.PartitionKey", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PartitionSpec_PartitionKey {
}

impl ::std::default::Default for PartitionSpec_PartitionKey {
    fn default() -> Self {
        PartitionSpec_PartitionKey::PARTITION_KEY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionSpec_PartitionKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PubsubDestination {
    // message fields
    pub topic: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubsubDestination {
    fn default() -> &'a PubsubDestination {
        <PubsubDestination as ::protobuf::Message>::default_instance()
    }
}

impl PubsubDestination {
    pub fn new() -> PubsubDestination {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PubsubDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubsubDestination {
        PubsubDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &PubsubDestination| { &m.topic },
                |m: &mut PubsubDestination| { &mut m.topic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PubsubDestination>(
                "PubsubDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PubsubDestination {
        static instance: ::protobuf::rt::LazyV2<PubsubDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PubsubDestination::new)
    }
}

impl ::protobuf::Clear for PubsubDestination {
    fn clear(&mut self) {
        self.topic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubsubDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubsubDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeedOutputConfig {
    // message oneof groups
    pub destination: ::std::option::Option<FeedOutputConfig_oneof_destination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeedOutputConfig {
    fn default() -> &'a FeedOutputConfig {
        <FeedOutputConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FeedOutputConfig_oneof_destination {
    pubsub_destination(PubsubDestination),
}

impl FeedOutputConfig {
    pub fn new() -> FeedOutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.PubsubDestination pubsub_destination = 1;


    pub fn get_pubsub_destination(&self) -> &PubsubDestination {
        match self.destination {
            ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(ref v)) => v,
            _ => <PubsubDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pubsub_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_pubsub_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pubsub_destination(&mut self, v: PubsubDestination) {
        self.destination = ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pubsub_destination(&mut self) -> &mut PubsubDestination {
        if let ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(PubsubDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pubsub_destination(&mut self) -> PubsubDestination {
        if self.has_pubsub_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            PubsubDestination::new()
        }
    }
}

impl ::protobuf::Message for FeedOutputConfig {
    fn is_initialized(&self) -> bool {
        if let Some(FeedOutputConfig_oneof_destination::pubsub_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(FeedOutputConfig_oneof_destination::pubsub_destination(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &FeedOutputConfig_oneof_destination::pubsub_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &FeedOutputConfig_oneof_destination::pubsub_destination(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeedOutputConfig {
        FeedOutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PubsubDestination>(
                "pubsub_destination",
                FeedOutputConfig::has_pubsub_destination,
                FeedOutputConfig::get_pubsub_destination,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeedOutputConfig>(
                "FeedOutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeedOutputConfig {
        static instance: ::protobuf::rt::LazyV2<FeedOutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeedOutputConfig::new)
    }
}

impl ::protobuf::Clear for FeedOutputConfig {
    fn clear(&mut self) {
        self.destination = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeedOutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedOutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Feed {
    // message fields
    pub name: ::std::string::String,
    pub asset_names: ::protobuf::RepeatedField<::std::string::String>,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub content_type: ContentType,
    pub feed_output_config: ::protobuf::SingularPtrField<FeedOutputConfig>,
    pub condition: ::protobuf::SingularPtrField<super::expr::Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Feed {
    fn default() -> &'a Feed {
        <Feed as ::protobuf::Message>::default_instance()
    }
}

impl Feed {
    pub fn new() -> Feed {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string asset_names = 2;


    pub fn get_asset_names(&self) -> &[::std::string::String] {
        &self.asset_names
    }
    pub fn clear_asset_names(&mut self) {
        self.asset_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_names
    }

    // Take field
    pub fn take_asset_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_names, ::protobuf::RepeatedField::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.asset.v1.ContentType content_type = 4;


    pub fn get_content_type(&self) -> ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ContentType) {
        self.content_type = v;
    }

    // .google.cloud.asset.v1.FeedOutputConfig feed_output_config = 5;


    pub fn get_feed_output_config(&self) -> &FeedOutputConfig {
        self.feed_output_config.as_ref().unwrap_or_else(|| <FeedOutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feed_output_config(&mut self) {
        self.feed_output_config.clear();
    }

    pub fn has_feed_output_config(&self) -> bool {
        self.feed_output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed_output_config(&mut self, v: FeedOutputConfig) {
        self.feed_output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_output_config(&mut self) -> &mut FeedOutputConfig {
        if self.feed_output_config.is_none() {
            self.feed_output_config.set_default();
        }
        self.feed_output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_feed_output_config(&mut self) -> FeedOutputConfig {
        self.feed_output_config.take().unwrap_or_else(|| FeedOutputConfig::new())
    }

    // .google.type.Expr condition = 6;


    pub fn get_condition(&self) -> &super::expr::Expr {
        self.condition.as_ref().unwrap_or_else(|| <super::expr::Expr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: super::expr::Expr) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut super::expr::Expr {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> super::expr::Expr {
        self.condition.take().unwrap_or_else(|| super::expr::Expr::new())
    }
}

impl ::protobuf::Message for Feed {
    fn is_initialized(&self) -> bool {
        for v in &self.feed_output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_names)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feed_output_config)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.asset_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.content_type);
        }
        if let Some(ref v) = self.feed_output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.asset_names {
            os.write_string(2, &v)?;
        };
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.content_type != ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.content_type))?;
        }
        if let Some(ref v) = self.feed_output_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Feed {
        Feed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Feed| { &m.name },
                |m: &mut Feed| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_names",
                |m: &Feed| { &m.asset_names },
                |m: &mut Feed| { &mut m.asset_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &Feed| { &m.asset_types },
                |m: &mut Feed| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                "content_type",
                |m: &Feed| { &m.content_type },
                |m: &mut Feed| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeedOutputConfig>>(
                "feed_output_config",
                |m: &Feed| { &m.feed_output_config },
                |m: &mut Feed| { &mut m.feed_output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::expr::Expr>>(
                "condition",
                |m: &Feed| { &m.condition },
                |m: &mut Feed| { &mut m.condition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Feed>(
                "Feed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Feed {
        static instance: ::protobuf::rt::LazyV2<Feed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Feed::new)
    }
}

impl ::protobuf::Clear for Feed {
    fn clear(&mut self) {
        self.name.clear();
        self.asset_names.clear();
        self.asset_types.clear();
        self.content_type = ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.feed_output_config.clear();
        self.condition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Feed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Feed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllResourcesRequest {
    // message fields
    pub scope: ::std::string::String,
    pub query: ::std::string::String,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub order_by: ::std::string::String,
    pub read_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllResourcesRequest {
    fn default() -> &'a SearchAllResourcesRequest {
        <SearchAllResourcesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllResourcesRequest {
    pub fn new() -> SearchAllResourcesRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string query = 2;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // repeated string asset_types = 3;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // int32 page_size = 4;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string order_by = 6;


    pub fn get_order_by(&self) -> &str {
        &self.order_by
    }
    pub fn clear_order_by(&mut self) {
        self.order_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_by(&mut self, v: ::std::string::String) {
        self.order_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_by(&mut self) -> &mut ::std::string::String {
        &mut self.order_by
    }

    // Take field
    pub fn take_order_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_by, ::std::string::String::new())
    }

    // .google.protobuf.FieldMask read_mask = 8;


    pub fn get_read_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.read_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_mask(&mut self) {
        self.read_mask.clear();
    }

    pub fn has_read_mask(&self) -> bool {
        self.read_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.read_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.read_mask.is_none() {
            self.read_mask.set_default();
        }
        self.read_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.read_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for SearchAllResourcesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.read_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_by)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.query);
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if !self.order_by.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.order_by);
        }
        if let Some(ref v) = self.read_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if !self.query.is_empty() {
            os.write_string(2, &self.query)?;
        }
        for v in &self.asset_types {
            os.write_string(3, &v)?;
        };
        if self.page_size != 0 {
            os.write_int32(4, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            os.write_string(6, &self.order_by)?;
        }
        if let Some(ref v) = self.read_mask.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllResourcesRequest {
        SearchAllResourcesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &SearchAllResourcesRequest| { &m.scope },
                |m: &mut SearchAllResourcesRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &SearchAllResourcesRequest| { &m.query },
                |m: &mut SearchAllResourcesRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &SearchAllResourcesRequest| { &m.asset_types },
                |m: &mut SearchAllResourcesRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &SearchAllResourcesRequest| { &m.page_size },
                |m: &mut SearchAllResourcesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &SearchAllResourcesRequest| { &m.page_token },
                |m: &mut SearchAllResourcesRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "order_by",
                |m: &SearchAllResourcesRequest| { &m.order_by },
                |m: &mut SearchAllResourcesRequest| { &mut m.order_by },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "read_mask",
                |m: &SearchAllResourcesRequest| { &m.read_mask },
                |m: &mut SearchAllResourcesRequest| { &mut m.read_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllResourcesRequest>(
                "SearchAllResourcesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllResourcesRequest {
        static instance: ::protobuf::rt::LazyV2<SearchAllResourcesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllResourcesRequest::new)
    }
}

impl ::protobuf::Clear for SearchAllResourcesRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.query.clear();
        self.asset_types.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.order_by.clear();
        self.read_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllResourcesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllResourcesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllResourcesResponse {
    // message fields
    pub results: ::protobuf::RepeatedField<super::assets::ResourceSearchResult>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllResourcesResponse {
    fn default() -> &'a SearchAllResourcesResponse {
        <SearchAllResourcesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllResourcesResponse {
    pub fn new() -> SearchAllResourcesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.ResourceSearchResult results = 1;


    pub fn get_results(&self) -> &[super::assets::ResourceSearchResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::assets::ResourceSearchResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::ResourceSearchResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::assets::ResourceSearchResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchAllResourcesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllResourcesResponse {
        SearchAllResourcesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::ResourceSearchResult>>(
                "results",
                |m: &SearchAllResourcesResponse| { &m.results },
                |m: &mut SearchAllResourcesResponse| { &mut m.results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &SearchAllResourcesResponse| { &m.next_page_token },
                |m: &mut SearchAllResourcesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllResourcesResponse>(
                "SearchAllResourcesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllResourcesResponse {
        static instance: ::protobuf::rt::LazyV2<SearchAllResourcesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllResourcesResponse::new)
    }
}

impl ::protobuf::Clear for SearchAllResourcesResponse {
    fn clear(&mut self) {
        self.results.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllResourcesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllResourcesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllIamPoliciesRequest {
    // message fields
    pub scope: ::std::string::String,
    pub query: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub asset_types: ::protobuf::RepeatedField<::std::string::String>,
    pub order_by: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllIamPoliciesRequest {
    fn default() -> &'a SearchAllIamPoliciesRequest {
        <SearchAllIamPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllIamPoliciesRequest {
    pub fn new() -> SearchAllIamPoliciesRequest {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string query = 2;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // repeated string asset_types = 5;


    pub fn get_asset_types(&self) -> &[::std::string::String] {
        &self.asset_types
    }
    pub fn clear_asset_types(&mut self) {
        self.asset_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.asset_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.asset_types
    }

    // Take field
    pub fn take_asset_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.asset_types, ::protobuf::RepeatedField::new())
    }

    // string order_by = 7;


    pub fn get_order_by(&self) -> &str {
        &self.order_by
    }
    pub fn clear_order_by(&mut self) {
        self.order_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_by(&mut self, v: ::std::string::String) {
        self.order_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_by(&mut self) -> &mut ::std::string::String {
        &mut self.order_by
    }

    // Take field
    pub fn take_order_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_by, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchAllIamPoliciesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.asset_types)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_by)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.query);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        for value in &self.asset_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.order_by.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.order_by);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if !self.query.is_empty() {
            os.write_string(2, &self.query)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        for v in &self.asset_types {
            os.write_string(5, &v)?;
        };
        if !self.order_by.is_empty() {
            os.write_string(7, &self.order_by)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllIamPoliciesRequest {
        SearchAllIamPoliciesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &SearchAllIamPoliciesRequest| { &m.scope },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &SearchAllIamPoliciesRequest| { &m.query },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &SearchAllIamPoliciesRequest| { &m.page_size },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &SearchAllIamPoliciesRequest| { &m.page_token },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_types",
                |m: &SearchAllIamPoliciesRequest| { &m.asset_types },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.asset_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "order_by",
                |m: &SearchAllIamPoliciesRequest| { &m.order_by },
                |m: &mut SearchAllIamPoliciesRequest| { &mut m.order_by },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllIamPoliciesRequest>(
                "SearchAllIamPoliciesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllIamPoliciesRequest {
        static instance: ::protobuf::rt::LazyV2<SearchAllIamPoliciesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllIamPoliciesRequest::new)
    }
}

impl ::protobuf::Clear for SearchAllIamPoliciesRequest {
    fn clear(&mut self) {
        self.scope.clear();
        self.query.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.asset_types.clear();
        self.order_by.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllIamPoliciesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllIamPoliciesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchAllIamPoliciesResponse {
    // message fields
    pub results: ::protobuf::RepeatedField<super::assets::IamPolicySearchResult>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchAllIamPoliciesResponse {
    fn default() -> &'a SearchAllIamPoliciesResponse {
        <SearchAllIamPoliciesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchAllIamPoliciesResponse {
    pub fn new() -> SearchAllIamPoliciesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.IamPolicySearchResult results = 1;


    pub fn get_results(&self) -> &[super::assets::IamPolicySearchResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::assets::IamPolicySearchResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::IamPolicySearchResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::assets::IamPolicySearchResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchAllIamPoliciesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchAllIamPoliciesResponse {
        SearchAllIamPoliciesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::IamPolicySearchResult>>(
                "results",
                |m: &SearchAllIamPoliciesResponse| { &m.results },
                |m: &mut SearchAllIamPoliciesResponse| { &mut m.results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &SearchAllIamPoliciesResponse| { &m.next_page_token },
                |m: &mut SearchAllIamPoliciesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchAllIamPoliciesResponse>(
                "SearchAllIamPoliciesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchAllIamPoliciesResponse {
        static instance: ::protobuf::rt::LazyV2<SearchAllIamPoliciesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchAllIamPoliciesResponse::new)
    }
}

impl ::protobuf::Clear for SearchAllIamPoliciesResponse {
    fn clear(&mut self) {
        self.results.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchAllIamPoliciesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchAllIamPoliciesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery {
    // message fields
    pub scope: ::std::string::String,
    pub resource_selector: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_ResourceSelector>,
    pub identity_selector: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_IdentitySelector>,
    pub access_selector: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_AccessSelector>,
    pub options: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_Options>,
    pub condition_context: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery_ConditionContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery {
    fn default() -> &'a IamPolicyAnalysisQuery {
        <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery {
    pub fn new() -> IamPolicyAnalysisQuery {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.ResourceSelector resource_selector = 2;


    pub fn get_resource_selector(&self) -> &IamPolicyAnalysisQuery_ResourceSelector {
        self.resource_selector.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_ResourceSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource_selector(&mut self) {
        self.resource_selector.clear();
    }

    pub fn has_resource_selector(&self) -> bool {
        self.resource_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource_selector(&mut self, v: IamPolicyAnalysisQuery_ResourceSelector) {
        self.resource_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_selector(&mut self) -> &mut IamPolicyAnalysisQuery_ResourceSelector {
        if self.resource_selector.is_none() {
            self.resource_selector.set_default();
        }
        self.resource_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource_selector(&mut self) -> IamPolicyAnalysisQuery_ResourceSelector {
        self.resource_selector.take().unwrap_or_else(|| IamPolicyAnalysisQuery_ResourceSelector::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.IdentitySelector identity_selector = 3;


    pub fn get_identity_selector(&self) -> &IamPolicyAnalysisQuery_IdentitySelector {
        self.identity_selector.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_IdentitySelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identity_selector(&mut self) {
        self.identity_selector.clear();
    }

    pub fn has_identity_selector(&self) -> bool {
        self.identity_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_selector(&mut self, v: IamPolicyAnalysisQuery_IdentitySelector) {
        self.identity_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_selector(&mut self) -> &mut IamPolicyAnalysisQuery_IdentitySelector {
        if self.identity_selector.is_none() {
            self.identity_selector.set_default();
        }
        self.identity_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_selector(&mut self) -> IamPolicyAnalysisQuery_IdentitySelector {
        self.identity_selector.take().unwrap_or_else(|| IamPolicyAnalysisQuery_IdentitySelector::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.AccessSelector access_selector = 4;


    pub fn get_access_selector(&self) -> &IamPolicyAnalysisQuery_AccessSelector {
        self.access_selector.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_AccessSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_access_selector(&mut self) {
        self.access_selector.clear();
    }

    pub fn has_access_selector(&self) -> bool {
        self.access_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_selector(&mut self, v: IamPolicyAnalysisQuery_AccessSelector) {
        self.access_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_selector(&mut self) -> &mut IamPolicyAnalysisQuery_AccessSelector {
        if self.access_selector.is_none() {
            self.access_selector.set_default();
        }
        self.access_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_selector(&mut self) -> IamPolicyAnalysisQuery_AccessSelector {
        self.access_selector.take().unwrap_or_else(|| IamPolicyAnalysisQuery_AccessSelector::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.Options options = 5;


    pub fn get_options(&self) -> &IamPolicyAnalysisQuery_Options {
        self.options.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_Options as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: IamPolicyAnalysisQuery_Options) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut IamPolicyAnalysisQuery_Options {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> IamPolicyAnalysisQuery_Options {
        self.options.take().unwrap_or_else(|| IamPolicyAnalysisQuery_Options::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery.ConditionContext condition_context = 6;


    pub fn get_condition_context(&self) -> &IamPolicyAnalysisQuery_ConditionContext {
        self.condition_context.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery_ConditionContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition_context(&mut self) {
        self.condition_context.clear();
    }

    pub fn has_condition_context(&self) -> bool {
        self.condition_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition_context(&mut self, v: IamPolicyAnalysisQuery_ConditionContext) {
        self.condition_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition_context(&mut self) -> &mut IamPolicyAnalysisQuery_ConditionContext {
        if self.condition_context.is_none() {
            self.condition_context.set_default();
        }
        self.condition_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition_context(&mut self) -> IamPolicyAnalysisQuery_ConditionContext {
        self.condition_context.take().unwrap_or_else(|| IamPolicyAnalysisQuery_ConditionContext::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.identity_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.access_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource_selector)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identity_selector)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.access_selector)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        if let Some(ref v) = self.resource_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.identity_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.access_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.condition_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        if let Some(ref v) = self.resource_selector.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.identity_selector.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.access_selector.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.condition_context.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery {
        IamPolicyAnalysisQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &IamPolicyAnalysisQuery| { &m.scope },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_ResourceSelector>>(
                "resource_selector",
                |m: &IamPolicyAnalysisQuery| { &m.resource_selector },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.resource_selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_IdentitySelector>>(
                "identity_selector",
                |m: &IamPolicyAnalysisQuery| { &m.identity_selector },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.identity_selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_AccessSelector>>(
                "access_selector",
                |m: &IamPolicyAnalysisQuery| { &m.access_selector },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.access_selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_Options>>(
                "options",
                |m: &IamPolicyAnalysisQuery| { &m.options },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery_ConditionContext>>(
                "condition_context",
                |m: &IamPolicyAnalysisQuery| { &m.condition_context },
                |m: &mut IamPolicyAnalysisQuery| { &mut m.condition_context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery>(
                "IamPolicyAnalysisQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery {
    fn clear(&mut self) {
        self.scope.clear();
        self.resource_selector.clear();
        self.identity_selector.clear();
        self.access_selector.clear();
        self.options.clear();
        self.condition_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_ResourceSelector {
    // message fields
    pub full_resource_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_ResourceSelector {
    fn default() -> &'a IamPolicyAnalysisQuery_ResourceSelector {
        <IamPolicyAnalysisQuery_ResourceSelector as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_ResourceSelector {
    pub fn new() -> IamPolicyAnalysisQuery_ResourceSelector {
        ::std::default::Default::default()
    }

    // string full_resource_name = 1;


    pub fn get_full_resource_name(&self) -> &str {
        &self.full_resource_name
    }
    pub fn clear_full_resource_name(&mut self) {
        self.full_resource_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_resource_name(&mut self, v: ::std::string::String) {
        self.full_resource_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_resource_name(&mut self) -> &mut ::std::string::String {
        &mut self.full_resource_name
    }

    // Take field
    pub fn take_full_resource_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.full_resource_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_ResourceSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.full_resource_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.full_resource_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.full_resource_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.full_resource_name.is_empty() {
            os.write_string(1, &self.full_resource_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_ResourceSelector {
        IamPolicyAnalysisQuery_ResourceSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "full_resource_name",
                |m: &IamPolicyAnalysisQuery_ResourceSelector| { &m.full_resource_name },
                |m: &mut IamPolicyAnalysisQuery_ResourceSelector| { &mut m.full_resource_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_ResourceSelector>(
                "IamPolicyAnalysisQuery.ResourceSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_ResourceSelector {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_ResourceSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_ResourceSelector::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_ResourceSelector {
    fn clear(&mut self) {
        self.full_resource_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_ResourceSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_ResourceSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_IdentitySelector {
    // message fields
    pub identity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_IdentitySelector {
    fn default() -> &'a IamPolicyAnalysisQuery_IdentitySelector {
        <IamPolicyAnalysisQuery_IdentitySelector as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_IdentitySelector {
    pub fn new() -> IamPolicyAnalysisQuery_IdentitySelector {
        ::std::default::Default::default()
    }

    // string identity = 1;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_IdentitySelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity.is_empty() {
            os.write_string(1, &self.identity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_IdentitySelector {
        IamPolicyAnalysisQuery_IdentitySelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity",
                |m: &IamPolicyAnalysisQuery_IdentitySelector| { &m.identity },
                |m: &mut IamPolicyAnalysisQuery_IdentitySelector| { &mut m.identity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_IdentitySelector>(
                "IamPolicyAnalysisQuery.IdentitySelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_IdentitySelector {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_IdentitySelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_IdentitySelector::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_IdentitySelector {
    fn clear(&mut self) {
        self.identity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_IdentitySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_IdentitySelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_AccessSelector {
    // message fields
    pub roles: ::protobuf::RepeatedField<::std::string::String>,
    pub permissions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_AccessSelector {
    fn default() -> &'a IamPolicyAnalysisQuery_AccessSelector {
        <IamPolicyAnalysisQuery_AccessSelector as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_AccessSelector {
    pub fn new() -> IamPolicyAnalysisQuery_AccessSelector {
        ::std::default::Default::default()
    }

    // repeated string roles = 1;


    pub fn get_roles(&self) -> &[::std::string::String] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }

    // repeated string permissions = 2;


    pub fn get_permissions(&self) -> &[::std::string::String] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.permissions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_AccessSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.roles)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.roles {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.permissions {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.roles {
            os.write_string(1, &v)?;
        };
        for v in &self.permissions {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_AccessSelector {
        IamPolicyAnalysisQuery_AccessSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "roles",
                |m: &IamPolicyAnalysisQuery_AccessSelector| { &m.roles },
                |m: &mut IamPolicyAnalysisQuery_AccessSelector| { &mut m.roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permissions",
                |m: &IamPolicyAnalysisQuery_AccessSelector| { &m.permissions },
                |m: &mut IamPolicyAnalysisQuery_AccessSelector| { &mut m.permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_AccessSelector>(
                "IamPolicyAnalysisQuery.AccessSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_AccessSelector {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_AccessSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_AccessSelector::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_AccessSelector {
    fn clear(&mut self) {
        self.roles.clear();
        self.permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_AccessSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_AccessSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_Options {
    // message fields
    pub expand_groups: bool,
    pub expand_roles: bool,
    pub expand_resources: bool,
    pub output_resource_edges: bool,
    pub output_group_edges: bool,
    pub analyze_service_account_impersonation: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_Options {
    fn default() -> &'a IamPolicyAnalysisQuery_Options {
        <IamPolicyAnalysisQuery_Options as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisQuery_Options {
    pub fn new() -> IamPolicyAnalysisQuery_Options {
        ::std::default::Default::default()
    }

    // bool expand_groups = 1;


    pub fn get_expand_groups(&self) -> bool {
        self.expand_groups
    }
    pub fn clear_expand_groups(&mut self) {
        self.expand_groups = false;
    }

    // Param is passed by value, moved
    pub fn set_expand_groups(&mut self, v: bool) {
        self.expand_groups = v;
    }

    // bool expand_roles = 2;


    pub fn get_expand_roles(&self) -> bool {
        self.expand_roles
    }
    pub fn clear_expand_roles(&mut self) {
        self.expand_roles = false;
    }

    // Param is passed by value, moved
    pub fn set_expand_roles(&mut self, v: bool) {
        self.expand_roles = v;
    }

    // bool expand_resources = 3;


    pub fn get_expand_resources(&self) -> bool {
        self.expand_resources
    }
    pub fn clear_expand_resources(&mut self) {
        self.expand_resources = false;
    }

    // Param is passed by value, moved
    pub fn set_expand_resources(&mut self, v: bool) {
        self.expand_resources = v;
    }

    // bool output_resource_edges = 4;


    pub fn get_output_resource_edges(&self) -> bool {
        self.output_resource_edges
    }
    pub fn clear_output_resource_edges(&mut self) {
        self.output_resource_edges = false;
    }

    // Param is passed by value, moved
    pub fn set_output_resource_edges(&mut self, v: bool) {
        self.output_resource_edges = v;
    }

    // bool output_group_edges = 5;


    pub fn get_output_group_edges(&self) -> bool {
        self.output_group_edges
    }
    pub fn clear_output_group_edges(&mut self) {
        self.output_group_edges = false;
    }

    // Param is passed by value, moved
    pub fn set_output_group_edges(&mut self, v: bool) {
        self.output_group_edges = v;
    }

    // bool analyze_service_account_impersonation = 6;


    pub fn get_analyze_service_account_impersonation(&self) -> bool {
        self.analyze_service_account_impersonation
    }
    pub fn clear_analyze_service_account_impersonation(&mut self) {
        self.analyze_service_account_impersonation = false;
    }

    // Param is passed by value, moved
    pub fn set_analyze_service_account_impersonation(&mut self, v: bool) {
        self.analyze_service_account_impersonation = v;
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_Options {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expand_groups = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expand_roles = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expand_resources = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.output_resource_edges = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.output_group_edges = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.analyze_service_account_impersonation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.expand_groups != false {
            my_size += 2;
        }
        if self.expand_roles != false {
            my_size += 2;
        }
        if self.expand_resources != false {
            my_size += 2;
        }
        if self.output_resource_edges != false {
            my_size += 2;
        }
        if self.output_group_edges != false {
            my_size += 2;
        }
        if self.analyze_service_account_impersonation != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.expand_groups != false {
            os.write_bool(1, self.expand_groups)?;
        }
        if self.expand_roles != false {
            os.write_bool(2, self.expand_roles)?;
        }
        if self.expand_resources != false {
            os.write_bool(3, self.expand_resources)?;
        }
        if self.output_resource_edges != false {
            os.write_bool(4, self.output_resource_edges)?;
        }
        if self.output_group_edges != false {
            os.write_bool(5, self.output_group_edges)?;
        }
        if self.analyze_service_account_impersonation != false {
            os.write_bool(6, self.analyze_service_account_impersonation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_Options {
        IamPolicyAnalysisQuery_Options::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expand_groups",
                |m: &IamPolicyAnalysisQuery_Options| { &m.expand_groups },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.expand_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expand_roles",
                |m: &IamPolicyAnalysisQuery_Options| { &m.expand_roles },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.expand_roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expand_resources",
                |m: &IamPolicyAnalysisQuery_Options| { &m.expand_resources },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.expand_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "output_resource_edges",
                |m: &IamPolicyAnalysisQuery_Options| { &m.output_resource_edges },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.output_resource_edges },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "output_group_edges",
                |m: &IamPolicyAnalysisQuery_Options| { &m.output_group_edges },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.output_group_edges },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "analyze_service_account_impersonation",
                |m: &IamPolicyAnalysisQuery_Options| { &m.analyze_service_account_impersonation },
                |m: &mut IamPolicyAnalysisQuery_Options| { &mut m.analyze_service_account_impersonation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_Options>(
                "IamPolicyAnalysisQuery.Options",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_Options {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_Options> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_Options::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_Options {
    fn clear(&mut self) {
        self.expand_groups = false;
        self.expand_roles = false;
        self.expand_resources = false;
        self.output_resource_edges = false;
        self.output_group_edges = false;
        self.analyze_service_account_impersonation = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_Options {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_Options {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisQuery_ConditionContext {
    // message oneof groups
    pub TimeContext: ::std::option::Option<IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisQuery_ConditionContext {
    fn default() -> &'a IamPolicyAnalysisQuery_ConditionContext {
        <IamPolicyAnalysisQuery_ConditionContext as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext {
    access_time(::protobuf::well_known_types::Timestamp),
}

impl IamPolicyAnalysisQuery_ConditionContext {
    pub fn new() -> IamPolicyAnalysisQuery_ConditionContext {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp access_time = 1;


    pub fn get_access_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.TimeContext {
            ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_access_time(&mut self) {
        self.TimeContext = ::std::option::Option::None;
    }

    pub fn has_access_time(&self) -> bool {
        match self.TimeContext {
            ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_access_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.TimeContext = ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_access_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(_)) = self.TimeContext {
        } else {
            self.TimeContext = ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.TimeContext {
            ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_access_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_access_time() {
            match self.TimeContext.take() {
                ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }
}

impl ::protobuf::Message for IamPolicyAnalysisQuery_ConditionContext {
    fn is_initialized(&self) -> bool {
        if let Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v)) = self.TimeContext {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.TimeContext = ::std::option::Option::Some(IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.TimeContext {
            match v {
                &IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.TimeContext {
            match v {
                &IamPolicyAnalysisQuery_ConditionContext_oneof_TimeContext::access_time(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisQuery_ConditionContext {
        IamPolicyAnalysisQuery_ConditionContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "access_time",
                IamPolicyAnalysisQuery_ConditionContext::has_access_time,
                IamPolicyAnalysisQuery_ConditionContext::get_access_time,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisQuery_ConditionContext>(
                "IamPolicyAnalysisQuery.ConditionContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisQuery_ConditionContext {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisQuery_ConditionContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisQuery_ConditionContext::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisQuery_ConditionContext {
    fn clear(&mut self) {
        self.TimeContext = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisQuery_ConditionContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisQuery_ConditionContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyRequest {
    // message fields
    pub analysis_query: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery>,
    pub execution_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyRequest {
    fn default() -> &'a AnalyzeIamPolicyRequest {
        <AnalyzeIamPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyRequest {
    pub fn new() -> AnalyzeIamPolicyRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery analysis_query = 1;


    pub fn get_analysis_query(&self) -> &IamPolicyAnalysisQuery {
        self.analysis_query.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_analysis_query(&mut self) {
        self.analysis_query.clear();
    }

    pub fn has_analysis_query(&self) -> bool {
        self.analysis_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_analysis_query(&mut self, v: IamPolicyAnalysisQuery) {
        self.analysis_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_analysis_query(&mut self) -> &mut IamPolicyAnalysisQuery {
        if self.analysis_query.is_none() {
            self.analysis_query.set_default();
        }
        self.analysis_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_analysis_query(&mut self) -> IamPolicyAnalysisQuery {
        self.analysis_query.take().unwrap_or_else(|| IamPolicyAnalysisQuery::new())
    }

    // .google.protobuf.Duration execution_timeout = 2;


    pub fn get_execution_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.execution_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execution_timeout(&mut self) {
        self.execution_timeout.clear();
    }

    pub fn has_execution_timeout(&self) -> bool {
        self.execution_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.execution_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.execution_timeout.is_none() {
            self.execution_timeout.set_default();
        }
        self.execution_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_execution_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.execution_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.analysis_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.execution_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.analysis_query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execution_timeout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.analysis_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.execution_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.analysis_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.execution_timeout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyRequest {
        AnalyzeIamPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery>>(
                "analysis_query",
                |m: &AnalyzeIamPolicyRequest| { &m.analysis_query },
                |m: &mut AnalyzeIamPolicyRequest| { &mut m.analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "execution_timeout",
                |m: &AnalyzeIamPolicyRequest| { &m.execution_timeout },
                |m: &mut AnalyzeIamPolicyRequest| { &mut m.execution_timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyRequest>(
                "AnalyzeIamPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyRequest {
    fn clear(&mut self) {
        self.analysis_query.clear();
        self.execution_timeout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyResponse {
    // message fields
    pub main_analysis: ::protobuf::SingularPtrField<AnalyzeIamPolicyResponse_IamPolicyAnalysis>,
    pub service_account_impersonation_analysis: ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis>,
    pub fully_explored: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyResponse {
    fn default() -> &'a AnalyzeIamPolicyResponse {
        <AnalyzeIamPolicyResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyResponse {
    pub fn new() -> AnalyzeIamPolicyResponse {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis main_analysis = 1;


    pub fn get_main_analysis(&self) -> &AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        self.main_analysis.as_ref().unwrap_or_else(|| <AnalyzeIamPolicyResponse_IamPolicyAnalysis as ::protobuf::Message>::default_instance())
    }
    pub fn clear_main_analysis(&mut self) {
        self.main_analysis.clear();
    }

    pub fn has_main_analysis(&self) -> bool {
        self.main_analysis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_analysis(&mut self, v: AnalyzeIamPolicyResponse_IamPolicyAnalysis) {
        self.main_analysis = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_analysis(&mut self) -> &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        if self.main_analysis.is_none() {
            self.main_analysis.set_default();
        }
        self.main_analysis.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_analysis(&mut self) -> AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        self.main_analysis.take().unwrap_or_else(|| AnalyzeIamPolicyResponse_IamPolicyAnalysis::new())
    }

    // repeated .google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis service_account_impersonation_analysis = 2;


    pub fn get_service_account_impersonation_analysis(&self) -> &[AnalyzeIamPolicyResponse_IamPolicyAnalysis] {
        &self.service_account_impersonation_analysis
    }
    pub fn clear_service_account_impersonation_analysis(&mut self) {
        self.service_account_impersonation_analysis.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account_impersonation_analysis(&mut self, v: ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis>) {
        self.service_account_impersonation_analysis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_account_impersonation_analysis(&mut self) -> &mut ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis> {
        &mut self.service_account_impersonation_analysis
    }

    // Take field
    pub fn take_service_account_impersonation_analysis(&mut self) -> ::protobuf::RepeatedField<AnalyzeIamPolicyResponse_IamPolicyAnalysis> {
        ::std::mem::replace(&mut self.service_account_impersonation_analysis, ::protobuf::RepeatedField::new())
    }

    // bool fully_explored = 3;


    pub fn get_fully_explored(&self) -> bool {
        self.fully_explored
    }
    pub fn clear_fully_explored(&mut self) {
        self.fully_explored = false;
    }

    // Param is passed by value, moved
    pub fn set_fully_explored(&mut self, v: bool) {
        self.fully_explored = v;
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.main_analysis {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service_account_impersonation_analysis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.main_analysis)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_account_impersonation_analysis)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fully_explored = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.main_analysis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.service_account_impersonation_analysis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.fully_explored != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.main_analysis.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.service_account_impersonation_analysis {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.fully_explored != false {
            os.write_bool(3, self.fully_explored)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyResponse {
        AnalyzeIamPolicyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzeIamPolicyResponse_IamPolicyAnalysis>>(
                "main_analysis",
                |m: &AnalyzeIamPolicyResponse| { &m.main_analysis },
                |m: &mut AnalyzeIamPolicyResponse| { &mut m.main_analysis },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalyzeIamPolicyResponse_IamPolicyAnalysis>>(
                "service_account_impersonation_analysis",
                |m: &AnalyzeIamPolicyResponse| { &m.service_account_impersonation_analysis },
                |m: &mut AnalyzeIamPolicyResponse| { &mut m.service_account_impersonation_analysis },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fully_explored",
                |m: &AnalyzeIamPolicyResponse| { &m.fully_explored },
                |m: &mut AnalyzeIamPolicyResponse| { &mut m.fully_explored },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyResponse>(
                "AnalyzeIamPolicyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyResponse {
    fn clear(&mut self) {
        self.main_analysis.clear();
        self.service_account_impersonation_analysis.clear();
        self.fully_explored = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    // message fields
    pub analysis_query: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery>,
    pub analysis_results: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult>,
    pub fully_explored: bool,
    pub non_critical_errors: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn default() -> &'a AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        <AnalyzeIamPolicyResponse_IamPolicyAnalysis as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    pub fn new() -> AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery analysis_query = 1;


    pub fn get_analysis_query(&self) -> &IamPolicyAnalysisQuery {
        self.analysis_query.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_analysis_query(&mut self) {
        self.analysis_query.clear();
    }

    pub fn has_analysis_query(&self) -> bool {
        self.analysis_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_analysis_query(&mut self, v: IamPolicyAnalysisQuery) {
        self.analysis_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_analysis_query(&mut self) -> &mut IamPolicyAnalysisQuery {
        if self.analysis_query.is_none() {
            self.analysis_query.set_default();
        }
        self.analysis_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_analysis_query(&mut self) -> IamPolicyAnalysisQuery {
        self.analysis_query.take().unwrap_or_else(|| IamPolicyAnalysisQuery::new())
    }

    // repeated .google.cloud.asset.v1.IamPolicyAnalysisResult analysis_results = 2;


    pub fn get_analysis_results(&self) -> &[super::assets::IamPolicyAnalysisResult] {
        &self.analysis_results
    }
    pub fn clear_analysis_results(&mut self) {
        self.analysis_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_analysis_results(&mut self, v: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult>) {
        self.analysis_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_analysis_results(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult> {
        &mut self.analysis_results
    }

    // Take field
    pub fn take_analysis_results(&mut self) -> ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisResult> {
        ::std::mem::replace(&mut self.analysis_results, ::protobuf::RepeatedField::new())
    }

    // bool fully_explored = 3;


    pub fn get_fully_explored(&self) -> bool {
        self.fully_explored
    }
    pub fn clear_fully_explored(&mut self) {
        self.fully_explored = false;
    }

    // Param is passed by value, moved
    pub fn set_fully_explored(&mut self, v: bool) {
        self.fully_explored = v;
    }

    // repeated .google.cloud.asset.v1.IamPolicyAnalysisState non_critical_errors = 5;


    pub fn get_non_critical_errors(&self) -> &[super::assets::IamPolicyAnalysisState] {
        &self.non_critical_errors
    }
    pub fn clear_non_critical_errors(&mut self) {
        self.non_critical_errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_non_critical_errors(&mut self, v: ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState>) {
        self.non_critical_errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_non_critical_errors(&mut self) -> &mut ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState> {
        &mut self.non_critical_errors
    }

    // Take field
    pub fn take_non_critical_errors(&mut self) -> ::protobuf::RepeatedField<super::assets::IamPolicyAnalysisState> {
        ::std::mem::replace(&mut self.non_critical_errors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn is_initialized(&self) -> bool {
        for v in &self.analysis_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.analysis_results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.non_critical_errors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.analysis_query)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.analysis_results)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fully_explored = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.non_critical_errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.analysis_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.analysis_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.fully_explored != false {
            my_size += 2;
        }
        for value in &self.non_critical_errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.analysis_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.analysis_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.fully_explored != false {
            os.write_bool(3, self.fully_explored)?;
        }
        for v in &self.non_critical_errors {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        AnalyzeIamPolicyResponse_IamPolicyAnalysis::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery>>(
                "analysis_query",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.analysis_query },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::IamPolicyAnalysisResult>>(
                "analysis_results",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.analysis_results },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.analysis_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fully_explored",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.fully_explored },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.fully_explored },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::assets::IamPolicyAnalysisState>>(
                "non_critical_errors",
                |m: &AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &m.non_critical_errors },
                |m: &mut AnalyzeIamPolicyResponse_IamPolicyAnalysis| { &mut m.non_critical_errors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyResponse_IamPolicyAnalysis>(
                "AnalyzeIamPolicyResponse.IamPolicyAnalysis",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyResponse_IamPolicyAnalysis {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyResponse_IamPolicyAnalysis> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyResponse_IamPolicyAnalysis::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn clear(&mut self) {
        self.analysis_query.clear();
        self.analysis_results.clear();
        self.fully_explored = false;
        self.non_critical_errors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyResponse_IamPolicyAnalysis {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisOutputConfig {
    // message oneof groups
    pub destination: ::std::option::Option<IamPolicyAnalysisOutputConfig_oneof_destination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisOutputConfig {
    fn default() -> &'a IamPolicyAnalysisOutputConfig {
        <IamPolicyAnalysisOutputConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum IamPolicyAnalysisOutputConfig_oneof_destination {
    gcs_destination(IamPolicyAnalysisOutputConfig_GcsDestination),
    bigquery_destination(IamPolicyAnalysisOutputConfig_BigQueryDestination),
}

impl IamPolicyAnalysisOutputConfig {
    pub fn new() -> IamPolicyAnalysisOutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.GcsDestination gcs_destination = 1;


    pub fn get_gcs_destination(&self) -> &IamPolicyAnalysisOutputConfig_GcsDestination {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v)) => v,
            _ => <IamPolicyAnalysisOutputConfig_GcsDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_gcs_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_destination(&mut self, v: IamPolicyAnalysisOutputConfig_GcsDestination) {
        self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_destination(&mut self) -> &mut IamPolicyAnalysisOutputConfig_GcsDestination {
        if let ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(IamPolicyAnalysisOutputConfig_GcsDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_destination(&mut self) -> IamPolicyAnalysisOutputConfig_GcsDestination {
        if self.has_gcs_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            IamPolicyAnalysisOutputConfig_GcsDestination::new()
        }
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.BigQueryDestination bigquery_destination = 2;


    pub fn get_bigquery_destination(&self) -> &IamPolicyAnalysisOutputConfig_BigQueryDestination {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v)) => v,
            _ => <IamPolicyAnalysisOutputConfig_BigQueryDestination as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bigquery_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_bigquery_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bigquery_destination(&mut self, v: IamPolicyAnalysisOutputConfig_BigQueryDestination) {
        self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bigquery_destination(&mut self) -> &mut IamPolicyAnalysisOutputConfig_BigQueryDestination {
        if let ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(IamPolicyAnalysisOutputConfig_BigQueryDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bigquery_destination(&mut self) -> IamPolicyAnalysisOutputConfig_BigQueryDestination {
        if self.has_bigquery_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(v)) => v,
                _ => panic!(),
            }
        } else {
            IamPolicyAnalysisOutputConfig_BigQueryDestination::new()
        }
    }
}

impl ::protobuf::Message for IamPolicyAnalysisOutputConfig {
    fn is_initialized(&self) -> bool {
        if let Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v)) = self.destination {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.destination = ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &IamPolicyAnalysisOutputConfig_oneof_destination::gcs_destination(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &IamPolicyAnalysisOutputConfig_oneof_destination::bigquery_destination(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisOutputConfig {
        IamPolicyAnalysisOutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IamPolicyAnalysisOutputConfig_GcsDestination>(
                "gcs_destination",
                IamPolicyAnalysisOutputConfig::has_gcs_destination,
                IamPolicyAnalysisOutputConfig::get_gcs_destination,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IamPolicyAnalysisOutputConfig_BigQueryDestination>(
                "bigquery_destination",
                IamPolicyAnalysisOutputConfig::has_bigquery_destination,
                IamPolicyAnalysisOutputConfig::get_bigquery_destination,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig>(
                "IamPolicyAnalysisOutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisOutputConfig {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisOutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisOutputConfig::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisOutputConfig {
    fn clear(&mut self) {
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisOutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisOutputConfig_GcsDestination {
    // message fields
    pub uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisOutputConfig_GcsDestination {
    fn default() -> &'a IamPolicyAnalysisOutputConfig_GcsDestination {
        <IamPolicyAnalysisOutputConfig_GcsDestination as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisOutputConfig_GcsDestination {
    pub fn new() -> IamPolicyAnalysisOutputConfig_GcsDestination {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisOutputConfig_GcsDestination {
        IamPolicyAnalysisOutputConfig_GcsDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &IamPolicyAnalysisOutputConfig_GcsDestination| { &m.uri },
                |m: &mut IamPolicyAnalysisOutputConfig_GcsDestination| { &mut m.uri },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig_GcsDestination>(
                "IamPolicyAnalysisOutputConfig.GcsDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisOutputConfig_GcsDestination {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisOutputConfig_GcsDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisOutputConfig_GcsDestination::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn clear(&mut self) {
        self.uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig_GcsDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IamPolicyAnalysisOutputConfig_BigQueryDestination {
    // message fields
    pub dataset: ::std::string::String,
    pub table_prefix: ::std::string::String,
    pub partition_key: IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey,
    pub write_disposition: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn default() -> &'a IamPolicyAnalysisOutputConfig_BigQueryDestination {
        <IamPolicyAnalysisOutputConfig_BigQueryDestination as ::protobuf::Message>::default_instance()
    }
}

impl IamPolicyAnalysisOutputConfig_BigQueryDestination {
    pub fn new() -> IamPolicyAnalysisOutputConfig_BigQueryDestination {
        ::std::default::Default::default()
    }

    // string dataset = 1;


    pub fn get_dataset(&self) -> &str {
        &self.dataset
    }
    pub fn clear_dataset(&mut self) {
        self.dataset.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset(&mut self, v: ::std::string::String) {
        self.dataset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset(&mut self) -> &mut ::std::string::String {
        &mut self.dataset
    }

    // Take field
    pub fn take_dataset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset, ::std::string::String::new())
    }

    // string table_prefix = 2;


    pub fn get_table_prefix(&self) -> &str {
        &self.table_prefix
    }
    pub fn clear_table_prefix(&mut self) {
        self.table_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_prefix(&mut self, v: ::std::string::String) {
        self.table_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.table_prefix
    }

    // Take field
    pub fn take_table_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table_prefix, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey partition_key = 3;


    pub fn get_partition_key(&self) -> IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
        self.partition_key
    }
    pub fn clear_partition_key(&mut self) {
        self.partition_key = IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey) {
        self.partition_key = v;
    }

    // string write_disposition = 4;


    pub fn get_write_disposition(&self) -> &str {
        &self.write_disposition
    }
    pub fn clear_write_disposition(&mut self) {
        self.write_disposition.clear();
    }

    // Param is passed by value, moved
    pub fn set_write_disposition(&mut self, v: ::std::string::String) {
        self.write_disposition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_write_disposition(&mut self) -> &mut ::std::string::String {
        &mut self.write_disposition
    }

    // Take field
    pub fn take_write_disposition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.write_disposition, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table_prefix)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.partition_key, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.write_disposition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataset.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset);
        }
        if !self.table_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table_prefix);
        }
        if self.partition_key != IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.partition_key);
        }
        if !self.write_disposition.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.write_disposition);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dataset.is_empty() {
            os.write_string(1, &self.dataset)?;
        }
        if !self.table_prefix.is_empty() {
            os.write_string(2, &self.table_prefix)?;
        }
        if self.partition_key != IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.partition_key))?;
        }
        if !self.write_disposition.is_empty() {
            os.write_string(4, &self.write_disposition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IamPolicyAnalysisOutputConfig_BigQueryDestination {
        IamPolicyAnalysisOutputConfig_BigQueryDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.dataset },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.dataset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_prefix",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.table_prefix },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.table_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey>>(
                "partition_key",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.partition_key },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.partition_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "write_disposition",
                |m: &IamPolicyAnalysisOutputConfig_BigQueryDestination| { &m.write_disposition },
                |m: &mut IamPolicyAnalysisOutputConfig_BigQueryDestination| { &mut m.write_disposition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig_BigQueryDestination>(
                "IamPolicyAnalysisOutputConfig.BigQueryDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IamPolicyAnalysisOutputConfig_BigQueryDestination {
        static instance: ::protobuf::rt::LazyV2<IamPolicyAnalysisOutputConfig_BigQueryDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IamPolicyAnalysisOutputConfig_BigQueryDestination::new)
    }
}

impl ::protobuf::Clear for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn clear(&mut self) {
        self.dataset.clear();
        self.table_prefix.clear();
        self.partition_key = IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED;
        self.write_disposition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig_BigQueryDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    PARTITION_KEY_UNSPECIFIED = 0,
    REQUEST_TIME = 1,
}

impl ::protobuf::ProtobufEnum for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey> {
        match value {
            0 => ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED),
            1 => ::std::option::Option::Some(IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::REQUEST_TIME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey] = &[
            IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED,
            IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::REQUEST_TIME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey>("IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
}

impl ::std::default::Default for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    fn default() -> Self {
        IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey::PARTITION_KEY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for IamPolicyAnalysisOutputConfig_BigQueryDestination_PartitionKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyLongrunningRequest {
    // message fields
    pub analysis_query: ::protobuf::SingularPtrField<IamPolicyAnalysisQuery>,
    pub output_config: ::protobuf::SingularPtrField<IamPolicyAnalysisOutputConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyLongrunningRequest {
    fn default() -> &'a AnalyzeIamPolicyLongrunningRequest {
        <AnalyzeIamPolicyLongrunningRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyLongrunningRequest {
    pub fn new() -> AnalyzeIamPolicyLongrunningRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisQuery analysis_query = 1;


    pub fn get_analysis_query(&self) -> &IamPolicyAnalysisQuery {
        self.analysis_query.as_ref().unwrap_or_else(|| <IamPolicyAnalysisQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_analysis_query(&mut self) {
        self.analysis_query.clear();
    }

    pub fn has_analysis_query(&self) -> bool {
        self.analysis_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_analysis_query(&mut self, v: IamPolicyAnalysisQuery) {
        self.analysis_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_analysis_query(&mut self) -> &mut IamPolicyAnalysisQuery {
        if self.analysis_query.is_none() {
            self.analysis_query.set_default();
        }
        self.analysis_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_analysis_query(&mut self) -> IamPolicyAnalysisQuery {
        self.analysis_query.take().unwrap_or_else(|| IamPolicyAnalysisQuery::new())
    }

    // .google.cloud.asset.v1.IamPolicyAnalysisOutputConfig output_config = 2;


    pub fn get_output_config(&self) -> &IamPolicyAnalysisOutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <IamPolicyAnalysisOutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: IamPolicyAnalysisOutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut IamPolicyAnalysisOutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> IamPolicyAnalysisOutputConfig {
        self.output_config.take().unwrap_or_else(|| IamPolicyAnalysisOutputConfig::new())
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyLongrunningRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.analysis_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.analysis_query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.analysis_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.analysis_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyLongrunningRequest {
        AnalyzeIamPolicyLongrunningRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisQuery>>(
                "analysis_query",
                |m: &AnalyzeIamPolicyLongrunningRequest| { &m.analysis_query },
                |m: &mut AnalyzeIamPolicyLongrunningRequest| { &mut m.analysis_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IamPolicyAnalysisOutputConfig>>(
                "output_config",
                |m: &AnalyzeIamPolicyLongrunningRequest| { &m.output_config },
                |m: &mut AnalyzeIamPolicyLongrunningRequest| { &mut m.output_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyLongrunningRequest>(
                "AnalyzeIamPolicyLongrunningRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyLongrunningRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyLongrunningRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyLongrunningRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyLongrunningRequest {
    fn clear(&mut self) {
        self.analysis_query.clear();
        self.output_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyLongrunningRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyLongrunningRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeIamPolicyLongrunningResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeIamPolicyLongrunningResponse {
    fn default() -> &'a AnalyzeIamPolicyLongrunningResponse {
        <AnalyzeIamPolicyLongrunningResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeIamPolicyLongrunningResponse {
    pub fn new() -> AnalyzeIamPolicyLongrunningResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AnalyzeIamPolicyLongrunningResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeIamPolicyLongrunningResponse {
        AnalyzeIamPolicyLongrunningResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeIamPolicyLongrunningResponse>(
                "AnalyzeIamPolicyLongrunningResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeIamPolicyLongrunningResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeIamPolicyLongrunningResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeIamPolicyLongrunningResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeIamPolicyLongrunningResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeIamPolicyLongrunningResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeIamPolicyLongrunningResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeMoveRequest {
    // message fields
    pub resource: ::std::string::String,
    pub destination_parent: ::std::string::String,
    pub view: AnalyzeMoveRequest_AnalysisView,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeMoveRequest {
    fn default() -> &'a AnalyzeMoveRequest {
        <AnalyzeMoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeMoveRequest {
    pub fn new() -> AnalyzeMoveRequest {
        ::std::default::Default::default()
    }

    // string resource = 1;


    pub fn get_resource(&self) -> &str {
        &self.resource
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        &mut self.resource
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource, ::std::string::String::new())
    }

    // string destination_parent = 2;


    pub fn get_destination_parent(&self) -> &str {
        &self.destination_parent
    }
    pub fn clear_destination_parent(&mut self) {
        self.destination_parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_parent(&mut self, v: ::std::string::String) {
        self.destination_parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_parent(&mut self) -> &mut ::std::string::String {
        &mut self.destination_parent
    }

    // Take field
    pub fn take_destination_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_parent, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.AnalyzeMoveRequest.AnalysisView view = 3;


    pub fn get_view(&self) -> AnalyzeMoveRequest_AnalysisView {
        self.view
    }
    pub fn clear_view(&mut self) {
        self.view = AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_view(&mut self, v: AnalyzeMoveRequest_AnalysisView) {
        self.view = v;
    }
}

impl ::protobuf::Message for AnalyzeMoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_parent)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.view, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.resource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.resource);
        }
        if !self.destination_parent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination_parent);
        }
        if self.view != AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.view);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.resource.is_empty() {
            os.write_string(1, &self.resource)?;
        }
        if !self.destination_parent.is_empty() {
            os.write_string(2, &self.destination_parent)?;
        }
        if self.view != AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.view))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeMoveRequest {
        AnalyzeMoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource",
                |m: &AnalyzeMoveRequest| { &m.resource },
                |m: &mut AnalyzeMoveRequest| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_parent",
                |m: &AnalyzeMoveRequest| { &m.destination_parent },
                |m: &mut AnalyzeMoveRequest| { &mut m.destination_parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AnalyzeMoveRequest_AnalysisView>>(
                "view",
                |m: &AnalyzeMoveRequest| { &m.view },
                |m: &mut AnalyzeMoveRequest| { &mut m.view },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeMoveRequest>(
                "AnalyzeMoveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeMoveRequest {
        static instance: ::protobuf::rt::LazyV2<AnalyzeMoveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeMoveRequest::new)
    }
}

impl ::protobuf::Clear for AnalyzeMoveRequest {
    fn clear(&mut self) {
        self.resource.clear();
        self.destination_parent.clear();
        self.view = AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeMoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeMoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AnalyzeMoveRequest_AnalysisView {
    ANALYSIS_VIEW_UNSPECIFIED = 0,
    FULL = 1,
    BASIC = 2,
}

impl ::protobuf::ProtobufEnum for AnalyzeMoveRequest_AnalysisView {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnalyzeMoveRequest_AnalysisView> {
        match value {
            0 => ::std::option::Option::Some(AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED),
            1 => ::std::option::Option::Some(AnalyzeMoveRequest_AnalysisView::FULL),
            2 => ::std::option::Option::Some(AnalyzeMoveRequest_AnalysisView::BASIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AnalyzeMoveRequest_AnalysisView] = &[
            AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED,
            AnalyzeMoveRequest_AnalysisView::FULL,
            AnalyzeMoveRequest_AnalysisView::BASIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AnalyzeMoveRequest_AnalysisView>("AnalyzeMoveRequest.AnalysisView", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AnalyzeMoveRequest_AnalysisView {
}

impl ::std::default::Default for AnalyzeMoveRequest_AnalysisView {
    fn default() -> Self {
        AnalyzeMoveRequest_AnalysisView::ANALYSIS_VIEW_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeMoveRequest_AnalysisView {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeMoveResponse {
    // message fields
    pub move_analysis: ::protobuf::RepeatedField<MoveAnalysis>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeMoveResponse {
    fn default() -> &'a AnalyzeMoveResponse {
        <AnalyzeMoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeMoveResponse {
    pub fn new() -> AnalyzeMoveResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.MoveAnalysis move_analysis = 1;


    pub fn get_move_analysis(&self) -> &[MoveAnalysis] {
        &self.move_analysis
    }
    pub fn clear_move_analysis(&mut self) {
        self.move_analysis.clear();
    }

    // Param is passed by value, moved
    pub fn set_move_analysis(&mut self, v: ::protobuf::RepeatedField<MoveAnalysis>) {
        self.move_analysis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_move_analysis(&mut self) -> &mut ::protobuf::RepeatedField<MoveAnalysis> {
        &mut self.move_analysis
    }

    // Take field
    pub fn take_move_analysis(&mut self) -> ::protobuf::RepeatedField<MoveAnalysis> {
        ::std::mem::replace(&mut self.move_analysis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeMoveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.move_analysis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.move_analysis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.move_analysis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.move_analysis {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeMoveResponse {
        AnalyzeMoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveAnalysis>>(
                "move_analysis",
                |m: &AnalyzeMoveResponse| { &m.move_analysis },
                |m: &mut AnalyzeMoveResponse| { &mut m.move_analysis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalyzeMoveResponse>(
                "AnalyzeMoveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalyzeMoveResponse {
        static instance: ::protobuf::rt::LazyV2<AnalyzeMoveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalyzeMoveResponse::new)
    }
}

impl ::protobuf::Clear for AnalyzeMoveResponse {
    fn clear(&mut self) {
        self.move_analysis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeMoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeMoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveAnalysis {
    // message fields
    pub display_name: ::std::string::String,
    // message oneof groups
    pub result: ::std::option::Option<MoveAnalysis_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveAnalysis {
    fn default() -> &'a MoveAnalysis {
        <MoveAnalysis as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MoveAnalysis_oneof_result {
    analysis(MoveAnalysisResult),
    error(super::status::Status),
}

impl MoveAnalysis {
    pub fn new() -> MoveAnalysis {
        ::std::default::Default::default()
    }

    // string display_name = 1;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.cloud.asset.v1.MoveAnalysisResult analysis = 2;


    pub fn get_analysis(&self) -> &MoveAnalysisResult {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(ref v)) => v,
            _ => <MoveAnalysisResult as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_analysis(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_analysis(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_analysis(&mut self, v: MoveAnalysisResult) {
        self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(v))
    }

    // Mutable pointer to the field.
    pub fn mut_analysis(&mut self) -> &mut MoveAnalysisResult {
        if let ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(MoveAnalysisResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_analysis(&mut self) -> MoveAnalysisResult {
        if self.has_analysis() {
            match self.result.take() {
                ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(v)) => v,
                _ => panic!(),
            }
        } else {
            MoveAnalysisResult::new()
        }
    }

    // .google.rpc.Status error = 3;


    pub fn get_error(&self) -> &super::status::Status {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::error(ref v)) => v,
            _ => <super::status::Status as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::status::Status) {
        self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut super::status::Status {
        if let ::std::option::Option::Some(MoveAnalysis_oneof_result::error(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::error(super::status::Status::new()));
        }
        match self.result {
            ::std::option::Option::Some(MoveAnalysis_oneof_result::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> super::status::Status {
        if self.has_error() {
            match self.result.take() {
                ::std::option::Option::Some(MoveAnalysis_oneof_result::error(v)) => v,
                _ => panic!(),
            }
        } else {
            super::status::Status::new()
        }
    }
}

impl ::protobuf::Message for MoveAnalysis {
    fn is_initialized(&self) -> bool {
        if let Some(MoveAnalysis_oneof_result::analysis(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MoveAnalysis_oneof_result::error(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::analysis(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(MoveAnalysis_oneof_result::error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.display_name);
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &MoveAnalysis_oneof_result::analysis(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MoveAnalysis_oneof_result::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.display_name.is_empty() {
            os.write_string(1, &self.display_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &MoveAnalysis_oneof_result::analysis(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MoveAnalysis_oneof_result::error(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveAnalysis {
        MoveAnalysis::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &MoveAnalysis| { &m.display_name },
                |m: &mut MoveAnalysis| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MoveAnalysisResult>(
                "analysis",
                MoveAnalysis::has_analysis,
                MoveAnalysis::get_analysis,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::status::Status>(
                "error",
                MoveAnalysis::has_error,
                MoveAnalysis::get_error,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveAnalysis>(
                "MoveAnalysis",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveAnalysis {
        static instance: ::protobuf::rt::LazyV2<MoveAnalysis> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveAnalysis::new)
    }
}

impl ::protobuf::Clear for MoveAnalysis {
    fn clear(&mut self) {
        self.display_name.clear();
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveAnalysis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveAnalysis {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveAnalysisResult {
    // message fields
    pub blockers: ::protobuf::RepeatedField<MoveImpact>,
    pub warnings: ::protobuf::RepeatedField<MoveImpact>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveAnalysisResult {
    fn default() -> &'a MoveAnalysisResult {
        <MoveAnalysisResult as ::protobuf::Message>::default_instance()
    }
}

impl MoveAnalysisResult {
    pub fn new() -> MoveAnalysisResult {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.asset.v1.MoveImpact blockers = 1;


    pub fn get_blockers(&self) -> &[MoveImpact] {
        &self.blockers
    }
    pub fn clear_blockers(&mut self) {
        self.blockers.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockers(&mut self, v: ::protobuf::RepeatedField<MoveImpact>) {
        self.blockers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockers(&mut self) -> &mut ::protobuf::RepeatedField<MoveImpact> {
        &mut self.blockers
    }

    // Take field
    pub fn take_blockers(&mut self) -> ::protobuf::RepeatedField<MoveImpact> {
        ::std::mem::replace(&mut self.blockers, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.asset.v1.MoveImpact warnings = 2;


    pub fn get_warnings(&self) -> &[MoveImpact] {
        &self.warnings
    }
    pub fn clear_warnings(&mut self) {
        self.warnings.clear();
    }

    // Param is passed by value, moved
    pub fn set_warnings(&mut self, v: ::protobuf::RepeatedField<MoveImpact>) {
        self.warnings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_warnings(&mut self) -> &mut ::protobuf::RepeatedField<MoveImpact> {
        &mut self.warnings
    }

    // Take field
    pub fn take_warnings(&mut self) -> ::protobuf::RepeatedField<MoveImpact> {
        ::std::mem::replace(&mut self.warnings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoveAnalysisResult {
    fn is_initialized(&self) -> bool {
        for v in &self.blockers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.warnings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blockers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.warnings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blockers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.warnings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blockers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.warnings {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveAnalysisResult {
        MoveAnalysisResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveImpact>>(
                "blockers",
                |m: &MoveAnalysisResult| { &m.blockers },
                |m: &mut MoveAnalysisResult| { &mut m.blockers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveImpact>>(
                "warnings",
                |m: &MoveAnalysisResult| { &m.warnings },
                |m: &mut MoveAnalysisResult| { &mut m.warnings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveAnalysisResult>(
                "MoveAnalysisResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveAnalysisResult {
        static instance: ::protobuf::rt::LazyV2<MoveAnalysisResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveAnalysisResult::new)
    }
}

impl ::protobuf::Clear for MoveAnalysisResult {
    fn clear(&mut self) {
        self.blockers.clear();
        self.warnings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveAnalysisResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveAnalysisResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveImpact {
    // message fields
    pub detail: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveImpact {
    fn default() -> &'a MoveImpact {
        <MoveImpact as ::protobuf::Message>::default_instance()
    }
}

impl MoveImpact {
    pub fn new() -> MoveImpact {
        ::std::default::Default::default()
    }

    // string detail = 1;


    pub fn get_detail(&self) -> &str {
        &self.detail
    }
    pub fn clear_detail(&mut self) {
        self.detail.clear();
    }

    // Param is passed by value, moved
    pub fn set_detail(&mut self, v: ::std::string::String) {
        self.detail = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detail(&mut self) -> &mut ::std::string::String {
        &mut self.detail
    }

    // Take field
    pub fn take_detail(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.detail, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MoveImpact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.detail.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.detail);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.detail.is_empty() {
            os.write_string(1, &self.detail)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveImpact {
        MoveImpact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detail",
                |m: &MoveImpact| { &m.detail },
                |m: &mut MoveImpact| { &mut m.detail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveImpact>(
                "MoveImpact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveImpact {
        static instance: ::protobuf::rt::LazyV2<MoveImpact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveImpact::new)
    }
}

impl ::protobuf::Clear for MoveImpact {
    fn clear(&mut self) {
        self.detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveImpact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveImpact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContentType {
    CONTENT_TYPE_UNSPECIFIED = 0,
    RESOURCE = 1,
    IAM_POLICY = 2,
    ORG_POLICY = 4,
    ACCESS_POLICY = 5,
    OS_INVENTORY = 6,
}

impl ::protobuf::ProtobufEnum for ContentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContentType> {
        match value {
            0 => ::std::option::Option::Some(ContentType::CONTENT_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ContentType::RESOURCE),
            2 => ::std::option::Option::Some(ContentType::IAM_POLICY),
            4 => ::std::option::Option::Some(ContentType::ORG_POLICY),
            5 => ::std::option::Option::Some(ContentType::ACCESS_POLICY),
            6 => ::std::option::Option::Some(ContentType::OS_INVENTORY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContentType] = &[
            ContentType::CONTENT_TYPE_UNSPECIFIED,
            ContentType::RESOURCE,
            ContentType::IAM_POLICY,
            ContentType::ORG_POLICY,
            ContentType::ACCESS_POLICY,
            ContentType::OS_INVENTORY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContentType>("ContentType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContentType {
}

impl ::std::default::Default for ContentType {
    fn default() -> Self {
        ContentType::CONTENT_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)google/cloud/asset/v1/asset_service.proto\x12\x15google.cloud.asset.v\
    1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\
    \x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.proto\x1a\
    \"google/cloud/asset/v1/assets.proto\x1a#google/longrunning/operations.p\
    roto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.\
    proto\x1a\x20google/protobuf/field_mask.proto\x1a\x1cgoogle/protobuf/str\
    uct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x17google/rpc/statu\
    s.proto\x1a\x16google/type/expr.proto\"g\n#AnalyzeIamPolicyLongrunningMe\
    tadata\x12@\n\x0bcreate_time\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\ncreateTimeB\x03\xe0A\x03\"\xc6\x02\n\x13ExportAssetsRequest\
    \x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\x12\x1fcloudasse\
    t.googleapis.com/Asset\xe0A\x02\x127\n\tread_time\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x08readTime\x12\x1f\n\x0basset_types\x18\
    \x03\x20\x03(\tR\nassetTypes\x12E\n\x0ccontent_type\x18\x04\x20\x01(\x0e\
    2\".google.cloud.asset.v1.ContentTypeR\x0bcontentType\x12M\n\routput_con\
    fig\x18\x05\x20\x01(\x0b2#.google.cloud.asset.v1.OutputConfigR\x0coutput\
    ConfigB\x03\xe0A\x02\"\xe3\x01\n\x14ExportAssetsResponse\x127\n\tread_ti\
    me\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x08readTime\x12H\
    \n\routput_config\x18\x02\x20\x01(\x0b2#.google.cloud.asset.v1.OutputCon\
    figR\x0coutputConfig\x12H\n\routput_result\x18\x03\x20\x01(\x0b2#.google\
    .cloud.asset.v1.OutputResultR\x0coutputResult\"\xb1\x02\n\x11ListAssetsR\
    equest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\x12\x1fclo\
    udasset.googleapis.com/Asset\xe0A\x02\x127\n\tread_time\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x08readTime\x12\x1f\n\x0basset_type\
    s\x18\x03\x20\x03(\tR\nassetTypes\x12E\n\x0ccontent_type\x18\x04\x20\x01\
    (\x0e2\".google.cloud.asset.v1.ContentTypeR\x0bcontentType\x12\x1b\n\tpa\
    ge_size\x18\x05\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x06\
    \x20\x01(\tR\tpageToken\"\xab\x01\n\x12ListAssetsResponse\x127\n\tread_t\
    ime\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x08readTime\x12\
    4\n\x06assets\x18\x02\x20\x03(\x0b2\x1c.google.cloud.asset.v1.AssetR\x06\
    assets\x12&\n\x0fnext_page_token\x18\x03\x20\x01(\tR\rnextPageToken\"\
    \x9e\x02\n\x1cBatchGetAssetsHistoryRequest\x12?\n\x06parent\x18\x01\x20\
    \x01(\tR\x06parentB'\xfaA!\x12\x1fcloudasset.googleapis.com/Asset\xe0A\
    \x02\x12\x1f\n\x0basset_names\x18\x02\x20\x03(\tR\nassetNames\x12J\n\x0c\
    content_type\x18\x03\x20\x01(\x0e2\".google.cloud.asset.v1.ContentTypeR\
    \x0bcontentTypeB\x03\xe0A\x01\x12P\n\x10read_time_window\x18\x04\x20\x01\
    (\x0b2!.google.cloud.asset.v1.TimeWindowR\x0ereadTimeWindowB\x03\xe0A\
    \x01\"]\n\x1dBatchGetAssetsHistoryResponse\x12<\n\x06assets\x18\x01\x20\
    \x03(\x0b2$.google.cloud.asset.v1.TemporalAssetR\x06assets\"\x84\x01\n\
    \x11CreateFeedRequest\x12\x1b\n\x06parent\x18\x01\x20\x01(\tR\x06parentB\
    \x03\xe0A\x02\x12\x1c\n\x07feed_id\x18\x02\x20\x01(\tR\x06feedIdB\x03\
    \xe0A\x02\x124\n\x04feed\x18\x03\x20\x01(\x0b2\x1b.google.cloud.asset.v1\
    .FeedR\x04feedB\x03\xe0A\x02\"L\n\x0eGetFeedRequest\x12:\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB&\xfaA\x20\n\x1ecloudasset.googleapis.com/Feed\
    \xe0A\x02\"/\n\x10ListFeedsRequest\x12\x1b\n\x06parent\x18\x01\x20\x01(\
    \tR\x06parentB\x03\xe0A\x02\"F\n\x11ListFeedsResponse\x121\n\x05feeds\
    \x18\x01\x20\x03(\x0b2\x1b.google.cloud.asset.v1.FeedR\x05feeds\"\x8b\
    \x01\n\x11UpdateFeedRequest\x124\n\x04feed\x18\x01\x20\x01(\x0b2\x1b.goo\
    gle.cloud.asset.v1.FeedR\x04feedB\x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMaskB\x03\xe0A\
    \x02\"O\n\x11DeleteFeedRequest\x12:\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    eB&\xfaA\x20\n\x1ecloudasset.googleapis.com/Feed\xe0A\x02\"\xd0\x01\n\
    \x0cOutputConfig\x12P\n\x0fgcs_destination\x18\x01\x20\x01(\x0b2%.google\
    .cloud.asset.v1.GcsDestinationH\0R\x0egcsDestination\x12_\n\x14bigquery_\
    destination\x18\x02\x20\x01(\x0b2*.google.cloud.asset.v1.BigQueryDestina\
    tionH\0R\x13bigqueryDestinationB\r\n\x0bdestination\"a\n\x0cOutputResult\
    \x12G\n\ngcs_result\x18\x01\x20\x01(\x0b2&.google.cloud.asset.v1.GcsOutp\
    utResultH\0R\tgcsResultB\x08\n\x06result\"%\n\x0fGcsOutputResult\x12\x12\
    \n\x04uris\x18\x01\x20\x03(\tR\x04uris\"S\n\x0eGcsDestination\x12\x12\n\
    \x03uri\x18\x01\x20\x01(\tH\0R\x03uri\x12\x1f\n\nuri_prefix\x18\x02\x20\
    \x01(\tH\0R\turiPrefixB\x0c\n\nobject_uri\"\xf6\x01\n\x13BigQueryDestina\
    tion\x12\x1d\n\x07dataset\x18\x01\x20\x01(\tR\x07datasetB\x03\xe0A\x02\
    \x12\x19\n\x05table\x18\x02\x20\x01(\tR\x05tableB\x03\xe0A\x02\x12\x14\n\
    \x05force\x18\x03\x20\x01(\x08R\x05force\x12K\n\x0epartition_spec\x18\
    \x04\x20\x01(\x0b2$.google.cloud.asset.v1.PartitionSpecR\rpartitionSpec\
    \x12B\n\x1eseparate_tables_per_asset_type\x18\x05\x20\x01(\x08R\x1asepar\
    ateTablesPerAssetType\"\xb7\x01\n\rPartitionSpec\x12V\n\rpartition_key\
    \x18\x01\x20\x01(\x0e21.google.cloud.asset.v1.PartitionSpec.PartitionKey\
    R\x0cpartitionKey\"N\n\x0cPartitionKey\x12\x1d\n\x19PARTITION_KEY_UNSPEC\
    IFIED\x10\0\x12\r\n\tREAD_TIME\x10\x01\x12\x10\n\x0cREQUEST_TIME\x10\x02\
    \")\n\x11PubsubDestination\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05top\
    ic\"|\n\x10FeedOutputConfig\x12Y\n\x12pubsub_destination\x18\x01\x20\x01\
    (\x0b2(.google.cloud.asset.v1.PubsubDestinationH\0R\x11pubsubDestination\
    B\r\n\x0bdestination\"\xc9\x03\n\x04Feed\x12\x17\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\x03\xe0A\x02\x12\x1f\n\x0basset_names\x18\x02\x20\x03(\
    \tR\nassetNames\x12\x1f\n\x0basset_types\x18\x03\x20\x03(\tR\nassetTypes\
    \x12E\n\x0ccontent_type\x18\x04\x20\x01(\x0e2\".google.cloud.asset.v1.Co\
    ntentTypeR\x0bcontentType\x12Z\n\x12feed_output_config\x18\x05\x20\x01(\
    \x0b2'.google.cloud.asset.v1.FeedOutputConfigR\x10feedOutputConfigB\x03\
    \xe0A\x02\x12/\n\tcondition\x18\x06\x20\x01(\x0b2\x11.google.type.ExprR\
    \tcondition:\x91\x01\xeaA\x8d\x01\n\x1ecloudasset.googleapis.com/Feed\
    \x12\x1fprojects/{project}/feeds/{feed}\x12\x1dfolders/{folder}/feeds/{f\
    eed}\x12)organizations/{organization}/feeds/{feed}\x20\x01\"\x9b\x02\n\
    \x19SearchAllResourcesRequest\x12\x19\n\x05scope\x18\x01\x20\x01(\tR\x05\
    scopeB\x03\xe0A\x02\x12\x19\n\x05query\x18\x02\x20\x01(\tR\x05queryB\x03\
    \xe0A\x01\x12$\n\x0basset_types\x18\x03\x20\x03(\tR\nassetTypesB\x03\xe0\
    A\x01\x12\x20\n\tpage_size\x18\x04\x20\x01(\x05R\x08pageSizeB\x03\xe0A\
    \x01\x12\"\n\npage_token\x18\x05\x20\x01(\tR\tpageTokenB\x03\xe0A\x01\
    \x12\x1e\n\x08order_by\x18\x06\x20\x01(\tR\x07orderByB\x03\xe0A\x01\x12<\
    \n\tread_mask\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\x08re\
    adMaskB\x03\xe0A\x01\"\x8b\x01\n\x1aSearchAllResourcesResponse\x12E\n\
    \x07results\x18\x01\x20\x03(\x0b2+.google.cloud.asset.v1.ResourceSearchR\
    esultR\x07results\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPag\
    eToken\"\xdf\x01\n\x1bSearchAllIamPoliciesRequest\x12\x19\n\x05scope\x18\
    \x01\x20\x01(\tR\x05scopeB\x03\xe0A\x02\x12\x19\n\x05query\x18\x02\x20\
    \x01(\tR\x05queryB\x03\xe0A\x01\x12\x20\n\tpage_size\x18\x03\x20\x01(\
    \x05R\x08pageSizeB\x03\xe0A\x01\x12\"\n\npage_token\x18\x04\x20\x01(\tR\
    \tpageTokenB\x03\xe0A\x01\x12$\n\x0basset_types\x18\x05\x20\x03(\tR\nass\
    etTypesB\x03\xe0A\x01\x12\x1e\n\x08order_by\x18\x07\x20\x01(\tR\x07order\
    ByB\x03\xe0A\x01\"\x8e\x01\n\x1cSearchAllIamPoliciesResponse\x12F\n\x07r\
    esults\x18\x01\x20\x03(\x0b2,.google.cloud.asset.v1.IamPolicySearchResul\
    tR\x07results\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageTok\
    en\"\xcf\t\n\x16IamPolicyAnalysisQuery\x12\x19\n\x05scope\x18\x01\x20\
    \x01(\tR\x05scopeB\x03\xe0A\x02\x12p\n\x11resource_selector\x18\x02\x20\
    \x01(\x0b2>.google.cloud.asset.v1.IamPolicyAnalysisQuery.ResourceSelecto\
    rR\x10resourceSelectorB\x03\xe0A\x01\x12p\n\x11identity_selector\x18\x03\
    \x20\x01(\x0b2>.google.cloud.asset.v1.IamPolicyAnalysisQuery.IdentitySel\
    ectorR\x10identitySelectorB\x03\xe0A\x01\x12j\n\x0faccess_selector\x18\
    \x04\x20\x01(\x0b2<.google.cloud.asset.v1.IamPolicyAnalysisQuery.AccessS\
    electorR\x0eaccessSelectorB\x03\xe0A\x01\x12T\n\x07options\x18\x05\x20\
    \x01(\x0b25.google.cloud.asset.v1.IamPolicyAnalysisQuery.OptionsR\x07opt\
    ionsB\x03\xe0A\x01\x12p\n\x11condition_context\x18\x06\x20\x01(\x0b2>.go\
    ogle.cloud.asset.v1.IamPolicyAnalysisQuery.ConditionContextR\x10conditio\
    nContextB\x03\xe0A\x01\x1aE\n\x10ResourceSelector\x121\n\x12full_resourc\
    e_name\x18\x01\x20\x01(\tR\x10fullResourceNameB\x03\xe0A\x02\x1a3\n\x10I\
    dentitySelector\x12\x1f\n\x08identity\x18\x01\x20\x01(\tR\x08identityB\
    \x03\xe0A\x02\x1aR\n\x0eAccessSelector\x12\x19\n\x05roles\x18\x01\x20\
    \x03(\tR\x05rolesB\x03\xe0A\x01\x12%\n\x0bpermissions\x18\x02\x20\x03(\t\
    R\x0bpermissionsB\x03\xe0A\x01\x1a\xcf\x02\n\x07Options\x12(\n\rexpand_g\
    roups\x18\x01\x20\x01(\x08R\x0cexpandGroupsB\x03\xe0A\x01\x12&\n\x0cexpa\
    nd_roles\x18\x02\x20\x01(\x08R\x0bexpandRolesB\x03\xe0A\x01\x12.\n\x10ex\
    pand_resources\x18\x03\x20\x01(\x08R\x0fexpandResourcesB\x03\xe0A\x01\
    \x127\n\x15output_resource_edges\x18\x04\x20\x01(\x08R\x13outputResource\
    EdgesB\x03\xe0A\x01\x121\n\x12output_group_edges\x18\x05\x20\x01(\x08R\
    \x10outputGroupEdgesB\x03\xe0A\x01\x12V\n%analyze_service_account_impers\
    onation\x18\x06\x20\x01(\x08R\"analyzeServiceAccountImpersonationB\x03\
    \xe0A\x01\x1a`\n\x10ConditionContext\x12=\n\x0baccess_time\x18\x01\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampH\0R\naccessTimeB\r\n\x0bTimeCon\
    text\"\xc1\x01\n\x17AnalyzeIamPolicyRequest\x12Y\n\x0eanalysis_query\x18\
    \x01\x20\x01(\x0b2-.google.cloud.asset.v1.IamPolicyAnalysisQueryR\ranaly\
    sisQueryB\x03\xe0A\x02\x12K\n\x11execution_timeout\x18\x02\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\x10executionTimeoutB\x03\xe0A\x01\"\x8f\
    \x05\n\x18AnalyzeIamPolicyResponse\x12f\n\rmain_analysis\x18\x01\x20\x01\
    (\x0b2A.google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis\
    R\x0cmainAnalysis\x12\x96\x01\n&service_account_impersonation_analysis\
    \x18\x02\x20\x03(\x0b2A.google.cloud.asset.v1.AnalyzeIamPolicyResponse.I\
    amPolicyAnalysisR#serviceAccountImpersonationAnalysis\x12%\n\x0efully_ex\
    plored\x18\x03\x20\x01(\x08R\rfullyExplored\x1a\xca\x02\n\x11IamPolicyAn\
    alysis\x12T\n\x0eanalysis_query\x18\x01\x20\x01(\x0b2-.google.cloud.asse\
    t.v1.IamPolicyAnalysisQueryR\ranalysisQuery\x12Y\n\x10analysis_results\
    \x18\x02\x20\x03(\x0b2..google.cloud.asset.v1.IamPolicyAnalysisResultR\
    \x0fanalysisResults\x12%\n\x0efully_explored\x18\x03\x20\x01(\x08R\rfull\
    yExplored\x12]\n\x13non_critical_errors\x18\x05\x20\x03(\x0b2-.google.cl\
    oud.asset.v1.IamPolicyAnalysisStateR\x11nonCriticalErrors\"\x94\x05\n\
    \x1dIamPolicyAnalysisOutputConfig\x12n\n\x0fgcs_destination\x18\x01\x20\
    \x01(\x0b2C.google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.GcsDesti\
    nationH\0R\x0egcsDestination\x12}\n\x14bigquery_destination\x18\x02\x20\
    \x01(\x0b2H.google.cloud.asset.v1.IamPolicyAnalysisOutputConfig.BigQuery\
    DestinationH\0R\x13bigqueryDestination\x1a'\n\x0eGcsDestination\x12\x15\
    \n\x03uri\x18\x01\x20\x01(\tR\x03uriB\x03\xe0A\x02\x1a\xcb\x02\n\x13BigQ\
    ueryDestination\x12\x1d\n\x07dataset\x18\x01\x20\x01(\tR\x07datasetB\x03\
    \xe0A\x02\x12&\n\x0ctable_prefix\x18\x02\x20\x01(\tR\x0btablePrefixB\x03\
    \xe0A\x02\x12z\n\rpartition_key\x18\x03\x20\x01(\x0e2U.google.cloud.asse\
    t.v1.IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKeyR\x0c\
    partitionKey\x120\n\x11write_disposition\x18\x04\x20\x01(\tR\x10writeDis\
    positionB\x03\xe0A\x01\"?\n\x0cPartitionKey\x12\x1d\n\x19PARTITION_KEY_U\
    NSPECIFIED\x10\0\x12\x10\n\x0cREQUEST_TIME\x10\x01B\r\n\x0bdestination\"\
    \xdf\x01\n\"AnalyzeIamPolicyLongrunningRequest\x12Y\n\x0eanalysis_query\
    \x18\x01\x20\x01(\x0b2-.google.cloud.asset.v1.IamPolicyAnalysisQueryR\ra\
    nalysisQueryB\x03\xe0A\x02\x12^\n\routput_config\x18\x02\x20\x01(\x0b24.\
    google.cloud.asset.v1.IamPolicyAnalysisOutputConfigR\x0coutputConfigB\
    \x03\xe0A\x02\"%\n#AnalyzeIamPolicyLongrunningResponse\"\xf9\x01\n\x12An\
    alyzeMoveRequest\x12\x1f\n\x08resource\x18\x01\x20\x01(\tR\x08resourceB\
    \x03\xe0A\x02\x122\n\x12destination_parent\x18\x02\x20\x01(\tR\x11destin\
    ationParentB\x03\xe0A\x02\x12J\n\x04view\x18\x03\x20\x01(\x0e26.google.c\
    loud.asset.v1.AnalyzeMoveRequest.AnalysisViewR\x04view\"B\n\x0cAnalysisV\
    iew\x12\x1d\n\x19ANALYSIS_VIEW_UNSPECIFIED\x10\0\x12\x08\n\x04FULL\x10\
    \x01\x12\t\n\x05BASIC\x10\x02\"_\n\x13AnalyzeMoveResponse\x12H\n\rmove_a\
    nalysis\x18\x01\x20\x03(\x0b2#.google.cloud.asset.v1.MoveAnalysisR\x0cmo\
    veAnalysis\"\xb0\x01\n\x0cMoveAnalysis\x12!\n\x0cdisplay_name\x18\x01\
    \x20\x01(\tR\x0bdisplayName\x12G\n\x08analysis\x18\x02\x20\x01(\x0b2).go\
    ogle.cloud.asset.v1.MoveAnalysisResultH\0R\x08analysis\x12*\n\x05error\
    \x18\x03\x20\x01(\x0b2\x12.google.rpc.StatusH\0R\x05errorB\x08\n\x06resu\
    lt\"\x92\x01\n\x12MoveAnalysisResult\x12=\n\x08blockers\x18\x01\x20\x03(\
    \x0b2!.google.cloud.asset.v1.MoveImpactR\x08blockers\x12=\n\x08warnings\
    \x18\x02\x20\x03(\x0b2!.google.cloud.asset.v1.MoveImpactR\x08warnings\"$\
    \n\nMoveImpact\x12\x16\n\x06detail\x18\x01\x20\x01(\tR\x06detail*~\n\x0b\
    ContentType\x12\x1c\n\x18CONTENT_TYPE_UNSPECIFIED\x10\0\x12\x0c\n\x08RES\
    OURCE\x10\x01\x12\x0e\n\nIAM_POLICY\x10\x02\x12\x0e\n\nORG_POLICY\x10\
    \x04\x12\x11\n\rACCESS_POLICY\x10\x05\x12\x10\n\x0cOS_INVENTORY\x10\x062\
    \xf7\x11\n\x0cAssetService\x12\xde\x01\n\x0cExportAssets\x12*.google.clo\
    ud.asset.v1.ExportAssetsRequest\x1a\x1d.google.longrunning.Operation\"\
    \x82\x01\xcaAW\n*google.cloud.asset.v1.ExportAssetsResponse\x12)google.c\
    loud.asset.v1.ExportAssetsRequest\x82\xd3\xe4\x93\x02\"\"\x1d/v1/{parent\
    =*/*}:exportAssets:\x01*\x12\x8b\x01\n\nListAssets\x12(.google.cloud.ass\
    et.v1.ListAssetsRequest\x1a).google.cloud.asset.v1.ListAssetsResponse\"(\
    \x82\xd3\xe4\x93\x02\x19\x12\x17/v1/{parent=*/*}/assets\xdaA\x06parent\
    \x12\xb2\x01\n\x15BatchGetAssetsHistory\x123.google.cloud.asset.v1.Batch\
    GetAssetsHistoryRequest\x1a4.google.cloud.asset.v1.BatchGetAssetsHistory\
    Response\".\x82\xd3\xe4\x93\x02(\x12&/v1/{parent=*/*}:batchGetAssetsHist\
    ory\x12\x7f\n\nCreateFeed\x12(.google.cloud.asset.v1.CreateFeedRequest\
    \x1a\x1b.google.cloud.asset.v1.Feed\"*\x82\xd3\xe4\x93\x02\x1b\"\x16/v1/\
    {parent=*/*}/feeds:\x01*\xdaA\x06parent\x12t\n\x07GetFeed\x12%.google.cl\
    oud.asset.v1.GetFeedRequest\x1a\x1b.google.cloud.asset.v1.Feed\"%\x82\
    \xd3\xe4\x93\x02\x18\x12\x16/v1/{name=*/*/feeds/*}\xdaA\x04name\x12\x87\
    \x01\n\tListFeeds\x12'.google.cloud.asset.v1.ListFeedsRequest\x1a(.googl\
    e.cloud.asset.v1.ListFeedsResponse\"'\x82\xd3\xe4\x93\x02\x18\x12\x16/v1\
    /{parent=*/*}/feeds\xdaA\x06parent\x12\x82\x01\n\nUpdateFeed\x12(.google\
    .cloud.asset.v1.UpdateFeedRequest\x1a\x1b.google.cloud.asset.v1.Feed\"-\
    \x82\xd3\xe4\x93\x02\x202\x1b/v1/{feed.name=*/*/feeds/*}:\x01*\xdaA\x04f\
    eed\x12u\n\nDeleteFeed\x12(.google.cloud.asset.v1.DeleteFeedRequest\x1a\
    \x16.google.protobuf.Empty\"%\x82\xd3\xe4\x93\x02\x18*\x16/v1/{name=*/*/\
    feeds/*}\xdaA\x04name\x12\xbf\x01\n\x12SearchAllResources\x120.google.cl\
    oud.asset.v1.SearchAllResourcesRequest\x1a1.google.cloud.asset.v1.Search\
    AllResourcesResponse\"D\x82\xd3\xe4\x93\x02$\x12\"/v1/{scope=*/*}:search\
    AllResources\xdaA\x17scope,query,asset_types\x12\xbb\x01\n\x14SearchAllI\
    amPolicies\x122.google.cloud.asset.v1.SearchAllIamPoliciesRequest\x1a3.g\
    oogle.cloud.asset.v1.SearchAllIamPoliciesResponse\":\x82\xd3\xe4\x93\x02\
    &\x12$/v1/{scope=*/*}:searchAllIamPolicies\xdaA\x0bscope,query\x12\xac\
    \x01\n\x10AnalyzeIamPolicy\x12..google.cloud.asset.v1.AnalyzeIamPolicyRe\
    quest\x1a/.google.cloud.asset.v1.AnalyzeIamPolicyResponse\"7\x82\xd3\xe4\
    \x93\x021\x12//v1/{analysis_query.scope=*/*}:analyzeIamPolicy\x12\xb8\
    \x02\n\x1bAnalyzeIamPolicyLongrunning\x129.google.cloud.asset.v1.Analyze\
    IamPolicyLongrunningRequest\x1a\x1d.google.longrunning.Operation\"\xbe\
    \x01\xcaAv\n9google.cloud.asset.v1.AnalyzeIamPolicyLongrunningResponse\
    \x129google.cloud.asset.v1.AnalyzeIamPolicyLongrunningMetadata\x82\xd3\
    \xe4\x93\x02?\":/v1/{analysis_query.scope=*/*}:analyzeIamPolicyLongrunni\
    ng:\x01*\x12\x8c\x01\n\x0bAnalyzeMove\x12).google.cloud.asset.v1.Analyze\
    MoveRequest\x1a*.google.cloud.asset.v1.AnalyzeMoveResponse\"&\x82\xd3\
    \xe4\x93\x02\x20\x12\x1e/v1/{resource=*/*}:analyzeMove\x1aM\xd2A.https:/\
    /www.googleapis.com/auth/cloud-platform\xcaA\x19cloudasset.googleapis.co\
    mB\x9c\x01\n\x19com.google.cloud.asset.v1B\x11AssetServiceProtoP\x01Z:go\
    ogle.golang.org/genproto/googleapis/cloud/asset/v1;asset\xaa\x02\x15Goog\
    le.Cloud.Asset.V1\xca\x02\x15Google\\Cloud\\Asset\\V1J\xf9\xc4\x03\n\x07\
    \x12\x05\x0e\0\xcb\n\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\
    \x20Copyright\x202021\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\
    \x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20y\
    ou\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\
    \x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\
    \x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/li\
    censes/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\
    \x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\
    \x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20\
    IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20A\
    NY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20Li\
    cense\x20for\x20the\x20specific\x20language\x20governing\x20permissions\
    \x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\
    \x12\x03\x10\0\x1e\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\
    \x03\x13\0!\n\t\n\x02\x03\x02\x12\x03\x14\0)\n\t\n\x02\x03\x03\x12\x03\
    \x15\0#\n\t\n\x02\x03\x04\x12\x03\x16\0,\n\t\n\x02\x03\x05\x12\x03\x17\0\
    -\n\t\n\x02\x03\x06\x12\x03\x18\0(\n\t\n\x02\x03\x07\x12\x03\x19\0%\n\t\
    \n\x02\x03\x08\x12\x03\x1a\0*\n\t\n\x02\x03\t\x12\x03\x1b\0&\n\t\n\x02\
    \x03\n\x12\x03\x1c\0)\n\t\n\x02\x03\x0b\x12\x03\x1d\0!\n\t\n\x02\x03\x0c\
    \x12\x03\x1e\0\x20\n\x08\n\x01\x08\x12\x03\x20\02\n\t\n\x02\x08%\x12\x03\
    \x20\02\n\x08\n\x01\x08\x12\x03!\0Q\n\t\n\x02\x08\x0b\x12\x03!\0Q\n\x08\
    \n\x01\x08\x12\x03\"\0\"\n\t\n\x02\x08\n\x12\x03\"\0\"\n\x08\n\x01\x08\
    \x12\x03#\02\n\t\n\x02\x08\x08\x12\x03#\02\n\x08\n\x01\x08\x12\x03$\02\n\
    \t\n\x02\x08\x01\x12\x03$\02\n\x08\n\x01\x08\x12\x03%\02\n\t\n\x02\x08)\
    \x12\x03%\02\n(\n\x02\x06\0\x12\x05(\0\xbe\x01\x01\x1a\x1b\x20Asset\x20s\
    ervice\x20definition.\n\n\n\n\x03\x06\0\x01\x12\x03(\x08\x14\n\n\n\x03\
    \x06\0\x03\x12\x03)\x02A\n\x0c\n\x05\x06\0\x03\x99\x08\x12\x03)\x02A\n\n\
    \n\x03\x06\0\x03\x12\x03*\x02V\n\x0c\n\x05\x06\0\x03\x9a\x08\x12\x03*\
    \x02V\n\xde\x05\n\x04\x06\0\x02\0\x12\x046\x02?\x03\x1a\xcf\x05\x20Expor\
    ts\x20assets\x20with\x20time\x20and\x20resource\x20types\x20to\x20a\x20g\
    iven\x20Cloud\x20Storage\n\x20location/BigQuery\x20table.\x20For\x20Clou\
    d\x20Storage\x20location\x20destinations,\x20the\n\x20output\x20format\
    \x20is\x20newline-delimited\x20JSON.\x20Each\x20line\x20represents\x20a\
    \n\x20[google.cloud.asset.v1.Asset][google.cloud.asset.v1.Asset]\x20in\
    \x20the\x20JSON\x20format;\x20for\x20BigQuery\x20table\n\x20destinations\
    ,\x20the\x20output\x20table\x20stores\x20the\x20fields\x20in\x20asset\
    \x20proto\x20as\x20columns.\n\x20This\x20API\x20implements\x20the\x20[go\
    ogle.longrunning.Operation][google.longrunning.Operation]\x20API\n\x20,\
    \x20which\x20allows\x20you\x20to\x20keep\x20track\x20of\x20the\x20export\
    .\x20We\x20recommend\x20intervals\x20of\n\x20at\x20least\x202\x20seconds\
    \x20with\x20exponential\x20retry\x20to\x20poll\x20the\x20export\x20opera\
    tion\n\x20result.\x20For\x20regular-size\x20resource\x20parent,\x20the\
    \x20export\x20operation\x20usually\n\x20finishes\x20within\x205\x20minut\
    es.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x036\x06\x12\n\x0c\n\x05\x06\0\x02\
    \0\x02\x12\x036\x13&\n\x0c\n\x05\x06\0\x02\0\x03\x12\x0361M\n\r\n\x05\
    \x06\0\x02\0\x04\x12\x047\x04:\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\
    \"\x12\x047\x04:\x06\n\r\n\x05\x06\0\x02\0\x04\x12\x04;\x04>\x06\n\x0f\n\
    \x07\x06\0\x02\0\x04\x99\x08\x12\x04;\x04>\x06\na\n\x04\x06\0\x02\x01\
    \x12\x04C\x02H\x03\x1aS\x20Lists\x20assets\x20with\x20time\x20and\x20res\
    ource\x20types\x20and\x20returns\x20paged\x20results\x20in\n\x20response\
    .\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03C\x06\x10\n\x0c\n\x05\x06\0\x02\
    \x01\x02\x12\x03C\x11\"\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03C-?\n\r\n\
    \x05\x06\0\x02\x01\x04\x12\x04D\x04F\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\
    \xca\xbc\"\x12\x04D\x04F\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03G\x044\
    \n\x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\x12\x03G\x044\n\x94\x03\n\x04\
    \x06\0\x02\x02\x12\x04Q\x02U\x03\x1a\x85\x03\x20Batch\x20gets\x20the\x20\
    update\x20history\x20of\x20assets\x20that\x20overlap\x20a\x20time\x20win\
    dow.\n\x20For\x20IAM_POLICY\x20content,\x20this\x20API\x20outputs\x20his\
    tory\x20when\x20the\x20asset\x20and\x20its\n\x20attached\x20IAM\x20POLIC\
    Y\x20both\x20exist.\x20This\x20can\x20create\x20gaps\x20in\x20the\x20out\
    put\x20history.\n\x20Otherwise,\x20this\x20API\x20outputs\x20history\x20\
    with\x20asset\x20in\x20both\x20non-delete\x20or\n\x20deleted\x20status.\
    \n\x20If\x20a\x20specified\x20asset\x20does\x20not\x20exist,\x20this\x20\
    API\x20returns\x20an\x20INVALID_ARGUMENT\n\x20error.\n\n\x0c\n\x05\x06\0\
    \x02\x02\x01\x12\x03Q\x06\x1b\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03Q\x1c\
    8\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03QC`\n\r\n\x05\x06\0\x02\x02\x04\
    \x12\x04R\x04T\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04R\
    \x04T\x06\ng\n\x04\x06\0\x02\x03\x12\x04Y\x02_\x03\x1aY\x20Creates\x20a\
    \x20feed\x20in\x20a\x20parent\x20project/folder/organization\x20to\x20li\
    sten\x20to\x20its\n\x20asset\x20updates.\n\n\x0c\n\x05\x06\0\x02\x03\x01\
    \x12\x03Y\x06\x10\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03Y\x11\"\n\x0c\n\
    \x05\x06\0\x02\x03\x03\x12\x03Y-1\n\r\n\x05\x06\0\x02\x03\x04\x12\x04Z\
    \x04]\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04Z\x04]\x06\n\
    \x0c\n\x05\x06\0\x02\x03\x04\x12\x03^\x044\n\x0f\n\x08\x06\0\x02\x03\x04\
    \x9b\x08\0\x12\x03^\x044\n1\n\x04\x06\0\x02\x04\x12\x04b\x02g\x03\x1a#\
    \x20Gets\x20details\x20about\x20an\x20asset\x20feed.\n\n\x0c\n\x05\x06\0\
    \x02\x04\x01\x12\x03b\x06\r\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03b\x0e\
    \x1c\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03b'+\n\r\n\x05\x06\0\x02\x04\
    \x04\x12\x04c\x04e\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x04\
    c\x04e\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03f\x042\n\x0f\n\x08\x06\0\
    \x02\x04\x04\x9b\x08\0\x12\x03f\x042\nN\n\x04\x06\0\x02\x05\x12\x04j\x02\
    o\x03\x1a@\x20Lists\x20all\x20asset\x20feeds\x20in\x20a\x20parent\x20pro\
    ject/folder/organization.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03j\x06\
    \x0f\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03j\x10\x20\n\x0c\n\x05\x06\0\
    \x02\x05\x03\x12\x03j+<\n\r\n\x05\x06\0\x02\x05\x04\x12\x04k\x04m\x06\n\
    \x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x04k\x04m\x06\n\x0c\n\x05\
    \x06\0\x02\x05\x04\x12\x03n\x044\n\x0f\n\x08\x06\0\x02\x05\x04\x9b\x08\0\
    \x12\x03n\x044\n4\n\x04\x06\0\x02\x06\x12\x04r\x02x\x03\x1a&\x20Updates\
    \x20an\x20asset\x20feed\x20configuration.\n\n\x0c\n\x05\x06\0\x02\x06\
    \x01\x12\x03r\x06\x10\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03r\x11\"\n\x0c\
    \n\x05\x06\0\x02\x06\x03\x12\x03r-1\n\r\n\x05\x06\0\x02\x06\x04\x12\x04s\
    \x04v\x06\n\x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x04s\x04v\x06\n\
    \x0c\n\x05\x06\0\x02\x06\x04\x12\x03w\x042\n\x0f\n\x08\x06\0\x02\x06\x04\
    \x9b\x08\0\x12\x03w\x042\n'\n\x04\x06\0\x02\x07\x12\x05{\x02\x80\x01\x03\
    \x1a\x18\x20Deletes\x20an\x20asset\x20feed.\n\n\x0c\n\x05\x06\0\x02\x07\
    \x01\x12\x03{\x06\x10\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03{\x11\"\n\x0c\
    \n\x05\x06\0\x02\x07\x03\x12\x03{-B\n\r\n\x05\x06\0\x02\x07\x04\x12\x04|\
    \x04~\x06\n\x11\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x04|\x04~\x06\n\
    \x0c\n\x05\x06\0\x02\x07\x04\x12\x03\x7f\x042\n\x0f\n\x08\x06\0\x02\x07\
    \x04\x9b\x08\0\x12\x03\x7f\x042\n\x89\x02\n\x04\x06\0\x02\x08\x12\x06\
    \x86\x01\x02\x8b\x01\x03\x1a\xf8\x01\x20Searches\x20all\x20Cloud\x20reso\
    urces\x20within\x20the\x20specified\x20scope,\x20such\x20as\x20a\x20proj\
    ect,\n\x20folder,\x20or\x20organization.\x20The\x20caller\x20must\x20be\
    \x20granted\x20the\n\x20`cloudasset.assets.searchAllResources`\x20permis\
    sion\x20on\x20the\x20desired\x20scope,\n\x20otherwise\x20the\x20request\
    \x20will\x20be\x20rejected.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\x86\
    \x01\x06\x18\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\x86\x01\x192\n\r\n\x05\
    \x06\0\x02\x08\x03\x12\x04\x86\x01=W\n\x0f\n\x05\x06\0\x02\x08\x04\x12\
    \x06\x87\x01\x04\x89\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\
    \x12\x06\x87\x01\x04\x89\x01\x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\x8a\
    \x01\x04E\n\x10\n\x08\x06\0\x02\x08\x04\x9b\x08\0\x12\x04\x8a\x01\x04E\n\
    \x88\x02\n\x04\x06\0\x02\t\x12\x06\x91\x01\x02\x96\x01\x03\x1a\xf7\x01\
    \x20Searches\x20all\x20IAM\x20policies\x20within\x20the\x20specified\x20\
    scope,\x20such\x20as\x20a\x20project,\n\x20folder,\x20or\x20organization\
    .\x20The\x20caller\x20must\x20be\x20granted\x20the\n\x20`cloudasset.asse\
    ts.searchAllIamPolicies`\x20permission\x20on\x20the\x20desired\x20scope,\
    \n\x20otherwise\x20the\x20request\x20will\x20be\x20rejected.\n\n\r\n\x05\
    \x06\0\x02\t\x01\x12\x04\x91\x01\x06\x1a\n\r\n\x05\x06\0\x02\t\x02\x12\
    \x04\x91\x01\x1b6\n\r\n\x05\x06\0\x02\t\x03\x12\x04\x91\x01A]\n\x0f\n\
    \x05\x06\0\x02\t\x04\x12\x06\x92\x01\x04\x94\x01\x06\n\x13\n\t\x06\0\x02\
    \t\x04\xb0\xca\xbc\"\x12\x06\x92\x01\x04\x94\x01\x06\n\r\n\x05\x06\0\x02\
    \t\x04\x12\x04\x95\x01\x049\n\x10\n\x08\x06\0\x02\t\x04\x9b\x08\0\x12\
    \x04\x95\x01\x049\nj\n\x04\x06\0\x02\n\x12\x06\x9a\x01\x02\x9e\x01\x03\
    \x1aZ\x20Analyzes\x20IAM\x20policies\x20to\x20answer\x20which\x20identit\
    ies\x20have\x20what\x20accesses\x20on\n\x20which\x20resources.\n\n\r\n\
    \x05\x06\0\x02\n\x01\x12\x04\x9a\x01\x06\x16\n\r\n\x05\x06\0\x02\n\x02\
    \x12\x04\x9a\x01\x17.\n\r\n\x05\x06\0\x02\n\x03\x12\x04\x9a\x019Q\n\x0f\
    \n\x05\x06\0\x02\n\x04\x12\x06\x9b\x01\x04\x9d\x01\x06\n\x13\n\t\x06\0\
    \x02\n\x04\xb0\xca\xbc\"\x12\x06\x9b\x01\x04\x9d\x01\x06\n\xae\x05\n\x04\
    \x06\0\x02\x0b\x12\x06\xa9\x01\x02\xb2\x01\x03\x1a\x9d\x05\x20Analyzes\
    \x20IAM\x20policies\x20asynchronously\x20to\x20answer\x20which\x20identi\
    ties\x20have\x20what\n\x20accesses\x20on\x20which\x20resources,\x20and\
    \x20writes\x20the\x20analysis\x20results\x20to\x20a\x20Google\n\x20Cloud\
    \x20Storage\x20or\x20a\x20BigQuery\x20destination.\x20For\x20Cloud\x20St\
    orage\x20destination,\x20the\n\x20output\x20format\x20is\x20the\x20JSON\
    \x20format\x20that\x20represents\x20a\n\x20[AnalyzeIamPolicyResponse][go\
    ogle.cloud.asset.v1.AnalyzeIamPolicyResponse].\x20This\x20method\x20impl\
    ements\x20the\n\x20[google.longrunning.Operation][google.longrunning.Ope\
    ration],\x20which\x20allows\x20you\x20to\x20track\x20the\x20operation\n\
    \x20status.\x20We\x20recommend\x20intervals\x20of\x20at\x20least\x202\
    \x20seconds\x20with\x20exponential\n\x20backoff\x20retry\x20to\x20poll\
    \x20the\x20operation\x20result.\x20The\x20metadata\x20contains\x20the\n\
    \x20metadata\x20for\x20the\x20long-running\x20operation.\n\n\r\n\x05\x06\
    \0\x02\x0b\x01\x12\x04\xa9\x01\x06!\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\
    \xa9\x01\"D\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xa9\x01Ok\n\x0f\n\x05\
    \x06\0\x02\x0b\x04\x12\x06\xaa\x01\x04\xad\x01\x06\n\x13\n\t\x06\0\x02\
    \x0b\x04\xb0\xca\xbc\"\x12\x06\xaa\x01\x04\xad\x01\x06\n\x0f\n\x05\x06\0\
    \x02\x0b\x04\x12\x06\xae\x01\x04\xb1\x01\x06\n\x11\n\x07\x06\0\x02\x0b\
    \x04\x99\x08\x12\x06\xae\x01\x04\xb1\x01\x06\n\xd6\x02\n\x04\x06\0\x02\
    \x0c\x12\x06\xb9\x01\x02\xbd\x01\x03\x1a\xc5\x02\x20Analyze\x20moving\
    \x20a\x20resource\x20to\x20a\x20specified\x20destination\x20without\x20k\
    icking\x20off\n\x20the\x20actual\x20move.\x20The\x20analysis\x20is\x20be\
    st\x20effort\x20depending\x20on\x20the\x20user's\n\x20permissions\x20of\
    \x20viewing\x20different\x20hierarchical\x20policies\x20and\x20configura\
    tions.\n\x20The\x20policies\x20and\x20configuration\x20are\x20subject\
    \x20to\x20change\x20before\x20the\x20actual\n\x20resource\x20migration\
    \x20takes\x20place.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xb9\x01\x06\
    \x11\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xb9\x01\x12$\n\r\n\x05\x06\0\
    \x02\x0c\x03\x12\x04\xb9\x01/B\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\x06\xba\
    \x01\x04\xbc\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\x06\
    \xba\x01\x04\xbc\x01\x06\nn\n\x02\x04\0\x12\x06\xc2\x01\0\xc6\x01\x01\
    \x1a`\x20Represents\x20the\x20metadata\x20of\x20the\x20longrunning\x20op\
    eration\x20for\x20the\n\x20AnalyzeIamPolicyLongrunning\x20rpc.\n\n\x0b\n\
    \x03\x04\0\x01\x12\x04\xc2\x01\x08+\n5\n\x04\x04\0\x02\0\x12\x06\xc4\x01\
    \x02\xc5\x012\x1a%\x20The\x20time\x20the\x20operation\x20was\x20created.\
    \n\n\r\n\x05\x04\0\x02\0\x06\x12\x04\xc4\x01\x02\x1b\n\r\n\x05\x04\0\x02\
    \0\x01\x12\x04\xc4\x01\x1c'\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xc4\x01*+\
    \n\r\n\x05\x04\0\x02\0\x08\x12\x04\xc5\x01\x061\n\x10\n\x08\x04\0\x02\0\
    \x08\x9c\x08\0\x12\x04\xc5\x01\x070\n%\n\x02\x04\x01\x12\x06\xc9\x01\0\
    \xf6\x01\x01\x1a\x17\x20Export\x20asset\x20request.\n\n\x0b\n\x03\x04\
    \x01\x01\x12\x04\xc9\x01\x08\x1b\n\x98\x02\n\x04\x04\x01\x02\0\x12\x06\
    \xce\x01\x02\xd3\x01\x04\x1a\x87\x02\x20Required.\x20The\x20relative\x20\
    name\x20of\x20the\x20root\x20asset.\x20This\x20can\x20only\x20be\x20an\n\
    \x20organization\x20number\x20(such\x20as\x20\"organizations/123\"),\x20\
    a\x20project\x20ID\x20(such\x20as\n\x20\"projects/my-project-id\"),\x20o\
    r\x20a\x20project\x20number\x20(such\x20as\x20\"projects/12345\"),\n\x20\
    or\x20a\x20folder\x20number\x20(such\x20as\x20\"folders/123\").\n\n\r\n\
    \x05\x04\x01\x02\0\x05\x12\x04\xce\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\
    \x01\x12\x04\xce\x01\t\x0f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xce\x01\
    \x12\x13\n\x0f\n\x05\x04\x01\x02\0\x08\x12\x06\xce\x01\x14\xd3\x01\x03\n\
    \x10\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\x04\xcf\x01\x04*\n\x11\n\x07\
    \x04\x01\x02\0\x08\x9f\x08\x12\x06\xd0\x01\x04\xd2\x01\x05\n\xe9\x02\n\
    \x04\x04\x01\x02\x01\x12\x04\xda\x01\x02*\x1a\xda\x02\x20Timestamp\x20to\
    \x20take\x20an\x20asset\x20snapshot.\x20This\x20can\x20only\x20be\x20set\
    \x20to\x20a\x20timestamp\n\x20between\x20the\x20current\x20time\x20and\
    \x20the\x20current\x20time\x20minus\x2035\x20days\x20(inclusive).\n\x20I\
    f\x20not\x20specified,\x20the\x20current\x20time\x20will\x20be\x20used.\
    \x20Due\x20to\x20delays\x20in\x20resource\n\x20data\x20collection\x20and\
    \x20indexing,\x20there\x20is\x20a\x20volatile\x20window\x20during\x20whi\
    ch\n\x20running\x20the\x20same\x20query\x20may\x20get\x20different\x20re\
    sults.\n\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\xda\x01\x02\x1b\n\r\n\x05\
    \x04\x01\x02\x01\x01\x12\x04\xda\x01\x1c%\n\r\n\x05\x04\x01\x02\x01\x03\
    \x12\x04\xda\x01()\n\xe3\x06\n\x04\x04\x01\x02\x02\x12\x04\xee\x01\x02\"\
    \x1a\xd4\x06\x20A\x20list\x20of\x20asset\x20types\x20to\x20take\x20a\x20\
    snapshot\x20for.\x20For\x20example:\n\x20\"compute.googleapis.com/Disk\"\
    .\n\n\x20Regular\x20expressions\x20are\x20also\x20supported.\x20For\x20e\
    xample:\n\n\x20*\x20\"compute.googleapis.com.*\"\x20snapshots\x20resourc\
    es\x20whose\x20asset\x20type\x20starts\n\x20with\x20\"compute.googleapis\
    .com\".\n\x20*\x20\".*Instance\"\x20snapshots\x20resources\x20whose\x20a\
    sset\x20type\x20ends\x20with\x20\"Instance\".\n\x20*\x20\".*Instance.*\"\
    \x20snapshots\x20resources\x20whose\x20asset\x20type\x20contains\x20\"In\
    stance\".\n\n\x20See\x20[RE2](https://github.com/google/re2/wiki/Syntax)\
    \x20for\x20all\x20supported\n\x20regular\x20expression\x20syntax.\x20If\
    \x20the\x20regular\x20expression\x20does\x20not\x20match\x20any\n\x20sup\
    ported\x20asset\x20type,\x20an\x20INVALID_ARGUMENT\x20error\x20will\x20b\
    e\x20returned.\n\n\x20If\x20specified,\x20only\x20matching\x20assets\x20\
    will\x20be\x20returned,\x20otherwise,\x20it\x20will\n\x20snapshot\x20all\
    \x20asset\x20types.\x20See\x20[Introduction\x20to\x20Cloud\x20Asset\n\
    \x20Inventory](https://cloud.google.com/asset-inventory/docs/overview)\n\
    \x20for\x20all\x20supported\x20asset\x20types.\n\n\r\n\x05\x04\x01\x02\
    \x02\x04\x12\x04\xee\x01\x02\n\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xee\
    \x01\x0b\x11\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xee\x01\x12\x1d\n\r\n\
    \x05\x04\x01\x02\x02\x03\x12\x04\xee\x01\x20!\nf\n\x04\x04\x01\x02\x03\
    \x12\x04\xf2\x01\x02\x1f\x1aX\x20Asset\x20content\x20type.\x20If\x20not\
    \x20specified,\x20no\x20content\x20but\x20the\x20asset\x20name\x20will\
    \x20be\n\x20returned.\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\xf2\x01\
    \x02\r\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\xf2\x01\x0e\x1a\n\r\n\x05\
    \x04\x01\x02\x03\x03\x12\x04\xf2\x01\x1d\x1e\n^\n\x04\x04\x01\x02\x04\
    \x12\x04\xf5\x01\x02J\x1aP\x20Required.\x20Output\x20configuration\x20in\
    dicating\x20where\x20the\x20results\x20will\x20be\x20output\x20to.\n\n\r\
    \n\x05\x04\x01\x02\x04\x06\x12\x04\xf5\x01\x02\x0e\n\r\n\x05\x04\x01\x02\
    \x04\x01\x12\x04\xf5\x01\x0f\x1c\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\
    \xf5\x01\x1f\x20\n\r\n\x05\x04\x01\x02\x04\x08\x12\x04\xf5\x01!I\n\x10\n\
    \x08\x04\x01\x02\x04\x08\x9c\x08\0\x12\x04\xf5\x01\"H\n\x93\x02\n\x02\
    \x04\x02\x12\x06\xfb\x01\0\x88\x02\x01\x1a\x84\x02\x20The\x20export\x20a\
    sset\x20response.\x20This\x20message\x20is\x20returned\x20by\x20the\n\
    \x20[google.longrunning.Operations.GetOperation][google.longrunning.Oper\
    ations.GetOperation]\x20method\x20in\x20the\x20returned\n\x20[google.lon\
    grunning.Operation.response][google.longrunning.Operation.response]\x20f\
    ield.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xfb\x01\x08\x1c\n,\n\x04\x04\x02\
    \x02\0\x12\x04\xfd\x01\x02*\x1a\x1e\x20Time\x20the\x20snapshot\x20was\
    \x20taken.\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xfd\x01\x02\x1b\n\r\n\
    \x05\x04\x02\x02\0\x01\x12\x04\xfd\x01\x1c%\n\r\n\x05\x04\x02\x02\0\x03\
    \x12\x04\xfd\x01()\nQ\n\x04\x04\x02\x02\x01\x12\x04\x80\x02\x02!\x1aC\
    \x20Output\x20configuration\x20indicating\x20where\x20the\x20results\x20\
    were\x20output\x20to.\n\n\r\n\x05\x04\x02\x02\x01\x06\x12\x04\x80\x02\
    \x02\x0e\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x80\x02\x0f\x1c\n\r\n\x05\
    \x04\x02\x02\x01\x03\x12\x04\x80\x02\x1f\x20\n\xee\x02\n\x04\x04\x02\x02\
    \x02\x12\x04\x87\x02\x02!\x1a\xdf\x02\x20Output\x20result\x20indicating\
    \x20where\x20the\x20assets\x20were\x20exported\x20to.\x20For\x20example,\
    \x20a\n\x20set\x20of\x20actual\x20Google\x20Cloud\x20Storage\x20object\
    \x20uris\x20where\x20the\x20assets\x20are\n\x20exported\x20to.\x20The\
    \x20uris\x20can\x20be\x20different\x20from\x20what\x20[output_config]\
    \x20has\n\x20specified,\x20as\x20the\x20service\x20will\x20split\x20the\
    \x20output\x20object\x20into\x20multiple\x20ones\n\x20once\x20it\x20exce\
    eds\x20a\x20single\x20Google\x20Cloud\x20Storage\x20object\x20limit.\n\n\
    \r\n\x05\x04\x02\x02\x02\x06\x12\x04\x87\x02\x02\x0e\n\r\n\x05\x04\x02\
    \x02\x02\x01\x12\x04\x87\x02\x0f\x1c\n\r\n\x05\x04\x02\x02\x02\x03\x12\
    \x04\x87\x02\x1f\x20\n#\n\x02\x04\x03\x12\x06\x8b\x02\0\xbe\x02\x01\x1a\
    \x15\x20ListAssets\x20request.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x8b\x02\
    \x08\x19\n\x9d\x02\n\x04\x04\x03\x02\0\x12\x06\x90\x02\x02\x95\x02\x04\
    \x1a\x8c\x02\x20Required.\x20Name\x20of\x20the\x20organization\x20or\x20\
    project\x20the\x20assets\x20belong\x20to.\x20Format:\n\x20\"organization\
    s/[organization-number]\"\x20(such\x20as\x20\"organizations/123\"),\n\
    \x20\"projects/[project-id]\"\x20(such\x20as\x20\"projects/my-project-id\
    \"),\x20or\n\x20\"projects/[project-number]\"\x20(such\x20as\x20\"projec\
    ts/12345\").\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x90\x02\x02\x08\n\r\n\
    \x05\x04\x03\x02\0\x01\x12\x04\x90\x02\t\x0f\n\r\n\x05\x04\x03\x02\0\x03\
    \x12\x04\x90\x02\x12\x13\n\x0f\n\x05\x04\x03\x02\0\x08\x12\x06\x90\x02\
    \x14\x95\x02\x03\n\x10\n\x08\x04\x03\x02\0\x08\x9c\x08\0\x12\x04\x91\x02\
    \x04*\n\x11\n\x07\x04\x03\x02\0\x08\x9f\x08\x12\x06\x92\x02\x04\x94\x02\
    \x05\n\xe9\x02\n\x04\x04\x03\x02\x01\x12\x04\x9c\x02\x02*\x1a\xda\x02\
    \x20Timestamp\x20to\x20take\x20an\x20asset\x20snapshot.\x20This\x20can\
    \x20only\x20be\x20set\x20to\x20a\x20timestamp\n\x20between\x20the\x20cur\
    rent\x20time\x20and\x20the\x20current\x20time\x20minus\x2035\x20days\x20\
    (inclusive).\n\x20If\x20not\x20specified,\x20the\x20current\x20time\x20w\
    ill\x20be\x20used.\x20Due\x20to\x20delays\x20in\x20resource\n\x20data\
    \x20collection\x20and\x20indexing,\x20there\x20is\x20a\x20volatile\x20wi\
    ndow\x20during\x20which\n\x20running\x20the\x20same\x20query\x20may\x20g\
    et\x20different\x20results.\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x9c\
    \x02\x02\x1b\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x9c\x02\x1c%\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\x9c\x02()\n\xe1\x06\n\x04\x04\x03\x02\
    \x02\x12\x04\xb0\x02\x02\"\x1a\xd2\x06\x20A\x20list\x20of\x20asset\x20ty\
    pes\x20to\x20take\x20a\x20snapshot\x20for.\x20For\x20example:\n\x20\"com\
    pute.googleapis.com/Disk\".\n\n\x20Regular\x20expression\x20is\x20also\
    \x20supported.\x20For\x20example:\n\n\x20*\x20\"compute.googleapis.com.*\
    \"\x20snapshots\x20resources\x20whose\x20asset\x20type\x20starts\n\x20wi\
    th\x20\"compute.googleapis.com\".\n\x20*\x20\".*Instance\"\x20snapshots\
    \x20resources\x20whose\x20asset\x20type\x20ends\x20with\x20\"Instance\".\
    \n\x20*\x20\".*Instance.*\"\x20snapshots\x20resources\x20whose\x20asset\
    \x20type\x20contains\x20\"Instance\".\n\n\x20See\x20[RE2](https://github\
    .com/google/re2/wiki/Syntax)\x20for\x20all\x20supported\n\x20regular\x20\
    expression\x20syntax.\x20If\x20the\x20regular\x20expression\x20does\x20n\
    ot\x20match\x20any\n\x20supported\x20asset\x20type,\x20an\x20INVALID_ARG\
    UMENT\x20error\x20will\x20be\x20returned.\n\n\x20If\x20specified,\x20onl\
    y\x20matching\x20assets\x20will\x20be\x20returned,\x20otherwise,\x20it\
    \x20will\n\x20snapshot\x20all\x20asset\x20types.\x20See\x20[Introduction\
    \x20to\x20Cloud\x20Asset\n\x20Inventory](https://cloud.google.com/asset-\
    inventory/docs/overview)\n\x20for\x20all\x20supported\x20asset\x20types.\
    \n\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04\xb0\x02\x02\n\n\r\n\x05\x04\x03\
    \x02\x02\x05\x12\x04\xb0\x02\x0b\x11\n\r\n\x05\x04\x03\x02\x02\x01\x12\
    \x04\xb0\x02\x12\x1d\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xb0\x02\x20!\
    \nf\n\x04\x04\x03\x02\x03\x12\x04\xb4\x02\x02\x1f\x1aX\x20Asset\x20conte\
    nt\x20type.\x20If\x20not\x20specified,\x20no\x20content\x20but\x20the\
    \x20asset\x20name\x20will\n\x20be\x20returned.\n\n\r\n\x05\x04\x03\x02\
    \x03\x06\x12\x04\xb4\x02\x02\r\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xb4\
    \x02\x0e\x1a\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xb4\x02\x1d\x1e\n\x85\
    \x01\n\x04\x04\x03\x02\x04\x12\x04\xb8\x02\x02\x16\x1aw\x20The\x20maximu\
    m\x20number\x20of\x20assets\x20to\x20be\x20returned\x20in\x20a\x20single\
    \x20response.\x20Default\n\x20is\x20100,\x20minimum\x20is\x201,\x20and\
    \x20maximum\x20is\x201000.\n\n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\xb8\
    \x02\x02\x07\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xb8\x02\x08\x11\n\r\n\
    \x05\x04\x03\x02\x04\x03\x12\x04\xb8\x02\x14\x15\n\xf1\x01\n\x04\x04\x03\
    \x02\x05\x12\x04\xbd\x02\x02\x18\x1a\xe2\x01\x20The\x20`next_page_token`\
    \x20returned\x20from\x20the\x20previous\x20`ListAssetsResponse`,\x20or\n\
    \x20unspecified\x20for\x20the\x20first\x20`ListAssetsRequest`.\x20It\x20\
    is\x20a\x20continuation\x20of\x20a\n\x20prior\x20`ListAssets`\x20call,\
    \x20and\x20the\x20API\x20should\x20return\x20the\x20next\x20page\x20of\
    \x20assets.\n\n\r\n\x05\x04\x03\x02\x05\x05\x12\x04\xbd\x02\x02\x08\n\r\
    \n\x05\x04\x03\x02\x05\x01\x12\x04\xbd\x02\t\x13\n\r\n\x05\x04\x03\x02\
    \x05\x03\x12\x04\xbd\x02\x16\x17\n$\n\x02\x04\x04\x12\x06\xc1\x02\0\xcc\
    \x02\x01\x1a\x16\x20ListAssets\x20response.\n\n\x0b\n\x03\x04\x04\x01\
    \x12\x04\xc1\x02\x08\x1a\n,\n\x04\x04\x04\x02\0\x12\x04\xc3\x02\x02*\x1a\
    \x1e\x20Time\x20the\x20snapshot\x20was\x20taken.\n\n\r\n\x05\x04\x04\x02\
    \0\x06\x12\x04\xc3\x02\x02\x1b\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xc3\
    \x02\x1c%\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xc3\x02()\n\x17\n\x04\x04\
    \x04\x02\x01\x12\x04\xc6\x02\x02\x1c\x1a\t\x20Assets.\n\n\r\n\x05\x04\
    \x04\x02\x01\x04\x12\x04\xc6\x02\x02\n\n\r\n\x05\x04\x04\x02\x01\x06\x12\
    \x04\xc6\x02\x0b\x10\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xc6\x02\x11\
    \x17\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xc6\x02\x1a\x1b\n\xb8\x01\n\
    \x04\x04\x04\x02\x02\x12\x04\xcb\x02\x02\x1d\x1a\xa9\x01\x20Token\x20to\
    \x20retrieve\x20the\x20next\x20page\x20of\x20results.\x20It\x20expires\
    \x2072\x20hours\x20after\x20the\n\x20page\x20token\x20for\x20the\x20firs\
    t\x20page\x20is\x20generated.\x20Set\x20to\x20empty\x20if\x20there\x20ar\
    e\x20no\n\x20remaining\x20results.\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\
    \x04\xcb\x02\x02\x08\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\xcb\x02\t\x18\
    \n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xcb\x02\x1b\x1c\n1\n\x02\x04\x05\
    \x12\x06\xcf\x02\0\xee\x02\x01\x1a#\x20Batch\x20get\x20assets\x20history\
    \x20request.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xcf\x02\x08$\n\xea\x01\n\
    \x04\x04\x05\x02\0\x12\x06\xd3\x02\x02\xd8\x02\x04\x1a\xd9\x01\x20Requir\
    ed.\x20The\x20relative\x20name\x20of\x20the\x20root\x20asset.\x20It\x20c\
    an\x20only\x20be\x20an\n\x20organization\x20number\x20(such\x20as\x20\"o\
    rganizations/123\"),\x20a\x20project\x20ID\x20(such\x20as\n\x20\"project\
    s/my-project-id\")\",\x20or\x20a\x20project\x20number\x20(such\x20as\x20\
    \"projects/12345\").\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xd3\x02\x02\
    \x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xd3\x02\t\x0f\n\r\n\x05\x04\x05\
    \x02\0\x03\x12\x04\xd3\x02\x12\x13\n\x0f\n\x05\x04\x05\x02\0\x08\x12\x06\
    \xd3\x02\x14\xd8\x02\x03\n\x10\n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\
    \xd4\x02\x04*\n\x11\n\x07\x04\x05\x02\0\x08\x9f\x08\x12\x06\xd5\x02\x04\
    \xd7\x02\x05\n\xe0\x02\n\x04\x04\x05\x02\x01\x12\x04\xe2\x02\x02\"\x1a\
    \xd1\x02\x20A\x20list\x20of\x20the\x20full\x20names\x20of\x20the\x20asse\
    ts.\n\x20See:\x20https://cloud.google.com/asset-inventory/docs/resource-\
    name-format\n\x20Example:\n\n\x20`//compute.googleapis.com/projects/my_p\
    roject_123/zones/zone1/instances/instance1`.\n\n\x20The\x20request\x20be\
    comes\x20a\x20no-op\x20if\x20the\x20asset\x20name\x20list\x20is\x20empty\
    ,\x20and\x20the\x20max\n\x20size\x20of\x20the\x20asset\x20name\x20list\
    \x20is\x20100\x20in\x20one\x20request.\n\n\r\n\x05\x04\x05\x02\x01\x04\
    \x12\x04\xe2\x02\x02\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xe2\x02\x0b\
    \x11\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xe2\x02\x12\x1d\n\r\n\x05\x04\
    \x05\x02\x01\x03\x12\x04\xe2\x02\x20!\n+\n\x04\x04\x05\x02\x02\x12\x04\
    \xe5\x02\x02H\x1a\x1d\x20Optional.\x20The\x20content\x20type.\n\n\r\n\
    \x05\x04\x05\x02\x02\x06\x12\x04\xe5\x02\x02\r\n\r\n\x05\x04\x05\x02\x02\
    \x01\x12\x04\xe5\x02\x0e\x1a\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xe5\
    \x02\x1d\x1e\n\r\n\x05\x04\x05\x02\x02\x08\x12\x04\xe5\x02\x1fG\n\x10\n\
    \x08\x04\x05\x02\x02\x08\x9c\x08\0\x12\x04\xe5\x02\x20F\n\x9e\x03\n\x04\
    \x04\x05\x02\x03\x12\x04\xed\x02\x02K\x1a\x8f\x03\x20Optional.\x20The\
    \x20time\x20window\x20for\x20the\x20asset\x20history.\x20Both\x20start_t\
    ime\x20and\n\x20end_time\x20are\x20optional\x20and\x20if\x20set,\x20it\
    \x20must\x20be\x20after\x20the\x20current\x20time\x20minus\n\x2035\x20da\
    ys.\x20If\x20end_time\x20is\x20not\x20set,\x20it\x20is\x20default\x20to\
    \x20current\x20timestamp.\n\x20If\x20start_time\x20is\x20not\x20set,\x20\
    the\x20snapshot\x20of\x20the\x20assets\x20at\x20end_time\x20will\x20be\n\
    \x20returned.\x20The\x20returned\x20results\x20contain\x20all\x20tempora\
    l\x20assets\x20whose\x20time\n\x20window\x20overlap\x20with\x20read_time\
    _window.\n\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\xed\x02\x02\x0c\n\r\n\
    \x05\x04\x05\x02\x03\x01\x12\x04\xed\x02\r\x1d\n\r\n\x05\x04\x05\x02\x03\
    \x03\x12\x04\xed\x02\x20!\n\r\n\x05\x04\x05\x02\x03\x08\x12\x04\xed\x02\
    \"J\n\x10\n\x08\x04\x05\x02\x03\x08\x9c\x08\0\x12\x04\xed\x02#I\n2\n\x02\
    \x04\x06\x12\x06\xf1\x02\0\xf4\x02\x01\x1a$\x20Batch\x20get\x20assets\
    \x20history\x20response.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xf1\x02\x08%\
    \n9\n\x04\x04\x06\x02\0\x12\x04\xf3\x02\x02$\x1a+\x20A\x20list\x20of\x20\
    assets\x20with\x20valid\x20time\x20windows.\n\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04\xf3\x02\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xf3\x02\
    \x0b\x18\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xf3\x02\x19\x1f\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\xf3\x02\"#\n*\n\x02\x04\x07\x12\x06\xf7\x02\0\
    \x89\x03\x01\x1a\x1c\x20Create\x20asset\x20feed\x20request.\n\n\x0b\n\
    \x03\x04\x07\x01\x12\x04\xf7\x02\x08\x19\n\xc0\x02\n\x04\x04\x07\x02\0\
    \x12\x04\xfd\x02\x02=\x1a\xb1\x02\x20Required.\x20The\x20name\x20of\x20t\
    he\x20project/folder/organization\x20where\x20this\x20feed\n\x20should\
    \x20be\x20created\x20in.\x20It\x20can\x20only\x20be\x20an\x20organizatio\
    n\x20number\x20(such\x20as\n\x20\"organizations/123\"),\x20a\x20folder\
    \x20number\x20(such\x20as\x20\"folders/123\"),\x20a\x20project\x20ID\n\
    \x20(such\x20as\x20\"projects/my-project-id\")\",\x20or\x20a\x20project\
    \x20number\x20(such\x20as\n\x20\"projects/12345\").\n\n\r\n\x05\x04\x07\
    \x02\0\x05\x12\x04\xfd\x02\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xfd\x02\t\x0f\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xfd\x02\x12\x13\n\r\n\
    \x05\x04\x07\x02\0\x08\x12\x04\xfd\x02\x14<\n\x10\n\x08\x04\x07\x02\0\
    \x08\x9c\x08\0\x12\x04\xfd\x02\x15;\n\x9c\x01\n\x04\x04\x07\x02\x01\x12\
    \x04\x81\x03\x02>\x1a\x8d\x01\x20Required.\x20This\x20is\x20the\x20clien\
    t-assigned\x20asset\x20feed\x20identifier\x20and\x20it\x20needs\x20to\n\
    \x20be\x20unique\x20under\x20a\x20specific\x20parent\x20project/folder/o\
    rganization.\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\x81\x03\x02\x08\n\r\
    \n\x05\x04\x07\x02\x01\x01\x12\x04\x81\x03\t\x10\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\x81\x03\x13\x14\n\r\n\x05\x04\x07\x02\x01\x08\x12\x04\
    \x81\x03\x15=\n\x10\n\x08\x04\x07\x02\x01\x08\x9c\x08\0\x12\x04\x81\x03\
    \x16<\n\xf4\x01\n\x04\x04\x07\x02\x02\x12\x04\x88\x03\x029\x1a\xe5\x01\
    \x20Required.\x20The\x20feed\x20details.\x20The\x20field\x20`name`\x20mu\
    st\x20be\x20empty\x20and\x20it\x20will\x20be\x20generated\n\x20in\x20the\
    \x20format\x20of:\n\x20projects/project_number/feeds/feed_id\n\x20folder\
    s/folder_number/feeds/feed_id\n\x20organizations/organization_number/fee\
    ds/feed_id\n\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\x88\x03\x02\x06\n\r\n\
    \x05\x04\x07\x02\x02\x01\x12\x04\x88\x03\x07\x0b\n\r\n\x05\x04\x07\x02\
    \x02\x03\x12\x04\x88\x03\x0e\x0f\n\r\n\x05\x04\x07\x02\x02\x08\x12\x04\
    \x88\x03\x108\n\x10\n\x08\x04\x07\x02\x02\x08\x9c\x08\0\x12\x04\x88\x03\
    \x117\n'\n\x02\x04\x08\x12\x06\x8c\x03\0\x97\x03\x01\x1a\x19\x20Get\x20a\
    sset\x20feed\x20request.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x8c\x03\x08\
    \x16\n\xcf\x01\n\x04\x04\x08\x02\0\x12\x06\x91\x03\x02\x96\x03\x04\x1a\
    \xbe\x01\x20Required.\x20The\x20name\x20of\x20the\x20Feed\x20and\x20it\
    \x20must\x20be\x20in\x20the\x20format\x20of:\n\x20projects/project_numbe\
    r/feeds/feed_id\n\x20folders/folder_number/feeds/feed_id\n\x20organizati\
    ons/organization_number/feeds/feed_id\n\n\r\n\x05\x04\x08\x02\0\x05\x12\
    \x04\x91\x03\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x91\x03\t\r\n\r\
    \n\x05\x04\x08\x02\0\x03\x12\x04\x91\x03\x10\x11\n\x0f\n\x05\x04\x08\x02\
    \0\x08\x12\x06\x91\x03\x12\x96\x03\x03\n\x10\n\x08\x04\x08\x02\0\x08\x9c\
    \x08\0\x12\x04\x92\x03\x04*\n\x11\n\x07\x04\x08\x02\0\x08\x9f\x08\x12\
    \x06\x93\x03\x04\x95\x03\x05\n)\n\x02\x04\t\x12\x06\x9a\x03\0\x9f\x03\
    \x01\x1a\x1b\x20List\x20asset\x20feeds\x20request.\n\n\x0b\n\x03\x04\t\
    \x01\x12\x04\x9a\x03\x08\x18\n\xe9\x01\n\x04\x04\t\x02\0\x12\x04\x9e\x03\
    \x02=\x1a\xda\x01\x20Required.\x20The\x20parent\x20project/folder/organi\
    zation\x20whose\x20feeds\x20are\x20to\x20be\n\x20listed.\x20It\x20can\
    \x20only\x20be\x20using\x20project/folder/organization\x20number\x20(suc\
    h\x20as\n\x20\"folders/12345\")\",\x20or\x20a\x20project\x20ID\x20(such\
    \x20as\x20\"projects/my-project-id\").\n\n\r\n\x05\x04\t\x02\0\x05\x12\
    \x04\x9e\x03\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x9e\x03\t\x0f\n\r\
    \n\x05\x04\t\x02\0\x03\x12\x04\x9e\x03\x12\x13\n\r\n\x05\x04\t\x02\0\x08\
    \x12\x04\x9e\x03\x14<\n\x10\n\x08\x04\t\x02\0\x08\x9c\x08\0\x12\x04\x9e\
    \x03\x15;\n\x0c\n\x02\x04\n\x12\x06\xa1\x03\0\xa4\x03\x01\n\x0b\n\x03\
    \x04\n\x01\x12\x04\xa1\x03\x08\x19\n\x20\n\x04\x04\n\x02\0\x12\x04\xa3\
    \x03\x02\x1a\x1a\x12\x20A\x20list\x20of\x20feeds.\n\n\r\n\x05\x04\n\x02\
    \0\x04\x12\x04\xa3\x03\x02\n\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xa3\x03\
    \x0b\x0f\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xa3\x03\x10\x15\n\r\n\x05\x04\
    \n\x02\0\x03\x12\x04\xa3\x03\x18\x19\n*\n\x02\x04\x0b\x12\x06\xa7\x03\0\
    \xb3\x03\x01\x1a\x1c\x20Update\x20asset\x20feed\x20request.\n\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\xa7\x03\x08\x19\n\x8d\x02\n\x04\x04\x0b\x02\0\
    \x12\x04\xad\x03\x029\x1a\xfe\x01\x20Required.\x20The\x20new\x20values\
    \x20of\x20feed\x20details.\x20It\x20must\x20match\x20an\x20existing\x20f\
    eed\x20and\x20the\n\x20field\x20`name`\x20must\x20be\x20in\x20the\x20for\
    mat\x20of:\n\x20projects/project_number/feeds/feed_id\x20or\n\x20folders\
    /folder_number/feeds/feed_id\x20or\n\x20organizations/organization_numbe\
    r/feeds/feed_id.\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xad\x03\x02\x06\n\
    \r\n\x05\x04\x0b\x02\0\x01\x12\x04\xad\x03\x07\x0b\n\r\n\x05\x04\x0b\x02\
    \0\x03\x12\x04\xad\x03\x0e\x0f\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\xad\
    \x03\x108\n\x10\n\x08\x04\x0b\x02\0\x08\x9c\x08\0\x12\x04\xad\x03\x117\n\
    \xc2\x01\n\x04\x04\x0b\x02\x01\x12\x04\xb2\x03\x02U\x1a\xb3\x01\x20Requi\
    red.\x20Only\x20updates\x20the\x20`feed`\x20fields\x20indicated\x20by\
    \x20this\x20mask.\n\x20The\x20field\x20mask\x20must\x20not\x20be\x20empt\
    y,\x20and\x20it\x20must\x20not\x20contain\x20fields\x20that\n\x20are\x20\
    immutable\x20or\x20only\x20set\x20by\x20the\x20server.\n\n\r\n\x05\x04\
    \x0b\x02\x01\x06\x12\x04\xb2\x03\x02\x1b\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\xb2\x03\x1c'\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xb2\x03*+\n\
    \r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xb2\x03,T\n\x10\n\x08\x04\x0b\x02\
    \x01\x08\x9c\x08\0\x12\x04\xb2\x03-S\n\x0c\n\x02\x04\x0c\x12\x06\xb5\x03\
    \0\xc0\x03\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xb5\x03\x08\x19\n\xcf\x01\
    \n\x04\x04\x0c\x02\0\x12\x06\xba\x03\x02\xbf\x03\x04\x1a\xbe\x01\x20Requ\
    ired.\x20The\x20name\x20of\x20the\x20feed\x20and\x20it\x20must\x20be\x20\
    in\x20the\x20format\x20of:\n\x20projects/project_number/feeds/feed_id\n\
    \x20folders/folder_number/feeds/feed_id\n\x20organizations/organization_\
    number/feeds/feed_id\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xba\x03\x02\
    \x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xba\x03\t\r\n\r\n\x05\x04\x0c\
    \x02\0\x03\x12\x04\xba\x03\x10\x11\n\x0f\n\x05\x04\x0c\x02\0\x08\x12\x06\
    \xba\x03\x12\xbf\x03\x03\n\x10\n\x08\x04\x0c\x02\0\x08\x9c\x08\0\x12\x04\
    \xbb\x03\x04*\n\x11\n\x07\x04\x0c\x02\0\x08\x9f\x08\x12\x06\xbc\x03\x04\
    \xbe\x03\x05\nC\n\x02\x04\r\x12\x06\xc3\x03\0\xcd\x03\x01\x1a5\x20Output\
    \x20configuration\x20for\x20export\x20assets\x20destination.\n\n\x0b\n\
    \x03\x04\r\x01\x12\x04\xc3\x03\x08\x14\n+\n\x04\x04\r\x08\0\x12\x06\xc5\
    \x03\x02\xcc\x03\x03\x1a\x1b\x20Asset\x20export\x20destination.\n\n\r\n\
    \x05\x04\r\x08\0\x01\x12\x04\xc5\x03\x08\x13\n-\n\x04\x04\r\x02\0\x12\
    \x04\xc7\x03\x04'\x1a\x1f\x20Destination\x20on\x20Cloud\x20Storage.\n\n\
    \r\n\x05\x04\r\x02\0\x06\x12\x04\xc7\x03\x04\x12\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\xc7\x03\x13\"\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xc7\x03%&\n\
    s\n\x04\x04\r\x02\x01\x12\x04\xcb\x03\x041\x1ae\x20Destination\x20on\x20\
    BigQuery.\x20The\x20output\x20table\x20stores\x20the\x20fields\x20in\x20\
    asset\n\x20proto\x20as\x20columns\x20in\x20BigQuery.\n\n\r\n\x05\x04\r\
    \x02\x01\x06\x12\x04\xcb\x03\x04\x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \xcb\x03\x18,\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xcb\x03/0\n/\n\x02\x04\
    \x0e\x12\x06\xd0\x03\0\xd6\x03\x01\x1a!\x20Output\x20result\x20of\x20exp\
    ort\x20assets.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xd0\x03\x08\x14\n&\n\
    \x04\x04\x0e\x08\0\x12\x06\xd2\x03\x02\xd5\x03\x03\x1a\x16\x20Asset\x20e\
    xport\x20result.\n\n\r\n\x05\x04\x0e\x08\0\x01\x12\x04\xd2\x03\x08\x0e\n\
    /\n\x04\x04\x0e\x02\0\x12\x04\xd4\x03\x04#\x1a!\x20Export\x20result\x20o\
    n\x20Cloud\x20Storage.\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xd4\x03\x04\
    \x13\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xd4\x03\x14\x1e\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\xd4\x03!\"\n.\n\x02\x04\x0f\x12\x06\xd9\x03\0\xdd\
    \x03\x01\x1a\x20\x20A\x20Cloud\x20Storage\x20output\x20result.\n\n\x0b\n\
    \x03\x04\x0f\x01\x12\x04\xd9\x03\x08\x17\nd\n\x04\x04\x0f\x02\0\x12\x04\
    \xdc\x03\x02\x1b\x1aV\x20List\x20of\x20uris\x20of\x20the\x20Cloud\x20Sto\
    rage\x20objects.\x20Example:\n\x20\"gs://bucket_name/object_name\".\n\n\
    \r\n\x05\x04\x0f\x02\0\x04\x12\x04\xdc\x03\x02\n\n\r\n\x05\x04\x0f\x02\0\
    \x05\x12\x04\xdc\x03\x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xdc\x03\
    \x12\x16\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xdc\x03\x19\x1a\n)\n\x02\
    \x04\x10\x12\x06\xe0\x03\0\xf9\x03\x01\x1a\x1b\x20A\x20Cloud\x20Storage\
    \x20location.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xe0\x03\x08\x16\n\x1b\n\
    \x04\x04\x10\x08\0\x12\x06\xe2\x03\x02\xf8\x03\x03\x1a\x0b\x20Required.\
    \n\n\r\n\x05\x04\x10\x08\0\x01\x12\x04\xe2\x03\x08\x12\n\xc2\x03\n\x04\
    \x04\x10\x02\0\x12\x04\xec\x03\x04\x13\x1a\xb3\x03\x20The\x20uri\x20of\
    \x20the\x20Cloud\x20Storage\x20object.\x20It's\x20the\x20same\x20uri\x20\
    that\x20is\x20used\x20by\n\x20gsutil.\x20Example:\x20\"gs://bucket_name/\
    object_name\".\x20See\x20[Viewing\x20and\n\x20Editing\x20Object\n\x20Met\
    adata](https://cloud.google.com/storage/docs/viewing-editing-metadata)\n\
    \x20for\x20more\x20information.\n\n\x20If\x20the\x20specified\x20Cloud\
    \x20Storage\x20object\x20already\x20exists\x20and\x20there\x20is\x20no\n\
    \x20[hold](https://cloud.google.com/storage/docs/object-holds),\x20it\
    \x20will\x20be\n\x20overwritten\x20with\x20the\x20exported\x20result.\n\
    \n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xec\x03\x04\n\n\r\n\x05\x04\x10\x02\
    \0\x01\x12\x04\xec\x03\x0b\x0e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xec\
    \x03\x11\x12\n\xc5\x04\n\x04\x04\x10\x02\x01\x12\x04\xf7\x03\x04\x1a\x1a\
    \xb6\x04\x20The\x20uri\x20prefix\x20of\x20all\x20generated\x20Cloud\x20S\
    torage\x20objects.\x20Example:\n\x20\"gs://bucket_name/object_name_prefi\
    x\".\x20Each\x20object\x20uri\x20is\x20in\x20format:\n\x20\"gs://bucket_\
    name/object_name_prefix/<asset\x20type>/<shard\x20number>\x20and\x20only\
    \n\x20contains\x20assets\x20for\x20that\x20type.\x20<shard\x20number>\
    \x20starts\x20from\x200.\x20Example:\n\x20\"gs://bucket_name/object_name\
    _prefix/compute.googleapis.com/Disk/0\"\x20is\n\x20the\x20first\x20shard\
    \x20of\x20output\x20objects\x20containing\x20all\n\x20compute.googleapis\
    .com/Disk\x20assets.\x20An\x20INVALID_ARGUMENT\x20error\x20will\x20be\n\
    \x20returned\x20if\x20file\x20with\x20the\x20same\x20name\x20\"gs://buck\
    et_name/object_name_prefix\"\n\x20already\x20exists.\n\n\r\n\x05\x04\x10\
    \x02\x01\x05\x12\x04\xf7\x03\x04\n\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xf7\x03\x0b\x15\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xf7\x03\x18\x19\n\
    ?\n\x02\x04\x11\x12\x06\xfc\x03\0\xbd\x04\x01\x1a1\x20A\x20BigQuery\x20d\
    estination\x20for\x20exporting\x20assets\x20to.\n\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\xfc\x03\x08\x1b\n\xe9\x01\n\x04\x04\x11\x02\0\x12\x04\x81\
    \x04\x02>\x1a\xda\x01\x20Required.\x20The\x20BigQuery\x20dataset\x20in\
    \x20format\n\x20\"projects/projectId/datasets/datasetId\",\x20to\x20whic\
    h\x20the\x20snapshot\x20result\n\x20should\x20be\x20exported.\x20If\x20t\
    his\x20dataset\x20does\x20not\x20exist,\x20the\x20export\x20call\x20retu\
    rns\n\x20an\x20INVALID_ARGUMENT\x20error.\n\n\r\n\x05\x04\x11\x02\0\x05\
    \x12\x04\x81\x04\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x81\x04\t\
    \x10\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x81\x04\x13\x14\n\r\n\x05\x04\
    \x11\x02\0\x08\x12\x04\x81\x04\x15=\n\x10\n\x08\x04\x11\x02\0\x08\x9c\
    \x08\0\x12\x04\x81\x04\x16<\n\xae\x01\n\x04\x04\x11\x02\x01\x12\x04\x86\
    \x04\x02<\x1a\x9f\x01\x20Required.\x20The\x20BigQuery\x20table\x20to\x20\
    which\x20the\x20snapshot\x20result\x20should\x20be\n\x20written.\x20If\
    \x20this\x20table\x20does\x20not\x20exist,\x20a\x20new\x20table\x20with\
    \x20the\x20given\x20name\n\x20will\x20be\x20created.\n\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\x86\x04\x02\x08\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\x86\x04\t\x0e\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x86\x04\x11\x12\
    \n\r\n\x05\x04\x11\x02\x01\x08\x12\x04\x86\x04\x13;\n\x10\n\x08\x04\x11\
    \x02\x01\x08\x9c\x08\0\x12\x04\x86\x04\x14:\n\x93\x02\n\x04\x04\x11\x02\
    \x02\x12\x04\x8c\x04\x02\x11\x1a\x84\x02\x20If\x20the\x20destination\x20\
    table\x20already\x20exists\x20and\x20this\x20flag\x20is\x20`TRUE`,\x20th\
    e\n\x20table\x20will\x20be\x20overwritten\x20by\x20the\x20contents\x20of\
    \x20assets\x20snapshot.\x20If\x20the\x20flag\n\x20is\x20`FALSE`\x20or\
    \x20unset\x20and\x20the\x20destination\x20table\x20already\x20exists,\
    \x20the\x20export\n\x20call\x20returns\x20an\x20INVALID_ARGUMEMT\x20erro\
    r.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\x8c\x04\x02\x06\n\r\n\x05\x04\
    \x11\x02\x02\x01\x12\x04\x8c\x04\x07\x0c\n\r\n\x05\x04\x11\x02\x02\x03\
    \x12\x04\x8c\x04\x0f\x10\n\xf6\x07\n\x04\x04\x11\x02\x03\x12\x04\x9f\x04\
    \x02#\x1a\xe7\x07\x20[partition_spec]\x20determines\x20whether\x20to\x20\
    export\x20to\x20partitioned\x20table(s)\x20and\n\x20how\x20to\x20partiti\
    on\x20the\x20data.\n\n\x20If\x20[partition_spec]\x20is\x20unset\x20or\
    \x20[partition_spec.partition_key]\x20is\x20unset\x20or\n\x20`PARTITION_\
    KEY_UNSPECIFIED`,\x20the\x20snapshot\x20results\x20will\x20be\x20exporte\
    d\x20to\n\x20non-partitioned\x20table(s).\x20[force]\x20will\x20decide\
    \x20whether\x20to\x20overwrite\x20existing\n\x20table(s).\n\n\x20If\x20[\
    partition_spec]\x20is\x20specified.\x20First,\x20the\x20snapshot\x20resu\
    lts\x20will\x20be\n\x20written\x20to\x20partitioned\x20table(s)\x20with\
    \x20two\x20additional\x20timestamp\x20columns,\n\x20readTime\x20and\x20r\
    equestTime,\x20one\x20of\x20which\x20will\x20be\x20the\x20partition\x20k\
    ey.\x20Secondly,\n\x20in\x20the\x20case\x20when\x20any\x20destination\
    \x20table\x20already\x20exists,\x20it\x20will\x20first\x20try\x20to\n\
    \x20update\x20existing\x20table's\x20schema\x20as\x20necessary\x20by\x20\
    appending\x20additional\n\x20columns.\x20Then,\x20if\x20[force]\x20is\
    \x20`TRUE`,\x20the\x20corresponding\x20partition\x20will\x20be\n\x20over\
    written\x20by\x20the\x20snapshot\x20results\x20(data\x20in\x20different\
    \x20partitions\x20will\n\x20remain\x20intact);\x20if\x20[force]\x20is\
    \x20unset\x20or\x20`FALSE`,\x20it\x20will\x20append\x20the\x20data.\x20A\
    n\n\x20error\x20will\x20be\x20returned\x20if\x20the\x20schema\x20update\
    \x20or\x20data\x20appension\x20fails.\n\n\r\n\x05\x04\x11\x02\x03\x06\
    \x12\x04\x9f\x04\x02\x0f\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\x9f\x04\
    \x10\x1e\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\x9f\x04!\"\n\xcd\x0c\n\
    \x04\x04\x11\x02\x04\x12\x04\xbc\x04\x02*\x1a\xbe\x0c\x20If\x20this\x20f\
    lag\x20is\x20`TRUE`,\x20the\x20snapshot\x20results\x20will\x20be\x20writ\
    ten\x20to\x20one\x20or\n\x20multiple\x20tables,\x20each\x20of\x20which\
    \x20contains\x20results\x20of\x20one\x20asset\x20type.\x20The\n\x20[forc\
    e]\x20and\x20[partition_spec]\x20fields\x20will\x20apply\x20to\x20each\
    \x20of\x20them.\n\n\x20Field\x20[table]\x20will\x20be\x20concatenated\
    \x20with\x20\"_\"\x20and\x20the\x20asset\x20type\x20names\x20(see\n\x20h\
    ttps://cloud.google.com/asset-inventory/docs/supported-asset-types\x20fo\
    r\n\x20supported\x20asset\x20types)\x20to\x20construct\x20per-asset-type\
    \x20table\x20names,\x20in\x20which\n\x20all\x20non-alphanumeric\x20chara\
    cters\x20like\x20\".\"\x20and\x20\"/\"\x20will\x20be\x20substituted\x20b\
    y\n\x20\"_\".\x20Example:\x20if\x20field\x20[table]\x20is\x20\"mytable\"\
    \x20and\x20snapshot\x20results\n\x20contain\x20\"storage.googleapis.com/\
    Bucket\"\x20assets,\x20the\x20corresponding\x20table\n\x20name\x20will\
    \x20be\x20\"mytable_storage_googleapis_com_Bucket\".\x20If\x20any\x20of\
    \x20these\n\x20tables\x20does\x20not\x20exist,\x20a\x20new\x20table\x20w\
    ith\x20the\x20concatenated\x20name\x20will\x20be\n\x20created.\n\n\x20Wh\
    en\x20[content_type]\x20in\x20the\x20ExportAssetsRequest\x20is\x20`RESOU\
    RCE`,\x20the\x20schema\x20of\n\x20each\x20table\x20will\x20include\x20RE\
    CORD-type\x20columns\x20mapped\x20to\x20the\x20nested\x20fields\x20in\n\
    \x20the\x20Asset.resource.data\x20field\x20of\x20that\x20asset\x20type\
    \x20(up\x20to\x20the\x2015\x20nested\x20level\n\x20BigQuery\x20supports\
    \n\x20(https://cloud.google.com/bigquery/docs/nested-repeated#limitation\
    s)).\x20The\n\x20fields\x20in\x20>15\x20nested\x20levels\x20will\x20be\
    \x20stored\x20in\x20JSON\x20format\x20string\x20as\x20a\x20child\n\x20co\
    lumn\x20of\x20its\x20parent\x20RECORD\x20column.\n\n\x20If\x20error\x20o\
    ccurs\x20when\x20exporting\x20to\x20any\x20table,\x20the\x20whole\x20exp\
    ort\x20call\x20will\n\x20return\x20an\x20error\x20but\x20the\x20export\
    \x20results\x20that\x20already\x20succeed\x20will\x20persist.\n\x20Examp\
    le:\x20if\x20exporting\x20to\x20table_type_A\x20succeeds\x20when\x20expo\
    rting\x20to\n\x20table_type_B\x20fails\x20during\x20one\x20export\x20cal\
    l,\x20the\x20results\x20in\x20table_type_A\x20will\n\x20persist\x20and\
    \x20there\x20will\x20not\x20be\x20partial\x20results\x20persisting\x20in\
    \x20a\x20table.\n\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xbc\x04\x02\x06\
    \n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xbc\x04\x07%\n\r\n\x05\x04\x11\
    \x02\x04\x03\x12\x04\xbc\x04()\nS\n\x02\x04\x12\x12\x06\xc0\x04\0\xda\
    \x04\x01\x1aE\x20Specifications\x20of\x20BigQuery\x20partitioned\x20tabl\
    e\x20as\x20export\x20destination.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xc0\
    \x04\x08\x15\n\xed\x02\n\x04\x04\x12\x04\0\x12\x06\xc6\x04\x02\xd6\x04\
    \x03\x1a\xdc\x02\x20This\x20enum\x20is\x20used\x20to\x20determine\x20the\
    \x20partition\x20key\x20column\x20when\x20exporting\n\x20assets\x20to\
    \x20BigQuery\x20partitioned\x20table(s).\x20Note\x20that,\x20if\x20the\
    \x20partition\x20key\x20is\n\x20a\x20timestamp\x20column,\x20the\x20actu\
    al\x20partition\x20is\x20based\x20on\x20its\x20date\x20value\n\x20(expre\
    ssed\x20in\x20UTC.\x20see\x20details\x20in\n\x20https://cloud.google.com\
    /bigquery/docs/partitioned-tables#date_timestamp_partitioned_tables).\n\
    \n\r\n\x05\x04\x12\x04\0\x01\x12\x04\xc6\x04\x07\x13\n[\n\x06\x04\x12\
    \x04\0\x02\0\x12\x04\xc8\x04\x04\"\x1aK\x20Unspecified\x20partition\x20k\
    ey.\x20If\x20used,\x20it\x20means\x20using\x20non-partitioned\x20table.\
    \n\n\x0f\n\x07\x04\x12\x04\0\x02\0\x01\x12\x04\xc8\x04\x04\x1d\n\x0f\n\
    \x07\x04\x12\x04\0\x02\0\x02\x12\x04\xc8\x04\x20!\n\xe3\x02\n\x06\x04\
    \x12\x04\0\x02\x01\x12\x04\xcf\x04\x04\x12\x1a\xd2\x02\x20The\x20time\
    \x20when\x20the\x20snapshot\x20is\x20taken.\x20If\x20specified\x20as\x20\
    partition\x20key,\x20the\n\x20result\x20table(s)\x20is\x20partitoned\x20\
    by\x20the\x20additional\x20timestamp\x20column,\n\x20readTime.\x20If\x20\
    [read_time]\x20in\x20ExportAssetsRequest\x20is\x20specified,\x20the\n\
    \x20readTime\x20column's\x20value\x20will\x20be\x20the\x20same\x20as\x20\
    it.\x20Otherwise,\x20its\x20value\x20will\n\x20be\x20the\x20current\x20t\
    ime\x20that\x20is\x20used\x20to\x20take\x20the\x20snapshot.\n\n\x0f\n\
    \x07\x04\x12\x04\0\x02\x01\x01\x12\x04\xcf\x04\x04\r\n\x0f\n\x07\x04\x12\
    \x04\0\x02\x01\x02\x12\x04\xcf\x04\x10\x11\n\xff\x01\n\x06\x04\x12\x04\0\
    \x02\x02\x12\x04\xd5\x04\x04\x15\x1a\xee\x01\x20The\x20time\x20when\x20t\
    he\x20request\x20is\x20received\x20and\x20started\x20to\x20be\x20process\
    ed.\x20If\n\x20specified\x20as\x20partition\x20key,\x20the\x20result\x20\
    table(s)\x20is\x20partitoned\x20by\x20the\n\x20requestTime\x20column,\
    \x20an\x20additional\x20timestamp\x20column\x20representing\x20when\x20t\
    he\n\x20request\x20was\x20received.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x02\
    \x01\x12\x04\xd5\x04\x04\x10\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x02\x12\
    \x04\xd5\x04\x13\x14\nA\n\x04\x04\x12\x02\0\x12\x04\xd9\x04\x02!\x1a3\
    \x20The\x20partition\x20key\x20for\x20BigQuery\x20partitioned\x20table.\
    \n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xd9\x04\x02\x0e\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\xd9\x04\x0f\x1c\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \xd9\x04\x1f\x20\n&\n\x02\x04\x13\x12\x06\xdd\x04\0\xe1\x04\x01\x1a\x18\
    \x20A\x20Pub/Sub\x20destination.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xdd\
    \x04\x08\x19\nm\n\x04\x04\x13\x02\0\x12\x04\xe0\x04\x02\x13\x1a_\x20The\
    \x20name\x20of\x20the\x20Pub/Sub\x20topic\x20to\x20publish\x20to.\n\x20E\
    xample:\x20`projects/PROJECT_ID/topics/TOPIC_ID`.\n\n\r\n\x05\x04\x13\
    \x02\0\x05\x12\x04\xe0\x04\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \xe0\x04\t\x0e\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xe0\x04\x11\x12\n@\n\
    \x02\x04\x14\x12\x06\xe4\x04\0\xea\x04\x01\x1a2\x20Output\x20configurati\
    on\x20for\x20asset\x20feed\x20destination.\n\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\xe4\x04\x08\x18\n)\n\x04\x04\x14\x08\0\x12\x06\xe6\x04\x02\xe9\x04\
    \x03\x1a\x19\x20Asset\x20feed\x20destination.\n\n\r\n\x05\x04\x14\x08\0\
    \x01\x12\x04\xe6\x04\x08\x13\n'\n\x04\x04\x14\x02\0\x12\x04\xe8\x04\x04-\
    \x1a\x19\x20Destination\x20on\x20Pub/Sub.\n\n\r\n\x05\x04\x14\x02\0\x06\
    \x12\x04\xe8\x04\x04\x15\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xe8\x04\x16\
    (\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xe8\x04+,\n\x81\x02\n\x02\x04\x15\
    \x12\x06\xf1\x04\0\xac\x05\x01\x1a\xf2\x01\x20An\x20asset\x20feed\x20use\
    d\x20to\x20export\x20asset\x20updates\x20to\x20a\x20destinations.\n\x20A\
    n\x20asset\x20feed\x20filter\x20controls\x20what\x20updates\x20are\x20ex\
    ported.\n\x20The\x20asset\x20feed\x20must\x20be\x20created\x20within\x20\
    a\x20project,\x20organization,\x20or\n\x20folder.\x20Supported\x20destin\
    ations\x20are:\n\x20Pub/Sub\x20topics.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\
    \xf1\x04\x08\x0c\n\r\n\x03\x04\x15\x07\x12\x06\xf2\x04\x02\xf8\x04\x04\n\
    \x0f\n\x05\x04\x15\x07\x9d\x08\x12\x06\xf2\x04\x02\xf8\x04\x04\n\xe9\x02\
    \n\x04\x04\x15\x02\0\x12\x04\x81\x05\x02;\x1a\xda\x02\x20Required.\x20Th\
    e\x20format\x20will\x20be\n\x20projects/{project_number}/feeds/{client-a\
    ssigned_feed_identifier}\x20or\n\x20folders/{folder_number}/feeds/{clien\
    t-assigned_feed_identifier}\x20or\n\x20organizations/{organization_numbe\
    r}/feeds/{client-assigned_feed_identifier}\n\n\x20The\x20client-assigned\
    \x20feed\x20identifier\x20must\x20be\x20unique\x20within\x20the\x20paren\
    t\n\x20project/folder/organization.\n\n\r\n\x05\x04\x15\x02\0\x05\x12\
    \x04\x81\x05\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x81\x05\t\r\n\r\
    \n\x05\x04\x15\x02\0\x03\x12\x04\x81\x05\x10\x11\n\r\n\x05\x04\x15\x02\0\
    \x08\x12\x04\x81\x05\x12:\n\x10\n\x08\x04\x15\x02\0\x08\x9c\x08\0\x12\
    \x04\x81\x05\x139\n\xb6\x03\n\x04\x04\x15\x02\x01\x12\x04\x8b\x05\x02\"\
    \x1a\xa7\x03\x20A\x20list\x20of\x20the\x20full\x20names\x20of\x20the\x20\
    assets\x20to\x20receive\x20updates.\x20You\x20must\x20specify\n\x20eithe\
    r\x20or\x20both\x20of\x20asset_names\x20and\x20asset_types.\x20Only\x20a\
    sset\x20updates\x20matching\n\x20specified\x20asset_names\x20or\x20asset\
    _types\x20are\x20exported\x20to\x20the\x20feed.\n\x20Example:\n\x20`//co\
    mpute.googleapis.com/projects/my_project_123/zones/zone1/instances/insta\
    nce1`.\n\x20See\x20[Resource\n\x20Names](https://cloud.google.com/apis/d\
    esign/resource_names#full_resource_name)\n\x20for\x20more\x20info.\n\n\r\
    \n\x05\x04\x15\x02\x01\x04\x12\x04\x8b\x05\x02\n\n\r\n\x05\x04\x15\x02\
    \x01\x05\x12\x04\x8b\x05\x0b\x11\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \x8b\x05\x12\x1d\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x8b\x05\x20!\n\
    \x8c\x03\n\x04\x04\x15\x02\x02\x12\x04\x95\x05\x02\"\x1a\xfd\x02\x20A\
    \x20list\x20of\x20types\x20of\x20the\x20assets\x20to\x20receive\x20updat\
    es.\x20You\x20must\x20specify\x20either\n\x20or\x20both\x20of\x20asset_n\
    ames\x20and\x20asset_types.\x20Only\x20asset\x20updates\x20matching\n\
    \x20specified\x20asset_names\x20or\x20asset_types\x20are\x20exported\x20\
    to\x20the\x20feed.\n\x20Example:\x20`\"compute.googleapis.com/Disk\"`\n\
    \n\x20See\x20[this\n\x20topic](https://cloud.google.com/asset-inventory/\
    docs/supported-asset-types)\n\x20for\x20a\x20list\x20of\x20all\x20suppor\
    ted\x20asset\x20types.\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\x95\x05\
    \x02\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x95\x05\x0b\x11\n\r\n\x05\
    \x04\x15\x02\x02\x01\x12\x04\x95\x05\x12\x1d\n\r\n\x05\x04\x15\x02\x02\
    \x03\x12\x04\x95\x05\x20!\no\n\x04\x04\x15\x02\x03\x12\x04\x99\x05\x02\
    \x1f\x1aa\x20Asset\x20content\x20type.\x20If\x20not\x20specified,\x20no\
    \x20content\x20but\x20the\x20asset\x20name\x20and\n\x20type\x20will\x20b\
    e\x20returned.\n\n\r\n\x05\x04\x15\x02\x03\x06\x12\x04\x99\x05\x02\r\n\r\
    \n\x05\x04\x15\x02\x03\x01\x12\x04\x99\x05\x0e\x1a\n\r\n\x05\x04\x15\x02\
    \x03\x03\x12\x04\x99\x05\x1d\x1e\ng\n\x04\x04\x15\x02\x04\x12\x04\x9d\
    \x05\x02S\x1aY\x20Required.\x20Feed\x20output\x20configuration\x20defini\
    ng\x20where\x20the\x20asset\x20updates\x20are\n\x20published\x20to.\n\n\
    \r\n\x05\x04\x15\x02\x04\x06\x12\x04\x9d\x05\x02\x12\n\r\n\x05\x04\x15\
    \x02\x04\x01\x12\x04\x9d\x05\x13%\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\
    \x9d\x05()\n\r\n\x05\x04\x15\x02\x04\x08\x12\x04\x9d\x05*R\n\x10\n\x08\
    \x04\x15\x02\x04\x08\x9c\x08\0\x12\x04\x9d\x05+Q\n\xeb\x04\n\x04\x04\x15\
    \x02\x05\x12\x04\xab\x05\x02!\x1a\xdc\x04\x20A\x20condition\x20which\x20\
    determines\x20whether\x20an\x20asset\x20update\x20should\x20be\x20publis\
    hed.\n\x20If\x20specified,\x20an\x20asset\x20will\x20be\x20returned\x20o\
    nly\x20when\x20the\x20expression\x20evaluates\n\x20to\x20true.\n\x20When\
    \x20set,\x20`expression`\x20field\x20in\x20the\x20`Expr`\x20must\x20be\
    \x20a\x20valid\x20[CEL\x20expression]\n\x20(https://github.com/google/ce\
    l-spec)\x20on\x20a\x20TemporalAsset\x20with\x20name\n\x20`temporal_asset\
    `.\x20Example:\x20a\x20Feed\x20with\x20expression\x20(\"temporal_asset.d\
    eleted\n\x20==\x20true\")\x20will\x20only\x20publish\x20Asset\x20deletio\
    ns.\x20Other\x20fields\x20of\x20`Expr`\x20are\n\x20optional.\n\n\x20See\
    \x20our\x20[user\n\x20guide](https://cloud.google.com/asset-inventory/do\
    cs/monitoring-asset-changes-with-condition)\n\x20for\x20detailed\x20inst\
    ructions.\n\n\r\n\x05\x04\x15\x02\x05\x06\x12\x04\xab\x05\x02\x12\n\r\n\
    \x05\x04\x15\x02\x05\x01\x12\x04\xab\x05\x13\x1c\n\r\n\x05\x04\x15\x02\
    \x05\x03\x12\x04\xab\x05\x1f\x20\n-\n\x02\x04\x16\x12\x06\xaf\x05\0\xb8\
    \x06\x01\x1a\x1f\x20Search\x20all\x20resources\x20request.\n\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xaf\x05\x08!\n\xcf\x04\n\x04\x04\x16\x02\0\x12\x04\
    \xbb\x05\x02<\x1a\xc0\x04\x20Required.\x20A\x20scope\x20can\x20be\x20a\
    \x20project,\x20a\x20folder,\x20or\x20an\x20organization.\x20The\x20sear\
    ch\x20is\n\x20limited\x20to\x20the\x20resources\x20within\x20the\x20`sco\
    pe`.\x20The\x20caller\x20must\x20be\x20granted\x20the\n\x20[`cloudasset.\
    assets.searchAllResources`](https://cloud.google.com/asset-inventory/doc\
    s/access-control#required_permissions)\n\x20permission\x20on\x20the\x20d\
    esired\x20scope.\n\n\x20The\x20allowed\x20values\x20are:\n\n\x20*\x20pro\
    jects/{PROJECT_ID}\x20(e.g.,\x20\"projects/foo-bar\")\n\x20*\x20projects\
    /{PROJECT_NUMBER}\x20(e.g.,\x20\"projects/12345678\")\n\x20*\x20folders/\
    {FOLDER_NUMBER}\x20(e.g.,\x20\"folders/1234567\")\n\x20*\x20organization\
    s/{ORGANIZATION_NUMBER}\x20(e.g.,\x20\"organizations/123456\")\n\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\xbb\x05\x02\x08\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xbb\x05\t\x0e\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xbb\x05\
    \x11\x12\n\r\n\x05\x04\x16\x02\0\x08\x12\x04\xbb\x05\x13;\n\x10\n\x08\
    \x04\x16\x02\0\x08\x9c\x08\0\x12\x04\xbb\x05\x14:\n\xa3\x10\n\x04\x04\
    \x16\x02\x01\x12\x04\xe5\x05\x02<\x1a\x94\x10\x20Optional.\x20The\x20que\
    ry\x20statement.\x20See\x20[how\x20to\x20construct\x20a\n\x20query](http\
    s://cloud.google.com/asset-inventory/docs/searching-resources#how_to_con\
    struct_a_query)\n\x20for\x20more\x20information.\x20If\x20not\x20specifi\
    ed\x20or\x20empty,\x20it\x20will\x20search\x20all\x20the\n\x20resources\
    \x20within\x20the\x20specified\x20`scope`.\n\n\x20Examples:\n\n\x20*\x20\
    `name:Important`\x20to\x20find\x20Cloud\x20resources\x20whose\x20name\
    \x20contains\n\x20\x20\x20\"Important\"\x20as\x20a\x20word.\n\x20*\x20`n\
    ame=Important`\x20to\x20find\x20the\x20Cloud\x20resource\x20whose\x20nam\
    e\x20is\x20exactly\n\x20\x20\x20\"Important\".\n\x20*\x20`displayName:Im\
    por*`\x20to\x20find\x20Cloud\x20resources\x20whose\x20display\x20name\n\
    \x20\x20\x20contains\x20\"Impor\"\x20as\x20a\x20prefix\x20of\x20any\x20w\
    ord\x20in\x20the\x20field.\n\x20*\x20`location:us-west*`\x20to\x20find\
    \x20Cloud\x20resources\x20whose\x20location\x20contains\x20both\n\x20\
    \x20\x20\"us\"\x20and\x20\"west\"\x20as\x20prefixes.\n\x20*\x20`labels:p\
    rod`\x20to\x20find\x20Cloud\x20resources\x20whose\x20labels\x20contain\
    \x20\"prod\"\x20as\n\x20\x20\x20a\x20key\x20or\x20value.\n\x20*\x20`labe\
    ls.env:prod`\x20to\x20find\x20Cloud\x20resources\x20that\x20have\x20a\
    \x20label\x20\"env\"\n\x20\x20\x20and\x20its\x20value\x20is\x20\"prod\".\
    \n\x20*\x20`labels.env:*`\x20to\x20find\x20Cloud\x20resources\x20that\
    \x20have\x20a\x20label\x20\"env\".\n\x20*\x20`kmsKey:key`\x20to\x20find\
    \x20Cloud\x20resources\x20encrypted\x20with\x20a\x20customer-managed\n\
    \x20\x20\x20encryption\x20key\x20whose\x20name\x20contains\x20the\x20wor\
    d\x20\"key\".\n\x20*\x20`state:ACTIVE`\x20to\x20find\x20Cloud\x20resourc\
    es\x20whose\x20state\x20contains\x20\"ACTIVE\"\x20as\x20a\n\x20\x20\x20w\
    ord.\n\x20*\x20`NOT\x20state:ACTIVE`\x20to\x20find\x20Cloud\x20resources\
    \x20whose\x20state\x20doesn't\x20contain\n\x20\x20\x20\"ACTIVE\"\x20as\
    \x20a\x20word.\n\x20*\x20`createTime<1609459200`\x20to\x20find\x20Cloud\
    \x20resources\x20that\x20were\x20created\x20before\n\x20\x20\x20\"2021-0\
    1-01\x2000:00:00\x20UTC\".\x201609459200\x20is\x20the\x20epoch\x20timest\
    amp\x20of\n\x20\x20\x20\"2021-01-01\x2000:00:00\x20UTC\"\x20in\x20second\
    s.\n\x20*\x20`updateTime>1609459200`\x20to\x20find\x20Cloud\x20resources\
    \x20that\x20were\x20updated\x20after\n\x20\x20\x20\"2021-01-01\x2000:00:\
    00\x20UTC\".\x201609459200\x20is\x20the\x20epoch\x20timestamp\x20of\n\
    \x20\x20\x20\"2021-01-01\x2000:00:00\x20UTC\"\x20in\x20seconds.\n\x20*\
    \x20`Important`\x20to\x20find\x20Cloud\x20resources\x20that\x20contain\
    \x20\"Important\"\x20as\x20a\x20word\n\x20\x20\x20in\x20any\x20of\x20the\
    \x20searchable\x20fields.\n\x20*\x20`Impor*`\x20to\x20find\x20Cloud\x20r\
    esources\x20that\x20contain\x20\"Impor\"\x20as\x20a\x20prefix\x20of\x20a\
    ny\n\x20\x20\x20word\x20in\x20any\x20of\x20the\x20searchable\x20fields.\
    \n\x20*\x20`Important\x20location:(us-west1\x20OR\x20global)`\x20to\x20f\
    ind\x20Cloud\n\x20\x20\x20resources\x20that\x20contain\x20\"Important\"\
    \x20as\x20a\x20word\x20in\x20any\x20of\x20the\x20searchable\n\x20\x20\
    \x20fields\x20and\x20are\x20also\x20located\x20in\x20the\x20\"us-west1\"\
    \x20region\x20or\x20the\x20\"global\"\n\x20\x20\x20location.\n\n\r\n\x05\
    \x04\x16\x02\x01\x05\x12\x04\xe5\x05\x02\x08\n\r\n\x05\x04\x16\x02\x01\
    \x01\x12\x04\xe5\x05\t\x0e\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xe5\x05\
    \x11\x12\n\r\n\x05\x04\x16\x02\x01\x08\x12\x04\xe5\x05\x13;\n\x10\n\x08\
    \x04\x16\x02\x01\x08\x9c\x08\0\x12\x04\xe5\x05\x14:\n\xf7\x05\n\x04\x04\
    \x16\x02\x02\x12\x04\xf5\x05\x02K\x1a\xe8\x05\x20Optional.\x20A\x20list\
    \x20of\x20asset\x20types\x20that\x20this\x20request\x20searches\x20for.\
    \x20If\x20empty,\x20it\x20will\n\x20search\x20all\x20the\x20[searchable\
    \x20asset\n\x20types](https://cloud.google.com/asset-inventory/docs/supp\
    orted-asset-types#searchable_asset_types).\n\n\x20Regular\x20expressions\
    \x20are\x20also\x20supported.\x20For\x20example:\n\n\x20*\x20\"compute.g\
    oogleapis.com.*\"\x20snapshots\x20resources\x20whose\x20asset\x20type\
    \x20starts\n\x20with\x20\"compute.googleapis.com\".\n\x20*\x20\".*Instan\
    ce\"\x20snapshots\x20resources\x20whose\x20asset\x20type\x20ends\x20with\
    \x20\"Instance\".\n\x20*\x20\".*Instance.*\"\x20snapshots\x20resources\
    \x20whose\x20asset\x20type\x20contains\x20\"Instance\".\n\n\x20See\x20[R\
    E2](https://github.com/google/re2/wiki/Syntax)\x20for\x20all\x20supporte\
    d\n\x20regular\x20expression\x20syntax.\x20If\x20the\x20regular\x20expre\
    ssion\x20does\x20not\x20match\x20any\n\x20supported\x20asset\x20type,\
    \x20an\x20INVALID_ARGUMENT\x20error\x20will\x20be\x20returned.\n\n\r\n\
    \x05\x04\x16\x02\x02\x04\x12\x04\xf5\x05\x02\n\n\r\n\x05\x04\x16\x02\x02\
    \x05\x12\x04\xf5\x05\x0b\x11\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xf5\
    \x05\x12\x1d\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xf5\x05\x20!\n\r\n\
    \x05\x04\x16\x02\x02\x08\x12\x04\xf5\x05\"J\n\x10\n\x08\x04\x16\x02\x02\
    \x08\x9c\x08\0\x12\x04\xf5\x05#I\n\xc5\x02\n\x04\x04\x16\x02\x03\x12\x04\
    \xfb\x05\x02?\x1a\xb6\x02\x20Optional.\x20The\x20page\x20size\x20for\x20\
    search\x20result\x20pagination.\x20Page\x20size\x20is\x20capped\x20at\
    \x20500\x20even\n\x20if\x20a\x20larger\x20value\x20is\x20given.\x20If\
    \x20set\x20to\x20zero,\x20server\x20will\x20pick\x20an\x20appropriate\n\
    \x20default.\x20Returned\x20results\x20may\x20be\x20fewer\x20than\x20req\
    uested.\x20When\x20this\x20happens,\n\x20there\x20could\x20be\x20more\
    \x20results\x20as\x20long\x20as\x20`next_page_token`\x20is\x20returned.\
    \n\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\xfb\x05\x02\x07\n\r\n\x05\x04\
    \x16\x02\x03\x01\x12\x04\xfb\x05\x08\x11\n\r\n\x05\x04\x16\x02\x03\x03\
    \x12\x04\xfb\x05\x14\x15\n\r\n\x05\x04\x16\x02\x03\x08\x12\x04\xfb\x05\
    \x16>\n\x10\n\x08\x04\x16\x02\x03\x08\x9c\x08\0\x12\x04\xfb\x05\x17=\n\
    \xa5\x02\n\x04\x04\x16\x02\x04\x12\x04\x81\x06\x02A\x1a\x96\x02\x20Optio\
    nal.\x20If\x20present,\x20then\x20retrieve\x20the\x20next\x20batch\x20of\
    \x20results\x20from\x20the\x20preceding\x20call\n\x20to\x20this\x20metho\
    d.\x20`page_token`\x20must\x20be\x20the\x20value\x20of\x20`next_page_tok\
    en`\x20from\n\x20the\x20previous\x20response.\x20The\x20values\x20of\x20\
    all\x20other\x20method\x20parameters,\x20must\x20be\n\x20identical\x20to\
    \x20those\x20in\x20the\x20previous\x20call.\n\n\r\n\x05\x04\x16\x02\x04\
    \x05\x12\x04\x81\x06\x02\x08\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\x81\
    \x06\t\x13\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\x81\x06\x16\x17\n\r\n\
    \x05\x04\x16\x02\x04\x08\x12\x04\x81\x06\x18@\n\x10\n\x08\x04\x16\x02\
    \x04\x08\x9c\x08\0\x12\x04\x81\x06\x19?\n\xb7\x05\n\x04\x04\x16\x02\x05\
    \x12\x04\x99\x06\x02?\x1a\xa8\x05\x20Optional.\x20A\x20comma-separated\
    \x20list\x20of\x20fields\x20specifying\x20the\x20sorting\x20order\x20of\
    \x20the\n\x20results.\x20The\x20default\x20order\x20is\x20ascending.\x20\
    Add\x20\"\x20DESC\"\x20after\x20the\x20field\x20name\n\x20to\x20indicate\
    \x20descending\x20order.\x20Redundant\x20space\x20characters\x20are\x20i\
    gnored.\n\x20Example:\x20\"location\x20DESC,\x20name\".\n\x20Only\x20sin\
    gular\x20primitive\x20fields\x20in\x20the\x20response\x20are\x20sortable\
    :\n\n\x20\x20\x20*\x20name\n\x20\x20\x20*\x20assetType\n\x20\x20\x20*\
    \x20project\n\x20\x20\x20*\x20displayName\n\x20\x20\x20*\x20description\
    \n\x20\x20\x20*\x20location\n\x20\x20\x20*\x20kmsKey\n\x20\x20\x20*\x20c\
    reateTime\n\x20\x20\x20*\x20updateTime\n\x20\x20\x20*\x20state\n\x20\x20\
    \x20*\x20parentFullResourceName\n\x20\x20\x20*\x20parentAssetType\n\n\
    \x20All\x20the\x20other\x20fields\x20such\x20as\x20repeated\x20fields\
    \x20(e.g.,\x20`networkTags`),\x20map\n\x20fields\x20(e.g.,\x20`labels`)\
    \x20and\x20struct\x20fields\x20(e.g.,\x20`additionalAttributes`)\n\x20ar\
    e\x20not\x20supported.\n\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\x99\x06\
    \x02\x08\n\r\n\x05\x04\x16\x02\x05\x01\x12\x04\x99\x06\t\x11\n\r\n\x05\
    \x04\x16\x02\x05\x03\x12\x04\x99\x06\x14\x15\n\r\n\x05\x04\x16\x02\x05\
    \x08\x12\x04\x99\x06\x16>\n\x10\n\x08\x04\x16\x02\x05\x08\x9c\x08\0\x12\
    \x04\x99\x06\x17=\n\xfc\x06\n\x04\x04\x16\x02\x06\x12\x04\xb7\x06\x02S\
    \x1a\xed\x06\x20Optional.\x20A\x20comma-separated\x20list\x20of\x20field\
    s\x20specifying\x20which\x20fields\x20to\x20be\x20returned\x20in\n\x20Re\
    sourceSearchResult.\x20Only\x20'*'\x20or\x20combination\x20of\x20top\x20\
    level\x20fields\x20can\x20be\n\x20specified.\x20Field\x20names\x20of\x20\
    both\x20snake_case\x20and\x20camelCase\x20are\x20supported.\n\x20Example\
    s:\x20`\"*\"`,\x20`\"name,location\"`,\x20`\"name,versionedResources\"`.\
    \n\n\x20The\x20read_mask\x20paths\x20must\x20be\x20valid\x20field\x20pat\
    hs\x20listed\x20but\x20not\x20limited\x20to\n\x20(both\x20snake_case\x20\
    and\x20camelCase\x20are\x20supported):\n\n\x20\x20\x20*\x20name\n\x20\
    \x20\x20*\x20assetType\n\x20\x20\x20*\x20project\n\x20\x20\x20*\x20displ\
    ayName\n\x20\x20\x20*\x20description\n\x20\x20\x20*\x20location\n\x20\
    \x20\x20*\x20labels\n\x20\x20\x20*\x20networkTags\n\x20\x20\x20*\x20kmsK\
    ey\n\x20\x20\x20*\x20createTime\n\x20\x20\x20*\x20updateTime\n\x20\x20\
    \x20*\x20state\n\x20\x20\x20*\x20additionalAttributes\n\x20\x20\x20*\x20\
    versionedResources\n\n\x20If\x20read_mask\x20is\x20not\x20specified,\x20\
    all\x20fields\x20except\x20versionedResources\x20will\n\x20be\x20returne\
    d.\n\x20If\x20only\x20'*'\x20is\x20specified,\x20all\x20fields\x20includ\
    ing\x20versionedResources\x20will\x20be\n\x20returned.\n\x20Any\x20inval\
    id\x20field\x20path\x20will\x20trigger\x20INVALID_ARGUMENT\x20error.\n\n\
    \r\n\x05\x04\x16\x02\x06\x06\x12\x04\xb7\x06\x02\x1b\n\r\n\x05\x04\x16\
    \x02\x06\x01\x12\x04\xb7\x06\x1c%\n\r\n\x05\x04\x16\x02\x06\x03\x12\x04\
    \xb7\x06()\n\r\n\x05\x04\x16\x02\x06\x08\x12\x04\xb7\x06*R\n\x10\n\x08\
    \x04\x16\x02\x06\x08\x9c\x08\0\x12\x04\xb7\x06+Q\n.\n\x02\x04\x17\x12\
    \x06\xbb\x06\0\xc4\x06\x01\x1a\x20\x20Search\x20all\x20resources\x20resp\
    onse.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xbb\x06\x08\"\ny\n\x04\x04\x17\
    \x02\0\x12\x04\xbe\x06\x02,\x1ak\x20A\x20list\x20of\x20Resources\x20that\
    \x20match\x20the\x20search\x20query.\x20It\x20contains\x20the\x20resourc\
    e\n\x20standard\x20metadata\x20information.\n\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\xbe\x06\x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xbe\x06\
    \x0b\x1f\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xbe\x06\x20'\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xbe\x06*+\n\xe4\x01\n\x04\x04\x17\x02\x01\x12\x04\
    \xc3\x06\x02\x1d\x1a\xd5\x01\x20If\x20there\x20are\x20more\x20results\
    \x20than\x20those\x20appearing\x20in\x20this\x20response,\x20then\n\x20`\
    next_page_token`\x20is\x20included.\x20To\x20get\x20the\x20next\x20set\
    \x20of\x20results,\x20call\x20this\n\x20method\x20again\x20using\x20the\
    \x20value\x20of\x20`next_page_token`\x20as\x20`page_token`.\n\n\r\n\x05\
    \x04\x17\x02\x01\x05\x12\x04\xc3\x06\x02\x08\n\r\n\x05\x04\x17\x02\x01\
    \x01\x12\x04\xc3\x06\t\x18\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xc3\x06\
    \x1b\x1c\n0\n\x02\x04\x18\x12\x06\xc7\x06\0\xab\x07\x01\x1a\"\x20Search\
    \x20all\x20IAM\x20policies\x20request.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xc7\x06\x08#\n\xd5\x04\n\x04\x04\x18\x02\0\x12\x04\xd4\x06\x02<\x1a\xc6\
    \x04\x20Required.\x20A\x20scope\x20can\x20be\x20a\x20project,\x20a\x20fo\
    lder,\x20or\x20an\x20organization.\x20The\x20search\x20is\n\x20limited\
    \x20to\x20the\x20IAM\x20policies\x20within\x20the\x20`scope`.\x20The\x20\
    caller\x20must\x20be\x20granted\n\x20the\n\x20[`cloudasset.assets.search\
    AllIamPolicies`](https://cloud.google.com/asset-inventory/docs/access-co\
    ntrol#required_permissions)\n\x20permission\x20on\x20the\x20desired\x20s\
    cope.\n\n\x20The\x20allowed\x20values\x20are:\n\n\x20*\x20projects/{PROJ\
    ECT_ID}\x20(e.g.,\x20\"projects/foo-bar\")\n\x20*\x20projects/{PROJECT_N\
    UMBER}\x20(e.g.,\x20\"projects/12345678\")\n\x20*\x20folders/{FOLDER_NUM\
    BER}\x20(e.g.,\x20\"folders/1234567\")\n\x20*\x20organizations/{ORGANIZA\
    TION_NUMBER}\x20(e.g.,\x20\"organizations/123456\")\n\n\r\n\x05\x04\x18\
    \x02\0\x05\x12\x04\xd4\x06\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xd4\x06\t\x0e\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xd4\x06\x11\x12\n\r\n\
    \x05\x04\x18\x02\0\x08\x12\x04\xd4\x06\x13;\n\x10\n\x08\x04\x18\x02\0\
    \x08\x9c\x08\0\x12\x04\xd4\x06\x14:\n\xc6\x12\n\x04\x04\x18\x02\x01\x12\
    \x04\x80\x07\x02<\x1a\xb7\x12\x20Optional.\x20The\x20query\x20statement.\
    \x20See\x20[how\x20to\x20construct\x20a\n\x20query](https://cloud.google\
    .com/asset-inventory/docs/searching-iam-policies#how_to_construct_a_quer\
    y)\n\x20for\x20more\x20information.\x20If\x20not\x20specified\x20or\x20e\
    mpty,\x20it\x20will\x20search\x20all\x20the\n\x20IAM\x20policies\x20with\
    in\x20the\x20specified\x20`scope`.\x20Note\x20that\x20the\x20query\x20st\
    ring\x20is\n\x20compared\x20against\x20each\x20Cloud\x20IAM\x20policy\
    \x20binding,\x20including\x20its\x20members,\n\x20roles,\x20and\x20Cloud\
    \x20IAM\x20conditions.\x20The\x20returned\x20Cloud\x20IAM\x20policies\
    \x20will\x20only\n\x20contain\x20the\x20bindings\x20that\x20match\x20you\
    r\x20query.\x20To\x20learn\x20more\x20about\x20the\x20IAM\n\x20policy\
    \x20structure,\x20see\x20[IAM\x20policy\n\x20doc](https://cloud.google.c\
    om/iam/docs/policies#structure).\n\n\x20Examples:\n\n\x20*\x20`policy:am\
    y@gmail.com`\x20to\x20find\x20IAM\x20policy\x20bindings\x20that\x20speci\
    fy\x20user\n\x20\x20\x20\"amy@gmail.com\".\n\x20*\x20`policy:roles/compu\
    te.admin`\x20to\x20find\x20IAM\x20policy\x20bindings\x20that\x20specify\
    \n\x20\x20\x20the\x20Compute\x20Admin\x20role.\n\x20*\x20`policy:comp*`\
    \x20to\x20find\x20IAM\x20policy\x20bindings\x20that\x20contain\x20\"comp\
    \"\x20as\x20a\n\x20\x20\x20prefix\x20of\x20any\x20word\x20in\x20the\x20b\
    inding.\n\x20*\x20`policy.role.permissions:storage.buckets.update`\x20to\
    \x20find\x20IAM\x20policy\n\x20\x20\x20bindings\x20that\x20specify\x20a\
    \x20role\x20containing\x20\"storage.buckets.update\"\n\x20\x20\x20permis\
    sion.\x20Note\x20that\x20if\x20callers\x20don't\x20have\x20`iam.roles.ge\
    t`\x20access\x20to\x20a\n\x20\x20\x20role's\x20included\x20permissions,\
    \x20policy\x20bindings\x20that\x20specify\x20this\x20role\x20will\n\x20\
    \x20\x20be\x20dropped\x20from\x20the\x20search\x20results.\n\x20*\x20`po\
    licy.role.permissions:upd*`\x20to\x20find\x20IAM\x20policy\x20bindings\
    \x20that\x20specify\x20a\n\x20\x20\x20role\x20containing\x20\"upd\"\x20a\
    s\x20a\x20prefix\x20of\x20any\x20word\x20in\x20the\x20role\x20permission\
    .\n\x20\x20\x20Note\x20that\x20if\x20callers\x20don't\x20have\x20`iam.ro\
    les.get`\x20access\x20to\x20a\x20role's\n\x20\x20\x20included\x20permiss\
    ions,\x20policy\x20bindings\x20that\x20specify\x20this\x20role\x20will\
    \x20be\n\x20\x20\x20dropped\x20from\x20the\x20search\x20results.\n\x20*\
    \x20`resource:organizations/123456`\x20to\x20find\x20IAM\x20policy\x20bi\
    ndings\n\x20\x20\x20that\x20are\x20set\x20on\x20\"organizations/123456\"\
    .\n\x20*\x20`resource=//cloudresourcemanager.googleapis.com/projects/myp\
    roject`\x20to\n\x20\x20\x20find\x20IAM\x20policy\x20bindings\x20that\x20\
    are\x20set\x20on\x20the\x20project\x20named\x20\"myproject\".\n\x20*\x20\
    `Important`\x20to\x20find\x20IAM\x20policy\x20bindings\x20that\x20contai\
    n\x20\"Important\"\x20as\x20a\n\x20\x20\x20word\x20in\x20any\x20of\x20th\
    e\x20searchable\x20fields\x20(except\x20for\x20the\x20included\n\x20\x20\
    \x20permissions).\n\x20*\x20`resource:(instance1\x20OR\x20instance2)\x20\
    policy:amy`\x20to\x20find\n\x20\x20\x20IAM\x20policy\x20bindings\x20that\
    \x20are\x20set\x20on\x20resources\x20\"instance1\"\x20or\n\x20\x20\x20\"\
    instance2\"\x20and\x20also\x20specify\x20user\x20\"amy\".\n\x20*\x20`rol\
    es:roles/compute.admin`\x20to\x20find\x20IAM\x20policy\x20bindings\x20th\
    at\x20specify\x20the\n\x20\x20\x20Compute\x20Admin\x20role.\n\x20*\x20`m\
    emberTypes:user`\x20to\x20find\x20IAM\x20policy\x20bindings\x20that\x20c\
    ontain\x20the\x20\"user\"\n\x20\x20\x20member\x20type.\n\n\r\n\x05\x04\
    \x18\x02\x01\x05\x12\x04\x80\x07\x02\x08\n\r\n\x05\x04\x18\x02\x01\x01\
    \x12\x04\x80\x07\t\x0e\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x80\x07\x11\
    \x12\n\r\n\x05\x04\x18\x02\x01\x08\x12\x04\x80\x07\x13;\n\x10\n\x08\x04\
    \x18\x02\x01\x08\x9c\x08\0\x12\x04\x80\x07\x14:\n\xc5\x02\n\x04\x04\x18\
    \x02\x02\x12\x04\x86\x07\x02?\x1a\xb6\x02\x20Optional.\x20The\x20page\
    \x20size\x20for\x20search\x20result\x20pagination.\x20Page\x20size\x20is\
    \x20capped\x20at\x20500\x20even\n\x20if\x20a\x20larger\x20value\x20is\
    \x20given.\x20If\x20set\x20to\x20zero,\x20server\x20will\x20pick\x20an\
    \x20appropriate\n\x20default.\x20Returned\x20results\x20may\x20be\x20few\
    er\x20than\x20requested.\x20When\x20this\x20happens,\n\x20there\x20could\
    \x20be\x20more\x20results\x20as\x20long\x20as\x20`next_page_token`\x20is\
    \x20returned.\n\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\x86\x07\x02\x07\n\
    \r\n\x05\x04\x18\x02\x02\x01\x12\x04\x86\x07\x08\x11\n\r\n\x05\x04\x18\
    \x02\x02\x03\x12\x04\x86\x07\x14\x15\n\r\n\x05\x04\x18\x02\x02\x08\x12\
    \x04\x86\x07\x16>\n\x10\n\x08\x04\x18\x02\x02\x08\x9c\x08\0\x12\x04\x86\
    \x07\x17=\n\x9f\x02\n\x04\x04\x18\x02\x03\x12\x04\x8c\x07\x02A\x1a\x90\
    \x02\x20Optional.\x20If\x20present,\x20retrieve\x20the\x20next\x20batch\
    \x20of\x20results\x20from\x20the\x20preceding\x20call\x20to\n\x20this\
    \x20method.\x20`page_token`\x20must\x20be\x20the\x20value\x20of\x20`next\
    _page_token`\x20from\x20the\n\x20previous\x20response.\x20The\x20values\
    \x20of\x20all\x20other\x20method\x20parameters\x20must\x20be\n\x20identi\
    cal\x20to\x20those\x20in\x20the\x20previous\x20call.\n\n\r\n\x05\x04\x18\
    \x02\x03\x05\x12\x04\x8c\x07\x02\x08\n\r\n\x05\x04\x18\x02\x03\x01\x12\
    \x04\x8c\x07\t\x13\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\x8c\x07\x16\x17\
    \n\r\n\x05\x04\x18\x02\x03\x08\x12\x04\x8c\x07\x18@\n\x10\n\x08\x04\x18\
    \x02\x03\x08\x9c\x08\0\x12\x04\x8c\x07\x19?\n\xc1\x06\n\x04\x04\x18\x02\
    \x04\x12\x04\x9e\x07\x02K\x1a\xb2\x06\x20Optional.\x20A\x20list\x20of\
    \x20asset\x20types\x20that\x20the\x20IAM\x20policies\x20are\x20attached\
    \x20to.\x20If\x20empty,\x20it\n\x20will\x20search\x20the\x20IAM\x20polic\
    ies\x20that\x20are\x20attached\x20to\x20all\x20the\x20[searchable\x20ass\
    et\n\x20types](https://cloud.google.com/asset-inventory/docs/supported-a\
    sset-types#searchable_asset_types).\n\n\x20Regular\x20expressions\x20are\
    \x20also\x20supported.\x20For\x20example:\n\n\x20*\x20\"compute.googleap\
    is.com.*\"\x20snapshots\x20IAM\x20policies\x20attached\x20to\x20asset\
    \x20type\n\x20starts\x20with\x20\"compute.googleapis.com\".\n\x20*\x20\"\
    .*Instance\"\x20snapshots\x20IAM\x20policies\x20attached\x20to\x20asset\
    \x20type\x20ends\x20with\n\x20\"Instance\".\n\x20*\x20\".*Instance.*\"\
    \x20snapshots\x20IAM\x20policies\x20attached\x20to\x20asset\x20type\x20c\
    ontains\n\x20\"Instance\".\n\n\x20See\x20[RE2](https://github.com/google\
    /re2/wiki/Syntax)\x20for\x20all\x20supported\n\x20regular\x20expression\
    \x20syntax.\x20If\x20the\x20regular\x20expression\x20does\x20not\x20matc\
    h\x20any\n\x20supported\x20asset\x20type,\x20an\x20INVALID_ARGUMENT\x20e\
    rror\x20will\x20be\x20returned.\n\n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\
    \x9e\x07\x02\n\n\r\n\x05\x04\x18\x02\x04\x05\x12\x04\x9e\x07\x0b\x11\n\r\
    \n\x05\x04\x18\x02\x04\x01\x12\x04\x9e\x07\x12\x1d\n\r\n\x05\x04\x18\x02\
    \x04\x03\x12\x04\x9e\x07\x20!\n\r\n\x05\x04\x18\x02\x04\x08\x12\x04\x9e\
    \x07\"J\n\x10\n\x08\x04\x18\x02\x04\x08\x9c\x08\0\x12\x04\x9e\x07#I\n\
    \xfd\x03\n\x04\x04\x18\x02\x05\x12\x04\xaa\x07\x02?\x1a\xee\x03\x20Optio\
    nal.\x20A\x20comma-separated\x20list\x20of\x20fields\x20specifying\x20th\
    e\x20sorting\x20order\x20of\x20the\n\x20results.\x20The\x20default\x20or\
    der\x20is\x20ascending.\x20Add\x20\"\x20DESC\"\x20after\x20the\x20field\
    \x20name\n\x20to\x20indicate\x20descending\x20order.\x20Redundant\x20spa\
    ce\x20characters\x20are\x20ignored.\n\x20Example:\x20\"assetType\x20DESC\
    ,\x20resource\".\n\x20Only\x20singular\x20primitive\x20fields\x20in\x20t\
    he\x20response\x20are\x20sortable:\n\x20\x20\x20*\x20resource\n\x20\x20\
    \x20*\x20assetType\n\x20\x20\x20*\x20project\n\x20All\x20the\x20other\
    \x20fields\x20such\x20as\x20repeated\x20fields\x20(e.g.,\x20`folders`)\
    \x20and\n\x20non-primitive\x20fields\x20(e.g.,\x20`policy`)\x20are\x20no\
    t\x20supported.\n\n\r\n\x05\x04\x18\x02\x05\x05\x12\x04\xaa\x07\x02\x08\
    \n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xaa\x07\t\x11\n\r\n\x05\x04\x18\
    \x02\x05\x03\x12\x04\xaa\x07\x14\x15\n\r\n\x05\x04\x18\x02\x05\x08\x12\
    \x04\xaa\x07\x16>\n\x10\n\x08\x04\x18\x02\x05\x08\x9c\x08\0\x12\x04\xaa\
    \x07\x17=\n1\n\x02\x04\x19\x12\x06\xae\x07\0\xb7\x07\x01\x1a#\x20Search\
    \x20all\x20IAM\x20policies\x20response.\n\n\x0b\n\x03\x04\x19\x01\x12\
    \x04\xae\x07\x08$\n\x99\x01\n\x04\x04\x19\x02\0\x12\x04\xb1\x07\x02-\x1a\
    \x8a\x01\x20A\x20list\x20of\x20IamPolicy\x20that\x20match\x20the\x20sear\
    ch\x20query.\x20Related\x20information\x20such\n\x20as\x20the\x20associa\
    ted\x20resource\x20is\x20returned\x20along\x20with\x20the\x20policy.\n\n\
    \r\n\x05\x04\x19\x02\0\x04\x12\x04\xb1\x07\x02\n\n\r\n\x05\x04\x19\x02\0\
    \x06\x12\x04\xb1\x07\x0b\x20\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xb1\x07\
    !(\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xb1\x07+,\n\xb5\x01\n\x04\x04\x19\
    \x02\x01\x12\x04\xb6\x07\x02\x1d\x1a\xa6\x01\x20Set\x20if\x20there\x20ar\
    e\x20more\x20results\x20than\x20those\x20appearing\x20in\x20this\x20resp\
    onse;\x20to\x20get\n\x20the\x20next\x20set\x20of\x20results,\x20call\x20\
    this\x20method\x20again,\x20using\x20this\x20value\x20as\x20the\n\x20`pa\
    ge_token`.\n\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xb6\x07\x02\x08\n\r\n\
    \x05\x04\x19\x02\x01\x01\x12\x04\xb6\x07\t\x18\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\xb6\x07\x1b\x1c\n5\n\x02\x04\x1a\x12\x06\xba\x07\0\xde\x08\
    \x01\x1a'\x20##\x20IAM\x20policy\x20analysis\x20query\x20message.\n\n\
    \x0b\n\x03\x04\x1a\x01\x12\x04\xba\x07\x08\x1e\n\xb2\x01\n\x04\x04\x1a\
    \x03\0\x12\x06\xbe\x07\x02\xc4\x07\x03\x1a\xa1\x01\x20Specifies\x20the\
    \x20resource\x20to\x20analyze\x20for\x20access\x20policies,\x20which\x20\
    may\x20be\x20set\n\x20directly\x20on\x20the\x20resource,\x20or\x20on\x20\
    ancestors\x20such\x20as\x20organizations,\x20folders\x20or\n\x20projects\
    .\n\n\r\n\x05\x04\x1a\x03\0\x01\x12\x04\xbe\x07\n\x1a\n\x86\x02\n\x06\
    \x04\x1a\x03\0\x02\0\x12\x04\xc3\x07\x04K\x1a\xf5\x01\x20Required.\x20Th\
    e\x20[full\x20resource\x20name]\n\x20(https://cloud.google.com/asset-inv\
    entory/docs/resource-name-format)\n\x20of\x20a\x20resource\x20of\x20[sup\
    ported\x20resource\n\x20types](https://cloud.google.com/asset-inventory/\
    docs/supported-asset-types#analyzable_asset_types).\n\n\x0f\n\x07\x04\
    \x1a\x03\0\x02\0\x05\x12\x04\xc3\x07\x04\n\n\x0f\n\x07\x04\x1a\x03\0\x02\
    \0\x01\x12\x04\xc3\x07\x0b\x1d\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x03\x12\
    \x04\xc3\x07\x20!\n\x0f\n\x07\x04\x1a\x03\0\x02\0\x08\x12\x04\xc3\x07\"J\
    \n\x12\n\n\x04\x1a\x03\0\x02\0\x08\x9c\x08\0\x12\x04\xc3\x07#I\n\xbb\x01\
    \n\x04\x04\x1a\x03\x01\x12\x06\xc9\x07\x02\xd7\x07\x03\x1a\xaa\x01\x20Sp\
    ecifies\x20an\x20identity\x20for\x20which\x20to\x20determine\x20resource\
    \x20access,\x20based\x20on\n\x20roles\x20assigned\x20either\x20directly\
    \x20to\x20them\x20or\x20to\x20the\x20groups\x20they\x20belong\x20to,\n\
    \x20directly\x20or\x20indirectly.\n\n\r\n\x05\x04\x1a\x03\x01\x01\x12\
    \x04\xc9\x07\n\x1a\n\xb6\x03\n\x06\x04\x1a\x03\x01\x02\0\x12\x04\xd6\x07\
    \x04A\x1a\xa5\x03\x20Required.\x20The\x20identity\x20appear\x20in\x20the\
    \x20form\x20of\x20members\x20in\n\x20[IAM\x20policy\n\x20binding](https:\
    //cloud.google.com/iam/reference/rest/v1/Binding).\n\n\x20The\x20example\
    s\x20of\x20supported\x20forms\x20are:\n\x20\"user:mike@example.com\",\n\
    \x20\"group:admins@example.com\",\n\x20\"domain:google.com\",\n\x20\"ser\
    viceAccount:my-project-id@appspot.gserviceaccount.com\".\n\n\x20Notice\
    \x20that\x20wildcard\x20characters\x20(such\x20as\x20*\x20and\x20?)\x20a\
    re\x20not\x20supported.\n\x20You\x20must\x20give\x20a\x20specific\x20ide\
    ntity.\n\n\x0f\n\x07\x04\x1a\x03\x01\x02\0\x05\x12\x04\xd6\x07\x04\n\n\
    \x0f\n\x07\x04\x1a\x03\x01\x02\0\x01\x12\x04\xd6\x07\x0b\x13\n\x0f\n\x07\
    \x04\x1a\x03\x01\x02\0\x03\x12\x04\xd6\x07\x16\x17\n\x0f\n\x07\x04\x1a\
    \x03\x01\x02\0\x08\x12\x04\xd6\x07\x18@\n\x12\n\n\x04\x1a\x03\x01\x02\0\
    \x08\x9c\x08\0\x12\x04\xd6\x07\x19?\n\xc3\x02\n\x04\x04\x1a\x03\x02\x12\
    \x06\xde\x07\x02\xe4\x07\x03\x1a\xb2\x02\x20Specifies\x20roles\x20and/or\
    \x20permissions\x20to\x20analyze,\x20to\x20determine\x20both\x20the\n\
    \x20identities\x20possessing\x20them\x20and\x20the\x20resources\x20they\
    \x20control.\x20If\x20multiple\n\x20values\x20are\x20specified,\x20resul\
    ts\x20will\x20include\x20roles\x20or\x20permissions\x20matching\n\x20any\
    \x20of\x20them.\x20The\x20total\x20number\x20of\x20roles\x20and\x20permi\
    ssions\x20should\x20be\x20equal\x20or\n\x20less\x20than\x2010.\n\n\r\n\
    \x05\x04\x1a\x03\x02\x01\x12\x04\xde\x07\n\x18\n:\n\x06\x04\x1a\x03\x02\
    \x02\0\x12\x04\xe0\x07\x04G\x1a*\x20Optional.\x20The\x20roles\x20to\x20a\
    ppear\x20in\x20result.\n\n\x0f\n\x07\x04\x1a\x03\x02\x02\0\x04\x12\x04\
    \xe0\x07\x04\x0c\n\x0f\n\x07\x04\x1a\x03\x02\x02\0\x05\x12\x04\xe0\x07\r\
    \x13\n\x0f\n\x07\x04\x1a\x03\x02\x02\0\x01\x12\x04\xe0\x07\x14\x19\n\x0f\
    \n\x07\x04\x1a\x03\x02\x02\0\x03\x12\x04\xe0\x07\x1c\x1d\n\x0f\n\x07\x04\
    \x1a\x03\x02\x02\0\x08\x12\x04\xe0\x07\x1eF\n\x12\n\n\x04\x1a\x03\x02\
    \x02\0\x08\x9c\x08\0\x12\x04\xe0\x07\x1fE\n@\n\x06\x04\x1a\x03\x02\x02\
    \x01\x12\x04\xe3\x07\x04M\x1a0\x20Optional.\x20The\x20permissions\x20to\
    \x20appear\x20in\x20result.\n\n\x0f\n\x07\x04\x1a\x03\x02\x02\x01\x04\
    \x12\x04\xe3\x07\x04\x0c\n\x0f\n\x07\x04\x1a\x03\x02\x02\x01\x05\x12\x04\
    \xe3\x07\r\x13\n\x0f\n\x07\x04\x1a\x03\x02\x02\x01\x01\x12\x04\xe3\x07\
    \x14\x1f\n\x0f\n\x07\x04\x1a\x03\x02\x02\x01\x03\x12\x04\xe3\x07\"#\n\
    \x0f\n\x07\x04\x1a\x03\x02\x02\x01\x08\x12\x04\xe3\x07$L\n\x12\n\n\x04\
    \x1a\x03\x02\x02\x01\x08\x9c\x08\0\x12\x04\xe3\x07%K\n)\n\x04\x04\x1a\
    \x03\x03\x12\x06\xe7\x07\x02\xb5\x08\x03\x1a\x19\x20Contains\x20query\
    \x20options.\n\n\r\n\x05\x04\x1a\x03\x03\x01\x12\x04\xe7\x07\n\x11\n\x85\
    \x03\n\x06\x04\x1a\x03\x03\x02\0\x12\x04\xf0\x07\x04D\x1a\xf4\x02\x20Opt\
    ional.\x20If\x20true,\x20the\x20identities\x20section\x20of\x20the\x20re\
    sult\x20will\x20expand\x20any\n\x20Google\x20groups\x20appearing\x20in\
    \x20an\x20IAM\x20policy\x20binding.\n\n\x20If\x20[IamPolicyAnalysisQuery\
    .identity_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.identit\
    y_selector]\x20is\x20specified,\x20the\n\x20identity\x20in\x20the\x20res\
    ult\x20will\x20be\x20determined\x20by\x20the\x20selector,\x20and\x20this\
    \x20flag\n\x20is\x20not\x20allowed\x20to\x20set.\n\n\x20Default\x20is\
    \x20false.\n\n\x0f\n\x07\x04\x1a\x03\x03\x02\0\x05\x12\x04\xf0\x07\x04\
    \x08\n\x0f\n\x07\x04\x1a\x03\x03\x02\0\x01\x12\x04\xf0\x07\t\x16\n\x0f\n\
    \x07\x04\x1a\x03\x03\x02\0\x03\x12\x04\xf0\x07\x19\x1a\n\x0f\n\x07\x04\
    \x1a\x03\x03\x02\0\x08\x12\x04\xf0\x07\x1bC\n\x12\n\n\x04\x1a\x03\x03\
    \x02\0\x08\x9c\x08\0\x12\x04\xf0\x07\x1cB\n\x92\x03\n\x06\x04\x1a\x03\
    \x03\x02\x01\x12\x04\xfa\x07\x04C\x1a\x81\x03\x20Optional.\x20If\x20true\
    ,\x20the\x20access\x20section\x20of\x20result\x20will\x20expand\x20any\
    \x20roles\n\x20appearing\x20in\x20IAM\x20policy\x20bindings\x20to\x20inc\
    lude\x20their\x20permissions.\n\n\x20If\x20[IamPolicyAnalysisQuery.acces\
    s_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.access_selector\
    ]\x20is\x20specified,\x20the\x20access\n\x20section\x20of\x20the\x20resu\
    lt\x20will\x20be\x20determined\x20by\x20the\x20selector,\x20and\x20this\
    \x20flag\n\x20is\x20not\x20allowed\x20to\x20set.\n\n\x20Default\x20is\
    \x20false.\n\n\x0f\n\x07\x04\x1a\x03\x03\x02\x01\x05\x12\x04\xfa\x07\x04\
    \x08\n\x0f\n\x07\x04\x1a\x03\x03\x02\x01\x01\x12\x04\xfa\x07\t\x15\n\x0f\
    \n\x07\x04\x1a\x03\x03\x02\x01\x03\x12\x04\xfa\x07\x18\x19\n\x0f\n\x07\
    \x04\x1a\x03\x03\x02\x01\x08\x12\x04\xfa\x07\x1aB\n\x12\n\n\x04\x1a\x03\
    \x03\x02\x01\x08\x9c\x08\0\x12\x04\xfa\x07\x1bA\n\xfe\x08\n\x06\x04\x1a\
    \x03\x03\x02\x02\x12\x04\x91\x08\x04G\x1a\xed\x08\x20Optional.\x20If\x20\
    true\x20and\x20[IamPolicyAnalysisQuery.resource_selector][google.cloud.a\
    sset.v1.IamPolicyAnalysisQuery.resource_selector]\x20is\x20not\n\x20spec\
    ified,\x20the\x20resource\x20section\x20of\x20the\x20result\x20will\x20e\
    xpand\x20any\x20resource\n\x20attached\x20to\x20an\x20IAM\x20policy\x20t\
    o\x20include\x20resources\x20lower\x20in\x20the\x20resource\n\x20hierarc\
    hy.\n\n\x20For\x20example,\x20if\x20the\x20request\x20analyzes\x20for\
    \x20which\x20resources\x20user\x20A\x20has\n\x20permission\x20P,\x20and\
    \x20the\x20results\x20include\x20an\x20IAM\x20policy\x20with\x20P\x20on\
    \x20a\x20GCP\n\x20folder,\x20the\x20results\x20will\x20also\x20include\
    \x20resources\x20in\x20that\x20folder\x20with\n\x20permission\x20P.\n\n\
    \x20If\x20true\x20and\x20[IamPolicyAnalysisQuery.resource_selector][goog\
    le.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector]\x20is\x20spe\
    cified,\n\x20the\x20resource\x20section\x20of\x20the\x20result\x20will\
    \x20expand\x20the\x20specified\x20resource\x20to\n\x20include\x20resourc\
    es\x20lower\x20in\x20the\x20resource\x20hierarchy.\x20Only\x20project\
    \x20or\n\x20lower\x20resources\x20are\x20supported.\x20Folder\x20and\x20\
    organization\x20resource\x20cannot\x20be\n\x20used\x20together\x20with\
    \x20this\x20option.\n\n\x20For\x20example,\x20if\x20the\x20request\x20an\
    alyzes\x20for\x20which\x20users\x20have\x20permission\x20P\x20on\n\x20a\
    \x20GCP\x20project\x20with\x20this\x20option\x20enabled,\x20the\x20resul\
    ts\x20will\x20include\x20all\n\x20users\x20who\x20have\x20permission\x20\
    P\x20on\x20that\x20project\x20or\x20any\x20lower\x20resource.\n\n\x20Def\
    ault\x20is\x20false.\n\n\x0f\n\x07\x04\x1a\x03\x03\x02\x02\x05\x12\x04\
    \x91\x08\x04\x08\n\x0f\n\x07\x04\x1a\x03\x03\x02\x02\x01\x12\x04\x91\x08\
    \t\x19\n\x0f\n\x07\x04\x1a\x03\x03\x02\x02\x03\x12\x04\x91\x08\x1c\x1d\n\
    \x0f\n\x07\x04\x1a\x03\x03\x02\x02\x08\x12\x04\x91\x08\x1eF\n\x12\n\n\
    \x04\x1a\x03\x03\x02\x02\x08\x9c\x08\0\x12\x04\x91\x08\x1fE\n\xa7\x01\n\
    \x06\x04\x1a\x03\x03\x02\x03\x12\x04\x96\x08\x04L\x1a\x96\x01\x20Optiona\
    l.\x20If\x20true,\x20the\x20result\x20will\x20output\x20resource\x20edge\
    s,\x20starting\n\x20from\x20the\x20policy\x20attached\x20resource,\x20to\
    \x20any\x20expanded\x20resources.\n\x20Default\x20is\x20false.\n\n\x0f\n\
    \x07\x04\x1a\x03\x03\x02\x03\x05\x12\x04\x96\x08\x04\x08\n\x0f\n\x07\x04\
    \x1a\x03\x03\x02\x03\x01\x12\x04\x96\x08\t\x1e\n\x0f\n\x07\x04\x1a\x03\
    \x03\x02\x03\x03\x12\x04\x96\x08!\"\n\x0f\n\x07\x04\x1a\x03\x03\x02\x03\
    \x08\x12\x04\x96\x08#K\n\x12\n\n\x04\x1a\x03\x03\x02\x03\x08\x9c\x08\0\
    \x12\x04\x96\x08$J\n\xad\x01\n\x06\x04\x1a\x03\x03\x02\x04\x12\x04\x9b\
    \x08\x04I\x1a\x9c\x01\x20Optional.\x20If\x20true,\x20the\x20result\x20wi\
    ll\x20output\x20group\x20identity\x20edges,\x20starting\n\x20from\x20the\
    \x20binding's\x20group\x20members,\x20to\x20any\x20expanded\x20identitie\
    s.\n\x20Default\x20is\x20false.\n\n\x0f\n\x07\x04\x1a\x03\x03\x02\x04\
    \x05\x12\x04\x9b\x08\x04\x08\n\x0f\n\x07\x04\x1a\x03\x03\x02\x04\x01\x12\
    \x04\x9b\x08\t\x1b\n\x0f\n\x07\x04\x1a\x03\x03\x02\x04\x03\x12\x04\x9b\
    \x08\x1e\x1f\n\x0f\n\x07\x04\x1a\x03\x03\x02\x04\x08\x12\x04\x9b\x08\x20\
    H\n\x12\n\n\x04\x1a\x03\x03\x02\x04\x08\x9c\x08\0\x12\x04\x9b\x08!G\n\
    \xf2\x0b\n\x06\x04\x1a\x03\x03\x02\x05\x12\x04\xb4\x08\x04\\\x1a\xe1\x0b\
    \x20Optional.\x20If\x20true,\x20the\x20response\x20will\x20include\x20ac\
    cess\x20analysis\x20from\x20identities\x20to\n\x20resources\x20via\x20se\
    rvice\x20account\x20impersonation.\x20This\x20is\x20a\x20very\x20expensi\
    ve\n\x20operation,\x20because\x20many\x20derived\x20queries\x20will\x20b\
    e\x20executed.\x20We\x20highly\n\x20recommend\x20you\x20use\x20[AssetSer\
    vice.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.Ana\
    lyzeIamPolicyLongrunning]\x20rpc\n\x20instead.\n\n\x20For\x20example,\
    \x20if\x20the\x20request\x20analyzes\x20for\x20which\x20resources\x20use\
    r\x20A\x20has\n\x20permission\x20P,\x20and\x20there's\x20an\x20IAM\x20po\
    licy\x20states\x20user\x20A\x20has\n\x20iam.serviceAccounts.getAccessTok\
    en\x20permission\x20to\x20a\x20service\x20account\x20SA,\n\x20and\x20the\
    re's\x20another\x20IAM\x20policy\x20states\x20service\x20account\x20SA\
    \x20has\x20permission\x20P\n\x20to\x20a\x20GCP\x20folder\x20F,\x20then\
    \x20user\x20A\x20potentially\x20has\x20access\x20to\x20the\x20GCP\x20fol\
    der\n\x20F.\x20And\x20those\x20advanced\x20analysis\x20results\x20will\
    \x20be\x20included\x20in\n\x20[AnalyzeIamPolicyResponse.service_account_\
    impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.s\
    ervice_account_impersonation_analysis].\n\n\x20Another\x20example,\x20if\
    \x20the\x20request\x20analyzes\x20for\x20who\x20has\n\x20permission\x20P\
    \x20to\x20a\x20GCP\x20folder\x20F,\x20and\x20there's\x20an\x20IAM\x20pol\
    icy\x20states\x20user\x20A\n\x20has\x20iam.serviceAccounts.actAs\x20perm\
    ission\x20to\x20a\x20service\x20account\x20SA,\x20and\n\x20there's\x20an\
    other\x20IAM\x20policy\x20states\x20service\x20account\x20SA\x20has\x20p\
    ermission\x20P\x20to\n\x20the\x20GCP\x20folder\x20F,\x20then\x20user\x20\
    A\x20potentially\x20has\x20access\x20to\x20the\x20GCP\x20folder\n\x20F.\
    \x20And\x20those\x20advanced\x20analysis\x20results\x20will\x20be\x20inc\
    luded\x20in\n\x20[AnalyzeIamPolicyResponse.service_account_impersonation\
    _analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_accoun\
    t_impersonation_analysis].\n\n\x20Default\x20is\x20false.\n\n\x0f\n\x07\
    \x04\x1a\x03\x03\x02\x05\x05\x12\x04\xb4\x08\x04\x08\n\x0f\n\x07\x04\x1a\
    \x03\x03\x02\x05\x01\x12\x04\xb4\x08\t.\n\x0f\n\x07\x04\x1a\x03\x03\x02\
    \x05\x03\x12\x04\xb4\x0812\n\x0f\n\x07\x04\x1a\x03\x03\x02\x05\x08\x12\
    \x04\xb4\x083[\n\x12\n\n\x04\x1a\x03\x03\x02\x05\x08\x9c\x08\0\x12\x04\
    \xb4\x084Z\n-\n\x04\x04\x1a\x03\x04\x12\x06\xb8\x08\x02\xc0\x08\x03\x1a\
    \x1d\x20The\x20IAM\x20conditions\x20context.\n\n\r\n\x05\x04\x1a\x03\x04\
    \x01\x12\x04\xb8\x08\n\x1a\n4\n\x06\x04\x1a\x03\x04\x08\0\x12\x06\xba\
    \x08\x04\xbf\x08\x05\x1a\"\x20The\x20IAM\x20conditions\x20time\x20contex\
    t.\n\n\x0f\n\x07\x04\x1a\x03\x04\x08\0\x01\x12\x04\xba\x08\n\x15\n\xc9\
    \x01\n\x06\x04\x1a\x03\x04\x02\0\x12\x04\xbe\x08\x060\x1a\xb8\x01\x20The\
    \x20hypothetical\x20access\x20timestamp\x20to\x20evaluate\x20IAM\x20cond\
    itions.\x20Note\x20that\n\x20this\x20value\x20must\x20not\x20be\x20earli\
    er\x20than\x20the\x20current\x20time;\x20otherwise,\x20an\n\x20INVALID_A\
    RGUMENT\x20error\x20will\x20be\x20returned.\n\n\x0f\n\x07\x04\x1a\x03\
    \x04\x02\0\x06\x12\x04\xbe\x08\x06\x1f\n\x0f\n\x07\x04\x1a\x03\x04\x02\0\
    \x01\x12\x04\xbe\x08\x20+\n\x0f\n\x07\x04\x1a\x03\x04\x02\0\x03\x12\x04\
    \xbe\x08./\n\xaa\x05\n\x04\x04\x1a\x02\0\x12\x04\xce\x08\x02<\x1a\x9b\
    \x05\x20Required.\x20The\x20relative\x20name\x20of\x20the\x20root\x20ass\
    et.\x20Only\x20resources\x20and\x20IAM\x20policies\x20within\n\x20the\
    \x20scope\x20will\x20be\x20analyzed.\n\n\x20This\x20can\x20only\x20be\
    \x20an\x20organization\x20number\x20(such\x20as\x20\"organizations/123\"\
    ),\x20a\n\x20folder\x20number\x20(such\x20as\x20\"folders/123\"),\x20a\
    \x20project\x20ID\x20(such\x20as\n\x20\"projects/my-project-id\"),\x20or\
    \x20a\x20project\x20number\x20(such\x20as\x20\"projects/12345\").\n\n\
    \x20To\x20know\x20how\x20to\x20get\x20organization\x20id,\x20visit\x20[h\
    ere\n\x20](https://cloud.google.com/resource-manager/docs/creating-manag\
    ing-organization#retrieving_your_organization_id).\n\n\x20To\x20know\x20\
    how\x20to\x20get\x20folder\x20or\x20project\x20id,\x20visit\x20[here\n\
    \x20](https://cloud.google.com/resource-manager/docs/creating-managing-f\
    olders#viewing_or_listing_folders_and_projects).\n\n\r\n\x05\x04\x1a\x02\
    \0\x05\x12\x04\xce\x08\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xce\
    \x08\t\x0e\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xce\x08\x11\x12\n\r\n\x05\
    \x04\x1a\x02\0\x08\x12\x04\xce\x08\x13;\n\x10\n\x08\x04\x1a\x02\0\x08\
    \x9c\x08\0\x12\x04\xce\x08\x14:\n<\n\x04\x04\x1a\x02\x01\x12\x04\xd1\x08\
    \x02R\x1a.\x20Optional.\x20Specifies\x20a\x20resource\x20for\x20analysis\
    .\n\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xd1\x08\x02\x12\n\r\n\x05\x04\
    \x1a\x02\x01\x01\x12\x04\xd1\x08\x13$\n\r\n\x05\x04\x1a\x02\x01\x03\x12\
    \x04\xd1\x08'(\n\r\n\x05\x04\x1a\x02\x01\x08\x12\x04\xd1\x08)Q\n\x10\n\
    \x08\x04\x1a\x02\x01\x08\x9c\x08\0\x12\x04\xd1\x08*P\n=\n\x04\x04\x1a\
    \x02\x02\x12\x04\xd4\x08\x02R\x1a/\x20Optional.\x20Specifies\x20an\x20id\
    entity\x20for\x20analysis.\n\n\r\n\x05\x04\x1a\x02\x02\x06\x12\x04\xd4\
    \x08\x02\x12\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xd4\x08\x13$\n\r\n\
    \x05\x04\x1a\x02\x02\x03\x12\x04\xd4\x08'(\n\r\n\x05\x04\x1a\x02\x02\x08\
    \x12\x04\xd4\x08)Q\n\x10\n\x08\x04\x1a\x02\x02\x08\x9c\x08\0\x12\x04\xd4\
    \x08*P\nX\n\x04\x04\x1a\x02\x03\x12\x04\xd7\x08\x02N\x1aJ\x20Optional.\
    \x20Specifies\x20roles\x20or\x20permissions\x20for\x20analysis.\x20This\
    \x20is\x20optional.\n\n\r\n\x05\x04\x1a\x02\x03\x06\x12\x04\xd7\x08\x02\
    \x10\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xd7\x08\x11\x20\n\r\n\x05\x04\
    \x1a\x02\x03\x03\x12\x04\xd7\x08#$\n\r\n\x05\x04\x1a\x02\x03\x08\x12\x04\
    \xd7\x08%M\n\x10\n\x08\x04\x1a\x02\x03\x08\x9c\x08\0\x12\x04\xd7\x08&L\n\
    ,\n\x04\x04\x1a\x02\x04\x12\x04\xda\x08\x02?\x1a\x1e\x20Optional.\x20The\
    \x20query\x20options.\n\n\r\n\x05\x04\x1a\x02\x04\x06\x12\x04\xda\x08\
    \x02\t\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\xda\x08\n\x11\n\r\n\x05\x04\
    \x1a\x02\x04\x03\x12\x04\xda\x08\x14\x15\n\r\n\x05\x04\x1a\x02\x04\x08\
    \x12\x04\xda\x08\x16>\n\x10\n\x08\x04\x1a\x02\x04\x08\x9c\x08\0\x12\x04\
    \xda\x08\x17=\nQ\n\x04\x04\x1a\x02\x05\x12\x04\xdd\x08\x02R\x1aC\x20Opti\
    onal.\x20The\x20hypothetical\x20context\x20for\x20IAM\x20conditions\x20e\
    valuation.\n\n\r\n\x05\x04\x1a\x02\x05\x06\x12\x04\xdd\x08\x02\x12\n\r\n\
    \x05\x04\x1a\x02\x05\x01\x12\x04\xdd\x08\x13$\n\r\n\x05\x04\x1a\x02\x05\
    \x03\x12\x04\xdd\x08'(\n\r\n\x05\x04\x1a\x02\x05\x08\x12\x04\xdd\x08)Q\n\
    \x10\n\x08\x04\x1a\x02\x05\x08\x9c\x08\0\x12\x04\xdd\x08*P\n{\n\x02\x04\
    \x1b\x12\x06\xe1\x08\0\xf0\x08\x01\x1am\x20A\x20request\x20message\x20fo\
    r\x20[AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.\
    AnalyzeIamPolicy].\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xe1\x08\x08\x1f\n,\
    \n\x04\x04\x1b\x02\0\x12\x04\xe3\x08\x02U\x1a\x1e\x20Required.\x20The\
    \x20request\x20query.\n\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xe3\x08\x02\
    \x18\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xe3\x08\x19'\n\r\n\x05\x04\x1b\
    \x02\0\x03\x12\x04\xe3\x08*+\n\r\n\x05\x04\x1b\x02\0\x08\x12\x04\xe3\x08\
    ,T\n\x10\n\x08\x04\x1b\x02\0\x08\x9c\x08\0\x12\x04\xe3\x08-S\n\x9b\x04\n\
    \x04\x04\x1b\x02\x01\x12\x04\xef\x08\x02Z\x1a\x8c\x04\x20Optional.\x20Am\
    ount\x20of\x20time\x20executable\x20has\x20to\x20complete.\x20\x20See\
    \x20JSON\x20representation\x20of\n\x20[Duration](https://developers.goog\
    le.com/protocol-buffers/docs/proto3#json).\n\n\x20If\x20this\x20field\
    \x20is\x20set\x20with\x20a\x20value\x20less\x20than\x20the\x20RPC\x20dea\
    dline,\x20and\x20the\n\x20execution\x20of\x20your\x20query\x20hasn't\x20\
    finished\x20in\x20the\x20specified\n\x20execution\x20timeout,\x20\x20you\
    \x20will\x20get\x20a\x20response\x20with\x20partial\x20result.\n\x20Othe\
    rwise,\x20your\x20query's\x20execution\x20will\x20continue\x20until\x20t\
    he\x20RPC\x20deadline.\n\x20If\x20it's\x20not\x20finished\x20until\x20th\
    en,\x20you\x20will\x20get\x20a\x20\x20DEADLINE_EXCEEDED\x20error.\n\n\
    \x20Default\x20is\x20empty.\n\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xef\
    \x08\x02\x1a\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xef\x08\x1b,\n\r\n\
    \x05\x04\x1b\x02\x01\x03\x12\x04\xef\x08/0\n\r\n\x05\x04\x1b\x02\x01\x08\
    \x12\x04\xef\x081Y\n\x10\n\x08\x04\x1b\x02\x01\x08\x9c\x08\0\x12\x04\xef\
    \x082X\n|\n\x02\x04\x1c\x12\x06\xf3\x08\0\x91\t\x01\x1an\x20A\x20respons\
    e\x20message\x20for\x20[AssetService.AnalyzeIamPolicy][google.cloud.asse\
    t.v1.AssetService.AnalyzeIamPolicy].\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\
    \xf3\x08\x08\x20\nE\n\x04\x04\x1c\x03\0\x12\x06\xf5\x08\x02\x83\t\x03\
    \x1a5\x20An\x20analysis\x20message\x20to\x20group\x20the\x20query\x20and\
    \x20results.\n\n\r\n\x05\x04\x1c\x03\0\x01\x12\x04\xf5\x08\n\x1b\n%\n\
    \x06\x04\x1c\x03\0\x02\0\x12\x04\xf7\x08\x04.\x1a\x15\x20The\x20analysis\
    \x20query.\n\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x06\x12\x04\xf7\x08\x04\x1a\
    \n\x0f\n\x07\x04\x1c\x03\0\x02\0\x01\x12\x04\xf7\x08\x1b)\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\0\x03\x12\x04\xf7\x08,-\n\xa7\x01\n\x06\x04\x1c\x03\0\
    \x02\x01\x12\x04\xfb\x08\x04:\x1a\x96\x01\x20A\x20list\x20of\x20[IamPoli\
    cyAnalysisResult][google.cloud.asset.v1.IamPolicyAnalysisResult]\x20that\
    \x20matches\x20the\x20analysis\x20query,\x20or\n\x20empty\x20if\x20no\
    \x20result\x20is\x20found.\n\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\
    \x04\xfb\x08\x04\x0c\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x06\x12\x04\xfb\
    \x08\r$\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x01\x12\x04\xfb\x08%5\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\x01\x03\x12\x04\xfb\x0889\n\xcd\x01\n\x06\x04\x1c\
    \x03\0\x02\x02\x12\x04\xff\x08\x04\x1c\x1a\xbc\x01\x20Represents\x20whet\
    her\x20all\x20entries\x20in\x20the\x20[analysis_results][google.cloud.as\
    set.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis.analysis_results]\x20h\
    ave\x20been\n\x20fully\x20explored\x20to\x20answer\x20the\x20query.\n\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x02\x05\x12\x04\xff\x08\x04\x08\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\x02\x01\x12\x04\xff\x08\t\x17\n\x0f\n\x07\x04\x1c\x03\
    \0\x02\x02\x03\x12\x04\xff\x08\x1a\x1b\nS\n\x06\x04\x1c\x03\0\x02\x03\
    \x12\x04\x82\t\x04<\x1aC\x20A\x20list\x20of\x20non-critical\x20errors\
    \x20happened\x20during\x20the\x20query\x20handling.\n\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x03\x04\x12\x04\x82\t\x04\x0c\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x03\x06\x12\x04\x82\t\r#\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x01\x12\
    \x04\x82\t$7\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x03\x12\x04\x82\t:;\nD\n\
    \x04\x04\x1c\x02\0\x12\x04\x86\t\x02&\x1a6\x20The\x20main\x20analysis\
    \x20that\x20matches\x20the\x20original\x20request.\n\n\r\n\x05\x04\x1c\
    \x02\0\x06\x12\x04\x86\t\x02\x13\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\x86\
    \t\x14!\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\x86\t$%\n\x8d\x01\n\x04\x04\
    \x1c\x02\x01\x12\x04\x8b\t\x02H\x1a\x7f\x20The\x20service\x20account\x20\
    impersonation\x20analysis\x20if\n\x20[AnalyzeIamPolicyRequest.analyze_se\
    rvice_account_impersonation][]\x20is\n\x20enabled.\n\n\r\n\x05\x04\x1c\
    \x02\x01\x04\x12\x04\x8b\t\x02\n\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\
    \x8b\t\x0b\x1c\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\x8b\t\x1dC\n\r\n\
    \x05\x04\x1c\x02\x01\x03\x12\x04\x8b\tFG\n\xc7\x02\n\x04\x04\x1c\x02\x02\
    \x12\x04\x90\t\x02\x1a\x1a\xb8\x02\x20Represents\x20whether\x20all\x20en\
    tries\x20in\x20the\x20[main_analysis][google.cloud.asset.v1.AnalyzeIamPo\
    licyResponse.main_analysis]\x20and\n\x20[service_account_impersonation_a\
    nalysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_\
    impersonation_analysis]\x20have\x20been\x20fully\x20explored\x20to\n\x20\
    answer\x20the\x20query\x20in\x20the\x20request.\n\n\r\n\x05\x04\x1c\x02\
    \x02\x05\x12\x04\x90\t\x02\x06\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\x90\
    \t\x07\x15\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\x90\t\x18\x19\nP\n\x02\
    \x04\x1d\x12\x06\x94\t\0\xdd\t\x01\x1aB\x20Output\x20configuration\x20fo\
    r\x20export\x20IAM\x20policy\x20analysis\x20destination.\n\n\x0b\n\x03\
    \x04\x1d\x01\x12\x04\x94\t\x08%\n+\n\x04\x04\x1d\x03\0\x12\x06\x96\t\x02\
    \xa1\t\x03\x1a\x1b\x20A\x20Cloud\x20Storage\x20location.\n\n\r\n\x05\x04\
    \x1d\x03\0\x01\x12\x04\x96\t\n\x18\n\xce\x03\n\x06\x04\x1d\x03\0\x02\0\
    \x12\x04\xa0\t\x04<\x1a\xbd\x03\x20Required.\x20The\x20uri\x20of\x20the\
    \x20Cloud\x20Storage\x20object.\x20It's\x20the\x20same\x20uri\x20that\
    \x20is\x20used\x20by\n\x20gsutil.\x20Example:\x20\"gs://bucket_name/obje\
    ct_name\".\x20See\x20[Viewing\x20and\n\x20Editing\x20Object\n\x20Metadat\
    a](https://cloud.google.com/storage/docs/viewing-editing-metadata)\n\x20\
    for\x20more\x20information.\n\n\x20If\x20the\x20specified\x20Cloud\x20St\
    orage\x20object\x20already\x20exists\x20and\x20there\x20is\x20no\n\x20[h\
    old](https://cloud.google.com/storage/docs/object-holds),\x20it\x20will\
    \x20be\n\x20overwritten\x20with\x20the\x20analysis\x20result.\n\n\x0f\n\
    \x07\x04\x1d\x03\0\x02\0\x05\x12\x04\xa0\t\x04\n\n\x0f\n\x07\x04\x1d\x03\
    \0\x02\0\x01\x12\x04\xa0\t\x0b\x0e\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x03\
    \x12\x04\xa0\t\x11\x12\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x08\x12\x04\xa0\t\
    \x13;\n\x12\n\n\x04\x1d\x03\0\x02\0\x08\x9c\x08\0\x12\x04\xa0\t\x14:\n)\
    \n\x04\x04\x1d\x03\x01\x12\x06\xa4\t\x02\xd3\t\x03\x1a\x19\x20A\x20BigQu\
    ery\x20destination.\n\n\r\n\x05\x04\x1d\x03\x01\x01\x12\x04\xa4\t\n\x1d\
    \n\x88\x02\n\x06\x04\x1d\x03\x01\x04\0\x12\x06\xa9\t\x04\xb2\t\x05\x1a\
    \xf5\x01\x20This\x20enum\x20determines\x20the\x20partition\x20key\x20col\
    umn\x20for\x20the\x20bigquery\x20tables.\n\x20Partitioning\x20can\x20imp\
    rove\x20query\x20performance\x20and\x20reduce\x20query\x20cost\x20by\n\
    \x20filtering\x20partitions.\x20Refer\x20to\n\x20https://cloud.google.co\
    m/bigquery/docs/partitioned-tables\x20for\x20details.\n\n\x0f\n\x07\x04\
    \x1d\x03\x01\x04\0\x01\x12\x04\xa9\t\t\x15\n^\n\x08\x04\x1d\x03\x01\x04\
    \0\x02\0\x12\x04\xac\t\x06$\x1aL\x20Unspecified\x20partition\x20key.\x20\
    Tables\x20won't\x20be\x20partitioned\x20using\x20this\n\x20option.\n\n\
    \x11\n\t\x04\x1d\x03\x01\x04\0\x02\0\x01\x12\x04\xac\t\x06\x1f\n\x11\n\t\
    \x04\x1d\x03\x01\x04\0\x02\0\x02\x12\x04\xac\t\"#\n\xe4\x01\n\x08\x04\
    \x1d\x03\x01\x04\0\x02\x01\x12\x04\xb1\t\x06\x17\x1a\xd1\x01\x20The\x20t\
    ime\x20when\x20the\x20request\x20is\x20received.\x20If\x20specified\x20a\
    s\x20partition\x20key,\n\x20the\x20result\x20table(s)\x20is\x20partitone\
    d\x20by\x20the\x20RequestTime\x20column,\x20an\n\x20additional\x20timest\
    amp\x20column\x20representing\x20when\x20the\x20request\x20was\x20receiv\
    ed.\n\n\x11\n\t\x04\x1d\x03\x01\x04\0\x02\x01\x01\x12\x04\xb1\t\x06\x12\
    \n\x11\n\t\x04\x1d\x03\x01\x04\0\x02\x01\x02\x12\x04\xb1\t\x15\x16\n\xef\
    \x01\n\x06\x04\x1d\x03\x01\x02\0\x12\x04\xb7\t\x04@\x1a\xde\x01\x20Requi\
    red.\x20The\x20BigQuery\x20dataset\x20in\x20format\x20\"projects/project\
    Id/datasets/datasetId\",\n\x20to\x20which\x20the\x20analysis\x20results\
    \x20should\x20be\x20exported.\x20If\x20this\x20dataset\x20does\n\x20not\
    \x20exist,\x20the\x20export\x20call\x20will\x20return\x20an\x20INVALID_A\
    RGUMENT\x20error.\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\0\x05\x12\x04\xb7\t\
    \x04\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\0\x01\x12\x04\xb7\t\x0b\x12\n\x0f\
    \n\x07\x04\x1d\x03\x01\x02\0\x03\x12\x04\xb7\t\x15\x16\n\x0f\n\x07\x04\
    \x1d\x03\x01\x02\0\x08\x12\x04\xb7\t\x17?\n\x12\n\n\x04\x1d\x03\x01\x02\
    \0\x08\x9c\x08\0\x12\x04\xb7\t\x18>\n\xe0\x03\n\x06\x04\x1d\x03\x01\x02\
    \x01\x12\x04\xc0\t\x04E\x1a\xcf\x03\x20Required.\x20The\x20prefix\x20of\
    \x20the\x20BigQuery\x20tables\x20to\x20which\x20the\x20analysis\x20resul\
    ts\x20will\x20be\n\x20written.\x20Tables\x20will\x20be\x20created\x20bas\
    ed\x20on\x20this\x20table_prefix\x20if\x20not\x20exist:\n\x20*\x20<table\
    _prefix>_analysis\x20table\x20will\x20contain\x20export\x20operation's\
    \x20metadata.\n\x20*\x20<table_prefix>_analysis_result\x20will\x20contai\
    n\x20all\x20the\n\x20\x20\x20[IamPolicyAnalysisResult][google.cloud.asse\
    t.v1.IamPolicyAnalysisResult].\n\x20When\x20[partition_key]\x20is\x20spe\
    cified,\x20both\x20tables\x20will\x20be\x20partitioned\x20based\n\x20on\
    \x20the\x20[partition_key].\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x05\
    \x12\x04\xc0\t\x04\n\n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x01\x12\x04\xc0\
    \t\x0b\x17\n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x03\x12\x04\xc0\t\x1a\x1b\
    \n\x0f\n\x07\x04\x1d\x03\x01\x02\x01\x08\x12\x04\xc0\t\x1cD\n\x12\n\n\
    \x04\x1d\x03\x01\x02\x01\x08\x9c\x08\0\x12\x04\xc0\t\x1dC\nC\n\x06\x04\
    \x1d\x03\x01\x02\x02\x12\x04\xc3\t\x04#\x1a3\x20The\x20partition\x20key\
    \x20for\x20BigQuery\x20partitioned\x20table.\n\n\x0f\n\x07\x04\x1d\x03\
    \x01\x02\x02\x06\x12\x04\xc3\t\x04\x10\n\x0f\n\x07\x04\x1d\x03\x01\x02\
    \x02\x01\x12\x04\xc3\t\x11\x1e\n\x0f\n\x07\x04\x1d\x03\x01\x02\x02\x03\
    \x12\x04\xc3\t!\"\n\xee\x05\n\x06\x04\x1d\x03\x01\x02\x03\x12\x04\xd2\t\
    \x04J\x1a\xdd\x05\x20Optional.\x20Specifies\x20the\x20action\x20that\x20\
    occurs\x20if\x20the\x20destination\x20table\x20or\x20partition\n\x20alre\
    ady\x20exists.\x20The\x20following\x20values\x20are\x20supported:\n\n\
    \x20*\x20WRITE_TRUNCATE:\x20If\x20the\x20table\x20or\x20partition\x20alr\
    eady\x20exists,\x20BigQuery\n\x20overwrites\x20the\x20entire\x20table\
    \x20or\x20all\x20the\x20partitions\x20data.\n\x20*\x20WRITE_APPEND:\x20I\
    f\x20the\x20table\x20or\x20partition\x20already\x20exists,\x20BigQuery\n\
    \x20appends\x20the\x20data\x20to\x20the\x20table\x20or\x20the\x20latest\
    \x20partition.\n\x20*\x20WRITE_EMPTY:\x20If\x20the\x20table\x20already\
    \x20exists\x20and\x20contains\x20data,\x20an\x20error\x20is\n\x20returne\
    d.\n\n\x20The\x20default\x20value\x20is\x20WRITE_APPEND.\x20Each\x20acti\
    on\x20is\x20atomic\x20and\x20only\x20occurs\n\x20if\x20BigQuery\x20is\
    \x20able\x20to\x20complete\x20the\x20job\x20successfully.\x20Details\x20\
    are\x20at\n\x20https://cloud.google.com/bigquery/docs/loading-data-local\
    #appending_to_or_overwriting_a_table_using_a_local_file.\n\n\x0f\n\x07\
    \x04\x1d\x03\x01\x02\x03\x05\x12\x04\xd2\t\x04\n\n\x0f\n\x07\x04\x1d\x03\
    \x01\x02\x03\x01\x12\x04\xd2\t\x0b\x1c\n\x0f\n\x07\x04\x1d\x03\x01\x02\
    \x03\x03\x12\x04\xd2\t\x1f\x20\n\x0f\n\x07\x04\x1d\x03\x01\x02\x03\x08\
    \x12\x04\xd2\t!I\n\x12\n\n\x04\x1d\x03\x01\x02\x03\x08\x9c\x08\0\x12\x04\
    \xd2\t\"H\n9\n\x04\x04\x1d\x08\0\x12\x06\xd6\t\x02\xdc\t\x03\x1a)\x20IAM\
    \x20policy\x20analysis\x20export\x20destination.\n\n\r\n\x05\x04\x1d\x08\
    \0\x01\x12\x04\xd6\t\x08\x13\n-\n\x04\x04\x1d\x02\0\x12\x04\xd8\t\x04'\
    \x1a\x1f\x20Destination\x20on\x20Cloud\x20Storage.\n\n\r\n\x05\x04\x1d\
    \x02\0\x06\x12\x04\xd8\t\x04\x12\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xd8\
    \t\x13\"\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xd8\t%&\n(\n\x04\x04\x1d\
    \x02\x01\x12\x04\xdb\t\x041\x1a\x1a\x20Destination\x20on\x20BigQuery.\n\
    \n\r\n\x05\x04\x1d\x02\x01\x06\x12\x04\xdb\t\x04\x17\n\r\n\x05\x04\x1d\
    \x02\x01\x01\x12\x04\xdb\t\x18,\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\
    \xdb\t/0\n\x92\x01\n\x02\x04\x1e\x12\x06\xe0\t\0\xe6\t\x01\x1a\x83\x01\
    \x20A\x20request\x20message\x20for\x20[AssetService.AnalyzeIamPolicyLong\
    running][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]\
    .\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xe0\t\x08*\n,\n\x04\x04\x1e\x02\0\
    \x12\x04\xe2\t\x02U\x1a\x1e\x20Required.\x20The\x20request\x20query.\n\n\
    \r\n\x05\x04\x1e\x02\0\x06\x12\x04\xe2\t\x02\x18\n\r\n\x05\x04\x1e\x02\0\
    \x01\x12\x04\xe2\t\x19'\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xe2\t*+\n\r\
    \n\x05\x04\x1e\x02\0\x08\x12\x04\xe2\t,T\n\x10\n\x08\x04\x1e\x02\0\x08\
    \x9c\x08\0\x12\x04\xe2\t-S\n^\n\x04\x04\x1e\x02\x01\x12\x04\xe5\t\x02[\
    \x1aP\x20Required.\x20Output\x20configuration\x20indicating\x20where\x20\
    the\x20results\x20will\x20be\x20output\x20to.\n\n\r\n\x05\x04\x1e\x02\
    \x01\x06\x12\x04\xe5\t\x02\x1f\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xe5\
    \t\x20-\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xe5\t01\n\r\n\x05\x04\x1e\
    \x02\x01\x08\x12\x04\xe5\t2Z\n\x10\n\x08\x04\x1e\x02\x01\x08\x9c\x08\0\
    \x12\x04\xe5\t3Y\n\x93\x01\n\x02\x04\x1f\x12\x06\xe9\t\0\xeb\t\x01\x1a\
    \x84\x01\x20A\x20response\x20message\x20for\x20[AssetService.AnalyzeIamP\
    olicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLon\
    grunning].\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xe9\t\x08+\nJ\n\x02\x04\x20\
    \x12\x06\xee\t\0\x8e\n\x01\x1a<\x20The\x20request\x20message\x20for\x20p\
    erforming\x20resource\x20move\x20analysis.\n\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\xee\t\x08\x1a\nF\n\x04\x04\x20\x04\0\x12\x06\xf0\t\x02\xfc\t\x03\
    \x1a6\x20View\x20enum\x20for\x20supporting\x20partial\x20analysis\x20res\
    ponses.\n\n\r\n\x05\x04\x20\x04\0\x01\x12\x04\xf0\t\x07\x13\nR\n\x06\x04\
    \x20\x04\0\x02\0\x12\x04\xf3\t\x04\"\x1aB\x20The\x20default/unset\x20val\
    ue.\n\x20The\x20API\x20will\x20default\x20to\x20the\x20FULL\x20view.\n\n\
    \x0f\n\x07\x04\x20\x04\0\x02\0\x01\x12\x04\xf3\t\x04\x1d\n\x0f\n\x07\x04\
    \x20\x04\0\x02\0\x02\x12\x04\xf3\t\x20!\n_\n\x06\x04\x20\x04\0\x02\x01\
    \x12\x04\xf7\t\x04\r\x1aO\x20Full\x20analysis\x20including\x20all\x20lev\
    el\x20of\x20impacts\x20of\x20the\x20specified\x20resource\n\x20move.\n\n\
    \x0f\n\x07\x04\x20\x04\0\x02\x01\x01\x12\x04\xf7\t\x04\x08\n\x0f\n\x07\
    \x04\x20\x04\0\x02\x01\x02\x12\x04\xf7\t\x0b\x0c\nt\n\x06\x04\x20\x04\0\
    \x02\x02\x12\x04\xfb\t\x04\x0e\x1ad\x20Basic\x20analysis\x20only\x20incl\
    uding\x20blockers\x20which\x20will\x20prevent\x20the\x20specified\n\x20r\
    esource\x20move\x20at\x20runtime.\n\n\x0f\n\x07\x04\x20\x04\0\x02\x02\
    \x01\x12\x04\xfb\t\x04\t\n\x0f\n\x07\x04\x20\x04\0\x02\x02\x02\x12\x04\
    \xfb\t\x0c\r\n\xf5\x01\n\x04\x04\x20\x02\0\x12\x04\x82\n\x02?\x1a\xe6\
    \x01\x20Required.\x20Name\x20of\x20the\x20resource\x20to\x20perform\x20t\
    he\x20analysis\x20against.\n\x20Only\x20GCP\x20Project\x20are\x20support\
    ed\x20as\x20of\x20today.\x20Hence,\x20this\x20can\x20only\x20be\x20Proje\
    ct\n\x20ID\x20(such\x20as\x20\"projects/my-project-id\")\x20or\x20a\x20P\
    roject\x20Number\x20(such\x20as\n\x20\"projects/12345\").\n\n\r\n\x05\
    \x04\x20\x02\0\x05\x12\x04\x82\n\x02\x08\n\r\n\x05\x04\x20\x02\0\x01\x12\
    \x04\x82\n\t\x11\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x82\n\x14\x15\n\r\n\
    \x05\x04\x20\x02\0\x08\x12\x04\x82\n\x16>\n\x10\n\x08\x04\x20\x02\0\x08\
    \x9c\x08\0\x12\x04\x82\n\x17=\n\xc9\x02\n\x04\x04\x20\x02\x01\x12\x04\
    \x89\n\x02I\x1a\xba\x02\x20Required.\x20Name\x20of\x20the\x20GCP\x20Fold\
    er\x20or\x20Organization\x20to\x20reparent\x20the\x20target\n\x20resourc\
    e.\x20The\x20analysis\x20will\x20be\x20performed\x20against\x20hypotheti\
    cally\x20moving\x20the\n\x20resource\x20to\x20this\x20specified\x20desit\
    ination\x20parent.\x20This\x20can\x20only\x20be\x20a\x20Folder\n\x20numb\
    er\x20(such\x20as\x20\"folders/123\")\x20or\x20an\x20Organization\x20num\
    ber\x20(such\x20as\n\x20\"organizations/123\").\n\n\r\n\x05\x04\x20\x02\
    \x01\x05\x12\x04\x89\n\x02\x08\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x89\
    \n\t\x1b\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x89\n\x1e\x1f\n\r\n\x05\
    \x04\x20\x02\x01\x08\x12\x04\x89\n\x20H\n\x10\n\x08\x04\x20\x02\x01\x08\
    \x9c\x08\0\x12\x04\x89\n!G\n\x92\x01\n\x04\x04\x20\x02\x02\x12\x04\x8d\n\
    \x02\x18\x1a\x83\x01\x20Analysis\x20view\x20indicating\x20what\x20inform\
    ation\x20should\x20be\x20included\x20in\x20the\n\x20analysis\x20response\
    .\x20If\x20unspecified,\x20the\x20default\x20view\x20is\x20FULL.\n\n\r\n\
    \x05\x04\x20\x02\x02\x06\x12\x04\x8d\n\x02\x0e\n\r\n\x05\x04\x20\x02\x02\
    \x01\x12\x04\x8d\n\x0f\x13\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x8d\n\
    \x16\x17\n@\n\x02\x04!\x12\x06\x91\n\0\x95\n\x01\x1a2\x20The\x20response\
    \x20message\x20for\x20resource\x20move\x20analysis.\n\n\x0b\n\x03\x04!\
    \x01\x12\x04\x91\n\x08\x1b\n\x99\x01\n\x04\x04!\x02\0\x12\x04\x94\n\x02*\
    \x1a\x8a\x01\x20The\x20list\x20of\x20analyses\x20returned\x20from\x20per\
    forming\x20the\x20intended\x20resource\x20move\n\x20analysis.\x20The\x20\
    analysis\x20is\x20grouped\x20by\x20different\x20Cloud\x20services.\n\n\r\
    \n\x05\x04!\x02\0\x04\x12\x04\x94\n\x02\n\n\r\n\x05\x04!\x02\0\x06\x12\
    \x04\x94\n\x0b\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\x94\n\x18%\n\r\n\x05\
    \x04!\x02\0\x03\x12\x04\x94\n()\n<\n\x02\x04\"\x12\x06\x98\n\0\xa4\n\x01\
    \x1a.\x20A\x20message\x20to\x20group\x20the\x20analysis\x20information.\
    \n\n\x0b\n\x03\x04\"\x01\x12\x04\x98\n\x08\x14\nc\n\x04\x04\"\x02\0\x12\
    \x04\x9b\n\x02\x1a\x1aU\x20The\x20user\x20friendly\x20display\x20name\
    \x20of\x20the\x20analysis.\x20E.g.\x20IAM,\x20Organization\n\x20Policy\
    \x20etc.\n\n\r\n\x05\x04\"\x02\0\x05\x12\x04\x9b\n\x02\x08\n\r\n\x05\x04\
    \"\x02\0\x01\x12\x04\x9b\n\t\x15\n\r\n\x05\x04\"\x02\0\x03\x12\x04\x9b\n\
    \x18\x19\n\x0e\n\x04\x04\"\x08\0\x12\x06\x9d\n\x02\xa3\n\x03\n\r\n\x05\
    \x04\"\x08\0\x01\x12\x04\x9d\n\x08\x0e\n>\n\x04\x04\"\x02\x01\x12\x04\
    \x9f\n\x04$\x1a0\x20Analysis\x20result\x20of\x20moving\x20the\x20target\
    \x20resource.\n\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\x9f\n\x04\x16\n\r\n\
    \x05\x04\"\x02\x01\x01\x12\x04\x9f\n\x17\x1f\n\r\n\x05\x04\"\x02\x01\x03\
    \x12\x04\x9f\n\"#\nN\n\x04\x04\"\x02\x02\x12\x04\xa2\n\x04\x20\x1a@\x20D\
    escription\x20of\x20error\x20encountered\x20when\x20performing\x20the\
    \x20analysis.\n\n\r\n\x05\x04\"\x02\x02\x06\x12\x04\xa2\n\x04\x15\n\r\n\
    \x05\x04\"\x02\x02\x01\x12\x04\xa2\n\x16\x1b\n\r\n\x05\x04\"\x02\x02\x03\
    \x12\x04\xa2\n\x1e\x1f\nC\n\x02\x04#\x12\x06\xa7\n\0\xb0\n\x01\x1a5\x20A\
    n\x20analysis\x20result\x20including\x20blockers\x20and\x20warnings.\n\n\
    \x0b\n\x03\x04#\x01\x12\x04\xa7\n\x08\x1a\n\x81\x01\n\x04\x04#\x02\0\x12\
    \x04\xaa\n\x02#\x1as\x20Blocking\x20information\x20that\x20would\x20prev\
    ent\x20the\x20target\x20resource\x20from\x20moving\n\x20to\x20the\x20spe\
    cified\x20destination\x20at\x20runtime.\n\n\r\n\x05\x04#\x02\0\x04\x12\
    \x04\xaa\n\x02\n\n\r\n\x05\x04#\x02\0\x06\x12\x04\xaa\n\x0b\x15\n\r\n\
    \x05\x04#\x02\0\x01\x12\x04\xaa\n\x16\x1e\n\r\n\x05\x04#\x02\0\x03\x12\
    \x04\xaa\n!\"\n\xed\x01\n\x04\x04#\x02\x01\x12\x04\xaf\n\x02#\x1a\xde\
    \x01\x20Warning\x20information\x20indicating\x20that\x20moving\x20the\
    \x20target\x20resource\x20to\x20the\n\x20specified\x20destination\x20mig\
    ht\x20be\x20unsafe.\x20This\x20can\x20include\x20important\x20policy\n\
    \x20information\x20and\x20configuration\x20changes,\x20but\x20will\x20no\
    t\x20block\x20moves\x20at\x20runtime.\n\n\r\n\x05\x04#\x02\x01\x04\x12\
    \x04\xaf\n\x02\n\n\r\n\x05\x04#\x02\x01\x06\x12\x04\xaf\n\x0b\x15\n\r\n\
    \x05\x04#\x02\x01\x01\x12\x04\xaf\n\x16\x1e\n\r\n\x05\x04#\x02\x01\x03\
    \x12\x04\xaf\n!\"\nI\n\x02\x04$\x12\x06\xb3\n\0\xb6\n\x01\x1a;\x20A\x20m\
    essage\x20to\x20group\x20impacts\x20of\x20moving\x20the\x20target\x20res\
    ource.\n\n\x0b\n\x03\x04$\x01\x12\x04\xb3\n\x08\x12\nC\n\x04\x04$\x02\0\
    \x12\x04\xb5\n\x02\x14\x1a5\x20User\x20friendly\x20impact\x20detail\x20i\
    n\x20a\x20free\x20form\x20message.\n\n\r\n\x05\x04$\x02\0\x05\x12\x04\
    \xb5\n\x02\x08\n\r\n\x05\x04$\x02\0\x01\x12\x04\xb5\n\t\x0f\n\r\n\x05\
    \x04$\x02\0\x03\x12\x04\xb5\n\x12\x13\n#\n\x02\x05\0\x12\x06\xb9\n\0\xcb\
    \n\x01\x1a\x15\x20Asset\x20content\x20type.\n\n\x0b\n\x03\x05\0\x01\x12\
    \x04\xb9\n\x05\x10\n)\n\x04\x05\0\x02\0\x12\x04\xbb\n\x02\x1f\x1a\x1b\
    \x20Unspecified\x20content\x20type.\n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\
    \xbb\n\x02\x1a\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xbb\n\x1d\x1e\n\"\n\x04\
    \x05\0\x02\x01\x12\x04\xbe\n\x02\x0f\x1a\x14\x20Resource\x20metadata.\n\
    \n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xbe\n\x02\n\n\r\n\x05\x05\0\x02\x01\
    \x02\x12\x04\xbe\n\r\x0e\n8\n\x04\x05\0\x02\x02\x12\x04\xc1\n\x02\x11\
    \x1a*\x20The\x20actual\x20IAM\x20policy\x20set\x20on\x20a\x20resource.\n\
    \n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xc1\n\x02\x0c\n\r\n\x05\x05\0\x02\
    \x02\x02\x12\x04\xc1\n\x0f\x10\n>\n\x04\x05\0\x02\x03\x12\x04\xc4\n\x02\
    \x11\x1a0\x20The\x20Cloud\x20Organization\x20Policy\x20set\x20on\x20an\
    \x20asset.\n\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\xc4\n\x02\x0c\n\r\n\x05\
    \x05\0\x02\x03\x02\x12\x04\xc4\n\x0f\x10\nH\n\x04\x05\0\x02\x04\x12\x04\
    \xc7\n\x02\x14\x1a:\x20The\x20Cloud\x20Access\x20context\x20manager\x20P\
    olicy\x20set\x20on\x20an\x20asset.\n\n\r\n\x05\x05\0\x02\x04\x01\x12\x04\
    \xc7\n\x02\x0f\n\r\n\x05\x05\0\x02\x04\x02\x12\x04\xc7\n\x12\x13\n5\n\
    \x04\x05\0\x02\x05\x12\x04\xca\n\x02\x13\x1a'\x20The\x20runtime\x20OS\
    \x20Inventory\x20information.\n\n\r\n\x05\x05\0\x02\x05\x01\x12\x04\xca\
    \n\x02\x0e\n\r\n\x05\x05\0\x02\x05\x02\x12\x04\xca\n\x11\x12b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
