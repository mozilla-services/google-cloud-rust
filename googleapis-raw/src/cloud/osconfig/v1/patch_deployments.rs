// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1/patch_deployments.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct PatchDeployment {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub instance_filter: ::protobuf::SingularPtrField<super::patch_jobs::PatchInstanceFilter>,
    pub patch_config: ::protobuf::SingularPtrField<super::patch_jobs::PatchConfig>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub last_execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub rollout: ::protobuf::SingularPtrField<super::patch_jobs::PatchRollout>,
    pub state: PatchDeployment_State,
    // message oneof groups
    pub schedule: ::std::option::Option<PatchDeployment_oneof_schedule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchDeployment {
    fn default() -> &'a PatchDeployment {
        <PatchDeployment as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PatchDeployment_oneof_schedule {
    one_time_schedule(OneTimeSchedule),
    recurring_schedule(RecurringSchedule),
}

impl PatchDeployment {
    pub fn new() -> PatchDeployment {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.PatchInstanceFilter instance_filter = 3;


    pub fn get_instance_filter(&self) -> &super::patch_jobs::PatchInstanceFilter {
        self.instance_filter.as_ref().unwrap_or_else(|| <super::patch_jobs::PatchInstanceFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance_filter(&mut self) {
        self.instance_filter.clear();
    }

    pub fn has_instance_filter(&self) -> bool {
        self.instance_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_filter(&mut self, v: super::patch_jobs::PatchInstanceFilter) {
        self.instance_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_filter(&mut self) -> &mut super::patch_jobs::PatchInstanceFilter {
        if self.instance_filter.is_none() {
            self.instance_filter.set_default();
        }
        self.instance_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_filter(&mut self) -> super::patch_jobs::PatchInstanceFilter {
        self.instance_filter.take().unwrap_or_else(|| super::patch_jobs::PatchInstanceFilter::new())
    }

    // .google.cloud.osconfig.v1.PatchConfig patch_config = 4;


    pub fn get_patch_config(&self) -> &super::patch_jobs::PatchConfig {
        self.patch_config.as_ref().unwrap_or_else(|| <super::patch_jobs::PatchConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_patch_config(&mut self) {
        self.patch_config.clear();
    }

    pub fn has_patch_config(&self) -> bool {
        self.patch_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_config(&mut self, v: super::patch_jobs::PatchConfig) {
        self.patch_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_config(&mut self) -> &mut super::patch_jobs::PatchConfig {
        if self.patch_config.is_none() {
            self.patch_config.set_default();
        }
        self.patch_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_patch_config(&mut self) -> super::patch_jobs::PatchConfig {
        self.patch_config.take().unwrap_or_else(|| super::patch_jobs::PatchConfig::new())
    }

    // .google.protobuf.Duration duration = 5;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.cloud.osconfig.v1.OneTimeSchedule one_time_schedule = 6;


    pub fn get_one_time_schedule(&self) -> &OneTimeSchedule {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(ref v)) => v,
            _ => <OneTimeSchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_one_time_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_one_time_schedule(&self) -> bool {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_one_time_schedule(&mut self, v: OneTimeSchedule) {
        self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_one_time_schedule(&mut self) -> &mut OneTimeSchedule {
        if let ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(_)) = self.schedule {
        } else {
            self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(OneTimeSchedule::new()));
        }
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_one_time_schedule(&mut self) -> OneTimeSchedule {
        if self.has_one_time_schedule() {
            match self.schedule.take() {
                ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(v)) => v,
                _ => panic!(),
            }
        } else {
            OneTimeSchedule::new()
        }
    }

    // .google.cloud.osconfig.v1.RecurringSchedule recurring_schedule = 7;


    pub fn get_recurring_schedule(&self) -> &RecurringSchedule {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(ref v)) => v,
            _ => <RecurringSchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_recurring_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_recurring_schedule(&self) -> bool {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_recurring_schedule(&mut self, v: RecurringSchedule) {
        self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_recurring_schedule(&mut self) -> &mut RecurringSchedule {
        if let ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(_)) = self.schedule {
        } else {
            self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(RecurringSchedule::new()));
        }
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_recurring_schedule(&mut self) -> RecurringSchedule {
        if self.has_recurring_schedule() {
            match self.schedule.take() {
                ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(v)) => v,
                _ => panic!(),
            }
        } else {
            RecurringSchedule::new()
        }
    }

    // .google.protobuf.Timestamp create_time = 8;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 9;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp last_execute_time = 10;


    pub fn get_last_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_execute_time(&mut self) {
        self.last_execute_time.clear();
    }

    pub fn has_last_execute_time(&self) -> bool {
        self.last_execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_execute_time.is_none() {
            self.last_execute_time.set_default();
        }
        self.last_execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.cloud.osconfig.v1.PatchRollout rollout = 11;


    pub fn get_rollout(&self) -> &super::patch_jobs::PatchRollout {
        self.rollout.as_ref().unwrap_or_else(|| <super::patch_jobs::PatchRollout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout(&mut self) {
        self.rollout.clear();
    }

    pub fn has_rollout(&self) -> bool {
        self.rollout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout(&mut self, v: super::patch_jobs::PatchRollout) {
        self.rollout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout(&mut self) -> &mut super::patch_jobs::PatchRollout {
        if self.rollout.is_none() {
            self.rollout.set_default();
        }
        self.rollout.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout(&mut self) -> super::patch_jobs::PatchRollout {
        self.rollout.take().unwrap_or_else(|| super::patch_jobs::PatchRollout::new())
    }

    // .google.cloud.osconfig.v1.PatchDeployment.State state = 12;


    pub fn get_state(&self) -> PatchDeployment_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = PatchDeployment_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PatchDeployment_State) {
        self.state = v;
    }
}

impl ::protobuf::Message for PatchDeployment {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patch_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(PatchDeployment_oneof_schedule::one_time_schedule(ref v)) = self.schedule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PatchDeployment_oneof_schedule::recurring_schedule(ref v)) = self.schedule {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_filter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patch_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(is.read_message()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_execute_time)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 12, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != PatchDeployment_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(12, self.state);
        }
        if let ::std::option::Option::Some(ref v) = self.schedule {
            match v {
                &PatchDeployment_oneof_schedule::one_time_schedule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PatchDeployment_oneof_schedule::recurring_schedule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != PatchDeployment_State::STATE_UNSPECIFIED {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if let ::std::option::Option::Some(ref v) = self.schedule {
            match v {
                &PatchDeployment_oneof_schedule::one_time_schedule(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PatchDeployment_oneof_schedule::recurring_schedule(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchDeployment {
        PatchDeployment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PatchDeployment| { &m.name },
                |m: &mut PatchDeployment| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &PatchDeployment| { &m.description },
                |m: &mut PatchDeployment| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::patch_jobs::PatchInstanceFilter>>(
                "instance_filter",
                |m: &PatchDeployment| { &m.instance_filter },
                |m: &mut PatchDeployment| { &mut m.instance_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::patch_jobs::PatchConfig>>(
                "patch_config",
                |m: &PatchDeployment| { &m.patch_config },
                |m: &mut PatchDeployment| { &mut m.patch_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &PatchDeployment| { &m.duration },
                |m: &mut PatchDeployment| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OneTimeSchedule>(
                "one_time_schedule",
                PatchDeployment::has_one_time_schedule,
                PatchDeployment::get_one_time_schedule,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RecurringSchedule>(
                "recurring_schedule",
                PatchDeployment::has_recurring_schedule,
                PatchDeployment::get_recurring_schedule,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &PatchDeployment| { &m.create_time },
                |m: &mut PatchDeployment| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &PatchDeployment| { &m.update_time },
                |m: &mut PatchDeployment| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_execute_time",
                |m: &PatchDeployment| { &m.last_execute_time },
                |m: &mut PatchDeployment| { &mut m.last_execute_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::patch_jobs::PatchRollout>>(
                "rollout",
                |m: &PatchDeployment| { &m.rollout },
                |m: &mut PatchDeployment| { &mut m.rollout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PatchDeployment_State>>(
                "state",
                |m: &PatchDeployment| { &m.state },
                |m: &mut PatchDeployment| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchDeployment>(
                "PatchDeployment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchDeployment {
        static instance: ::protobuf::rt::LazyV2<PatchDeployment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchDeployment::new)
    }
}

impl ::protobuf::Clear for PatchDeployment {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.instance_filter.clear();
        self.patch_config.clear();
        self.duration.clear();
        self.schedule = ::std::option::Option::None;
        self.schedule = ::std::option::Option::None;
        self.create_time.clear();
        self.update_time.clear();
        self.last_execute_time.clear();
        self.rollout.clear();
        self.state = PatchDeployment_State::STATE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchDeployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDeployment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PatchDeployment_State {
    STATE_UNSPECIFIED = 0,
    ACTIVE = 1,
    PAUSED = 2,
}

impl ::protobuf::ProtobufEnum for PatchDeployment_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatchDeployment_State> {
        match value {
            0 => ::std::option::Option::Some(PatchDeployment_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(PatchDeployment_State::ACTIVE),
            2 => ::std::option::Option::Some(PatchDeployment_State::PAUSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PatchDeployment_State] = &[
            PatchDeployment_State::STATE_UNSPECIFIED,
            PatchDeployment_State::ACTIVE,
            PatchDeployment_State::PAUSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PatchDeployment_State>("PatchDeployment.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PatchDeployment_State {
}

impl ::std::default::Default for PatchDeployment_State {
    fn default() -> Self {
        PatchDeployment_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDeployment_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OneTimeSchedule {
    // message fields
    pub execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OneTimeSchedule {
    fn default() -> &'a OneTimeSchedule {
        <OneTimeSchedule as ::protobuf::Message>::default_instance()
    }
}

impl OneTimeSchedule {
    pub fn new() -> OneTimeSchedule {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp execute_time = 1;


    pub fn get_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execute_time(&mut self) {
        self.execute_time.clear();
    }

    pub fn has_execute_time(&self) -> bool {
        self.execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.execute_time.is_none() {
            self.execute_time.set_default();
        }
        self.execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for OneTimeSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execute_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.execute_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OneTimeSchedule {
        OneTimeSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "execute_time",
                |m: &OneTimeSchedule| { &m.execute_time },
                |m: &mut OneTimeSchedule| { &mut m.execute_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OneTimeSchedule>(
                "OneTimeSchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OneTimeSchedule {
        static instance: ::protobuf::rt::LazyV2<OneTimeSchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OneTimeSchedule::new)
    }
}

impl ::protobuf::Clear for OneTimeSchedule {
    fn clear(&mut self) {
        self.execute_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OneTimeSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OneTimeSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecurringSchedule {
    // message fields
    pub time_zone: ::protobuf::SingularPtrField<super::datetime::TimeZone>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub time_of_day: ::protobuf::SingularPtrField<super::timeofday::TimeOfDay>,
    pub frequency: RecurringSchedule_Frequency,
    pub last_execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub next_execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub schedule_config: ::std::option::Option<RecurringSchedule_oneof_schedule_config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecurringSchedule {
    fn default() -> &'a RecurringSchedule {
        <RecurringSchedule as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RecurringSchedule_oneof_schedule_config {
    weekly(WeeklySchedule),
    monthly(MonthlySchedule),
}

impl RecurringSchedule {
    pub fn new() -> RecurringSchedule {
        ::std::default::Default::default()
    }

    // .google.type.TimeZone time_zone = 1;


    pub fn get_time_zone(&self) -> &super::datetime::TimeZone {
        self.time_zone.as_ref().unwrap_or_else(|| <super::datetime::TimeZone as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_zone(&mut self) {
        self.time_zone.clear();
    }

    pub fn has_time_zone(&self) -> bool {
        self.time_zone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_zone(&mut self, v: super::datetime::TimeZone) {
        self.time_zone = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_zone(&mut self) -> &mut super::datetime::TimeZone {
        if self.time_zone.is_none() {
            self.time_zone.set_default();
        }
        self.time_zone.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_zone(&mut self) -> super::datetime::TimeZone {
        self.time_zone.take().unwrap_or_else(|| super::datetime::TimeZone::new())
    }

    // .google.protobuf.Timestamp start_time = 2;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 3;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.type.TimeOfDay time_of_day = 4;


    pub fn get_time_of_day(&self) -> &super::timeofday::TimeOfDay {
        self.time_of_day.as_ref().unwrap_or_else(|| <super::timeofday::TimeOfDay as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_of_day(&mut self) {
        self.time_of_day.clear();
    }

    pub fn has_time_of_day(&self) -> bool {
        self.time_of_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_of_day(&mut self, v: super::timeofday::TimeOfDay) {
        self.time_of_day = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_of_day(&mut self) -> &mut super::timeofday::TimeOfDay {
        if self.time_of_day.is_none() {
            self.time_of_day.set_default();
        }
        self.time_of_day.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_of_day(&mut self) -> super::timeofday::TimeOfDay {
        self.time_of_day.take().unwrap_or_else(|| super::timeofday::TimeOfDay::new())
    }

    // .google.cloud.osconfig.v1.RecurringSchedule.Frequency frequency = 5;


    pub fn get_frequency(&self) -> RecurringSchedule_Frequency {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: RecurringSchedule_Frequency) {
        self.frequency = v;
    }

    // .google.cloud.osconfig.v1.WeeklySchedule weekly = 6;


    pub fn get_weekly(&self) -> &WeeklySchedule {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(ref v)) => v,
            _ => <WeeklySchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_weekly(&mut self) {
        self.schedule_config = ::std::option::Option::None;
    }

    pub fn has_weekly(&self) -> bool {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_weekly(&mut self, v: WeeklySchedule) {
        self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(v))
    }

    // Mutable pointer to the field.
    pub fn mut_weekly(&mut self) -> &mut WeeklySchedule {
        if let ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(_)) = self.schedule_config {
        } else {
            self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(WeeklySchedule::new()));
        }
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_weekly(&mut self) -> WeeklySchedule {
        if self.has_weekly() {
            match self.schedule_config.take() {
                ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(v)) => v,
                _ => panic!(),
            }
        } else {
            WeeklySchedule::new()
        }
    }

    // .google.cloud.osconfig.v1.MonthlySchedule monthly = 7;


    pub fn get_monthly(&self) -> &MonthlySchedule {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(ref v)) => v,
            _ => <MonthlySchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_monthly(&mut self) {
        self.schedule_config = ::std::option::Option::None;
    }

    pub fn has_monthly(&self) -> bool {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_monthly(&mut self, v: MonthlySchedule) {
        self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(v))
    }

    // Mutable pointer to the field.
    pub fn mut_monthly(&mut self) -> &mut MonthlySchedule {
        if let ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(_)) = self.schedule_config {
        } else {
            self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(MonthlySchedule::new()));
        }
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_monthly(&mut self) -> MonthlySchedule {
        if self.has_monthly() {
            match self.schedule_config.take() {
                ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(v)) => v,
                _ => panic!(),
            }
        } else {
            MonthlySchedule::new()
        }
    }

    // .google.protobuf.Timestamp last_execute_time = 9;


    pub fn get_last_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_execute_time(&mut self) {
        self.last_execute_time.clear();
    }

    pub fn has_last_execute_time(&self) -> bool {
        self.last_execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_execute_time.is_none() {
            self.last_execute_time.set_default();
        }
        self.last_execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp next_execute_time = 10;


    pub fn get_next_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.next_execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_next_execute_time(&mut self) {
        self.next_execute_time.clear();
    }

    pub fn has_next_execute_time(&self) -> bool {
        self.next_execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.next_execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.next_execute_time.is_none() {
            self.next_execute_time.set_default();
        }
        self.next_execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.next_execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for RecurringSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.time_zone {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_of_day {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(RecurringSchedule_oneof_schedule_config::weekly(ref v)) = self.schedule_config {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RecurringSchedule_oneof_schedule_config::monthly(ref v)) = self.schedule_config {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.last_execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.next_execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_zone)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_of_day)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.frequency, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(is.read_message()?));
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_execute_time)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.next_execute_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time_zone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_of_day.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.frequency != RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.frequency);
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.next_execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.schedule_config {
            match v {
                &RecurringSchedule_oneof_schedule_config::weekly(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RecurringSchedule_oneof_schedule_config::monthly(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time_zone.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_of_day.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.frequency != RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.frequency))?;
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.next_execute_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.schedule_config {
            match v {
                &RecurringSchedule_oneof_schedule_config::weekly(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RecurringSchedule_oneof_schedule_config::monthly(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecurringSchedule {
        RecurringSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datetime::TimeZone>>(
                "time_zone",
                |m: &RecurringSchedule| { &m.time_zone },
                |m: &mut RecurringSchedule| { &mut m.time_zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &RecurringSchedule| { &m.start_time },
                |m: &mut RecurringSchedule| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &RecurringSchedule| { &m.end_time },
                |m: &mut RecurringSchedule| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::timeofday::TimeOfDay>>(
                "time_of_day",
                |m: &RecurringSchedule| { &m.time_of_day },
                |m: &mut RecurringSchedule| { &mut m.time_of_day },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RecurringSchedule_Frequency>>(
                "frequency",
                |m: &RecurringSchedule| { &m.frequency },
                |m: &mut RecurringSchedule| { &mut m.frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WeeklySchedule>(
                "weekly",
                RecurringSchedule::has_weekly,
                RecurringSchedule::get_weekly,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MonthlySchedule>(
                "monthly",
                RecurringSchedule::has_monthly,
                RecurringSchedule::get_monthly,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_execute_time",
                |m: &RecurringSchedule| { &m.last_execute_time },
                |m: &mut RecurringSchedule| { &mut m.last_execute_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "next_execute_time",
                |m: &RecurringSchedule| { &m.next_execute_time },
                |m: &mut RecurringSchedule| { &mut m.next_execute_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecurringSchedule>(
                "RecurringSchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecurringSchedule {
        static instance: ::protobuf::rt::LazyV2<RecurringSchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecurringSchedule::new)
    }
}

impl ::protobuf::Clear for RecurringSchedule {
    fn clear(&mut self) {
        self.time_zone.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.time_of_day.clear();
        self.frequency = RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED;
        self.schedule_config = ::std::option::Option::None;
        self.schedule_config = ::std::option::Option::None;
        self.last_execute_time.clear();
        self.next_execute_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecurringSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecurringSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RecurringSchedule_Frequency {
    FREQUENCY_UNSPECIFIED = 0,
    WEEKLY = 1,
    MONTHLY = 2,
    DAILY = 3,
}

impl ::protobuf::ProtobufEnum for RecurringSchedule_Frequency {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RecurringSchedule_Frequency> {
        match value {
            0 => ::std::option::Option::Some(RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED),
            1 => ::std::option::Option::Some(RecurringSchedule_Frequency::WEEKLY),
            2 => ::std::option::Option::Some(RecurringSchedule_Frequency::MONTHLY),
            3 => ::std::option::Option::Some(RecurringSchedule_Frequency::DAILY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RecurringSchedule_Frequency] = &[
            RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED,
            RecurringSchedule_Frequency::WEEKLY,
            RecurringSchedule_Frequency::MONTHLY,
            RecurringSchedule_Frequency::DAILY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RecurringSchedule_Frequency>("RecurringSchedule.Frequency", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RecurringSchedule_Frequency {
}

impl ::std::default::Default for RecurringSchedule_Frequency {
    fn default() -> Self {
        RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for RecurringSchedule_Frequency {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeeklySchedule {
    // message fields
    pub day_of_week: super::dayofweek::DayOfWeek,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeeklySchedule {
    fn default() -> &'a WeeklySchedule {
        <WeeklySchedule as ::protobuf::Message>::default_instance()
    }
}

impl WeeklySchedule {
    pub fn new() -> WeeklySchedule {
        ::std::default::Default::default()
    }

    // .google.type.DayOfWeek day_of_week = 1;


    pub fn get_day_of_week(&self) -> super::dayofweek::DayOfWeek {
        self.day_of_week
    }
    pub fn clear_day_of_week(&mut self) {
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_day_of_week(&mut self, v: super::dayofweek::DayOfWeek) {
        self.day_of_week = v;
    }
}

impl ::protobuf::Message for WeeklySchedule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.day_of_week, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.day_of_week);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.day_of_week))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeeklySchedule {
        WeeklySchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dayofweek::DayOfWeek>>(
                "day_of_week",
                |m: &WeeklySchedule| { &m.day_of_week },
                |m: &mut WeeklySchedule| { &mut m.day_of_week },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeeklySchedule>(
                "WeeklySchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeeklySchedule {
        static instance: ::protobuf::rt::LazyV2<WeeklySchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeeklySchedule::new)
    }
}

impl ::protobuf::Clear for WeeklySchedule {
    fn clear(&mut self) {
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeeklySchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeeklySchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonthlySchedule {
    // message oneof groups
    pub day_of_month: ::std::option::Option<MonthlySchedule_oneof_day_of_month>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonthlySchedule {
    fn default() -> &'a MonthlySchedule {
        <MonthlySchedule as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MonthlySchedule_oneof_day_of_month {
    week_day_of_month(WeekDayOfMonth),
    month_day(i32),
}

impl MonthlySchedule {
    pub fn new() -> MonthlySchedule {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.WeekDayOfMonth week_day_of_month = 1;


    pub fn get_week_day_of_month(&self) -> &WeekDayOfMonth {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v)) => v,
            _ => <WeekDayOfMonth as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_week_day_of_month(&mut self) {
        self.day_of_month = ::std::option::Option::None;
    }

    pub fn has_week_day_of_month(&self) -> bool {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_week_day_of_month(&mut self, v: WeekDayOfMonth) {
        self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(v))
    }

    // Mutable pointer to the field.
    pub fn mut_week_day_of_month(&mut self) -> &mut WeekDayOfMonth {
        if let ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(_)) = self.day_of_month {
        } else {
            self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(WeekDayOfMonth::new()));
        }
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_week_day_of_month(&mut self) -> WeekDayOfMonth {
        if self.has_week_day_of_month() {
            match self.day_of_month.take() {
                ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(v)) => v,
                _ => panic!(),
            }
        } else {
            WeekDayOfMonth::new()
        }
    }

    // int32 month_day = 2;


    pub fn get_month_day(&self) -> i32 {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_month_day(&mut self) {
        self.day_of_month = ::std::option::Option::None;
    }

    pub fn has_month_day(&self) -> bool {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_month_day(&mut self, v: i32) {
        self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(v))
    }
}

impl ::protobuf::Message for MonthlySchedule {
    fn is_initialized(&self) -> bool {
        if let Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v)) = self.day_of_month {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(is.read_int32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.day_of_month {
            match v {
                &MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MonthlySchedule_oneof_day_of_month::month_day(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.day_of_month {
            match v {
                &MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MonthlySchedule_oneof_day_of_month::month_day(v) => {
                    os.write_int32(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonthlySchedule {
        MonthlySchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WeekDayOfMonth>(
                "week_day_of_month",
                MonthlySchedule::has_week_day_of_month,
                MonthlySchedule::get_week_day_of_month,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "month_day",
                MonthlySchedule::has_month_day,
                MonthlySchedule::get_month_day,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonthlySchedule>(
                "MonthlySchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonthlySchedule {
        static instance: ::protobuf::rt::LazyV2<MonthlySchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonthlySchedule::new)
    }
}

impl ::protobuf::Clear for MonthlySchedule {
    fn clear(&mut self) {
        self.day_of_month = ::std::option::Option::None;
        self.day_of_month = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonthlySchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonthlySchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeekDayOfMonth {
    // message fields
    pub week_ordinal: i32,
    pub day_of_week: super::dayofweek::DayOfWeek,
    pub day_offset: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeekDayOfMonth {
    fn default() -> &'a WeekDayOfMonth {
        <WeekDayOfMonth as ::protobuf::Message>::default_instance()
    }
}

impl WeekDayOfMonth {
    pub fn new() -> WeekDayOfMonth {
        ::std::default::Default::default()
    }

    // int32 week_ordinal = 1;


    pub fn get_week_ordinal(&self) -> i32 {
        self.week_ordinal
    }
    pub fn clear_week_ordinal(&mut self) {
        self.week_ordinal = 0;
    }

    // Param is passed by value, moved
    pub fn set_week_ordinal(&mut self, v: i32) {
        self.week_ordinal = v;
    }

    // .google.type.DayOfWeek day_of_week = 2;


    pub fn get_day_of_week(&self) -> super::dayofweek::DayOfWeek {
        self.day_of_week
    }
    pub fn clear_day_of_week(&mut self) {
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_day_of_week(&mut self, v: super::dayofweek::DayOfWeek) {
        self.day_of_week = v;
    }

    // int32 day_offset = 3;


    pub fn get_day_offset(&self) -> i32 {
        self.day_offset
    }
    pub fn clear_day_offset(&mut self) {
        self.day_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_day_offset(&mut self, v: i32) {
        self.day_offset = v;
    }
}

impl ::protobuf::Message for WeekDayOfMonth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.week_ordinal = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.day_of_week, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.day_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.week_ordinal != 0 {
            my_size += ::protobuf::rt::value_size(1, self.week_ordinal, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.day_of_week);
        }
        if self.day_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.day_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.week_ordinal != 0 {
            os.write_int32(1, self.week_ordinal)?;
        }
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.day_of_week))?;
        }
        if self.day_offset != 0 {
            os.write_int32(3, self.day_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeekDayOfMonth {
        WeekDayOfMonth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "week_ordinal",
                |m: &WeekDayOfMonth| { &m.week_ordinal },
                |m: &mut WeekDayOfMonth| { &mut m.week_ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dayofweek::DayOfWeek>>(
                "day_of_week",
                |m: &WeekDayOfMonth| { &m.day_of_week },
                |m: &mut WeekDayOfMonth| { &mut m.day_of_week },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "day_offset",
                |m: &WeekDayOfMonth| { &m.day_offset },
                |m: &mut WeekDayOfMonth| { &mut m.day_offset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeekDayOfMonth>(
                "WeekDayOfMonth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeekDayOfMonth {
        static instance: ::protobuf::rt::LazyV2<WeekDayOfMonth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeekDayOfMonth::new)
    }
}

impl ::protobuf::Clear for WeekDayOfMonth {
    fn clear(&mut self) {
        self.week_ordinal = 0;
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
        self.day_offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeekDayOfMonth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeekDayOfMonth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreatePatchDeploymentRequest {
    // message fields
    pub parent: ::std::string::String,
    pub patch_deployment_id: ::std::string::String,
    pub patch_deployment: ::protobuf::SingularPtrField<PatchDeployment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePatchDeploymentRequest {
    fn default() -> &'a CreatePatchDeploymentRequest {
        <CreatePatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreatePatchDeploymentRequest {
    pub fn new() -> CreatePatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string patch_deployment_id = 2;


    pub fn get_patch_deployment_id(&self) -> &str {
        &self.patch_deployment_id
    }
    pub fn clear_patch_deployment_id(&mut self) {
        self.patch_deployment_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_patch_deployment_id(&mut self, v: ::std::string::String) {
        self.patch_deployment_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_deployment_id(&mut self) -> &mut ::std::string::String {
        &mut self.patch_deployment_id
    }

    // Take field
    pub fn take_patch_deployment_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.patch_deployment_id, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.PatchDeployment patch_deployment = 3;


    pub fn get_patch_deployment(&self) -> &PatchDeployment {
        self.patch_deployment.as_ref().unwrap_or_else(|| <PatchDeployment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_patch_deployment(&mut self) {
        self.patch_deployment.clear();
    }

    pub fn has_patch_deployment(&self) -> bool {
        self.patch_deployment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_deployment(&mut self, v: PatchDeployment) {
        self.patch_deployment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_deployment(&mut self) -> &mut PatchDeployment {
        if self.patch_deployment.is_none() {
            self.patch_deployment.set_default();
        }
        self.patch_deployment.as_mut().unwrap()
    }

    // Take field
    pub fn take_patch_deployment(&mut self) -> PatchDeployment {
        self.patch_deployment.take().unwrap_or_else(|| PatchDeployment::new())
    }
}

impl ::protobuf::Message for CreatePatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.patch_deployment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.patch_deployment_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patch_deployment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.patch_deployment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.patch_deployment_id);
        }
        if let Some(ref v) = self.patch_deployment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.patch_deployment_id.is_empty() {
            os.write_string(2, &self.patch_deployment_id)?;
        }
        if let Some(ref v) = self.patch_deployment.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePatchDeploymentRequest {
        CreatePatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreatePatchDeploymentRequest| { &m.parent },
                |m: &mut CreatePatchDeploymentRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "patch_deployment_id",
                |m: &CreatePatchDeploymentRequest| { &m.patch_deployment_id },
                |m: &mut CreatePatchDeploymentRequest| { &mut m.patch_deployment_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchDeployment>>(
                "patch_deployment",
                |m: &CreatePatchDeploymentRequest| { &m.patch_deployment },
                |m: &mut CreatePatchDeploymentRequest| { &mut m.patch_deployment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreatePatchDeploymentRequest>(
                "CreatePatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreatePatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<CreatePatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatePatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for CreatePatchDeploymentRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.patch_deployment_id.clear();
        self.patch_deployment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatePatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPatchDeploymentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPatchDeploymentRequest {
    fn default() -> &'a GetPatchDeploymentRequest {
        <GetPatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPatchDeploymentRequest {
    pub fn new() -> GetPatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPatchDeploymentRequest {
        GetPatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetPatchDeploymentRequest| { &m.name },
                |m: &mut GetPatchDeploymentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPatchDeploymentRequest>(
                "GetPatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetPatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<GetPatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for GetPatchDeploymentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchDeploymentsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchDeploymentsRequest {
    fn default() -> &'a ListPatchDeploymentsRequest {
        <ListPatchDeploymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchDeploymentsRequest {
    pub fn new() -> ListPatchDeploymentsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchDeploymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchDeploymentsRequest {
        ListPatchDeploymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListPatchDeploymentsRequest| { &m.parent },
                |m: &mut ListPatchDeploymentsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListPatchDeploymentsRequest| { &m.page_size },
                |m: &mut ListPatchDeploymentsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListPatchDeploymentsRequest| { &m.page_token },
                |m: &mut ListPatchDeploymentsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchDeploymentsRequest>(
                "ListPatchDeploymentsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchDeploymentsRequest {
        static instance: ::protobuf::rt::LazyV2<ListPatchDeploymentsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchDeploymentsRequest::new)
    }
}

impl ::protobuf::Clear for ListPatchDeploymentsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchDeploymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchDeploymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchDeploymentsResponse {
    // message fields
    pub patch_deployments: ::protobuf::RepeatedField<PatchDeployment>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchDeploymentsResponse {
    fn default() -> &'a ListPatchDeploymentsResponse {
        <ListPatchDeploymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchDeploymentsResponse {
    pub fn new() -> ListPatchDeploymentsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1.PatchDeployment patch_deployments = 1;


    pub fn get_patch_deployments(&self) -> &[PatchDeployment] {
        &self.patch_deployments
    }
    pub fn clear_patch_deployments(&mut self) {
        self.patch_deployments.clear();
    }

    // Param is passed by value, moved
    pub fn set_patch_deployments(&mut self, v: ::protobuf::RepeatedField<PatchDeployment>) {
        self.patch_deployments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patch_deployments(&mut self) -> &mut ::protobuf::RepeatedField<PatchDeployment> {
        &mut self.patch_deployments
    }

    // Take field
    pub fn take_patch_deployments(&mut self) -> ::protobuf::RepeatedField<PatchDeployment> {
        ::std::mem::replace(&mut self.patch_deployments, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchDeploymentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.patch_deployments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patch_deployments)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patch_deployments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patch_deployments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchDeploymentsResponse {
        ListPatchDeploymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchDeployment>>(
                "patch_deployments",
                |m: &ListPatchDeploymentsResponse| { &m.patch_deployments },
                |m: &mut ListPatchDeploymentsResponse| { &mut m.patch_deployments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListPatchDeploymentsResponse| { &m.next_page_token },
                |m: &mut ListPatchDeploymentsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchDeploymentsResponse>(
                "ListPatchDeploymentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchDeploymentsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPatchDeploymentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchDeploymentsResponse::new)
    }
}

impl ::protobuf::Clear for ListPatchDeploymentsResponse {
    fn clear(&mut self) {
        self.patch_deployments.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchDeploymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchDeploymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePatchDeploymentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePatchDeploymentRequest {
    fn default() -> &'a DeletePatchDeploymentRequest {
        <DeletePatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePatchDeploymentRequest {
    pub fn new() -> DeletePatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeletePatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePatchDeploymentRequest {
        DeletePatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeletePatchDeploymentRequest| { &m.name },
                |m: &mut DeletePatchDeploymentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeletePatchDeploymentRequest>(
                "DeletePatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeletePatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<DeletePatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeletePatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for DeletePatchDeploymentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePatchDeploymentRequest {
    // message fields
    pub patch_deployment: ::protobuf::SingularPtrField<PatchDeployment>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePatchDeploymentRequest {
    fn default() -> &'a UpdatePatchDeploymentRequest {
        <UpdatePatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePatchDeploymentRequest {
    pub fn new() -> UpdatePatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.PatchDeployment patch_deployment = 1;


    pub fn get_patch_deployment(&self) -> &PatchDeployment {
        self.patch_deployment.as_ref().unwrap_or_else(|| <PatchDeployment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_patch_deployment(&mut self) {
        self.patch_deployment.clear();
    }

    pub fn has_patch_deployment(&self) -> bool {
        self.patch_deployment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_deployment(&mut self, v: PatchDeployment) {
        self.patch_deployment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_deployment(&mut self) -> &mut PatchDeployment {
        if self.patch_deployment.is_none() {
            self.patch_deployment.set_default();
        }
        self.patch_deployment.as_mut().unwrap()
    }

    // Take field
    pub fn take_patch_deployment(&mut self) -> PatchDeployment {
        self.patch_deployment.take().unwrap_or_else(|| PatchDeployment::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdatePatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.patch_deployment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patch_deployment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.patch_deployment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.patch_deployment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePatchDeploymentRequest {
        UpdatePatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchDeployment>>(
                "patch_deployment",
                |m: &UpdatePatchDeploymentRequest| { &m.patch_deployment },
                |m: &mut UpdatePatchDeploymentRequest| { &mut m.patch_deployment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdatePatchDeploymentRequest| { &m.update_mask },
                |m: &mut UpdatePatchDeploymentRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdatePatchDeploymentRequest>(
                "UpdatePatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdatePatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<UpdatePatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdatePatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for UpdatePatchDeploymentRequest {
    fn clear(&mut self) {
        self.patch_deployment.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PausePatchDeploymentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PausePatchDeploymentRequest {
    fn default() -> &'a PausePatchDeploymentRequest {
        <PausePatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl PausePatchDeploymentRequest {
    pub fn new() -> PausePatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PausePatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PausePatchDeploymentRequest {
        PausePatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PausePatchDeploymentRequest| { &m.name },
                |m: &mut PausePatchDeploymentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PausePatchDeploymentRequest>(
                "PausePatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PausePatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<PausePatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PausePatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for PausePatchDeploymentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PausePatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PausePatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResumePatchDeploymentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResumePatchDeploymentRequest {
    fn default() -> &'a ResumePatchDeploymentRequest {
        <ResumePatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResumePatchDeploymentRequest {
    pub fn new() -> ResumePatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResumePatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResumePatchDeploymentRequest {
        ResumePatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ResumePatchDeploymentRequest| { &m.name },
                |m: &mut ResumePatchDeploymentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResumePatchDeploymentRequest>(
                "ResumePatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResumePatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<ResumePatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResumePatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for ResumePatchDeploymentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResumePatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumePatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n0google/cloud/osconfig/v1/patch_deployments.proto\x12\x18google.cloud.\
    osconfig.v1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/res\
    ource.proto\x1a)google/cloud/osconfig/v1/patch_jobs.proto\x1a\x1egoogle/\
    protobuf/duration.proto\x1a\x20google/protobuf/field_mask.proto\x1a\x1fg\
    oogle/protobuf/timestamp.proto\x1a\x1agoogle/type/datetime.proto\x1a\x1b\
    google/type/dayofweek.proto\x1a\x1bgoogle/type/timeofday.proto\"\x83\x08\
    \n\x0fPatchDeployment\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12%\
    \n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescriptionB\x03\xe0A\x01\x12[\
    \n\x0finstance_filter\x18\x03\x20\x01(\x0b2-.google.cloud.osconfig.v1.Pa\
    tchInstanceFilterR\x0einstanceFilterB\x03\xe0A\x02\x12M\n\x0cpatch_confi\
    g\x18\x04\x20\x01(\x0b2%.google.cloud.osconfig.v1.PatchConfigR\x0bpatchC\
    onfigB\x03\xe0A\x01\x12:\n\x08duration\x18\x05\x20\x01(\x0b2\x19.google.\
    protobuf.DurationR\x08durationB\x03\xe0A\x01\x12\\\n\x11one_time_schedul\
    e\x18\x06\x20\x01(\x0b2).google.cloud.osconfig.v1.OneTimeScheduleH\0R\
    \x0foneTimeScheduleB\x03\xe0A\x02\x12a\n\x12recurring_schedule\x18\x07\
    \x20\x01(\x0b2+.google.cloud.osconfig.v1.RecurringScheduleH\0R\x11recurr\
    ingScheduleB\x03\xe0A\x02\x12@\n\x0bcreate_time\x18\x08\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\ncreateTimeB\x03\xe0A\x03\x12@\n\x0bupda\
    te_time\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nupdateTimeB\
    \x03\xe0A\x03\x12K\n\x11last_execute_time\x18\n\x20\x01(\x0b2\x1a.google\
    .protobuf.TimestampR\x0flastExecuteTimeB\x03\xe0A\x03\x12E\n\x07rollout\
    \x18\x0b\x20\x01(\x0b2&.google.cloud.osconfig.v1.PatchRolloutR\x07rollou\
    tB\x03\xe0A\x01\x12J\n\x05state\x18\x0c\x20\x01(\x0e2/.google.cloud.osco\
    nfig.v1.PatchDeployment.StateR\x05stateB\x03\xe0A\x03\"6\n\x05State\x12\
    \x15\n\x11STATE_UNSPECIFIED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\n\n\x06P\
    AUSED\x10\x02B\n\n\x08schedule:d\xeaAa\n'osconfig.googleapis.com/PatchDe\
    ployment\x126projects/{project}/patchDeployments/{patch_deployment}\"U\n\
    \x0fOneTimeSchedule\x12B\n\x0cexecute_time\x18\x01\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\x0bexecuteTimeB\x03\xe0A\x02\"\xed\x05\n\x11Recu\
    rringSchedule\x127\n\ttime_zone\x18\x01\x20\x01(\x0b2\x15.google.type.Ti\
    meZoneR\x08timeZoneB\x03\xe0A\x02\x12>\n\nstart_time\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\tstartTimeB\x03\xe0A\x01\x12:\n\x08\
    end_time\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTime\
    B\x03\xe0A\x01\x12;\n\x0btime_of_day\x18\x04\x20\x01(\x0b2\x16.google.ty\
    pe.TimeOfDayR\ttimeOfDayB\x03\xe0A\x02\x12X\n\tfrequency\x18\x05\x20\x01\
    (\x0e25.google.cloud.osconfig.v1.RecurringSchedule.FrequencyR\tfrequency\
    B\x03\xe0A\x02\x12G\n\x06weekly\x18\x06\x20\x01(\x0b2(.google.cloud.osco\
    nfig.v1.WeeklyScheduleH\0R\x06weeklyB\x03\xe0A\x02\x12J\n\x07monthly\x18\
    \x07\x20\x01(\x0b2).google.cloud.osconfig.v1.MonthlyScheduleH\0R\x07mont\
    hlyB\x03\xe0A\x02\x12K\n\x11last_execute_time\x18\t\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.TimestampR\x0flastExecuteTimeB\x03\xe0A\x03\x12K\n\x11next\
    _execute_time\x18\n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0fnext\
    ExecuteTimeB\x03\xe0A\x03\"J\n\tFrequency\x12\x19\n\x15FREQUENCY_UNSPECI\
    FIED\x10\0\x12\n\n\x06WEEKLY\x10\x01\x12\x0b\n\x07MONTHLY\x10\x02\x12\t\
    \n\x05DAILY\x10\x03B\x11\n\x0fschedule_config\"M\n\x0eWeeklySchedule\x12\
    ;\n\x0bday_of_week\x18\x01\x20\x01(\x0e2\x16.google.type.DayOfWeekR\tday\
    OfWeekB\x03\xe0A\x02\"\xa1\x01\n\x0fMonthlySchedule\x12Z\n\x11week_day_o\
    f_month\x18\x01\x20\x01(\x0b2(.google.cloud.osconfig.v1.WeekDayOfMonthH\
    \0R\x0eweekDayOfMonthB\x03\xe0A\x02\x12\"\n\tmonth_day\x18\x02\x20\x01(\
    \x05H\0R\x08monthDayB\x03\xe0A\x02B\x0e\n\x0cday_of_month\"\x99\x01\n\
    \x0eWeekDayOfMonth\x12&\n\x0cweek_ordinal\x18\x01\x20\x01(\x05R\x0bweekO\
    rdinalB\x03\xe0A\x02\x12;\n\x0bday_of_week\x18\x02\x20\x01(\x0e2\x16.goo\
    gle.type.DayOfWeekR\tdayOfWeekB\x03\xe0A\x02\x12\"\n\nday_offset\x18\x03\
    \x20\x01(\x05R\tdayOffsetB\x03\xe0A\x01\"\xfb\x01\n\x1cCreatePatchDeploy\
    mentRequest\x12K\n\x06parent\x18\x01\x20\x01(\tR\x06parentB3\xfaA-\n+clo\
    udresourcemanager.googleapis.com/Project\xe0A\x02\x123\n\x13patch_deploy\
    ment_id\x18\x02\x20\x01(\tR\x11patchDeploymentIdB\x03\xe0A\x02\x12Y\n\
    \x10patch_deployment\x18\x03\x20\x01(\x0b2).google.cloud.osconfig.v1.Pat\
    chDeploymentR\x0fpatchDeploymentB\x03\xe0A\x02\"`\n\x19GetPatchDeploymen\
    tRequest\x12C\n\x04name\x18\x01\x20\x01(\tR\x04nameB/\xfaA)\n'osconfig.g\
    oogleapis.com/PatchDeployment\xe0A\x02\"\xb0\x01\n\x1bListPatchDeploymen\
    tsRequest\x12K\n\x06parent\x18\x01\x20\x01(\tR\x06parentB3\xfaA-\n+cloud\
    resourcemanager.googleapis.com/Project\xe0A\x02\x12\x20\n\tpage_size\x18\
    \x02\x20\x01(\x05R\x08pageSizeB\x03\xe0A\x01\x12\"\n\npage_token\x18\x03\
    \x20\x01(\tR\tpageTokenB\x03\xe0A\x01\"\x9e\x01\n\x1cListPatchDeployment\
    sResponse\x12V\n\x11patch_deployments\x18\x01\x20\x03(\x0b2).google.clou\
    d.osconfig.v1.PatchDeploymentR\x10patchDeployments\x12&\n\x0fnext_page_t\
    oken\x18\x02\x20\x01(\tR\rnextPageToken\"c\n\x1cDeletePatchDeploymentReq\
    uest\x12C\n\x04name\x18\x01\x20\x01(\tR\x04nameB/\xfaA)\n'osconfig.googl\
    eapis.com/PatchDeployment\xe0A\x02\"\xbb\x01\n\x1cUpdatePatchDeploymentR\
    equest\x12Y\n\x10patch_deployment\x18\x01\x20\x01(\x0b2).google.cloud.os\
    config.v1.PatchDeploymentR\x0fpatchDeploymentB\x03\xe0A\x02\x12@\n\x0bup\
    date_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMa\
    skB\x03\xe0A\x01\"b\n\x1bPausePatchDeploymentRequest\x12C\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB/\xfaA)\n'osconfig.googleapis.com/PatchDeployme\
    nt\xe0A\x02\"c\n\x1cResumePatchDeploymentRequest\x12C\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB/\xfaA)\n'osconfig.googleapis.com/PatchDeployment\
    \xe0A\x02B\xbe\x01\n\x1ccom.google.cloud.osconfig.v1B\x10PatchDeployment\
    sZ8cloud.google.com/go/osconfig/apiv1/osconfigpb;osconfigpb\xaa\x02\x18G\
    oogle.Cloud.OsConfig.V1\xca\x02\x18Google\\Cloud\\OsConfig\\V1\xea\x02\
    \x1bGoogle::Cloud::OsConfig::V1J\x88]\n\x07\x12\x05\x0e\0\xd2\x02\x01\n\
    \xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202020\x20Go\
    ogle\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ver\
    sion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20th\
    is\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0!\n\t\n\x02\x03\0\
    \x12\x03\x12\0)\n\t\n\x02\x03\x01\x12\x03\x13\0#\n\t\n\x02\x03\x02\x12\
    \x03\x14\03\n\t\n\x02\x03\x03\x12\x03\x15\0(\n\t\n\x02\x03\x04\x12\x03\
    \x16\0*\n\t\n\x02\x03\x05\x12\x03\x17\0)\n\t\n\x02\x03\x06\x12\x03\x18\0\
    $\n\t\n\x02\x03\x07\x12\x03\x19\0%\n\t\n\x02\x03\x08\x12\x03\x1a\0%\n\
    \x08\n\x01\x08\x12\x03\x1c\05\n\t\n\x02\x08%\x12\x03\x1c\05\n\x08\n\x01\
    \x08\x12\x03\x1d\0O\n\t\n\x02\x08\x0b\x12\x03\x1d\0O\n\x08\n\x01\x08\x12\
    \x03\x1e\01\n\t\n\x02\x08\x08\x12\x03\x1e\01\n\x08\n\x01\x08\x12\x03\x1f\
    \05\n\t\n\x02\x08\x01\x12\x03\x1f\05\n\x08\n\x01\x08\x12\x03\x20\05\n\t\
    \n\x02\x08)\x12\x03\x20\05\n\x08\n\x01\x08\x12\x03!\04\n\t\n\x02\x08-\
    \x12\x03!\04\n\xf6\x02\n\x02\x04\0\x12\x04(\0q\x01\x1a\xe9\x02\x20Patch\
    \x20deployments\x20are\x20configurations\x20that\x20individual\x20patch\
    \x20jobs\x20use\x20to\n\x20complete\x20a\x20patch.\x20These\x20configura\
    tions\x20include\x20instance\x20filter,\x20package\n\x20repository\x20se\
    ttings,\x20and\x20a\x20schedule.\x20For\x20more\x20information\x20about\
    \x20creating\x20and\n\x20managing\x20patch\x20deployments,\x20see\x20[Sc\
    heduling\x20patch\n\x20jobs](https://cloud.google.com/compute/docs/os-pa\
    tch-management/schedule-patch-jobs).\n\n\n\n\x03\x04\0\x01\x12\x03(\x08\
    \x17\n\x0b\n\x03\x04\0\x07\x12\x04)\x02,\x04\n\r\n\x05\x04\0\x07\x9d\x08\
    \x12\x04)\x02,\x04\n5\n\x04\x04\0\x04\0\x12\x04/\x029\x03\x1a'\x20Repres\
    ents\x20state\x20of\x20patch\x20peployment.\n\n\x0c\n\x05\x04\0\x04\0\
    \x01\x12\x03/\x07\x0c\nO\n\x06\x04\0\x04\0\x02\0\x12\x031\x04\x1a\x1a@\
    \x20The\x20default\x20value.\x20This\x20value\x20is\x20used\x20if\x20the\
    \x20state\x20is\x20omitted.\n\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x031\
    \x04\x15\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x031\x18\x19\nO\n\x06\x04\
    \0\x04\0\x02\x01\x12\x034\x04\x0f\x1a@\x20Active\x20value\x20means\x20th\
    at\x20patch\x20deployment\x20generates\x20Patch\x20Jobs.\n\n\x0e\n\x07\
    \x04\0\x04\0\x02\x01\x01\x12\x034\x04\n\n\x0e\n\x07\x04\0\x04\0\x02\x01\
    \x02\x12\x034\r\x0e\n\x92\x01\n\x06\x04\0\x04\0\x02\x02\x12\x038\x04\x0f\
    \x1a\x82\x01\x20Paused\x20value\x20means\x20that\x20patch\x20deployment\
    \x20does\x20not\x20generate\n\x20Patch\x20jobs.\x20Requires\x20user\x20a\
    ction\x20to\x20move\x20in\x20and\x20out\x20from\x20this\x20state.\n\n\
    \x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x038\x04\n\n\x0e\n\x07\x04\0\x04\
    \0\x02\x02\x02\x12\x038\r\x0e\n\xf6\x01\n\x04\x04\0\x02\0\x12\x03?\x02\
    \x12\x1a\xe8\x01\x20Unique\x20name\x20for\x20the\x20patch\x20deployment\
    \x20resource\x20in\x20a\x20project.\x20The\x20patch\n\x20deployment\x20n\
    ame\x20is\x20in\x20the\x20form:\n\x20`projects/{project_id}/patchDeploym\
    ents/{patch_deployment_id}`.\n\x20This\x20field\x20is\x20ignored\x20when\
    \x20you\x20create\x20a\x20new\x20patch\x20deployment.\n\n\x0c\n\x05\x04\
    \0\x02\0\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03?\t\r\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03?\x10\x11\nw\n\x04\x04\0\x02\x01\x12\
    \x03C\x02B\x1aj\x20Optional.\x20Description\x20of\x20the\x20patch\x20dep\
    loyment.\x20Length\x20of\x20the\x20description\x20is\n\x20limited\x20to\
    \x201024\x20characters.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03C\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03C\t\x14\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03C\x17\x18\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03C\x19A\n\x0f\
    \n\x08\x04\0\x02\x01\x08\x9c\x08\0\x12\x03C\x1a@\n0\n\x04\x04\0\x02\x02\
    \x12\x04F\x02G/\x1a\"\x20Required.\x20VM\x20instances\x20to\x20patch.\n\
    \n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03F\x02\x15\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03F\x16%\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03F()\n\x0c\n\
    \x05\x04\0\x02\x02\x08\x12\x03G\x06.\n\x0f\n\x08\x04\0\x02\x02\x08\x9c\
    \x08\0\x12\x03G\x07-\n=\n\x04\x04\0\x02\x03\x12\x03J\x02H\x1a0\x20Option\
    al.\x20Patch\x20configuration\x20that\x20is\x20applied.\n\n\x0c\n\x05\
    \x04\0\x02\x03\x06\x12\x03J\x02\r\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03J\
    \x0e\x1a\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03J\x1d\x1e\n\x0c\n\x05\x04\
    \0\x02\x03\x08\x12\x03J\x1fG\n\x0f\n\x08\x04\0\x02\x03\x08\x9c\x08\0\x12\
    \x03J\x20F\n_\n\x04\x04\0\x02\x04\x12\x04N\x02O/\x1aQ\x20Optional.\x20Du\
    ration\x20of\x20the\x20patch.\x20After\x20the\x20duration\x20ends,\x20th\
    e\x20patch\x20times\n\x20out.\n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03N\
    \x02\x1a\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03N\x1b#\n\x0c\n\x05\x04\0\
    \x02\x04\x03\x12\x03N&'\n\x0c\n\x05\x04\0\x02\x04\x08\x12\x03O\x06.\n\
    \x0f\n\x08\x04\0\x02\x04\x08\x9c\x08\0\x12\x03O\x07-\n'\n\x04\x04\0\x08\
    \0\x12\x04R\x02Z\x03\x1a\x19\x20Schedule\x20for\x20the\x20patch.\n\n\x0c\
    \n\x05\x04\0\x08\0\x01\x12\x03R\x08\x10\n8\n\x04\x04\0\x02\x05\x12\x04T\
    \x04U1\x1a*\x20Required.\x20Schedule\x20a\x20one-time\x20execution.\n\n\
    \x0c\n\x05\x04\0\x02\x05\x06\x12\x03T\x04\x13\n\x0c\n\x05\x04\0\x02\x05\
    \x01\x12\x03T\x14%\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03T()\n\x0c\n\x05\
    \x04\0\x02\x05\x08\x12\x03U\x080\n\x0f\n\x08\x04\0\x02\x05\x08\x9c\x08\0\
    \x12\x03U\t/\n8\n\x04\x04\0\x02\x06\x12\x04X\x04Y1\x1a*\x20Required.\x20\
    Schedule\x20recurring\x20executions.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\
    \x03X\x04\x15\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03X\x16(\n\x0c\n\x05\
    \x04\0\x02\x06\x03\x12\x03X+,\n\x0c\n\x05\x04\0\x02\x06\x08\x12\x03Y\x08\
    0\n\x0f\n\x08\x04\0\x02\x06\x08\x9c\x08\0\x12\x03Y\t/\n\x92\x01\n\x04\
    \x04\0\x02\x07\x12\x04^\x02_2\x1a\x83\x01\x20Output\x20only.\x20Time\x20\
    the\x20patch\x20deployment\x20was\x20created.\x20Timestamp\x20is\x20in\n\
    \x20[RFC3339](https://www.ietf.org/rfc/rfc3339.txt)\x20text\x20format.\n\
    \n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03^\x02\x1b\n\x0c\n\x05\x04\0\x02\
    \x07\x01\x12\x03^\x1c'\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03^*+\n\x0c\n\
    \x05\x04\0\x02\x07\x08\x12\x03_\x061\n\x0f\n\x08\x04\0\x02\x07\x08\x9c\
    \x08\0\x12\x03_\x070\n\x97\x01\n\x04\x04\0\x02\x08\x12\x04c\x02d2\x1a\
    \x88\x01\x20Output\x20only.\x20Time\x20the\x20patch\x20deployment\x20was\
    \x20last\x20updated.\x20Timestamp\x20is\x20in\n\x20[RFC3339](https://www\
    .ietf.org/rfc/rfc3339.txt)\x20text\x20format.\n\n\x0c\n\x05\x04\0\x02\
    \x08\x06\x12\x03c\x02\x1b\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03c\x1c'\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x03c*+\n\x0c\n\x05\x04\0\x02\x08\x08\
    \x12\x03d\x061\n\x0f\n\x08\x04\0\x02\x08\x08\x9c\x08\0\x12\x03d\x070\n\
    \xa6\x01\n\x04\x04\0\x02\t\x12\x04i\x02j2\x1a\x97\x01\x20Output\x20only.\
    \x20The\x20last\x20time\x20a\x20patch\x20job\x20was\x20started\x20by\x20\
    this\x20deployment.\n\x20Timestamp\x20is\x20in\x20[RFC3339](https://www.\
    ietf.org/rfc/rfc3339.txt)\x20text\n\x20format.\n\n\x0c\n\x05\x04\0\x02\t\
    \x06\x12\x03i\x02\x1b\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03i\x1c-\n\x0c\n\
    \x05\x04\0\x02\t\x03\x12\x03i02\n\x0c\n\x05\x04\0\x02\t\x08\x12\x03j\x06\
    1\n\x0f\n\x08\x04\0\x02\t\x08\x9c\x08\0\x12\x03j\x070\n;\n\x04\x04\0\x02\
    \n\x12\x03m\x02E\x1a.\x20Optional.\x20Rollout\x20strategy\x20of\x20the\
    \x20patch\x20job.\n\n\x0c\n\x05\x04\0\x02\n\x06\x12\x03m\x02\x0e\n\x0c\n\
    \x05\x04\0\x02\n\x01\x12\x03m\x0f\x16\n\x0c\n\x05\x04\0\x02\n\x03\x12\
    \x03m\x19\x1b\n\x0c\n\x05\x04\0\x02\n\x08\x12\x03m\x1cD\n\x0f\n\x08\x04\
    \0\x02\n\x08\x9c\x08\0\x12\x03m\x1dC\nB\n\x04\x04\0\x02\x0b\x12\x03p\x02\
    ?\x1a5\x20Output\x20only.\x20Current\x20state\x20of\x20the\x20patch\x20d\
    eployment.\n\n\x0c\n\x05\x04\0\x02\x0b\x06\x12\x03p\x02\x07\n\x0c\n\x05\
    \x04\0\x02\x0b\x01\x12\x03p\x08\r\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03p\
    \x10\x12\n\x0c\n\x05\x04\0\x02\x0b\x08\x12\x03p\x13>\n\x0f\n\x08\x04\0\
    \x02\x0b\x08\x9c\x08\0\x12\x03p\x14=\n\x8a\x01\n\x02\x04\x01\x12\x04u\0y\
    \x01\x1a~\x20Sets\x20the\x20time\x20for\x20a\x20one\x20time\x20patch\x20\
    deployment.\x20Timestamp\x20is\x20in\n\x20[RFC3339](https://www.ietf.org\
    /rfc/rfc3339.txt)\x20text\x20format.\n\n\n\n\x03\x04\x01\x01\x12\x03u\
    \x08\x17\n?\n\x04\x04\x01\x02\0\x12\x04w\x02x/\x1a1\x20Required.\x20The\
    \x20desired\x20patch\x20job\x20execution\x20time.\n\n\x0c\n\x05\x04\x01\
    \x02\0\x06\x12\x03w\x02\x1b\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03w\x1c(\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03w+,\n\x0c\n\x05\x04\x01\x02\0\x08\
    \x12\x03x\x06.\n\x0f\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\x03x\x07-\n=\
    \n\x02\x04\x02\x12\x05|\0\xb5\x01\x01\x1a0\x20Sets\x20the\x20time\x20for\
    \x20recurring\x20patch\x20deployments.\n\n\n\n\x03\x04\x02\x01\x12\x03|\
    \x08\x19\nL\n\x04\x04\x02\x04\0\x12\x05~\x02\x8d\x01\x03\x1a=\x20Specifi\
    es\x20the\x20frequency\x20of\x20the\x20recurring\x20patch\x20deployments\
    .\n\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03~\x07\x10\n9\n\x06\x04\x02\x04\
    \0\x02\0\x12\x04\x80\x01\x04\x1e\x1a)\x20Invalid.\x20A\x20frequency\x20m\
    ust\x20be\x20specified.\n\n\x0f\n\x07\x04\x02\x04\0\x02\0\x01\x12\x04\
    \x80\x01\x04\x19\n\x0f\n\x07\x04\x02\x04\0\x02\0\x02\x12\x04\x80\x01\x1c\
    \x1d\nd\n\x06\x04\x02\x04\0\x02\x01\x12\x04\x84\x01\x04\x0f\x1aT\x20Indi\
    cates\x20that\x20the\x20frequency\x20of\x20recurrence\x20should\x20be\
    \x20expressed\x20in\x20terms\n\x20of\x20weeks.\n\n\x0f\n\x07\x04\x02\x04\
    \0\x02\x01\x01\x12\x04\x84\x01\x04\n\n\x0f\n\x07\x04\x02\x04\0\x02\x01\
    \x02\x12\x04\x84\x01\r\x0e\ne\n\x06\x04\x02\x04\0\x02\x02\x12\x04\x88\
    \x01\x04\x10\x1aU\x20Indicates\x20that\x20the\x20frequency\x20of\x20recu\
    rrence\x20should\x20be\x20expressed\x20in\x20terms\n\x20of\x20months.\n\
    \n\x0f\n\x07\x04\x02\x04\0\x02\x02\x01\x12\x04\x88\x01\x04\x0b\n\x0f\n\
    \x07\x04\x02\x04\0\x02\x02\x02\x12\x04\x88\x01\x0e\x0f\nc\n\x06\x04\x02\
    \x04\0\x02\x03\x12\x04\x8c\x01\x04\x0e\x1aS\x20Indicates\x20that\x20the\
    \x20frequency\x20of\x20recurrence\x20should\x20be\x20expressed\x20in\x20\
    terms\n\x20of\x20days.\n\n\x0f\n\x07\x04\x02\x04\0\x02\x03\x01\x12\x04\
    \x8c\x01\x04\t\n\x0f\n\x07\x04\x02\x04\0\x02\x03\x02\x12\x04\x8c\x01\x0c\
    \r\n\x9f\x01\n\x04\x04\x02\x02\0\x12\x04\x91\x01\x02N\x1a\x90\x01\x20Req\
    uired.\x20Defines\x20the\x20time\x20zone\x20that\x20`time_of_day`\x20is\
    \x20relative\x20to.\n\x20The\x20rules\x20for\x20daylight\x20saving\x20ti\
    me\x20are\x20determined\x20by\x20the\x20chosen\x20time\x20zone.\n\n\r\n\
    \x05\x04\x02\x02\0\x06\x12\x04\x91\x01\x02\x16\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\x91\x01\x17\x20\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x91\x01\
    #$\n\r\n\x05\x04\x02\x02\0\x08\x12\x04\x91\x01%M\n\x10\n\x08\x04\x02\x02\
    \0\x08\x9c\x08\0\x12\x04\x91\x01&L\n\x87\x01\n\x04\x04\x02\x02\x01\x12\
    \x06\x95\x01\x02\x96\x01/\x1aw\x20Optional.\x20The\x20time\x20that\x20th\
    e\x20recurring\x20schedule\x20becomes\x20effective.\n\x20Defaults\x20to\
    \x20`create_time`\x20of\x20the\x20patch\x20deployment.\n\n\r\n\x05\x04\
    \x02\x02\x01\x06\x12\x04\x95\x01\x02\x1b\n\r\n\x05\x04\x02\x02\x01\x01\
    \x12\x04\x95\x01\x1c&\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x95\x01)*\n\
    \r\n\x05\x04\x02\x02\x01\x08\x12\x04\x96\x01\x06.\n\x10\n\x08\x04\x02\
    \x02\x01\x08\x9c\x08\0\x12\x04\x96\x01\x07-\nm\n\x04\x04\x02\x02\x02\x12\
    \x06\x9a\x01\x02\x9b\x01/\x1a]\x20Optional.\x20The\x20end\x20time\x20at\
    \x20which\x20a\x20recurring\x20patch\x20deployment\x20schedule\x20is\x20\
    no\n\x20longer\x20active.\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\x9a\
    \x01\x02\x1b\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x9a\x01\x1c$\n\r\n\
    \x05\x04\x02\x02\x02\x03\x12\x04\x9a\x01'(\n\r\n\x05\x04\x02\x02\x02\x08\
    \x12\x04\x9b\x01\x06.\n\x10\n\x08\x04\x02\x02\x02\x08\x9c\x08\0\x12\x04\
    \x9b\x01\x07-\nJ\n\x04\x04\x02\x02\x03\x12\x06\x9e\x01\x02\x9f\x01/\x1a:\
    \x20Required.\x20Time\x20of\x20the\x20day\x20to\x20run\x20a\x20recurring\
    \x20deployment.\n\n\r\n\x05\x04\x02\x02\x03\x06\x12\x04\x9e\x01\x02\x17\
    \n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\x9e\x01\x18#\n\r\n\x05\x04\x02\
    \x02\x03\x03\x12\x04\x9e\x01&'\n\r\n\x05\x04\x02\x02\x03\x08\x12\x04\x9f\
    \x01\x06.\n\x10\n\x08\x04\x02\x02\x03\x08\x9c\x08\0\x12\x04\x9f\x01\x07-\
    \nH\n\x04\x04\x02\x02\x04\x12\x04\xa2\x01\x02C\x1a:\x20Required.\x20The\
    \x20frequency\x20unit\x20of\x20this\x20recurring\x20schedule.\n\n\r\n\
    \x05\x04\x02\x02\x04\x06\x12\x04\xa2\x01\x02\x0b\n\r\n\x05\x04\x02\x02\
    \x04\x01\x12\x04\xa2\x01\x0c\x15\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\
    \xa2\x01\x18\x19\n\r\n\x05\x04\x02\x02\x04\x08\x12\x04\xa2\x01\x1aB\n\
    \x10\n\x08\x04\x02\x02\x04\x08\x9c\x08\0\x12\x04\xa2\x01\x1bA\nc\n\x04\
    \x04\x02\x08\0\x12\x06\xa6\x01\x02\xac\x01\x03\x1aS\x20Configurations\
    \x20for\x20this\x20recurring\x20schedule.\n\x20Configurations\x20must\
    \x20match\x20frequency.\n\n\r\n\x05\x04\x02\x08\0\x01\x12\x04\xa6\x01\
    \x08\x17\n:\n\x04\x04\x02\x02\x05\x12\x04\xa8\x01\x04G\x1a,\x20Required.\
    \x20Schedule\x20with\x20weekly\x20executions.\n\n\r\n\x05\x04\x02\x02\
    \x05\x06\x12\x04\xa8\x01\x04\x12\n\r\n\x05\x04\x02\x02\x05\x01\x12\x04\
    \xa8\x01\x13\x19\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\xa8\x01\x1c\x1d\n\
    \r\n\x05\x04\x02\x02\x05\x08\x12\x04\xa8\x01\x1eF\n\x10\n\x08\x04\x02\
    \x02\x05\x08\x9c\x08\0\x12\x04\xa8\x01\x1fE\n;\n\x04\x04\x02\x02\x06\x12\
    \x04\xab\x01\x04I\x1a-\x20Required.\x20Schedule\x20with\x20monthly\x20ex\
    ecutions.\n\n\r\n\x05\x04\x02\x02\x06\x06\x12\x04\xab\x01\x04\x13\n\r\n\
    \x05\x04\x02\x02\x06\x01\x12\x04\xab\x01\x14\x1b\n\r\n\x05\x04\x02\x02\
    \x06\x03\x12\x04\xab\x01\x1e\x1f\n\r\n\x05\x04\x02\x02\x06\x08\x12\x04\
    \xab\x01\x20H\n\x10\n\x08\x04\x02\x02\x06\x08\x9c\x08\0\x12\x04\xab\x01!\
    G\nL\n\x04\x04\x02\x02\x07\x12\x06\xaf\x01\x02\xb0\x012\x1a<\x20Output\
    \x20only.\x20The\x20time\x20the\x20last\x20patch\x20job\x20ran\x20succes\
    sfully.\n\n\r\n\x05\x04\x02\x02\x07\x06\x12\x04\xaf\x01\x02\x1b\n\r\n\
    \x05\x04\x02\x02\x07\x01\x12\x04\xaf\x01\x1c-\n\r\n\x05\x04\x02\x02\x07\
    \x03\x12\x04\xaf\x0101\n\r\n\x05\x04\x02\x02\x07\x08\x12\x04\xb0\x01\x06\
    1\n\x10\n\x08\x04\x02\x02\x07\x08\x9c\x08\0\x12\x04\xb0\x01\x070\nO\n\
    \x04\x04\x02\x02\x08\x12\x06\xb3\x01\x02\xb4\x012\x1a?\x20Output\x20only\
    .\x20The\x20time\x20the\x20next\x20patch\x20job\x20is\x20scheduled\x20to\
    \x20run.\n\n\r\n\x05\x04\x02\x02\x08\x06\x12\x04\xb3\x01\x02\x1b\n\r\n\
    \x05\x04\x02\x02\x08\x01\x12\x04\xb3\x01\x1c-\n\r\n\x05\x04\x02\x02\x08\
    \x03\x12\x04\xb3\x0102\n\r\n\x05\x04\x02\x02\x08\x08\x12\x04\xb4\x01\x06\
    1\n\x10\n\x08\x04\x02\x02\x08\x08\x9c\x08\0\x12\x04\xb4\x01\x070\n-\n\
    \x02\x04\x03\x12\x06\xb8\x01\0\xbc\x01\x01\x1a\x1f\x20Represents\x20a\
    \x20weekly\x20schedule.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xb8\x01\x08\
    \x16\n,\n\x04\x04\x03\x02\0\x12\x06\xba\x01\x02\xbb\x01/\x1a\x1c\x20Requ\
    ired.\x20Day\x20of\x20the\x20week.\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\
    \xba\x01\x02\x17\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xba\x01\x18#\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\xba\x01&'\n\r\n\x05\x04\x03\x02\0\x08\x12\
    \x04\xbb\x01\x06.\n\x10\n\x08\x04\x03\x02\0\x08\x9c\x08\0\x12\x04\xbb\
    \x01\x07-\n\x9d\x01\n\x02\x04\x04\x12\x06\xc0\x01\0\xcd\x01\x01\x1a\x8e\
    \x01\x20Represents\x20a\x20monthly\x20schedule.\x20An\x20example\x20of\
    \x20a\x20valid\x20monthly\x20schedule\x20is\n\x20\"on\x20the\x20third\
    \x20Tuesday\x20of\x20the\x20month\"\x20or\x20\"on\x20the\x2015th\x20of\
    \x20the\x20month\".\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xc0\x01\x08\x17\n%\
    \n\x04\x04\x04\x08\0\x12\x06\xc2\x01\x02\xcc\x01\x03\x1a\x15\x20One\x20d\
    ay\x20in\x20a\x20month.\n\n\r\n\x05\x04\x04\x08\0\x01\x12\x04\xc2\x01\
    \x08\x14\n0\n\x04\x04\x04\x02\0\x12\x06\xc4\x01\x04\xc5\x011\x1a\x20\x20\
    Required.\x20Week\x20day\x20in\x20a\x20month.\n\n\r\n\x05\x04\x04\x02\0\
    \x06\x12\x04\xc4\x01\x04\x12\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xc4\x01\
    \x13$\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xc4\x01'(\n\r\n\x05\x04\x04\
    \x02\0\x08\x12\x04\xc5\x01\x080\n\x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\
    \x12\x04\xc5\x01\t/\n\x97\x02\n\x04\x04\x04\x02\x01\x12\x04\xcb\x01\x04A\
    \x1a\x88\x02\x20Required.\x20One\x20day\x20of\x20the\x20month.\x201-31\
    \x20indicates\x20the\x201st\x20to\x20the\x2031st\x20day.\n\x20-1\x20indi\
    cates\x20the\x20last\x20day\x20of\x20the\x20month.\x20Months\x20without\
    \x20the\x20target\x20day\n\x20will\x20be\x20skipped.\x20For\x20example,\
    \x20a\x20schedule\x20to\x20run\x20\"every\x20month\x20on\x20the\x2031st\
    \"\n\x20will\x20not\x20run\x20in\x20February,\x20April,\x20June,\x20etc.\
    \n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xcb\x01\x04\t\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\xcb\x01\n\x13\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\
    \xcb\x01\x16\x17\n\r\n\x05\x04\x04\x02\x01\x08\x12\x04\xcb\x01\x18@\n\
    \x10\n\x08\x04\x04\x02\x01\x08\x9c\x08\0\x12\x04\xcb\x01\x19?\nS\n\x02\
    \x04\x05\x12\x06\xd0\x01\0\xe1\x01\x01\x1aE\x20Represents\x20one\x20week\
    \x20day\x20in\x20a\x20month.\x20An\x20example\x20is\x20\"the\x204th\x20S\
    unday\".\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xd0\x01\x08\x16\n\x8b\x01\n\
    \x04\x04\x05\x02\0\x12\x04\xd3\x01\x02B\x1a}\x20Required.\x20Week\x20num\
    ber\x20in\x20a\x20month.\x201-4\x20indicates\x20the\x201st\x20to\x204th\
    \x20week\x20of\x20the\n\x20month.\x20-1\x20indicates\x20the\x20last\x20w\
    eek\x20of\x20the\x20month.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xd3\x01\
    \x02\x07\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xd3\x01\x08\x14\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xd3\x01\x17\x18\n\r\n\x05\x04\x05\x02\0\x08\
    \x12\x04\xd3\x01\x19A\n\x10\n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\
    \xd3\x01\x1a@\n.\n\x04\x04\x05\x02\x01\x12\x06\xd6\x01\x02\xd7\x01/\x1a\
    \x1e\x20Required.\x20A\x20day\x20of\x20the\x20week.\n\n\r\n\x05\x04\x05\
    \x02\x01\x06\x12\x04\xd6\x01\x02\x17\n\r\n\x05\x04\x05\x02\x01\x01\x12\
    \x04\xd6\x01\x18#\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xd6\x01&'\n\r\n\
    \x05\x04\x05\x02\x01\x08\x12\x04\xd7\x01\x06.\n\x10\n\x08\x04\x05\x02\
    \x01\x08\x9c\x08\0\x12\x04\xd7\x01\x07-\n\x94\x04\n\x04\x04\x05\x02\x02\
    \x12\x04\xe0\x01\x02@\x1a\x85\x04\x20Optional.\x20Represents\x20the\x20n\
    umber\x20of\x20days\x20before\x20or\x20after\x20the\x20given\x20week\x20\
    day\n\x20of\x20month\x20that\x20the\x20patch\x20deployment\x20is\x20sche\
    duled\x20for.\x20For\x20example\x20if\n\x20`week_ordinal`\x20and\x20`day\
    _of_week`\x20values\x20point\x20to\x20the\x20second\x20day\x20of\x20the\
    \n\x20month\x20and\x20this\x20`day_offset`\x20value\x20is\x20set\x20to\
    \x20`3`,\x20the\x20patch\x20deployment\x20takes\n\x20place\x20three\x20d\
    ays\x20after\x20the\x20second\x20Tuesday\x20of\x20the\x20month.\x20If\
    \x20this\x20value\x20is\n\x20negative,\x20for\x20example\x20-5,\x20the\
    \x20patches\x20are\x20deployed\x20five\x20days\x20before\x20before\n\x20\
    the\x20second\x20Tuesday\x20of\x20the\x20month.\x20Allowed\x20values\x20\
    are\x20in\x20range\x20[-30,\x2030].\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\
    \x04\xe0\x01\x02\x07\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xe0\x01\x08\
    \x12\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xe0\x01\x15\x16\n\r\n\x05\x04\
    \x05\x02\x02\x08\x12\x04\xe0\x01\x17?\n\x10\n\x08\x04\x05\x02\x02\x08\
    \x9c\x08\0\x12\x04\xe0\x01\x18>\nB\n\x02\x04\x06\x12\x06\xe4\x01\0\xf9\
    \x01\x01\x1a4\x20A\x20request\x20message\x20for\x20creating\x20a\x20patc\
    h\x20deployment.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xe4\x01\x08$\nd\n\x04\
    \x04\x06\x02\0\x12\x06\xe7\x01\x02\xec\x01\x04\x1aT\x20Required.\x20The\
    \x20project\x20to\x20apply\x20this\x20patch\x20deployment\x20to\x20in\
    \x20the\x20form\n\x20`projects/*`.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\
    \xe7\x01\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xe7\x01\t\x0f\n\r\n\
    \x05\x04\x06\x02\0\x03\x12\x04\xe7\x01\x12\x13\n\x0f\n\x05\x04\x06\x02\0\
    \x08\x12\x06\xe7\x01\x14\xec\x01\x03\n\x10\n\x08\x04\x06\x02\0\x08\x9c\
    \x08\0\x12\x04\xe8\x01\x04*\n\x11\n\x07\x04\x06\x02\0\x08\x9f\x08\x12\
    \x06\xe9\x01\x04\xeb\x01\x05\n\xc7\x02\n\x04\x04\x06\x02\x01\x12\x04\xf5\
    \x01\x02J\x1a\xb8\x02\x20Required.\x20A\x20name\x20for\x20the\x20patch\
    \x20deployment\x20in\x20the\x20project.\x20When\x20creating\x20a\n\x20na\
    me\x20the\x20following\x20rules\x20apply:\n\x20*\x20Must\x20contain\x20o\
    nly\x20lowercase\x20letters,\x20numbers,\x20and\x20hyphens.\n\x20*\x20Mu\
    st\x20start\x20with\x20a\x20letter.\n\x20*\x20Must\x20be\x20between\x201\
    -63\x20characters.\n\x20*\x20Must\x20end\x20with\x20a\x20number\x20or\
    \x20a\x20letter.\n\x20*\x20Must\x20be\x20unique\x20within\x20the\x20proj\
    ect.\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xf5\x01\x02\x08\n\r\n\x05\
    \x04\x06\x02\x01\x01\x12\x04\xf5\x01\t\x1c\n\r\n\x05\x04\x06\x02\x01\x03\
    \x12\x04\xf5\x01\x1f\x20\n\r\n\x05\x04\x06\x02\x01\x08\x12\x04\xf5\x01!I\
    \n\x10\n\x08\x04\x06\x02\x01\x08\x9c\x08\0\x12\x04\xf5\x01\"H\n9\n\x04\
    \x04\x06\x02\x02\x12\x04\xf8\x01\x02P\x1a+\x20Required.\x20The\x20patch\
    \x20deployment\x20to\x20create.\n\n\r\n\x05\x04\x06\x02\x02\x06\x12\x04\
    \xf8\x01\x02\x11\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xf8\x01\x12\"\n\r\
    \n\x05\x04\x06\x02\x02\x03\x12\x04\xf8\x01%&\n\r\n\x05\x04\x06\x02\x02\
    \x08\x12\x04\xf8\x01'O\n\x10\n\x08\x04\x06\x02\x02\x08\x9c\x08\0\x12\x04\
    \xf8\x01(N\nD\n\x02\x04\x07\x12\x06\xfc\x01\0\x85\x02\x01\x1a6\x20A\x20r\
    equest\x20message\x20for\x20retrieving\x20a\x20patch\x20deployment.\n\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\xfc\x01\x08!\ns\n\x04\x04\x07\x02\0\x12\
    \x06\xff\x01\x02\x84\x02\x04\x1ac\x20Required.\x20The\x20resource\x20nam\
    e\x20of\x20the\x20patch\x20deployment\x20in\x20the\x20form\n\x20`project\
    s/*/patchDeployments/*`.\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xff\x01\
    \x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xff\x01\t\r\n\r\n\x05\x04\
    \x07\x02\0\x03\x12\x04\xff\x01\x10\x11\n\x0f\n\x05\x04\x07\x02\0\x08\x12\
    \x06\xff\x01\x12\x84\x02\x03\n\x10\n\x08\x04\x07\x02\0\x08\x9c\x08\0\x12\
    \x04\x80\x02\x04*\n\x11\n\x07\x04\x07\x02\0\x08\x9f\x08\x12\x06\x81\x02\
    \x04\x83\x02\x05\n@\n\x02\x04\x08\x12\x06\x88\x02\0\x99\x02\x01\x1a2\x20\
    A\x20request\x20message\x20for\x20listing\x20patch\x20deployments.\n\n\
    \x0b\n\x03\x04\x08\x01\x12\x04\x88\x02\x08#\nU\n\x04\x04\x08\x02\0\x12\
    \x06\x8a\x02\x02\x8f\x02\x04\x1aE\x20Required.\x20The\x20resource\x20nam\
    e\x20of\x20the\x20parent\x20in\x20the\x20form\x20`projects/*`.\n\n\r\n\
    \x05\x04\x08\x02\0\x05\x12\x04\x8a\x02\x02\x08\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\x8a\x02\t\x0f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x8a\x02\
    \x12\x13\n\x0f\n\x05\x04\x08\x02\0\x08\x12\x06\x8a\x02\x14\x8f\x02\x03\n\
    \x10\n\x08\x04\x08\x02\0\x08\x9c\x08\0\x12\x04\x8b\x02\x04*\n\x11\n\x07\
    \x04\x08\x02\0\x08\x9f\x08\x12\x06\x8c\x02\x04\x8e\x02\x05\n]\n\x04\x04\
    \x08\x02\x01\x12\x04\x93\x02\x02?\x1aO\x20Optional.\x20The\x20maximum\
    \x20number\x20of\x20patch\x20deployments\x20to\x20return.\x20Default\x20\
    is\n\x20100.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x93\x02\x02\x07\n\r\
    \n\x05\x04\x08\x02\x01\x01\x12\x04\x93\x02\x08\x11\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\x93\x02\x14\x15\n\r\n\x05\x04\x08\x02\x01\x08\x12\x04\
    \x93\x02\x16>\n\x10\n\x08\x04\x08\x02\x01\x08\x9c\x08\0\x12\x04\x93\x02\
    \x17=\n\x9d\x01\n\x04\x04\x08\x02\x02\x12\x04\x98\x02\x02A\x1a\x8e\x01\
    \x20Optional.\x20A\x20pagination\x20token\x20returned\x20from\x20a\x20pr\
    evious\x20call\x20to\n\x20ListPatchDeployments\x20that\x20indicates\x20w\
    here\x20this\x20listing\x20should\x20continue\n\x20from.\n\n\r\n\x05\x04\
    \x08\x02\x02\x05\x12\x04\x98\x02\x02\x08\n\r\n\x05\x04\x08\x02\x02\x01\
    \x12\x04\x98\x02\t\x13\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x98\x02\x16\
    \x17\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\x98\x02\x18@\n\x10\n\x08\x04\
    \x08\x02\x02\x08\x9c\x08\0\x12\x04\x98\x02\x19?\nA\n\x02\x04\t\x12\x06\
    \x9c\x02\0\xa3\x02\x01\x1a3\x20A\x20response\x20message\x20for\x20listin\
    g\x20patch\x20deployments.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x9c\x02\x08$\
    \n.\n\x04\x04\t\x02\0\x12\x04\x9e\x02\x021\x1a\x20\x20The\x20list\x20of\
    \x20patch\x20deployments.\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04\x9e\x02\
    \x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x9e\x02\x0b\x1a\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\x9e\x02\x1b,\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x9e\
    \x02/0\n_\n\x04\x04\t\x02\x01\x12\x04\xa2\x02\x02\x1d\x1aQ\x20A\x20pagin\
    ation\x20token\x20that\x20can\x20be\x20used\x20to\x20get\x20the\x20next\
    \x20page\x20of\x20patch\n\x20deployments.\n\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\xa2\x02\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xa2\x02\t\
    \x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xa2\x02\x1b\x1c\nB\n\x02\x04\n\
    \x12\x06\xa6\x02\0\xaf\x02\x01\x1a4\x20A\x20request\x20message\x20for\
    \x20deleting\x20a\x20patch\x20deployment.\n\n\x0b\n\x03\x04\n\x01\x12\
    \x04\xa6\x02\x08$\ns\n\x04\x04\n\x02\0\x12\x06\xa9\x02\x02\xae\x02\x04\
    \x1ac\x20Required.\x20The\x20resource\x20name\x20of\x20the\x20patch\x20d\
    eployment\x20in\x20the\x20form\n\x20`projects/*/patchDeployments/*`.\n\n\
    \r\n\x05\x04\n\x02\0\x05\x12\x04\xa9\x02\x02\x08\n\r\n\x05\x04\n\x02\0\
    \x01\x12\x04\xa9\x02\t\r\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xa9\x02\x10\
    \x11\n\x0f\n\x05\x04\n\x02\0\x08\x12\x06\xa9\x02\x12\xae\x02\x03\n\x10\n\
    \x08\x04\n\x02\0\x08\x9c\x08\0\x12\x04\xaa\x02\x04*\n\x11\n\x07\x04\n\
    \x02\0\x08\x9f\x08\x12\x06\xab\x02\x04\xad\x02\x05\nB\n\x02\x04\x0b\x12\
    \x06\xb2\x02\0\xba\x02\x01\x1a4\x20A\x20request\x20message\x20for\x20upd\
    ating\x20a\x20patch\x20deployment.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb2\
    \x02\x08$\n9\n\x04\x04\x0b\x02\0\x12\x04\xb4\x02\x02P\x1a+\x20Required.\
    \x20The\x20patch\x20deployment\x20to\x20Update.\n\n\r\n\x05\x04\x0b\x02\
    \0\x06\x12\x04\xb4\x02\x02\x11\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xb4\
    \x02\x12\"\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xb4\x02%&\n\r\n\x05\x04\
    \x0b\x02\0\x08\x12\x04\xb4\x02'O\n\x10\n\x08\x04\x0b\x02\0\x08\x9c\x08\0\
    \x12\x04\xb4\x02(N\nm\n\x04\x04\x0b\x02\x01\x12\x06\xb8\x02\x02\xb9\x02/\
    \x1a]\x20Optional.\x20Field\x20mask\x20that\x20controls\x20which\x20fiel\
    ds\x20of\x20the\x20patch\x20deployment\n\x20should\x20be\x20updated.\n\n\
    \r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xb8\x02\x02\x1b\n\r\n\x05\x04\x0b\
    \x02\x01\x01\x12\x04\xb8\x02\x1c'\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xb8\x02*+\n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xb9\x02\x06.\n\x10\n\
    \x08\x04\x0b\x02\x01\x08\x9c\x08\0\x12\x04\xb9\x02\x07-\nA\n\x02\x04\x0c\
    \x12\x06\xbd\x02\0\xc6\x02\x01\x1a3\x20A\x20request\x20message\x20for\
    \x20pausing\x20a\x20patch\x20deployment.\n\n\x0b\n\x03\x04\x0c\x01\x12\
    \x04\xbd\x02\x08#\ns\n\x04\x04\x0c\x02\0\x12\x06\xc0\x02\x02\xc5\x02\x04\
    \x1ac\x20Required.\x20The\x20resource\x20name\x20of\x20the\x20patch\x20d\
    eployment\x20in\x20the\x20form\n\x20`projects/*/patchDeployments/*`.\n\n\
    \r\n\x05\x04\x0c\x02\0\x05\x12\x04\xc0\x02\x02\x08\n\r\n\x05\x04\x0c\x02\
    \0\x01\x12\x04\xc0\x02\t\r\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xc0\x02\
    \x10\x11\n\x0f\n\x05\x04\x0c\x02\0\x08\x12\x06\xc0\x02\x12\xc5\x02\x03\n\
    \x10\n\x08\x04\x0c\x02\0\x08\x9c\x08\0\x12\x04\xc1\x02\x04*\n\x11\n\x07\
    \x04\x0c\x02\0\x08\x9f\x08\x12\x06\xc2\x02\x04\xc4\x02\x05\nB\n\x02\x04\
    \r\x12\x06\xc9\x02\0\xd2\x02\x01\x1a4\x20A\x20request\x20message\x20for\
    \x20resuming\x20a\x20patch\x20deployment.\n\n\x0b\n\x03\x04\r\x01\x12\
    \x04\xc9\x02\x08$\ns\n\x04\x04\r\x02\0\x12\x06\xcc\x02\x02\xd1\x02\x04\
    \x1ac\x20Required.\x20The\x20resource\x20name\x20of\x20the\x20patch\x20d\
    eployment\x20in\x20the\x20form\n\x20`projects/*/patchDeployments/*`.\n\n\
    \r\n\x05\x04\r\x02\0\x05\x12\x04\xcc\x02\x02\x08\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\xcc\x02\t\r\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xcc\x02\x10\
    \x11\n\x0f\n\x05\x04\r\x02\0\x08\x12\x06\xcc\x02\x12\xd1\x02\x03\n\x10\n\
    \x08\x04\r\x02\0\x08\x9c\x08\0\x12\x04\xcd\x02\x04*\n\x11\n\x07\x04\r\
    \x02\0\x08\x9f\x08\x12\x06\xce\x02\x04\xd0\x02\x05b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
