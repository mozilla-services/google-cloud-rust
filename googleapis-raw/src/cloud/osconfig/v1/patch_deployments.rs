// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1/patch_deployments.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct PatchDeployment {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub instance_filter: ::protobuf::SingularPtrField<super::patch_jobs::PatchInstanceFilter>,
    pub patch_config: ::protobuf::SingularPtrField<super::patch_jobs::PatchConfig>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub last_execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub rollout: ::protobuf::SingularPtrField<super::patch_jobs::PatchRollout>,
    // message oneof groups
    pub schedule: ::std::option::Option<PatchDeployment_oneof_schedule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchDeployment {
    fn default() -> &'a PatchDeployment {
        <PatchDeployment as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PatchDeployment_oneof_schedule {
    one_time_schedule(OneTimeSchedule),
    recurring_schedule(RecurringSchedule),
}

impl PatchDeployment {
    pub fn new() -> PatchDeployment {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.PatchInstanceFilter instance_filter = 3;


    pub fn get_instance_filter(&self) -> &super::patch_jobs::PatchInstanceFilter {
        self.instance_filter.as_ref().unwrap_or_else(|| <super::patch_jobs::PatchInstanceFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance_filter(&mut self) {
        self.instance_filter.clear();
    }

    pub fn has_instance_filter(&self) -> bool {
        self.instance_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_filter(&mut self, v: super::patch_jobs::PatchInstanceFilter) {
        self.instance_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_filter(&mut self) -> &mut super::patch_jobs::PatchInstanceFilter {
        if self.instance_filter.is_none() {
            self.instance_filter.set_default();
        }
        self.instance_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_filter(&mut self) -> super::patch_jobs::PatchInstanceFilter {
        self.instance_filter.take().unwrap_or_else(|| super::patch_jobs::PatchInstanceFilter::new())
    }

    // .google.cloud.osconfig.v1.PatchConfig patch_config = 4;


    pub fn get_patch_config(&self) -> &super::patch_jobs::PatchConfig {
        self.patch_config.as_ref().unwrap_or_else(|| <super::patch_jobs::PatchConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_patch_config(&mut self) {
        self.patch_config.clear();
    }

    pub fn has_patch_config(&self) -> bool {
        self.patch_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_config(&mut self, v: super::patch_jobs::PatchConfig) {
        self.patch_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_config(&mut self) -> &mut super::patch_jobs::PatchConfig {
        if self.patch_config.is_none() {
            self.patch_config.set_default();
        }
        self.patch_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_patch_config(&mut self) -> super::patch_jobs::PatchConfig {
        self.patch_config.take().unwrap_or_else(|| super::patch_jobs::PatchConfig::new())
    }

    // .google.protobuf.Duration duration = 5;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.cloud.osconfig.v1.OneTimeSchedule one_time_schedule = 6;


    pub fn get_one_time_schedule(&self) -> &OneTimeSchedule {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(ref v)) => v,
            _ => <OneTimeSchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_one_time_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_one_time_schedule(&self) -> bool {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_one_time_schedule(&mut self, v: OneTimeSchedule) {
        self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_one_time_schedule(&mut self) -> &mut OneTimeSchedule {
        if let ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(_)) = self.schedule {
        } else {
            self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(OneTimeSchedule::new()));
        }
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_one_time_schedule(&mut self) -> OneTimeSchedule {
        if self.has_one_time_schedule() {
            match self.schedule.take() {
                ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(v)) => v,
                _ => panic!(),
            }
        } else {
            OneTimeSchedule::new()
        }
    }

    // .google.cloud.osconfig.v1.RecurringSchedule recurring_schedule = 7;


    pub fn get_recurring_schedule(&self) -> &RecurringSchedule {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(ref v)) => v,
            _ => <RecurringSchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_recurring_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_recurring_schedule(&self) -> bool {
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_recurring_schedule(&mut self, v: RecurringSchedule) {
        self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_recurring_schedule(&mut self) -> &mut RecurringSchedule {
        if let ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(_)) = self.schedule {
        } else {
            self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(RecurringSchedule::new()));
        }
        match self.schedule {
            ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_recurring_schedule(&mut self) -> RecurringSchedule {
        if self.has_recurring_schedule() {
            match self.schedule.take() {
                ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(v)) => v,
                _ => panic!(),
            }
        } else {
            RecurringSchedule::new()
        }
    }

    // .google.protobuf.Timestamp create_time = 8;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 9;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp last_execute_time = 10;


    pub fn get_last_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_execute_time(&mut self) {
        self.last_execute_time.clear();
    }

    pub fn has_last_execute_time(&self) -> bool {
        self.last_execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_execute_time.is_none() {
            self.last_execute_time.set_default();
        }
        self.last_execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.cloud.osconfig.v1.PatchRollout rollout = 11;


    pub fn get_rollout(&self) -> &super::patch_jobs::PatchRollout {
        self.rollout.as_ref().unwrap_or_else(|| <super::patch_jobs::PatchRollout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout(&mut self) {
        self.rollout.clear();
    }

    pub fn has_rollout(&self) -> bool {
        self.rollout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout(&mut self, v: super::patch_jobs::PatchRollout) {
        self.rollout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout(&mut self) -> &mut super::patch_jobs::PatchRollout {
        if self.rollout.is_none() {
            self.rollout.set_default();
        }
        self.rollout.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout(&mut self) -> super::patch_jobs::PatchRollout {
        self.rollout.take().unwrap_or_else(|| super::patch_jobs::PatchRollout::new())
    }
}

impl ::protobuf::Message for PatchDeployment {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patch_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(PatchDeployment_oneof_schedule::one_time_schedule(ref v)) = self.schedule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PatchDeployment_oneof_schedule::recurring_schedule(ref v)) = self.schedule {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_filter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patch_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::one_time_schedule(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule = ::std::option::Option::Some(PatchDeployment_oneof_schedule::recurring_schedule(is.read_message()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_execute_time)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.schedule {
            match v {
                &PatchDeployment_oneof_schedule::one_time_schedule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PatchDeployment_oneof_schedule::recurring_schedule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.schedule {
            match v {
                &PatchDeployment_oneof_schedule::one_time_schedule(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PatchDeployment_oneof_schedule::recurring_schedule(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchDeployment {
        PatchDeployment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PatchDeployment| { &m.name },
                |m: &mut PatchDeployment| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &PatchDeployment| { &m.description },
                |m: &mut PatchDeployment| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::patch_jobs::PatchInstanceFilter>>(
                "instance_filter",
                |m: &PatchDeployment| { &m.instance_filter },
                |m: &mut PatchDeployment| { &mut m.instance_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::patch_jobs::PatchConfig>>(
                "patch_config",
                |m: &PatchDeployment| { &m.patch_config },
                |m: &mut PatchDeployment| { &mut m.patch_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &PatchDeployment| { &m.duration },
                |m: &mut PatchDeployment| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OneTimeSchedule>(
                "one_time_schedule",
                PatchDeployment::has_one_time_schedule,
                PatchDeployment::get_one_time_schedule,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RecurringSchedule>(
                "recurring_schedule",
                PatchDeployment::has_recurring_schedule,
                PatchDeployment::get_recurring_schedule,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &PatchDeployment| { &m.create_time },
                |m: &mut PatchDeployment| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &PatchDeployment| { &m.update_time },
                |m: &mut PatchDeployment| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_execute_time",
                |m: &PatchDeployment| { &m.last_execute_time },
                |m: &mut PatchDeployment| { &mut m.last_execute_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::patch_jobs::PatchRollout>>(
                "rollout",
                |m: &PatchDeployment| { &m.rollout },
                |m: &mut PatchDeployment| { &mut m.rollout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchDeployment>(
                "PatchDeployment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchDeployment {
        static instance: ::protobuf::rt::LazyV2<PatchDeployment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchDeployment::new)
    }
}

impl ::protobuf::Clear for PatchDeployment {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.instance_filter.clear();
        self.patch_config.clear();
        self.duration.clear();
        self.schedule = ::std::option::Option::None;
        self.schedule = ::std::option::Option::None;
        self.create_time.clear();
        self.update_time.clear();
        self.last_execute_time.clear();
        self.rollout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchDeployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDeployment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OneTimeSchedule {
    // message fields
    pub execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OneTimeSchedule {
    fn default() -> &'a OneTimeSchedule {
        <OneTimeSchedule as ::protobuf::Message>::default_instance()
    }
}

impl OneTimeSchedule {
    pub fn new() -> OneTimeSchedule {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp execute_time = 1;


    pub fn get_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execute_time(&mut self) {
        self.execute_time.clear();
    }

    pub fn has_execute_time(&self) -> bool {
        self.execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.execute_time.is_none() {
            self.execute_time.set_default();
        }
        self.execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for OneTimeSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execute_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.execute_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OneTimeSchedule {
        OneTimeSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "execute_time",
                |m: &OneTimeSchedule| { &m.execute_time },
                |m: &mut OneTimeSchedule| { &mut m.execute_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OneTimeSchedule>(
                "OneTimeSchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OneTimeSchedule {
        static instance: ::protobuf::rt::LazyV2<OneTimeSchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OneTimeSchedule::new)
    }
}

impl ::protobuf::Clear for OneTimeSchedule {
    fn clear(&mut self) {
        self.execute_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OneTimeSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OneTimeSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecurringSchedule {
    // message fields
    pub time_zone: ::protobuf::SingularPtrField<super::datetime::TimeZone>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub time_of_day: ::protobuf::SingularPtrField<super::timeofday::TimeOfDay>,
    pub frequency: RecurringSchedule_Frequency,
    pub last_execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub next_execute_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub schedule_config: ::std::option::Option<RecurringSchedule_oneof_schedule_config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecurringSchedule {
    fn default() -> &'a RecurringSchedule {
        <RecurringSchedule as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RecurringSchedule_oneof_schedule_config {
    weekly(WeeklySchedule),
    monthly(MonthlySchedule),
}

impl RecurringSchedule {
    pub fn new() -> RecurringSchedule {
        ::std::default::Default::default()
    }

    // .google.type.TimeZone time_zone = 1;


    pub fn get_time_zone(&self) -> &super::datetime::TimeZone {
        self.time_zone.as_ref().unwrap_or_else(|| <super::datetime::TimeZone as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_zone(&mut self) {
        self.time_zone.clear();
    }

    pub fn has_time_zone(&self) -> bool {
        self.time_zone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_zone(&mut self, v: super::datetime::TimeZone) {
        self.time_zone = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_zone(&mut self) -> &mut super::datetime::TimeZone {
        if self.time_zone.is_none() {
            self.time_zone.set_default();
        }
        self.time_zone.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_zone(&mut self) -> super::datetime::TimeZone {
        self.time_zone.take().unwrap_or_else(|| super::datetime::TimeZone::new())
    }

    // .google.protobuf.Timestamp start_time = 2;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 3;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.type.TimeOfDay time_of_day = 4;


    pub fn get_time_of_day(&self) -> &super::timeofday::TimeOfDay {
        self.time_of_day.as_ref().unwrap_or_else(|| <super::timeofday::TimeOfDay as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_of_day(&mut self) {
        self.time_of_day.clear();
    }

    pub fn has_time_of_day(&self) -> bool {
        self.time_of_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_of_day(&mut self, v: super::timeofday::TimeOfDay) {
        self.time_of_day = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_of_day(&mut self) -> &mut super::timeofday::TimeOfDay {
        if self.time_of_day.is_none() {
            self.time_of_day.set_default();
        }
        self.time_of_day.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_of_day(&mut self) -> super::timeofday::TimeOfDay {
        self.time_of_day.take().unwrap_or_else(|| super::timeofday::TimeOfDay::new())
    }

    // .google.cloud.osconfig.v1.RecurringSchedule.Frequency frequency = 5;


    pub fn get_frequency(&self) -> RecurringSchedule_Frequency {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: RecurringSchedule_Frequency) {
        self.frequency = v;
    }

    // .google.cloud.osconfig.v1.WeeklySchedule weekly = 6;


    pub fn get_weekly(&self) -> &WeeklySchedule {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(ref v)) => v,
            _ => <WeeklySchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_weekly(&mut self) {
        self.schedule_config = ::std::option::Option::None;
    }

    pub fn has_weekly(&self) -> bool {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_weekly(&mut self, v: WeeklySchedule) {
        self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(v))
    }

    // Mutable pointer to the field.
    pub fn mut_weekly(&mut self) -> &mut WeeklySchedule {
        if let ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(_)) = self.schedule_config {
        } else {
            self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(WeeklySchedule::new()));
        }
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_weekly(&mut self) -> WeeklySchedule {
        if self.has_weekly() {
            match self.schedule_config.take() {
                ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(v)) => v,
                _ => panic!(),
            }
        } else {
            WeeklySchedule::new()
        }
    }

    // .google.cloud.osconfig.v1.MonthlySchedule monthly = 7;


    pub fn get_monthly(&self) -> &MonthlySchedule {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(ref v)) => v,
            _ => <MonthlySchedule as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_monthly(&mut self) {
        self.schedule_config = ::std::option::Option::None;
    }

    pub fn has_monthly(&self) -> bool {
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_monthly(&mut self, v: MonthlySchedule) {
        self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(v))
    }

    // Mutable pointer to the field.
    pub fn mut_monthly(&mut self) -> &mut MonthlySchedule {
        if let ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(_)) = self.schedule_config {
        } else {
            self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(MonthlySchedule::new()));
        }
        match self.schedule_config {
            ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_monthly(&mut self) -> MonthlySchedule {
        if self.has_monthly() {
            match self.schedule_config.take() {
                ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(v)) => v,
                _ => panic!(),
            }
        } else {
            MonthlySchedule::new()
        }
    }

    // .google.protobuf.Timestamp last_execute_time = 9;


    pub fn get_last_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_execute_time(&mut self) {
        self.last_execute_time.clear();
    }

    pub fn has_last_execute_time(&self) -> bool {
        self.last_execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_execute_time.is_none() {
            self.last_execute_time.set_default();
        }
        self.last_execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp next_execute_time = 10;


    pub fn get_next_execute_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.next_execute_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_next_execute_time(&mut self) {
        self.next_execute_time.clear();
    }

    pub fn has_next_execute_time(&self) -> bool {
        self.next_execute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_execute_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.next_execute_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_execute_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.next_execute_time.is_none() {
            self.next_execute_time.set_default();
        }
        self.next_execute_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_execute_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.next_execute_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for RecurringSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.time_zone {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_of_day {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(RecurringSchedule_oneof_schedule_config::weekly(ref v)) = self.schedule_config {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RecurringSchedule_oneof_schedule_config::monthly(ref v)) = self.schedule_config {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.last_execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.next_execute_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_zone)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_of_day)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.frequency, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::weekly(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schedule_config = ::std::option::Option::Some(RecurringSchedule_oneof_schedule_config::monthly(is.read_message()?));
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_execute_time)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.next_execute_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time_zone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_of_day.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.frequency != RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.frequency);
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.next_execute_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.schedule_config {
            match v {
                &RecurringSchedule_oneof_schedule_config::weekly(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RecurringSchedule_oneof_schedule_config::monthly(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time_zone.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_of_day.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.frequency != RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.frequency))?;
        }
        if let Some(ref v) = self.last_execute_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.next_execute_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.schedule_config {
            match v {
                &RecurringSchedule_oneof_schedule_config::weekly(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RecurringSchedule_oneof_schedule_config::monthly(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecurringSchedule {
        RecurringSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datetime::TimeZone>>(
                "time_zone",
                |m: &RecurringSchedule| { &m.time_zone },
                |m: &mut RecurringSchedule| { &mut m.time_zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &RecurringSchedule| { &m.start_time },
                |m: &mut RecurringSchedule| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &RecurringSchedule| { &m.end_time },
                |m: &mut RecurringSchedule| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::timeofday::TimeOfDay>>(
                "time_of_day",
                |m: &RecurringSchedule| { &m.time_of_day },
                |m: &mut RecurringSchedule| { &mut m.time_of_day },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RecurringSchedule_Frequency>>(
                "frequency",
                |m: &RecurringSchedule| { &m.frequency },
                |m: &mut RecurringSchedule| { &mut m.frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WeeklySchedule>(
                "weekly",
                RecurringSchedule::has_weekly,
                RecurringSchedule::get_weekly,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MonthlySchedule>(
                "monthly",
                RecurringSchedule::has_monthly,
                RecurringSchedule::get_monthly,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_execute_time",
                |m: &RecurringSchedule| { &m.last_execute_time },
                |m: &mut RecurringSchedule| { &mut m.last_execute_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "next_execute_time",
                |m: &RecurringSchedule| { &m.next_execute_time },
                |m: &mut RecurringSchedule| { &mut m.next_execute_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecurringSchedule>(
                "RecurringSchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecurringSchedule {
        static instance: ::protobuf::rt::LazyV2<RecurringSchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecurringSchedule::new)
    }
}

impl ::protobuf::Clear for RecurringSchedule {
    fn clear(&mut self) {
        self.time_zone.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.time_of_day.clear();
        self.frequency = RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED;
        self.schedule_config = ::std::option::Option::None;
        self.schedule_config = ::std::option::Option::None;
        self.last_execute_time.clear();
        self.next_execute_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecurringSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecurringSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RecurringSchedule_Frequency {
    FREQUENCY_UNSPECIFIED = 0,
    WEEKLY = 1,
    MONTHLY = 2,
}

impl ::protobuf::ProtobufEnum for RecurringSchedule_Frequency {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RecurringSchedule_Frequency> {
        match value {
            0 => ::std::option::Option::Some(RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED),
            1 => ::std::option::Option::Some(RecurringSchedule_Frequency::WEEKLY),
            2 => ::std::option::Option::Some(RecurringSchedule_Frequency::MONTHLY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RecurringSchedule_Frequency] = &[
            RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED,
            RecurringSchedule_Frequency::WEEKLY,
            RecurringSchedule_Frequency::MONTHLY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RecurringSchedule_Frequency>("RecurringSchedule.Frequency", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RecurringSchedule_Frequency {
}

impl ::std::default::Default for RecurringSchedule_Frequency {
    fn default() -> Self {
        RecurringSchedule_Frequency::FREQUENCY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for RecurringSchedule_Frequency {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeeklySchedule {
    // message fields
    pub day_of_week: super::dayofweek::DayOfWeek,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeeklySchedule {
    fn default() -> &'a WeeklySchedule {
        <WeeklySchedule as ::protobuf::Message>::default_instance()
    }
}

impl WeeklySchedule {
    pub fn new() -> WeeklySchedule {
        ::std::default::Default::default()
    }

    // .google.type.DayOfWeek day_of_week = 1;


    pub fn get_day_of_week(&self) -> super::dayofweek::DayOfWeek {
        self.day_of_week
    }
    pub fn clear_day_of_week(&mut self) {
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_day_of_week(&mut self, v: super::dayofweek::DayOfWeek) {
        self.day_of_week = v;
    }
}

impl ::protobuf::Message for WeeklySchedule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.day_of_week, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.day_of_week);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.day_of_week))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeeklySchedule {
        WeeklySchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dayofweek::DayOfWeek>>(
                "day_of_week",
                |m: &WeeklySchedule| { &m.day_of_week },
                |m: &mut WeeklySchedule| { &mut m.day_of_week },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeeklySchedule>(
                "WeeklySchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeeklySchedule {
        static instance: ::protobuf::rt::LazyV2<WeeklySchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeeklySchedule::new)
    }
}

impl ::protobuf::Clear for WeeklySchedule {
    fn clear(&mut self) {
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeeklySchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeeklySchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonthlySchedule {
    // message oneof groups
    pub day_of_month: ::std::option::Option<MonthlySchedule_oneof_day_of_month>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonthlySchedule {
    fn default() -> &'a MonthlySchedule {
        <MonthlySchedule as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MonthlySchedule_oneof_day_of_month {
    week_day_of_month(WeekDayOfMonth),
    month_day(i32),
}

impl MonthlySchedule {
    pub fn new() -> MonthlySchedule {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.WeekDayOfMonth week_day_of_month = 1;


    pub fn get_week_day_of_month(&self) -> &WeekDayOfMonth {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v)) => v,
            _ => <WeekDayOfMonth as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_week_day_of_month(&mut self) {
        self.day_of_month = ::std::option::Option::None;
    }

    pub fn has_week_day_of_month(&self) -> bool {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_week_day_of_month(&mut self, v: WeekDayOfMonth) {
        self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(v))
    }

    // Mutable pointer to the field.
    pub fn mut_week_day_of_month(&mut self) -> &mut WeekDayOfMonth {
        if let ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(_)) = self.day_of_month {
        } else {
            self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(WeekDayOfMonth::new()));
        }
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_week_day_of_month(&mut self) -> WeekDayOfMonth {
        if self.has_week_day_of_month() {
            match self.day_of_month.take() {
                ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(v)) => v,
                _ => panic!(),
            }
        } else {
            WeekDayOfMonth::new()
        }
    }

    // int32 month_day = 2;


    pub fn get_month_day(&self) -> i32 {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_month_day(&mut self) {
        self.day_of_month = ::std::option::Option::None;
    }

    pub fn has_month_day(&self) -> bool {
        match self.day_of_month {
            ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_month_day(&mut self, v: i32) {
        self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(v))
    }
}

impl ::protobuf::Message for MonthlySchedule {
    fn is_initialized(&self) -> bool {
        if let Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v)) = self.day_of_month {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::week_day_of_month(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.day_of_month = ::std::option::Option::Some(MonthlySchedule_oneof_day_of_month::month_day(is.read_int32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.day_of_month {
            match v {
                &MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MonthlySchedule_oneof_day_of_month::month_day(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.day_of_month {
            match v {
                &MonthlySchedule_oneof_day_of_month::week_day_of_month(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MonthlySchedule_oneof_day_of_month::month_day(v) => {
                    os.write_int32(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonthlySchedule {
        MonthlySchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WeekDayOfMonth>(
                "week_day_of_month",
                MonthlySchedule::has_week_day_of_month,
                MonthlySchedule::get_week_day_of_month,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "month_day",
                MonthlySchedule::has_month_day,
                MonthlySchedule::get_month_day,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonthlySchedule>(
                "MonthlySchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonthlySchedule {
        static instance: ::protobuf::rt::LazyV2<MonthlySchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonthlySchedule::new)
    }
}

impl ::protobuf::Clear for MonthlySchedule {
    fn clear(&mut self) {
        self.day_of_month = ::std::option::Option::None;
        self.day_of_month = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonthlySchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonthlySchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeekDayOfMonth {
    // message fields
    pub week_ordinal: i32,
    pub day_of_week: super::dayofweek::DayOfWeek,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeekDayOfMonth {
    fn default() -> &'a WeekDayOfMonth {
        <WeekDayOfMonth as ::protobuf::Message>::default_instance()
    }
}

impl WeekDayOfMonth {
    pub fn new() -> WeekDayOfMonth {
        ::std::default::Default::default()
    }

    // int32 week_ordinal = 1;


    pub fn get_week_ordinal(&self) -> i32 {
        self.week_ordinal
    }
    pub fn clear_week_ordinal(&mut self) {
        self.week_ordinal = 0;
    }

    // Param is passed by value, moved
    pub fn set_week_ordinal(&mut self, v: i32) {
        self.week_ordinal = v;
    }

    // .google.type.DayOfWeek day_of_week = 2;


    pub fn get_day_of_week(&self) -> super::dayofweek::DayOfWeek {
        self.day_of_week
    }
    pub fn clear_day_of_week(&mut self) {
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_day_of_week(&mut self, v: super::dayofweek::DayOfWeek) {
        self.day_of_week = v;
    }
}

impl ::protobuf::Message for WeekDayOfMonth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.week_ordinal = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.day_of_week, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.week_ordinal != 0 {
            my_size += ::protobuf::rt::value_size(1, self.week_ordinal, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.day_of_week);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.week_ordinal != 0 {
            os.write_int32(1, self.week_ordinal)?;
        }
        if self.day_of_week != super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.day_of_week))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeekDayOfMonth {
        WeekDayOfMonth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "week_ordinal",
                |m: &WeekDayOfMonth| { &m.week_ordinal },
                |m: &mut WeekDayOfMonth| { &mut m.week_ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dayofweek::DayOfWeek>>(
                "day_of_week",
                |m: &WeekDayOfMonth| { &m.day_of_week },
                |m: &mut WeekDayOfMonth| { &mut m.day_of_week },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeekDayOfMonth>(
                "WeekDayOfMonth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeekDayOfMonth {
        static instance: ::protobuf::rt::LazyV2<WeekDayOfMonth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeekDayOfMonth::new)
    }
}

impl ::protobuf::Clear for WeekDayOfMonth {
    fn clear(&mut self) {
        self.week_ordinal = 0;
        self.day_of_week = super::dayofweek::DayOfWeek::DAY_OF_WEEK_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeekDayOfMonth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeekDayOfMonth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreatePatchDeploymentRequest {
    // message fields
    pub parent: ::std::string::String,
    pub patch_deployment_id: ::std::string::String,
    pub patch_deployment: ::protobuf::SingularPtrField<PatchDeployment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePatchDeploymentRequest {
    fn default() -> &'a CreatePatchDeploymentRequest {
        <CreatePatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreatePatchDeploymentRequest {
    pub fn new() -> CreatePatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string patch_deployment_id = 2;


    pub fn get_patch_deployment_id(&self) -> &str {
        &self.patch_deployment_id
    }
    pub fn clear_patch_deployment_id(&mut self) {
        self.patch_deployment_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_patch_deployment_id(&mut self, v: ::std::string::String) {
        self.patch_deployment_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_deployment_id(&mut self) -> &mut ::std::string::String {
        &mut self.patch_deployment_id
    }

    // Take field
    pub fn take_patch_deployment_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.patch_deployment_id, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.PatchDeployment patch_deployment = 3;


    pub fn get_patch_deployment(&self) -> &PatchDeployment {
        self.patch_deployment.as_ref().unwrap_or_else(|| <PatchDeployment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_patch_deployment(&mut self) {
        self.patch_deployment.clear();
    }

    pub fn has_patch_deployment(&self) -> bool {
        self.patch_deployment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_deployment(&mut self, v: PatchDeployment) {
        self.patch_deployment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_deployment(&mut self) -> &mut PatchDeployment {
        if self.patch_deployment.is_none() {
            self.patch_deployment.set_default();
        }
        self.patch_deployment.as_mut().unwrap()
    }

    // Take field
    pub fn take_patch_deployment(&mut self) -> PatchDeployment {
        self.patch_deployment.take().unwrap_or_else(|| PatchDeployment::new())
    }
}

impl ::protobuf::Message for CreatePatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.patch_deployment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.patch_deployment_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patch_deployment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.patch_deployment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.patch_deployment_id);
        }
        if let Some(ref v) = self.patch_deployment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.patch_deployment_id.is_empty() {
            os.write_string(2, &self.patch_deployment_id)?;
        }
        if let Some(ref v) = self.patch_deployment.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePatchDeploymentRequest {
        CreatePatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreatePatchDeploymentRequest| { &m.parent },
                |m: &mut CreatePatchDeploymentRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "patch_deployment_id",
                |m: &CreatePatchDeploymentRequest| { &m.patch_deployment_id },
                |m: &mut CreatePatchDeploymentRequest| { &mut m.patch_deployment_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchDeployment>>(
                "patch_deployment",
                |m: &CreatePatchDeploymentRequest| { &m.patch_deployment },
                |m: &mut CreatePatchDeploymentRequest| { &mut m.patch_deployment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreatePatchDeploymentRequest>(
                "CreatePatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreatePatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<CreatePatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatePatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for CreatePatchDeploymentRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.patch_deployment_id.clear();
        self.patch_deployment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatePatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPatchDeploymentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPatchDeploymentRequest {
    fn default() -> &'a GetPatchDeploymentRequest {
        <GetPatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPatchDeploymentRequest {
    pub fn new() -> GetPatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPatchDeploymentRequest {
        GetPatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetPatchDeploymentRequest| { &m.name },
                |m: &mut GetPatchDeploymentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPatchDeploymentRequest>(
                "GetPatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetPatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<GetPatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for GetPatchDeploymentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchDeploymentsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchDeploymentsRequest {
    fn default() -> &'a ListPatchDeploymentsRequest {
        <ListPatchDeploymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchDeploymentsRequest {
    pub fn new() -> ListPatchDeploymentsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchDeploymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchDeploymentsRequest {
        ListPatchDeploymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListPatchDeploymentsRequest| { &m.parent },
                |m: &mut ListPatchDeploymentsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListPatchDeploymentsRequest| { &m.page_size },
                |m: &mut ListPatchDeploymentsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListPatchDeploymentsRequest| { &m.page_token },
                |m: &mut ListPatchDeploymentsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchDeploymentsRequest>(
                "ListPatchDeploymentsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchDeploymentsRequest {
        static instance: ::protobuf::rt::LazyV2<ListPatchDeploymentsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchDeploymentsRequest::new)
    }
}

impl ::protobuf::Clear for ListPatchDeploymentsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchDeploymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchDeploymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchDeploymentsResponse {
    // message fields
    pub patch_deployments: ::protobuf::RepeatedField<PatchDeployment>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchDeploymentsResponse {
    fn default() -> &'a ListPatchDeploymentsResponse {
        <ListPatchDeploymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchDeploymentsResponse {
    pub fn new() -> ListPatchDeploymentsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1.PatchDeployment patch_deployments = 1;


    pub fn get_patch_deployments(&self) -> &[PatchDeployment] {
        &self.patch_deployments
    }
    pub fn clear_patch_deployments(&mut self) {
        self.patch_deployments.clear();
    }

    // Param is passed by value, moved
    pub fn set_patch_deployments(&mut self, v: ::protobuf::RepeatedField<PatchDeployment>) {
        self.patch_deployments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patch_deployments(&mut self) -> &mut ::protobuf::RepeatedField<PatchDeployment> {
        &mut self.patch_deployments
    }

    // Take field
    pub fn take_patch_deployments(&mut self) -> ::protobuf::RepeatedField<PatchDeployment> {
        ::std::mem::replace(&mut self.patch_deployments, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchDeploymentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.patch_deployments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patch_deployments)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patch_deployments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patch_deployments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchDeploymentsResponse {
        ListPatchDeploymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchDeployment>>(
                "patch_deployments",
                |m: &ListPatchDeploymentsResponse| { &m.patch_deployments },
                |m: &mut ListPatchDeploymentsResponse| { &mut m.patch_deployments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListPatchDeploymentsResponse| { &m.next_page_token },
                |m: &mut ListPatchDeploymentsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchDeploymentsResponse>(
                "ListPatchDeploymentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchDeploymentsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPatchDeploymentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchDeploymentsResponse::new)
    }
}

impl ::protobuf::Clear for ListPatchDeploymentsResponse {
    fn clear(&mut self) {
        self.patch_deployments.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchDeploymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchDeploymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePatchDeploymentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePatchDeploymentRequest {
    fn default() -> &'a DeletePatchDeploymentRequest {
        <DeletePatchDeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePatchDeploymentRequest {
    pub fn new() -> DeletePatchDeploymentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeletePatchDeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePatchDeploymentRequest {
        DeletePatchDeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeletePatchDeploymentRequest| { &m.name },
                |m: &mut DeletePatchDeploymentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeletePatchDeploymentRequest>(
                "DeletePatchDeploymentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeletePatchDeploymentRequest {
        static instance: ::protobuf::rt::LazyV2<DeletePatchDeploymentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeletePatchDeploymentRequest::new)
    }
}

impl ::protobuf::Clear for DeletePatchDeploymentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePatchDeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePatchDeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n0google/cloud/osconfig/v1/patch_deployments.proto\x12\x18google.cloud.\
    osconfig.v1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/res\
    ource.proto\x1a)google/cloud/osconfig/v1/patch_jobs.proto\x1a\x1egoogle/\
    protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1ago\
    ogle/type/datetime.proto\x1a\x1bgoogle/type/dayofweek.proto\x1a\x1bgoogl\
    e/type/timeofday.proto\"\xff\x06\n\x0fPatchDeployment\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12%\n\x0bdescription\x18\x02\x20\x01(\tR\
    \x0bdescriptionB\x03\xe0A\x01\x12[\n\x0finstance_filter\x18\x03\x20\x01(\
    \x0b2-.google.cloud.osconfig.v1.PatchInstanceFilterR\x0einstanceFilterB\
    \x03\xe0A\x02\x12M\n\x0cpatch_config\x18\x04\x20\x01(\x0b2%.google.cloud\
    .osconfig.v1.PatchConfigR\x0bpatchConfigB\x03\xe0A\x01\x12:\n\x08duratio\
    n\x18\x05\x20\x01(\x0b2\x19.google.protobuf.DurationR\x08durationB\x03\
    \xe0A\x01\x12\\\n\x11one_time_schedule\x18\x06\x20\x01(\x0b2).google.clo\
    ud.osconfig.v1.OneTimeScheduleH\0R\x0foneTimeScheduleB\x03\xe0A\x02\x12a\
    \n\x12recurring_schedule\x18\x07\x20\x01(\x0b2+.google.cloud.osconfig.v1\
    .RecurringScheduleH\0R\x11recurringScheduleB\x03\xe0A\x02\x12@\n\x0bcrea\
    te_time\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\
    B\x03\xe0A\x03\x12@\n\x0bupdate_time\x18\t\x20\x01(\x0b2\x1a.google.prot\
    obuf.TimestampR\nupdateTimeB\x03\xe0A\x03\x12K\n\x11last_execute_time\
    \x18\n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0flastExecuteTimeB\
    \x03\xe0A\x03\x12E\n\x07rollout\x18\x0b\x20\x01(\x0b2&.google.cloud.osco\
    nfig.v1.PatchRolloutR\x07rolloutB\x03\xe0A\x01B\n\n\x08schedule:d\xeaAa\
    \n'osconfig.googleapis.com/PatchDeployment\x126projects/{project}/patchD\
    eployments/{patch_deployment}\"U\n\x0fOneTimeSchedule\x12B\n\x0cexecute_\
    time\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0bexecuteTime\
    B\x03\xe0A\x02\"\xe2\x05\n\x11RecurringSchedule\x127\n\ttime_zone\x18\
    \x01\x20\x01(\x0b2\x15.google.type.TimeZoneR\x08timeZoneB\x03\xe0A\x02\
    \x12>\n\nstart_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tstartTimeB\x03\xe0A\x01\x12:\n\x08end_time\x18\x03\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.TimestampR\x07endTimeB\x03\xe0A\x01\x12;\n\x0btime_of_day\
    \x18\x04\x20\x01(\x0b2\x16.google.type.TimeOfDayR\ttimeOfDayB\x03\xe0A\
    \x02\x12X\n\tfrequency\x18\x05\x20\x01(\x0e25.google.cloud.osconfig.v1.R\
    ecurringSchedule.FrequencyR\tfrequencyB\x03\xe0A\x02\x12G\n\x06weekly\
    \x18\x06\x20\x01(\x0b2(.google.cloud.osconfig.v1.WeeklyScheduleH\0R\x06w\
    eeklyB\x03\xe0A\x02\x12J\n\x07monthly\x18\x07\x20\x01(\x0b2).google.clou\
    d.osconfig.v1.MonthlyScheduleH\0R\x07monthlyB\x03\xe0A\x02\x12K\n\x11las\
    t_execute_time\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0flas\
    tExecuteTimeB\x03\xe0A\x03\x12K\n\x11next_execute_time\x18\n\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x0fnextExecuteTimeB\x03\xe0A\x03\"?\
    \n\tFrequency\x12\x19\n\x15FREQUENCY_UNSPECIFIED\x10\0\x12\n\n\x06WEEKLY\
    \x10\x01\x12\x0b\n\x07MONTHLY\x10\x02B\x11\n\x0fschedule_config\"M\n\x0e\
    WeeklySchedule\x12;\n\x0bday_of_week\x18\x01\x20\x01(\x0e2\x16.google.ty\
    pe.DayOfWeekR\tdayOfWeekB\x03\xe0A\x02\"\xa1\x01\n\x0fMonthlySchedule\
    \x12Z\n\x11week_day_of_month\x18\x01\x20\x01(\x0b2(.google.cloud.osconfi\
    g.v1.WeekDayOfMonthH\0R\x0eweekDayOfMonthB\x03\xe0A\x02\x12\"\n\tmonth_d\
    ay\x18\x02\x20\x01(\x05H\0R\x08monthDayB\x03\xe0A\x02B\x0e\n\x0cday_of_m\
    onth\"u\n\x0eWeekDayOfMonth\x12&\n\x0cweek_ordinal\x18\x01\x20\x01(\x05R\
    \x0bweekOrdinalB\x03\xe0A\x02\x12;\n\x0bday_of_week\x18\x02\x20\x01(\x0e\
    2\x16.google.type.DayOfWeekR\tdayOfWeekB\x03\xe0A\x02\"\xfb\x01\n\x1cCre\
    atePatchDeploymentRequest\x12K\n\x06parent\x18\x01\x20\x01(\tR\x06parent\
    B3\xfaA-\n+cloudresourcemanager.googleapis.com/Project\xe0A\x02\x123\n\
    \x13patch_deployment_id\x18\x02\x20\x01(\tR\x11patchDeploymentIdB\x03\
    \xe0A\x02\x12Y\n\x10patch_deployment\x18\x03\x20\x01(\x0b2).google.cloud\
    .osconfig.v1.PatchDeploymentR\x0fpatchDeploymentB\x03\xe0A\x02\"`\n\x19G\
    etPatchDeploymentRequest\x12C\n\x04name\x18\x01\x20\x01(\tR\x04nameB/\
    \xfaA)\n'osconfig.googleapis.com/PatchDeployment\xe0A\x02\"\xb0\x01\n\
    \x1bListPatchDeploymentsRequest\x12K\n\x06parent\x18\x01\x20\x01(\tR\x06\
    parentB3\xfaA-\n+cloudresourcemanager.googleapis.com/Project\xe0A\x02\
    \x12\x20\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSizeB\x03\xe0A\x01\
    \x12\"\n\npage_token\x18\x03\x20\x01(\tR\tpageTokenB\x03\xe0A\x01\"\x9e\
    \x01\n\x1cListPatchDeploymentsResponse\x12V\n\x11patch_deployments\x18\
    \x01\x20\x03(\x0b2).google.cloud.osconfig.v1.PatchDeploymentR\x10patchDe\
    ployments\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\
    c\n\x1cDeletePatchDeploymentRequest\x12C\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB/\xfaA)\n'osconfig.googleapis.com/PatchDeployment\xe0A\x02B\xc6\
    \x01\n\x1ccom.google.cloud.osconfig.v1B\x10PatchDeploymentsZ@google.gola\
    ng.org/genproto/googleapis/cloud/osconfig/v1;osconfig\xaa\x02\x18Google.\
    Cloud.OsConfig.V1\xca\x02\x18Google\\Cloud\\OsConfig\\V1\xea\x02\x1bGoog\
    le::Cloud::OsConfig::V1J\x94J\n\x07\x12\x05\x0e\0\x91\x02\x01\n\xbc\x04\
    \n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202020\x20Google\x20\
    LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x20\
    2.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20fi\
    le\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20\
    may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0!\n\t\n\x02\x03\0\x12\x03\
    \x12\0)\n\t\n\x02\x03\x01\x12\x03\x13\0#\n\t\n\x02\x03\x02\x12\x03\x14\0\
    3\n\t\n\x02\x03\x03\x12\x03\x15\0(\n\t\n\x02\x03\x04\x12\x03\x16\0)\n\t\
    \n\x02\x03\x05\x12\x03\x17\0$\n\t\n\x02\x03\x06\x12\x03\x18\0%\n\t\n\x02\
    \x03\x07\x12\x03\x19\0%\n\x08\n\x01\x08\x12\x03\x1b\05\n\t\n\x02\x08%\
    \x12\x03\x1b\05\n\x08\n\x01\x08\x12\x03\x1c\0W\n\t\n\x02\x08\x0b\x12\x03\
    \x1c\0W\n\x08\n\x01\x08\x12\x03\x1d\01\n\t\n\x02\x08\x08\x12\x03\x1d\01\
    \n\x08\n\x01\x08\x12\x03\x1e\05\n\t\n\x02\x08\x01\x12\x03\x1e\05\n\x08\n\
    \x01\x08\x12\x03\x1f\05\n\t\n\x02\x08)\x12\x03\x1f\05\n\x08\n\x01\x08\
    \x12\x03\x20\04\n\t\n\x02\x08-\x12\x03\x20\04\n\xf6\x02\n\x02\x04\0\x12\
    \x04'\0`\x01\x1a\xe9\x02\x20Patch\x20deployments\x20are\x20configuration\
    s\x20that\x20individual\x20patch\x20jobs\x20use\x20to\n\x20complete\x20a\
    \x20patch.\x20These\x20configurations\x20include\x20instance\x20filter,\
    \x20package\n\x20repository\x20settings,\x20and\x20a\x20schedule.\x20For\
    \x20more\x20information\x20about\x20creating\x20and\n\x20managing\x20pat\
    ch\x20deployments,\x20see\x20[Scheduling\x20patch\n\x20jobs](https://clo\
    ud.google.com/compute/docs/os-patch-management/schedule-patch-jobs).\n\n\
    \n\n\x03\x04\0\x01\x12\x03'\x08\x17\n\x0b\n\x03\x04\0\x07\x12\x04(\x02+\
    \x04\n\r\n\x05\x04\0\x07\x9d\x08\x12\x04(\x02+\x04\n\xf6\x01\n\x04\x04\0\
    \x02\0\x12\x031\x02\x12\x1a\xe8\x01\x20Unique\x20name\x20for\x20the\x20p\
    atch\x20deployment\x20resource\x20in\x20a\x20project.\x20The\x20patch\n\
    \x20deployment\x20name\x20is\x20in\x20the\x20form:\n\x20`projects/{proje\
    ct_id}/patchDeployments/{patch_deployment_id}`.\n\x20This\x20field\x20is\
    \x20ignored\x20when\x20you\x20create\x20a\x20new\x20patch\x20deployment.\
    \n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x031\x02\x08\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x031\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x031\x10\x11\nw\n\x04\
    \x04\0\x02\x01\x12\x035\x02B\x1aj\x20Optional.\x20Description\x20of\x20t\
    he\x20patch\x20deployment.\x20Length\x20of\x20the\x20description\x20is\n\
    \x20limited\x20to\x201024\x20characters.\n\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x035\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x035\t\x14\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x035\x17\x18\n\x0c\n\x05\x04\0\x02\x01\x08\
    \x12\x035\x19A\n\x0f\n\x08\x04\0\x02\x01\x08\x9c\x08\0\x12\x035\x1a@\n0\
    \n\x04\x04\0\x02\x02\x12\x048\x029/\x1a\"\x20Required.\x20VM\x20instance\
    s\x20to\x20patch.\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x038\x02\x15\n\x0c\
    \n\x05\x04\0\x02\x02\x01\x12\x038\x16%\n\x0c\n\x05\x04\0\x02\x02\x03\x12\
    \x038()\n\x0c\n\x05\x04\0\x02\x02\x08\x12\x039\x06.\n\x0f\n\x08\x04\0\
    \x02\x02\x08\x9c\x08\0\x12\x039\x07-\n=\n\x04\x04\0\x02\x03\x12\x03<\x02\
    H\x1a0\x20Optional.\x20Patch\x20configuration\x20that\x20is\x20applied.\
    \n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03<\x02\r\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03<\x0e\x1a\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03<\x1d\x1e\
    \n\x0c\n\x05\x04\0\x02\x03\x08\x12\x03<\x1fG\n\x0f\n\x08\x04\0\x02\x03\
    \x08\x9c\x08\0\x12\x03<\x20F\n_\n\x04\x04\0\x02\x04\x12\x04@\x02A/\x1aQ\
    \x20Optional.\x20Duration\x20of\x20the\x20patch.\x20After\x20the\x20dura\
    tion\x20ends,\x20the\x20patch\x20times\n\x20out.\n\n\x0c\n\x05\x04\0\x02\
    \x04\x06\x12\x03@\x02\x1a\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03@\x1b#\n\
    \x0c\n\x05\x04\0\x02\x04\x03\x12\x03@&'\n\x0c\n\x05\x04\0\x02\x04\x08\
    \x12\x03A\x06.\n\x0f\n\x08\x04\0\x02\x04\x08\x9c\x08\0\x12\x03A\x07-\n'\
    \n\x04\x04\0\x08\0\x12\x04D\x02L\x03\x1a\x19\x20Schedule\x20for\x20the\
    \x20patch.\n\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03D\x08\x10\n8\n\x04\x04\0\
    \x02\x05\x12\x04F\x04G1\x1a*\x20Required.\x20Schedule\x20a\x20one-time\
    \x20execution.\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03F\x04\x13\n\x0c\n\
    \x05\x04\0\x02\x05\x01\x12\x03F\x14%\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x03F()\n\x0c\n\x05\x04\0\x02\x05\x08\x12\x03G\x080\n\x0f\n\x08\x04\0\
    \x02\x05\x08\x9c\x08\0\x12\x03G\t/\n8\n\x04\x04\0\x02\x06\x12\x04J\x04K1\
    \x1a*\x20Required.\x20Schedule\x20recurring\x20executions.\n\n\x0c\n\x05\
    \x04\0\x02\x06\x06\x12\x03J\x04\x15\n\x0c\n\x05\x04\0\x02\x06\x01\x12\
    \x03J\x16(\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03J+,\n\x0c\n\x05\x04\0\
    \x02\x06\x08\x12\x03K\x080\n\x0f\n\x08\x04\0\x02\x06\x08\x9c\x08\0\x12\
    \x03K\t/\n\x92\x01\n\x04\x04\0\x02\x07\x12\x04P\x02Q2\x1a\x83\x01\x20Out\
    put\x20only.\x20Time\x20the\x20patch\x20deployment\x20was\x20created.\
    \x20Timestamp\x20is\x20in\n\x20[RFC3339](https://www.ietf.org/rfc/rfc333\
    9.txt)\x20text\x20format.\n\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03P\x02\
    \x1b\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03P\x1c'\n\x0c\n\x05\x04\0\x02\
    \x07\x03\x12\x03P*+\n\x0c\n\x05\x04\0\x02\x07\x08\x12\x03Q\x061\n\x0f\n\
    \x08\x04\0\x02\x07\x08\x9c\x08\0\x12\x03Q\x070\n\x97\x01\n\x04\x04\0\x02\
    \x08\x12\x04U\x02V2\x1a\x88\x01\x20Output\x20only.\x20Time\x20the\x20pat\
    ch\x20deployment\x20was\x20last\x20updated.\x20Timestamp\x20is\x20in\n\
    \x20[RFC3339](https://www.ietf.org/rfc/rfc3339.txt)\x20text\x20format.\n\
    \n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03U\x02\x1b\n\x0c\n\x05\x04\0\x02\
    \x08\x01\x12\x03U\x1c'\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03U*+\n\x0c\n\
    \x05\x04\0\x02\x08\x08\x12\x03V\x061\n\x0f\n\x08\x04\0\x02\x08\x08\x9c\
    \x08\0\x12\x03V\x070\n\xa6\x01\n\x04\x04\0\x02\t\x12\x04[\x02\\2\x1a\x97\
    \x01\x20Output\x20only.\x20The\x20last\x20time\x20a\x20patch\x20job\x20w\
    as\x20started\x20by\x20this\x20deployment.\n\x20Timestamp\x20is\x20in\
    \x20[RFC3339](https://www.ietf.org/rfc/rfc3339.txt)\x20text\n\x20format.\
    \n\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03[\x02\x1b\n\x0c\n\x05\x04\0\x02\t\
    \x01\x12\x03[\x1c-\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03[02\n\x0c\n\x05\
    \x04\0\x02\t\x08\x12\x03\\\x061\n\x0f\n\x08\x04\0\x02\t\x08\x9c\x08\0\
    \x12\x03\\\x070\n;\n\x04\x04\0\x02\n\x12\x03_\x02E\x1a.\x20Optional.\x20\
    Rollout\x20strategy\x20of\x20the\x20patch\x20job.\n\n\x0c\n\x05\x04\0\
    \x02\n\x06\x12\x03_\x02\x0e\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03_\x0f\x16\
    \n\x0c\n\x05\x04\0\x02\n\x03\x12\x03_\x19\x1b\n\x0c\n\x05\x04\0\x02\n\
    \x08\x12\x03_\x1cD\n\x0f\n\x08\x04\0\x02\n\x08\x9c\x08\0\x12\x03_\x1dC\n\
    \x8a\x01\n\x02\x04\x01\x12\x04d\0h\x01\x1a~\x20Sets\x20the\x20time\x20fo\
    r\x20a\x20one\x20time\x20patch\x20deployment.\x20Timestamp\x20is\x20in\n\
    \x20[RFC3339](https://www.ietf.org/rfc/rfc3339.txt)\x20text\x20format.\n\
    \n\n\n\x03\x04\x01\x01\x12\x03d\x08\x17\n?\n\x04\x04\x01\x02\0\x12\x04f\
    \x02g/\x1a1\x20Required.\x20The\x20desired\x20patch\x20job\x20execution\
    \x20time.\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03f\x02\x1b\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03f\x1c(\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03f+\
    ,\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03g\x06.\n\x0f\n\x08\x04\x01\x02\0\
    \x08\x9c\x08\0\x12\x03g\x07-\n=\n\x02\x04\x02\x12\x05k\0\xa0\x01\x01\x1a\
    0\x20Sets\x20the\x20time\x20for\x20recurring\x20patch\x20deployments.\n\
    \n\n\n\x03\x04\x02\x01\x12\x03k\x08\x19\nK\n\x04\x04\x02\x04\0\x12\x04m\
    \x02x\x03\x1a=\x20Specifies\x20the\x20frequency\x20of\x20the\x20recurrin\
    g\x20patch\x20deployments.\n\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03m\x07\
    \x10\n8\n\x06\x04\x02\x04\0\x02\0\x12\x03o\x04\x1e\x1a)\x20Invalid.\x20A\
    \x20frequency\x20must\x20be\x20specified.\n\n\x0e\n\x07\x04\x02\x04\0\
    \x02\0\x01\x12\x03o\x04\x19\n\x0e\n\x07\x04\x02\x04\0\x02\0\x02\x12\x03o\
    \x1c\x1d\nU\n\x06\x04\x02\x04\0\x02\x01\x12\x03s\x04\x0f\x1aF\x20Indicat\
    es\x20that\x20the\x20frequency\x20should\x20be\x20expressed\x20in\x20ter\
    ms\x20of\n\x20weeks.\n\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x01\x12\x03s\
    \x04\n\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x02\x12\x03s\r\x0e\nV\n\x06\x04\
    \x02\x04\0\x02\x02\x12\x03w\x04\x10\x1aG\x20Indicates\x20that\x20the\x20\
    frequency\x20should\x20be\x20expressed\x20in\x20terms\x20of\n\x20months.\
    \n\n\x0e\n\x07\x04\x02\x04\0\x02\x02\x01\x12\x03w\x04\x0b\n\x0e\n\x07\
    \x04\x02\x04\0\x02\x02\x02\x12\x03w\x0e\x0f\n\x9e\x01\n\x04\x04\x02\x02\
    \0\x12\x03|\x02N\x1a\x90\x01\x20Required.\x20Defines\x20the\x20time\x20z\
    one\x20that\x20`time_of_day`\x20is\x20relative\x20to.\n\x20The\x20rules\
    \x20for\x20daylight\x20saving\x20time\x20are\x20determined\x20by\x20the\
    \x20chosen\x20time\x20zone.\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03|\x02\
    \x16\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03|\x17\x20\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03|#$\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03|%M\n\x0f\n\
    \x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x03|&L\n\x87\x01\n\x04\x04\x02\x02\
    \x01\x12\x06\x80\x01\x02\x81\x01/\x1aw\x20Optional.\x20The\x20time\x20th\
    at\x20the\x20recurring\x20schedule\x20becomes\x20effective.\n\x20Default\
    s\x20to\x20`create_time`\x20of\x20the\x20patch\x20deployment.\n\n\r\n\
    \x05\x04\x02\x02\x01\x06\x12\x04\x80\x01\x02\x1b\n\r\n\x05\x04\x02\x02\
    \x01\x01\x12\x04\x80\x01\x1c&\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x80\
    \x01)*\n\r\n\x05\x04\x02\x02\x01\x08\x12\x04\x81\x01\x06.\n\x10\n\x08\
    \x04\x02\x02\x01\x08\x9c\x08\0\x12\x04\x81\x01\x07-\nm\n\x04\x04\x02\x02\
    \x02\x12\x06\x85\x01\x02\x86\x01/\x1a]\x20Optional.\x20The\x20end\x20tim\
    e\x20at\x20which\x20a\x20recurring\x20patch\x20deployment\x20schedule\
    \x20is\x20no\n\x20longer\x20active.\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\
    \x04\x85\x01\x02\x1b\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x85\x01\x1c$\
    \n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\x85\x01'(\n\r\n\x05\x04\x02\x02\
    \x02\x08\x12\x04\x86\x01\x06.\n\x10\n\x08\x04\x02\x02\x02\x08\x9c\x08\0\
    \x12\x04\x86\x01\x07-\nJ\n\x04\x04\x02\x02\x03\x12\x06\x89\x01\x02\x8a\
    \x01/\x1a:\x20Required.\x20Time\x20of\x20the\x20day\x20to\x20run\x20a\
    \x20recurring\x20deployment.\n\n\r\n\x05\x04\x02\x02\x03\x06\x12\x04\x89\
    \x01\x02\x17\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\x89\x01\x18#\n\r\n\
    \x05\x04\x02\x02\x03\x03\x12\x04\x89\x01&'\n\r\n\x05\x04\x02\x02\x03\x08\
    \x12\x04\x8a\x01\x06.\n\x10\n\x08\x04\x02\x02\x03\x08\x9c\x08\0\x12\x04\
    \x8a\x01\x07-\nH\n\x04\x04\x02\x02\x04\x12\x04\x8d\x01\x02C\x1a:\x20Requ\
    ired.\x20The\x20frequency\x20unit\x20of\x20this\x20recurring\x20schedule\
    .\n\n\r\n\x05\x04\x02\x02\x04\x06\x12\x04\x8d\x01\x02\x0b\n\r\n\x05\x04\
    \x02\x02\x04\x01\x12\x04\x8d\x01\x0c\x15\n\r\n\x05\x04\x02\x02\x04\x03\
    \x12\x04\x8d\x01\x18\x19\n\r\n\x05\x04\x02\x02\x04\x08\x12\x04\x8d\x01\
    \x1aB\n\x10\n\x08\x04\x02\x02\x04\x08\x9c\x08\0\x12\x04\x8d\x01\x1bA\nc\
    \n\x04\x04\x02\x08\0\x12\x06\x91\x01\x02\x97\x01\x03\x1aS\x20Configurati\
    ons\x20for\x20this\x20recurring\x20schedule.\n\x20Configurations\x20must\
    \x20match\x20frequency.\n\n\r\n\x05\x04\x02\x08\0\x01\x12\x04\x91\x01\
    \x08\x17\n:\n\x04\x04\x02\x02\x05\x12\x04\x93\x01\x04G\x1a,\x20Required.\
    \x20Schedule\x20with\x20weekly\x20executions.\n\n\r\n\x05\x04\x02\x02\
    \x05\x06\x12\x04\x93\x01\x04\x12\n\r\n\x05\x04\x02\x02\x05\x01\x12\x04\
    \x93\x01\x13\x19\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\x93\x01\x1c\x1d\n\
    \r\n\x05\x04\x02\x02\x05\x08\x12\x04\x93\x01\x1eF\n\x10\n\x08\x04\x02\
    \x02\x05\x08\x9c\x08\0\x12\x04\x93\x01\x1fE\n;\n\x04\x04\x02\x02\x06\x12\
    \x04\x96\x01\x04I\x1a-\x20Required.\x20Schedule\x20with\x20monthly\x20ex\
    ecutions.\n\n\r\n\x05\x04\x02\x02\x06\x06\x12\x04\x96\x01\x04\x13\n\r\n\
    \x05\x04\x02\x02\x06\x01\x12\x04\x96\x01\x14\x1b\n\r\n\x05\x04\x02\x02\
    \x06\x03\x12\x04\x96\x01\x1e\x1f\n\r\n\x05\x04\x02\x02\x06\x08\x12\x04\
    \x96\x01\x20H\n\x10\n\x08\x04\x02\x02\x06\x08\x9c\x08\0\x12\x04\x96\x01!\
    G\nL\n\x04\x04\x02\x02\x07\x12\x06\x9a\x01\x02\x9b\x012\x1a<\x20Output\
    \x20only.\x20The\x20time\x20the\x20last\x20patch\x20job\x20ran\x20succes\
    sfully.\n\n\r\n\x05\x04\x02\x02\x07\x06\x12\x04\x9a\x01\x02\x1b\n\r\n\
    \x05\x04\x02\x02\x07\x01\x12\x04\x9a\x01\x1c-\n\r\n\x05\x04\x02\x02\x07\
    \x03\x12\x04\x9a\x0101\n\r\n\x05\x04\x02\x02\x07\x08\x12\x04\x9b\x01\x06\
    1\n\x10\n\x08\x04\x02\x02\x07\x08\x9c\x08\0\x12\x04\x9b\x01\x070\nO\n\
    \x04\x04\x02\x02\x08\x12\x06\x9e\x01\x02\x9f\x012\x1a?\x20Output\x20only\
    .\x20The\x20time\x20the\x20next\x20patch\x20job\x20is\x20scheduled\x20to\
    \x20run.\n\n\r\n\x05\x04\x02\x02\x08\x06\x12\x04\x9e\x01\x02\x1b\n\r\n\
    \x05\x04\x02\x02\x08\x01\x12\x04\x9e\x01\x1c-\n\r\n\x05\x04\x02\x02\x08\
    \x03\x12\x04\x9e\x0102\n\r\n\x05\x04\x02\x02\x08\x08\x12\x04\x9f\x01\x06\
    1\n\x10\n\x08\x04\x02\x02\x08\x08\x9c\x08\0\x12\x04\x9f\x01\x070\n-\n\
    \x02\x04\x03\x12\x06\xa3\x01\0\xa7\x01\x01\x1a\x1f\x20Represents\x20a\
    \x20weekly\x20schedule.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xa3\x01\x08\
    \x16\n,\n\x04\x04\x03\x02\0\x12\x06\xa5\x01\x02\xa6\x01/\x1a\x1c\x20Requ\
    ired.\x20Day\x20of\x20the\x20week.\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\
    \xa5\x01\x02\x17\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xa5\x01\x18#\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\xa5\x01&'\n\r\n\x05\x04\x03\x02\0\x08\x12\
    \x04\xa6\x01\x06.\n\x10\n\x08\x04\x03\x02\0\x08\x9c\x08\0\x12\x04\xa6\
    \x01\x07-\n\x9d\x01\n\x02\x04\x04\x12\x06\xab\x01\0\xb8\x01\x01\x1a\x8e\
    \x01\x20Represents\x20a\x20monthly\x20schedule.\x20An\x20example\x20of\
    \x20a\x20valid\x20monthly\x20schedule\x20is\n\x20\"on\x20the\x20third\
    \x20Tuesday\x20of\x20the\x20month\"\x20or\x20\"on\x20the\x2015th\x20of\
    \x20the\x20month\".\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xab\x01\x08\x17\n%\
    \n\x04\x04\x04\x08\0\x12\x06\xad\x01\x02\xb7\x01\x03\x1a\x15\x20One\x20d\
    ay\x20in\x20a\x20month.\n\n\r\n\x05\x04\x04\x08\0\x01\x12\x04\xad\x01\
    \x08\x14\n0\n\x04\x04\x04\x02\0\x12\x06\xaf\x01\x04\xb0\x011\x1a\x20\x20\
    Required.\x20Week\x20day\x20in\x20a\x20month.\n\n\r\n\x05\x04\x04\x02\0\
    \x06\x12\x04\xaf\x01\x04\x12\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xaf\x01\
    \x13$\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xaf\x01'(\n\r\n\x05\x04\x04\
    \x02\0\x08\x12\x04\xb0\x01\x080\n\x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\
    \x12\x04\xb0\x01\t/\n\x97\x02\n\x04\x04\x04\x02\x01\x12\x04\xb6\x01\x04A\
    \x1a\x88\x02\x20Required.\x20One\x20day\x20of\x20the\x20month.\x201-31\
    \x20indicates\x20the\x201st\x20to\x20the\x2031st\x20day.\n\x20-1\x20indi\
    cates\x20the\x20last\x20day\x20of\x20the\x20month.\x20Months\x20without\
    \x20the\x20target\x20day\n\x20will\x20be\x20skipped.\x20For\x20example,\
    \x20a\x20schedule\x20to\x20run\x20\"every\x20month\x20on\x20the\x2031st\
    \"\n\x20will\x20not\x20run\x20in\x20February,\x20April,\x20June,\x20etc.\
    \n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xb6\x01\x04\t\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\xb6\x01\n\x13\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\
    \xb6\x01\x16\x17\n\r\n\x05\x04\x04\x02\x01\x08\x12\x04\xb6\x01\x18@\n\
    \x10\n\x08\x04\x04\x02\x01\x08\x9c\x08\0\x12\x04\xb6\x01\x19?\nS\n\x02\
    \x04\x05\x12\x06\xbb\x01\0\xc3\x01\x01\x1aE\x20Represents\x20one\x20week\
    \x20day\x20in\x20a\x20month.\x20An\x20example\x20is\x20\"the\x204th\x20S\
    unday\".\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xbb\x01\x08\x16\n\x8b\x01\n\
    \x04\x04\x05\x02\0\x12\x04\xbe\x01\x02B\x1a}\x20Required.\x20Week\x20num\
    ber\x20in\x20a\x20month.\x201-4\x20indicates\x20the\x201st\x20to\x204th\
    \x20week\x20of\x20the\n\x20month.\x20-1\x20indicates\x20the\x20last\x20w\
    eek\x20of\x20the\x20month.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xbe\x01\
    \x02\x07\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xbe\x01\x08\x14\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xbe\x01\x17\x18\n\r\n\x05\x04\x05\x02\0\x08\
    \x12\x04\xbe\x01\x19A\n\x10\n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\
    \xbe\x01\x1a@\n.\n\x04\x04\x05\x02\x01\x12\x06\xc1\x01\x02\xc2\x01/\x1a\
    \x1e\x20Required.\x20A\x20day\x20of\x20the\x20week.\n\n\r\n\x05\x04\x05\
    \x02\x01\x06\x12\x04\xc1\x01\x02\x17\n\r\n\x05\x04\x05\x02\x01\x01\x12\
    \x04\xc1\x01\x18#\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xc1\x01&'\n\r\n\
    \x05\x04\x05\x02\x01\x08\x12\x04\xc2\x01\x06.\n\x10\n\x08\x04\x05\x02\
    \x01\x08\x9c\x08\0\x12\x04\xc2\x01\x07-\nB\n\x02\x04\x06\x12\x06\xc6\x01\
    \0\xdb\x01\x01\x1a4\x20A\x20request\x20message\x20for\x20creating\x20a\
    \x20patch\x20deployment.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xc6\x01\x08$\
    \nd\n\x04\x04\x06\x02\0\x12\x06\xc9\x01\x02\xce\x01\x04\x1aT\x20Required\
    .\x20The\x20project\x20to\x20apply\x20this\x20patch\x20deployment\x20to\
    \x20in\x20the\x20form\n\x20`projects/*`.\n\n\r\n\x05\x04\x06\x02\0\x05\
    \x12\x04\xc9\x01\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xc9\x01\t\
    \x0f\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xc9\x01\x12\x13\n\x0f\n\x05\x04\
    \x06\x02\0\x08\x12\x06\xc9\x01\x14\xce\x01\x03\n\x10\n\x08\x04\x06\x02\0\
    \x08\x9c\x08\0\x12\x04\xca\x01\x04*\n\x11\n\x07\x04\x06\x02\0\x08\x9f\
    \x08\x12\x06\xcb\x01\x04\xcd\x01\x05\n\xc7\x02\n\x04\x04\x06\x02\x01\x12\
    \x04\xd7\x01\x02J\x1a\xb8\x02\x20Required.\x20A\x20name\x20for\x20the\
    \x20patch\x20deployment\x20in\x20the\x20project.\x20When\x20creating\x20\
    a\n\x20name\x20the\x20following\x20rules\x20apply:\n\x20*\x20Must\x20con\
    tain\x20only\x20lowercase\x20letters,\x20numbers,\x20and\x20hyphens.\n\
    \x20*\x20Must\x20start\x20with\x20a\x20letter.\n\x20*\x20Must\x20be\x20b\
    etween\x201-63\x20characters.\n\x20*\x20Must\x20end\x20with\x20a\x20numb\
    er\x20or\x20a\x20letter.\n\x20*\x20Must\x20be\x20unique\x20within\x20the\
    \x20project.\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xd7\x01\x02\x08\n\r\
    \n\x05\x04\x06\x02\x01\x01\x12\x04\xd7\x01\t\x1c\n\r\n\x05\x04\x06\x02\
    \x01\x03\x12\x04\xd7\x01\x1f\x20\n\r\n\x05\x04\x06\x02\x01\x08\x12\x04\
    \xd7\x01!I\n\x10\n\x08\x04\x06\x02\x01\x08\x9c\x08\0\x12\x04\xd7\x01\"H\
    \n9\n\x04\x04\x06\x02\x02\x12\x04\xda\x01\x02P\x1a+\x20Required.\x20The\
    \x20patch\x20deployment\x20to\x20create.\n\n\r\n\x05\x04\x06\x02\x02\x06\
    \x12\x04\xda\x01\x02\x11\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xda\x01\
    \x12\"\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xda\x01%&\n\r\n\x05\x04\x06\
    \x02\x02\x08\x12\x04\xda\x01'O\n\x10\n\x08\x04\x06\x02\x02\x08\x9c\x08\0\
    \x12\x04\xda\x01(N\nD\n\x02\x04\x07\x12\x06\xde\x01\0\xe7\x01\x01\x1a6\
    \x20A\x20request\x20message\x20for\x20retrieving\x20a\x20patch\x20deploy\
    ment.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xde\x01\x08!\ns\n\x04\x04\x07\
    \x02\0\x12\x06\xe1\x01\x02\xe6\x01\x04\x1ac\x20Required.\x20The\x20resou\
    rce\x20name\x20of\x20the\x20patch\x20deployment\x20in\x20the\x20form\n\
    \x20`projects/*/patchDeployments/*`.\n\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\xe1\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xe1\x01\t\r\n\r\
    \n\x05\x04\x07\x02\0\x03\x12\x04\xe1\x01\x10\x11\n\x0f\n\x05\x04\x07\x02\
    \0\x08\x12\x06\xe1\x01\x12\xe6\x01\x03\n\x10\n\x08\x04\x07\x02\0\x08\x9c\
    \x08\0\x12\x04\xe2\x01\x04*\n\x11\n\x07\x04\x07\x02\0\x08\x9f\x08\x12\
    \x06\xe3\x01\x04\xe5\x01\x05\n@\n\x02\x04\x08\x12\x06\xea\x01\0\xfb\x01\
    \x01\x1a2\x20A\x20request\x20message\x20for\x20listing\x20patch\x20deplo\
    yments.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xea\x01\x08#\nU\n\x04\x04\x08\
    \x02\0\x12\x06\xec\x01\x02\xf1\x01\x04\x1aE\x20Required.\x20The\x20resou\
    rce\x20name\x20of\x20the\x20parent\x20in\x20the\x20form\x20`projects/*`.\
    \n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xec\x01\x02\x08\n\r\n\x05\x04\x08\
    \x02\0\x01\x12\x04\xec\x01\t\x0f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xec\
    \x01\x12\x13\n\x0f\n\x05\x04\x08\x02\0\x08\x12\x06\xec\x01\x14\xf1\x01\
    \x03\n\x10\n\x08\x04\x08\x02\0\x08\x9c\x08\0\x12\x04\xed\x01\x04*\n\x11\
    \n\x07\x04\x08\x02\0\x08\x9f\x08\x12\x06\xee\x01\x04\xf0\x01\x05\n]\n\
    \x04\x04\x08\x02\x01\x12\x04\xf5\x01\x02?\x1aO\x20Optional.\x20The\x20ma\
    ximum\x20number\x20of\x20patch\x20deployments\x20to\x20return.\x20Defaul\
    t\x20is\n\x20100.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xf5\x01\x02\
    \x07\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xf5\x01\x08\x11\n\r\n\x05\x04\
    \x08\x02\x01\x03\x12\x04\xf5\x01\x14\x15\n\r\n\x05\x04\x08\x02\x01\x08\
    \x12\x04\xf5\x01\x16>\n\x10\n\x08\x04\x08\x02\x01\x08\x9c\x08\0\x12\x04\
    \xf5\x01\x17=\n\x9d\x01\n\x04\x04\x08\x02\x02\x12\x04\xfa\x01\x02A\x1a\
    \x8e\x01\x20Optional.\x20A\x20pagination\x20token\x20returned\x20from\
    \x20a\x20previous\x20call\x20to\n\x20ListPatchDeployments\x20that\x20ind\
    icates\x20where\x20this\x20listing\x20should\x20continue\n\x20from.\n\n\
    \r\n\x05\x04\x08\x02\x02\x05\x12\x04\xfa\x01\x02\x08\n\r\n\x05\x04\x08\
    \x02\x02\x01\x12\x04\xfa\x01\t\x13\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\
    \xfa\x01\x16\x17\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\xfa\x01\x18@\n\
    \x10\n\x08\x04\x08\x02\x02\x08\x9c\x08\0\x12\x04\xfa\x01\x19?\nA\n\x02\
    \x04\t\x12\x06\xfe\x01\0\x85\x02\x01\x1a3\x20A\x20response\x20message\
    \x20for\x20listing\x20patch\x20deployments.\n\n\x0b\n\x03\x04\t\x01\x12\
    \x04\xfe\x01\x08$\n.\n\x04\x04\t\x02\0\x12\x04\x80\x02\x021\x1a\x20\x20T\
    he\x20list\x20of\x20patch\x20deployments.\n\n\r\n\x05\x04\t\x02\0\x04\
    \x12\x04\x80\x02\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x80\x02\x0b\x1a\
    \n\r\n\x05\x04\t\x02\0\x01\x12\x04\x80\x02\x1b,\n\r\n\x05\x04\t\x02\0\
    \x03\x12\x04\x80\x02/0\n_\n\x04\x04\t\x02\x01\x12\x04\x84\x02\x02\x1d\
    \x1aQ\x20A\x20pagination\x20token\x20that\x20can\x20be\x20used\x20to\x20\
    get\x20the\x20next\x20page\x20of\x20patch\n\x20deployments.\n\n\r\n\x05\
    \x04\t\x02\x01\x05\x12\x04\x84\x02\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\
    \x12\x04\x84\x02\t\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x84\x02\x1b\
    \x1c\nB\n\x02\x04\n\x12\x06\x88\x02\0\x91\x02\x01\x1a4\x20A\x20request\
    \x20message\x20for\x20deleting\x20a\x20patch\x20deployment.\n\n\x0b\n\
    \x03\x04\n\x01\x12\x04\x88\x02\x08$\ns\n\x04\x04\n\x02\0\x12\x06\x8b\x02\
    \x02\x90\x02\x04\x1ac\x20Required.\x20The\x20resource\x20name\x20of\x20t\
    he\x20patch\x20deployment\x20in\x20the\x20form\n\x20`projects/*/patchDep\
    loyments/*`.\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x8b\x02\x02\x08\n\r\n\
    \x05\x04\n\x02\0\x01\x12\x04\x8b\x02\t\r\n\r\n\x05\x04\n\x02\0\x03\x12\
    \x04\x8b\x02\x10\x11\n\x0f\n\x05\x04\n\x02\0\x08\x12\x06\x8b\x02\x12\x90\
    \x02\x03\n\x10\n\x08\x04\n\x02\0\x08\x9c\x08\0\x12\x04\x8c\x02\x04*\n\
    \x11\n\x07\x04\n\x02\0\x08\x9f\x08\x12\x06\x8d\x02\x04\x8f\x02\x05b\x06p\
    roto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
