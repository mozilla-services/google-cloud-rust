// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1/patch_jobs.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct ExecutePatchJobRequest {
    // message fields
    pub parent: ::std::string::String,
    pub description: ::std::string::String,
    pub instance_filter: ::protobuf::SingularPtrField<PatchInstanceFilter>,
    pub patch_config: ::protobuf::SingularPtrField<PatchConfig>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub dry_run: bool,
    pub display_name: ::std::string::String,
    pub rollout: ::protobuf::SingularPtrField<PatchRollout>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutePatchJobRequest {
    fn default() -> &'a ExecutePatchJobRequest {
        <ExecutePatchJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecutePatchJobRequest {
    pub fn new() -> ExecutePatchJobRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.PatchInstanceFilter instance_filter = 7;


    pub fn get_instance_filter(&self) -> &PatchInstanceFilter {
        self.instance_filter.as_ref().unwrap_or_else(|| <PatchInstanceFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance_filter(&mut self) {
        self.instance_filter.clear();
    }

    pub fn has_instance_filter(&self) -> bool {
        self.instance_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_filter(&mut self, v: PatchInstanceFilter) {
        self.instance_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_filter(&mut self) -> &mut PatchInstanceFilter {
        if self.instance_filter.is_none() {
            self.instance_filter.set_default();
        }
        self.instance_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_filter(&mut self) -> PatchInstanceFilter {
        self.instance_filter.take().unwrap_or_else(|| PatchInstanceFilter::new())
    }

    // .google.cloud.osconfig.v1.PatchConfig patch_config = 4;


    pub fn get_patch_config(&self) -> &PatchConfig {
        self.patch_config.as_ref().unwrap_or_else(|| <PatchConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_patch_config(&mut self) {
        self.patch_config.clear();
    }

    pub fn has_patch_config(&self) -> bool {
        self.patch_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_config(&mut self, v: PatchConfig) {
        self.patch_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_config(&mut self) -> &mut PatchConfig {
        if self.patch_config.is_none() {
            self.patch_config.set_default();
        }
        self.patch_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_patch_config(&mut self) -> PatchConfig {
        self.patch_config.take().unwrap_or_else(|| PatchConfig::new())
    }

    // .google.protobuf.Duration duration = 5;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // bool dry_run = 6;


    pub fn get_dry_run(&self) -> bool {
        self.dry_run
    }
    pub fn clear_dry_run(&mut self) {
        self.dry_run = false;
    }

    // Param is passed by value, moved
    pub fn set_dry_run(&mut self, v: bool) {
        self.dry_run = v;
    }

    // string display_name = 8;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.PatchRollout rollout = 9;


    pub fn get_rollout(&self) -> &PatchRollout {
        self.rollout.as_ref().unwrap_or_else(|| <PatchRollout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout(&mut self) {
        self.rollout.clear();
    }

    pub fn has_rollout(&self) -> bool {
        self.rollout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout(&mut self, v: PatchRollout) {
        self.rollout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout(&mut self) -> &mut PatchRollout {
        if self.rollout.is_none() {
            self.rollout.set_default();
        }
        self.rollout.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout(&mut self) -> PatchRollout {
        self.rollout.take().unwrap_or_else(|| PatchRollout::new())
    }
}

impl ::protobuf::Message for ExecutePatchJobRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patch_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_filter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patch_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dry_run = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.dry_run != false {
            my_size += 2;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.display_name);
        }
        if let Some(ref v) = self.rollout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.dry_run != false {
            os.write_bool(6, self.dry_run)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(8, &self.display_name)?;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutePatchJobRequest {
        ExecutePatchJobRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ExecutePatchJobRequest| { &m.parent },
                |m: &mut ExecutePatchJobRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ExecutePatchJobRequest| { &m.description },
                |m: &mut ExecutePatchJobRequest| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchInstanceFilter>>(
                "instance_filter",
                |m: &ExecutePatchJobRequest| { &m.instance_filter },
                |m: &mut ExecutePatchJobRequest| { &mut m.instance_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchConfig>>(
                "patch_config",
                |m: &ExecutePatchJobRequest| { &m.patch_config },
                |m: &mut ExecutePatchJobRequest| { &mut m.patch_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &ExecutePatchJobRequest| { &m.duration },
                |m: &mut ExecutePatchJobRequest| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dry_run",
                |m: &ExecutePatchJobRequest| { &m.dry_run },
                |m: &mut ExecutePatchJobRequest| { &mut m.dry_run },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &ExecutePatchJobRequest| { &m.display_name },
                |m: &mut ExecutePatchJobRequest| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchRollout>>(
                "rollout",
                |m: &ExecutePatchJobRequest| { &m.rollout },
                |m: &mut ExecutePatchJobRequest| { &mut m.rollout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecutePatchJobRequest>(
                "ExecutePatchJobRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecutePatchJobRequest {
        static instance: ::protobuf::rt::LazyV2<ExecutePatchJobRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecutePatchJobRequest::new)
    }
}

impl ::protobuf::Clear for ExecutePatchJobRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.description.clear();
        self.instance_filter.clear();
        self.patch_config.clear();
        self.duration.clear();
        self.dry_run = false;
        self.display_name.clear();
        self.rollout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutePatchJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutePatchJobRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPatchJobRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPatchJobRequest {
    fn default() -> &'a GetPatchJobRequest {
        <GetPatchJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPatchJobRequest {
    pub fn new() -> GetPatchJobRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPatchJobRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPatchJobRequest {
        GetPatchJobRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetPatchJobRequest| { &m.name },
                |m: &mut GetPatchJobRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPatchJobRequest>(
                "GetPatchJobRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetPatchJobRequest {
        static instance: ::protobuf::rt::LazyV2<GetPatchJobRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPatchJobRequest::new)
    }
}

impl ::protobuf::Clear for GetPatchJobRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPatchJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPatchJobRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchJobInstanceDetailsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub filter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchJobInstanceDetailsRequest {
    fn default() -> &'a ListPatchJobInstanceDetailsRequest {
        <ListPatchJobInstanceDetailsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchJobInstanceDetailsRequest {
    pub fn new() -> ListPatchJobInstanceDetailsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string filter = 4;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchJobInstanceDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchJobInstanceDetailsRequest {
        ListPatchJobInstanceDetailsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListPatchJobInstanceDetailsRequest| { &m.parent },
                |m: &mut ListPatchJobInstanceDetailsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListPatchJobInstanceDetailsRequest| { &m.page_size },
                |m: &mut ListPatchJobInstanceDetailsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListPatchJobInstanceDetailsRequest| { &m.page_token },
                |m: &mut ListPatchJobInstanceDetailsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListPatchJobInstanceDetailsRequest| { &m.filter },
                |m: &mut ListPatchJobInstanceDetailsRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchJobInstanceDetailsRequest>(
                "ListPatchJobInstanceDetailsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchJobInstanceDetailsRequest {
        static instance: ::protobuf::rt::LazyV2<ListPatchJobInstanceDetailsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchJobInstanceDetailsRequest::new)
    }
}

impl ::protobuf::Clear for ListPatchJobInstanceDetailsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchJobInstanceDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchJobInstanceDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchJobInstanceDetailsResponse {
    // message fields
    pub patch_job_instance_details: ::protobuf::RepeatedField<PatchJobInstanceDetails>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchJobInstanceDetailsResponse {
    fn default() -> &'a ListPatchJobInstanceDetailsResponse {
        <ListPatchJobInstanceDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchJobInstanceDetailsResponse {
    pub fn new() -> ListPatchJobInstanceDetailsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1.PatchJobInstanceDetails patch_job_instance_details = 1;


    pub fn get_patch_job_instance_details(&self) -> &[PatchJobInstanceDetails] {
        &self.patch_job_instance_details
    }
    pub fn clear_patch_job_instance_details(&mut self) {
        self.patch_job_instance_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_patch_job_instance_details(&mut self, v: ::protobuf::RepeatedField<PatchJobInstanceDetails>) {
        self.patch_job_instance_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patch_job_instance_details(&mut self) -> &mut ::protobuf::RepeatedField<PatchJobInstanceDetails> {
        &mut self.patch_job_instance_details
    }

    // Take field
    pub fn take_patch_job_instance_details(&mut self) -> ::protobuf::RepeatedField<PatchJobInstanceDetails> {
        ::std::mem::replace(&mut self.patch_job_instance_details, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchJobInstanceDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.patch_job_instance_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patch_job_instance_details)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patch_job_instance_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patch_job_instance_details {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchJobInstanceDetailsResponse {
        ListPatchJobInstanceDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchJobInstanceDetails>>(
                "patch_job_instance_details",
                |m: &ListPatchJobInstanceDetailsResponse| { &m.patch_job_instance_details },
                |m: &mut ListPatchJobInstanceDetailsResponse| { &mut m.patch_job_instance_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListPatchJobInstanceDetailsResponse| { &m.next_page_token },
                |m: &mut ListPatchJobInstanceDetailsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchJobInstanceDetailsResponse>(
                "ListPatchJobInstanceDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchJobInstanceDetailsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPatchJobInstanceDetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchJobInstanceDetailsResponse::new)
    }
}

impl ::protobuf::Clear for ListPatchJobInstanceDetailsResponse {
    fn clear(&mut self) {
        self.patch_job_instance_details.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchJobInstanceDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchJobInstanceDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchJobInstanceDetails {
    // message fields
    pub name: ::std::string::String,
    pub instance_system_id: ::std::string::String,
    pub state: Instance_PatchState,
    pub failure_reason: ::std::string::String,
    pub attempt_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchJobInstanceDetails {
    fn default() -> &'a PatchJobInstanceDetails {
        <PatchJobInstanceDetails as ::protobuf::Message>::default_instance()
    }
}

impl PatchJobInstanceDetails {
    pub fn new() -> PatchJobInstanceDetails {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string instance_system_id = 2;


    pub fn get_instance_system_id(&self) -> &str {
        &self.instance_system_id
    }
    pub fn clear_instance_system_id(&mut self) {
        self.instance_system_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance_system_id(&mut self, v: ::std::string::String) {
        self.instance_system_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_system_id(&mut self) -> &mut ::std::string::String {
        &mut self.instance_system_id
    }

    // Take field
    pub fn take_instance_system_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.instance_system_id, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.Instance.PatchState state = 3;


    pub fn get_state(&self) -> Instance_PatchState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Instance_PatchState::PATCH_STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Instance_PatchState) {
        self.state = v;
    }

    // string failure_reason = 4;


    pub fn get_failure_reason(&self) -> &str {
        &self.failure_reason
    }
    pub fn clear_failure_reason(&mut self) {
        self.failure_reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_failure_reason(&mut self, v: ::std::string::String) {
        self.failure_reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failure_reason(&mut self) -> &mut ::std::string::String {
        &mut self.failure_reason
    }

    // Take field
    pub fn take_failure_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.failure_reason, ::std::string::String::new())
    }

    // int64 attempt_count = 5;


    pub fn get_attempt_count(&self) -> i64 {
        self.attempt_count
    }
    pub fn clear_attempt_count(&mut self) {
        self.attempt_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempt_count(&mut self, v: i64) {
        self.attempt_count = v;
    }
}

impl ::protobuf::Message for PatchJobInstanceDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.instance_system_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.failure_reason)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.attempt_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.instance_system_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.instance_system_id);
        }
        if self.state != Instance_PatchState::PATCH_STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if !self.failure_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.failure_reason);
        }
        if self.attempt_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.attempt_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.instance_system_id.is_empty() {
            os.write_string(2, &self.instance_system_id)?;
        }
        if self.state != Instance_PatchState::PATCH_STATE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if !self.failure_reason.is_empty() {
            os.write_string(4, &self.failure_reason)?;
        }
        if self.attempt_count != 0 {
            os.write_int64(5, self.attempt_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchJobInstanceDetails {
        PatchJobInstanceDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PatchJobInstanceDetails| { &m.name },
                |m: &mut PatchJobInstanceDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instance_system_id",
                |m: &PatchJobInstanceDetails| { &m.instance_system_id },
                |m: &mut PatchJobInstanceDetails| { &mut m.instance_system_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Instance_PatchState>>(
                "state",
                |m: &PatchJobInstanceDetails| { &m.state },
                |m: &mut PatchJobInstanceDetails| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "failure_reason",
                |m: &PatchJobInstanceDetails| { &m.failure_reason },
                |m: &mut PatchJobInstanceDetails| { &mut m.failure_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "attempt_count",
                |m: &PatchJobInstanceDetails| { &m.attempt_count },
                |m: &mut PatchJobInstanceDetails| { &mut m.attempt_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchJobInstanceDetails>(
                "PatchJobInstanceDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchJobInstanceDetails {
        static instance: ::protobuf::rt::LazyV2<PatchJobInstanceDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchJobInstanceDetails::new)
    }
}

impl ::protobuf::Clear for PatchJobInstanceDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.instance_system_id.clear();
        self.state = Instance_PatchState::PATCH_STATE_UNSPECIFIED;
        self.failure_reason.clear();
        self.attempt_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchJobInstanceDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchJobInstanceDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchJobsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub filter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchJobsRequest {
    fn default() -> &'a ListPatchJobsRequest {
        <ListPatchJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchJobsRequest {
    pub fn new() -> ListPatchJobsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string filter = 4;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchJobsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchJobsRequest {
        ListPatchJobsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListPatchJobsRequest| { &m.parent },
                |m: &mut ListPatchJobsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListPatchJobsRequest| { &m.page_size },
                |m: &mut ListPatchJobsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListPatchJobsRequest| { &m.page_token },
                |m: &mut ListPatchJobsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListPatchJobsRequest| { &m.filter },
                |m: &mut ListPatchJobsRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchJobsRequest>(
                "ListPatchJobsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchJobsRequest {
        static instance: ::protobuf::rt::LazyV2<ListPatchJobsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchJobsRequest::new)
    }
}

impl ::protobuf::Clear for ListPatchJobsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchJobsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPatchJobsResponse {
    // message fields
    pub patch_jobs: ::protobuf::RepeatedField<PatchJob>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPatchJobsResponse {
    fn default() -> &'a ListPatchJobsResponse {
        <ListPatchJobsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPatchJobsResponse {
    pub fn new() -> ListPatchJobsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1.PatchJob patch_jobs = 1;


    pub fn get_patch_jobs(&self) -> &[PatchJob] {
        &self.patch_jobs
    }
    pub fn clear_patch_jobs(&mut self) {
        self.patch_jobs.clear();
    }

    // Param is passed by value, moved
    pub fn set_patch_jobs(&mut self, v: ::protobuf::RepeatedField<PatchJob>) {
        self.patch_jobs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patch_jobs(&mut self) -> &mut ::protobuf::RepeatedField<PatchJob> {
        &mut self.patch_jobs
    }

    // Take field
    pub fn take_patch_jobs(&mut self) -> ::protobuf::RepeatedField<PatchJob> {
        ::std::mem::replace(&mut self.patch_jobs, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPatchJobsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.patch_jobs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patch_jobs)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.patch_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.patch_jobs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPatchJobsResponse {
        ListPatchJobsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchJob>>(
                "patch_jobs",
                |m: &ListPatchJobsResponse| { &m.patch_jobs },
                |m: &mut ListPatchJobsResponse| { &mut m.patch_jobs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListPatchJobsResponse| { &m.next_page_token },
                |m: &mut ListPatchJobsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPatchJobsResponse>(
                "ListPatchJobsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPatchJobsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPatchJobsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPatchJobsResponse::new)
    }
}

impl ::protobuf::Clear for ListPatchJobsResponse {
    fn clear(&mut self) {
        self.patch_jobs.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPatchJobsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPatchJobsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchJob {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub state: PatchJob_State,
    pub instance_filter: ::protobuf::SingularPtrField<PatchInstanceFilter>,
    pub patch_config: ::protobuf::SingularPtrField<PatchConfig>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub instance_details_summary: ::protobuf::SingularPtrField<PatchJob_InstanceDetailsSummary>,
    pub dry_run: bool,
    pub error_message: ::std::string::String,
    pub percent_complete: f64,
    pub patch_deployment: ::std::string::String,
    pub rollout: ::protobuf::SingularPtrField<PatchRollout>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchJob {
    fn default() -> &'a PatchJob {
        <PatchJob as ::protobuf::Message>::default_instance()
    }
}

impl PatchJob {
    pub fn new() -> PatchJob {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 14;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp create_time = 3;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 4;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.cloud.osconfig.v1.PatchJob.State state = 5;


    pub fn get_state(&self) -> PatchJob_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = PatchJob_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PatchJob_State) {
        self.state = v;
    }

    // .google.cloud.osconfig.v1.PatchInstanceFilter instance_filter = 13;


    pub fn get_instance_filter(&self) -> &PatchInstanceFilter {
        self.instance_filter.as_ref().unwrap_or_else(|| <PatchInstanceFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance_filter(&mut self) {
        self.instance_filter.clear();
    }

    pub fn has_instance_filter(&self) -> bool {
        self.instance_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_filter(&mut self, v: PatchInstanceFilter) {
        self.instance_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_filter(&mut self) -> &mut PatchInstanceFilter {
        if self.instance_filter.is_none() {
            self.instance_filter.set_default();
        }
        self.instance_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_filter(&mut self) -> PatchInstanceFilter {
        self.instance_filter.take().unwrap_or_else(|| PatchInstanceFilter::new())
    }

    // .google.cloud.osconfig.v1.PatchConfig patch_config = 7;


    pub fn get_patch_config(&self) -> &PatchConfig {
        self.patch_config.as_ref().unwrap_or_else(|| <PatchConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_patch_config(&mut self) {
        self.patch_config.clear();
    }

    pub fn has_patch_config(&self) -> bool {
        self.patch_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_config(&mut self, v: PatchConfig) {
        self.patch_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_config(&mut self) -> &mut PatchConfig {
        if self.patch_config.is_none() {
            self.patch_config.set_default();
        }
        self.patch_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_patch_config(&mut self) -> PatchConfig {
        self.patch_config.take().unwrap_or_else(|| PatchConfig::new())
    }

    // .google.protobuf.Duration duration = 8;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.cloud.osconfig.v1.PatchJob.InstanceDetailsSummary instance_details_summary = 9;


    pub fn get_instance_details_summary(&self) -> &PatchJob_InstanceDetailsSummary {
        self.instance_details_summary.as_ref().unwrap_or_else(|| <PatchJob_InstanceDetailsSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance_details_summary(&mut self) {
        self.instance_details_summary.clear();
    }

    pub fn has_instance_details_summary(&self) -> bool {
        self.instance_details_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_details_summary(&mut self, v: PatchJob_InstanceDetailsSummary) {
        self.instance_details_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_details_summary(&mut self) -> &mut PatchJob_InstanceDetailsSummary {
        if self.instance_details_summary.is_none() {
            self.instance_details_summary.set_default();
        }
        self.instance_details_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_details_summary(&mut self) -> PatchJob_InstanceDetailsSummary {
        self.instance_details_summary.take().unwrap_or_else(|| PatchJob_InstanceDetailsSummary::new())
    }

    // bool dry_run = 10;


    pub fn get_dry_run(&self) -> bool {
        self.dry_run
    }
    pub fn clear_dry_run(&mut self) {
        self.dry_run = false;
    }

    // Param is passed by value, moved
    pub fn set_dry_run(&mut self, v: bool) {
        self.dry_run = v;
    }

    // string error_message = 11;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    // double percent_complete = 12;


    pub fn get_percent_complete(&self) -> f64 {
        self.percent_complete
    }
    pub fn clear_percent_complete(&mut self) {
        self.percent_complete = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percent_complete(&mut self, v: f64) {
        self.percent_complete = v;
    }

    // string patch_deployment = 15;


    pub fn get_patch_deployment(&self) -> &str {
        &self.patch_deployment
    }
    pub fn clear_patch_deployment(&mut self) {
        self.patch_deployment.clear();
    }

    // Param is passed by value, moved
    pub fn set_patch_deployment(&mut self, v: ::std::string::String) {
        self.patch_deployment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patch_deployment(&mut self) -> &mut ::std::string::String {
        &mut self.patch_deployment
    }

    // Take field
    pub fn take_patch_deployment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.patch_deployment, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.PatchRollout rollout = 16;


    pub fn get_rollout(&self) -> &PatchRollout {
        self.rollout.as_ref().unwrap_or_else(|| <PatchRollout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout(&mut self) {
        self.rollout.clear();
    }

    pub fn has_rollout(&self) -> bool {
        self.rollout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout(&mut self, v: PatchRollout) {
        self.rollout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout(&mut self) -> &mut PatchRollout {
        if self.rollout.is_none() {
            self.rollout.set_default();
        }
        self.rollout.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout(&mut self) -> PatchRollout {
        self.rollout.take().unwrap_or_else(|| PatchRollout::new())
    }
}

impl ::protobuf::Message for PatchJob {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patch_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance_details_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 5, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_filter)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patch_config)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_details_summary)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dry_run = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.percent_complete = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.patch_deployment)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != PatchJob_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.state);
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instance_details_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.dry_run != false {
            my_size += 2;
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.error_message);
        }
        if self.percent_complete != 0. {
            my_size += 9;
        }
        if !self.patch_deployment.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.patch_deployment);
        }
        if let Some(ref v) = self.rollout.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(14, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != PatchJob_State::STATE_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if let Some(ref v) = self.instance_filter.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.patch_config.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instance_details_summary.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.dry_run != false {
            os.write_bool(10, self.dry_run)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(11, &self.error_message)?;
        }
        if self.percent_complete != 0. {
            os.write_double(12, self.percent_complete)?;
        }
        if !self.patch_deployment.is_empty() {
            os.write_string(15, &self.patch_deployment)?;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchJob {
        PatchJob::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PatchJob| { &m.name },
                |m: &mut PatchJob| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &PatchJob| { &m.display_name },
                |m: &mut PatchJob| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &PatchJob| { &m.description },
                |m: &mut PatchJob| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &PatchJob| { &m.create_time },
                |m: &mut PatchJob| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &PatchJob| { &m.update_time },
                |m: &mut PatchJob| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PatchJob_State>>(
                "state",
                |m: &PatchJob| { &m.state },
                |m: &mut PatchJob| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchInstanceFilter>>(
                "instance_filter",
                |m: &PatchJob| { &m.instance_filter },
                |m: &mut PatchJob| { &mut m.instance_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchConfig>>(
                "patch_config",
                |m: &PatchJob| { &m.patch_config },
                |m: &mut PatchJob| { &mut m.patch_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &PatchJob| { &m.duration },
                |m: &mut PatchJob| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchJob_InstanceDetailsSummary>>(
                "instance_details_summary",
                |m: &PatchJob| { &m.instance_details_summary },
                |m: &mut PatchJob| { &mut m.instance_details_summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dry_run",
                |m: &PatchJob| { &m.dry_run },
                |m: &mut PatchJob| { &mut m.dry_run },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &PatchJob| { &m.error_message },
                |m: &mut PatchJob| { &mut m.error_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "percent_complete",
                |m: &PatchJob| { &m.percent_complete },
                |m: &mut PatchJob| { &mut m.percent_complete },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "patch_deployment",
                |m: &PatchJob| { &m.patch_deployment },
                |m: &mut PatchJob| { &mut m.patch_deployment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchRollout>>(
                "rollout",
                |m: &PatchJob| { &m.rollout },
                |m: &mut PatchJob| { &mut m.rollout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchJob>(
                "PatchJob",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchJob {
        static instance: ::protobuf::rt::LazyV2<PatchJob> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchJob::new)
    }
}

impl ::protobuf::Clear for PatchJob {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.description.clear();
        self.create_time.clear();
        self.update_time.clear();
        self.state = PatchJob_State::STATE_UNSPECIFIED;
        self.instance_filter.clear();
        self.patch_config.clear();
        self.duration.clear();
        self.instance_details_summary.clear();
        self.dry_run = false;
        self.error_message.clear();
        self.percent_complete = 0.;
        self.patch_deployment.clear();
        self.rollout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchJob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchJob {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchJob_InstanceDetailsSummary {
    // message fields
    pub pending_instance_count: i64,
    pub inactive_instance_count: i64,
    pub notified_instance_count: i64,
    pub started_instance_count: i64,
    pub downloading_patches_instance_count: i64,
    pub applying_patches_instance_count: i64,
    pub rebooting_instance_count: i64,
    pub succeeded_instance_count: i64,
    pub succeeded_reboot_required_instance_count: i64,
    pub failed_instance_count: i64,
    pub acked_instance_count: i64,
    pub timed_out_instance_count: i64,
    pub pre_patch_step_instance_count: i64,
    pub post_patch_step_instance_count: i64,
    pub no_agent_detected_instance_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchJob_InstanceDetailsSummary {
    fn default() -> &'a PatchJob_InstanceDetailsSummary {
        <PatchJob_InstanceDetailsSummary as ::protobuf::Message>::default_instance()
    }
}

impl PatchJob_InstanceDetailsSummary {
    pub fn new() -> PatchJob_InstanceDetailsSummary {
        ::std::default::Default::default()
    }

    // int64 pending_instance_count = 1;


    pub fn get_pending_instance_count(&self) -> i64 {
        self.pending_instance_count
    }
    pub fn clear_pending_instance_count(&mut self) {
        self.pending_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_pending_instance_count(&mut self, v: i64) {
        self.pending_instance_count = v;
    }

    // int64 inactive_instance_count = 2;


    pub fn get_inactive_instance_count(&self) -> i64 {
        self.inactive_instance_count
    }
    pub fn clear_inactive_instance_count(&mut self) {
        self.inactive_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_inactive_instance_count(&mut self, v: i64) {
        self.inactive_instance_count = v;
    }

    // int64 notified_instance_count = 3;


    pub fn get_notified_instance_count(&self) -> i64 {
        self.notified_instance_count
    }
    pub fn clear_notified_instance_count(&mut self) {
        self.notified_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_notified_instance_count(&mut self, v: i64) {
        self.notified_instance_count = v;
    }

    // int64 started_instance_count = 4;


    pub fn get_started_instance_count(&self) -> i64 {
        self.started_instance_count
    }
    pub fn clear_started_instance_count(&mut self) {
        self.started_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_started_instance_count(&mut self, v: i64) {
        self.started_instance_count = v;
    }

    // int64 downloading_patches_instance_count = 5;


    pub fn get_downloading_patches_instance_count(&self) -> i64 {
        self.downloading_patches_instance_count
    }
    pub fn clear_downloading_patches_instance_count(&mut self) {
        self.downloading_patches_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_downloading_patches_instance_count(&mut self, v: i64) {
        self.downloading_patches_instance_count = v;
    }

    // int64 applying_patches_instance_count = 6;


    pub fn get_applying_patches_instance_count(&self) -> i64 {
        self.applying_patches_instance_count
    }
    pub fn clear_applying_patches_instance_count(&mut self) {
        self.applying_patches_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_applying_patches_instance_count(&mut self, v: i64) {
        self.applying_patches_instance_count = v;
    }

    // int64 rebooting_instance_count = 7;


    pub fn get_rebooting_instance_count(&self) -> i64 {
        self.rebooting_instance_count
    }
    pub fn clear_rebooting_instance_count(&mut self) {
        self.rebooting_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_rebooting_instance_count(&mut self, v: i64) {
        self.rebooting_instance_count = v;
    }

    // int64 succeeded_instance_count = 8;


    pub fn get_succeeded_instance_count(&self) -> i64 {
        self.succeeded_instance_count
    }
    pub fn clear_succeeded_instance_count(&mut self) {
        self.succeeded_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_succeeded_instance_count(&mut self, v: i64) {
        self.succeeded_instance_count = v;
    }

    // int64 succeeded_reboot_required_instance_count = 9;


    pub fn get_succeeded_reboot_required_instance_count(&self) -> i64 {
        self.succeeded_reboot_required_instance_count
    }
    pub fn clear_succeeded_reboot_required_instance_count(&mut self) {
        self.succeeded_reboot_required_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_succeeded_reboot_required_instance_count(&mut self, v: i64) {
        self.succeeded_reboot_required_instance_count = v;
    }

    // int64 failed_instance_count = 10;


    pub fn get_failed_instance_count(&self) -> i64 {
        self.failed_instance_count
    }
    pub fn clear_failed_instance_count(&mut self) {
        self.failed_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_failed_instance_count(&mut self, v: i64) {
        self.failed_instance_count = v;
    }

    // int64 acked_instance_count = 11;


    pub fn get_acked_instance_count(&self) -> i64 {
        self.acked_instance_count
    }
    pub fn clear_acked_instance_count(&mut self) {
        self.acked_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_acked_instance_count(&mut self, v: i64) {
        self.acked_instance_count = v;
    }

    // int64 timed_out_instance_count = 12;


    pub fn get_timed_out_instance_count(&self) -> i64 {
        self.timed_out_instance_count
    }
    pub fn clear_timed_out_instance_count(&mut self) {
        self.timed_out_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_timed_out_instance_count(&mut self, v: i64) {
        self.timed_out_instance_count = v;
    }

    // int64 pre_patch_step_instance_count = 13;


    pub fn get_pre_patch_step_instance_count(&self) -> i64 {
        self.pre_patch_step_instance_count
    }
    pub fn clear_pre_patch_step_instance_count(&mut self) {
        self.pre_patch_step_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_pre_patch_step_instance_count(&mut self, v: i64) {
        self.pre_patch_step_instance_count = v;
    }

    // int64 post_patch_step_instance_count = 14;


    pub fn get_post_patch_step_instance_count(&self) -> i64 {
        self.post_patch_step_instance_count
    }
    pub fn clear_post_patch_step_instance_count(&mut self) {
        self.post_patch_step_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_post_patch_step_instance_count(&mut self, v: i64) {
        self.post_patch_step_instance_count = v;
    }

    // int64 no_agent_detected_instance_count = 15;


    pub fn get_no_agent_detected_instance_count(&self) -> i64 {
        self.no_agent_detected_instance_count
    }
    pub fn clear_no_agent_detected_instance_count(&mut self) {
        self.no_agent_detected_instance_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_no_agent_detected_instance_count(&mut self, v: i64) {
        self.no_agent_detected_instance_count = v;
    }
}

impl ::protobuf::Message for PatchJob_InstanceDetailsSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pending_instance_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.inactive_instance_count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.notified_instance_count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.started_instance_count = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloading_patches_instance_count = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.applying_patches_instance_count = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.rebooting_instance_count = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.succeeded_instance_count = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.succeeded_reboot_required_instance_count = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.failed_instance_count = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.acked_instance_count = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timed_out_instance_count = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pre_patch_step_instance_count = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.post_patch_step_instance_count = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.no_agent_detected_instance_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pending_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.pending_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inactive_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.inactive_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.notified_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.notified_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.started_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.started_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.downloading_patches_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.downloading_patches_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.applying_patches_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.applying_patches_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rebooting_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(7, self.rebooting_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.succeeded_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(8, self.succeeded_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.succeeded_reboot_required_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(9, self.succeeded_reboot_required_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failed_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(10, self.failed_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.acked_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(11, self.acked_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timed_out_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(12, self.timed_out_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pre_patch_step_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(13, self.pre_patch_step_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.post_patch_step_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(14, self.post_patch_step_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.no_agent_detected_instance_count != 0 {
            my_size += ::protobuf::rt::value_size(15, self.no_agent_detected_instance_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.pending_instance_count != 0 {
            os.write_int64(1, self.pending_instance_count)?;
        }
        if self.inactive_instance_count != 0 {
            os.write_int64(2, self.inactive_instance_count)?;
        }
        if self.notified_instance_count != 0 {
            os.write_int64(3, self.notified_instance_count)?;
        }
        if self.started_instance_count != 0 {
            os.write_int64(4, self.started_instance_count)?;
        }
        if self.downloading_patches_instance_count != 0 {
            os.write_int64(5, self.downloading_patches_instance_count)?;
        }
        if self.applying_patches_instance_count != 0 {
            os.write_int64(6, self.applying_patches_instance_count)?;
        }
        if self.rebooting_instance_count != 0 {
            os.write_int64(7, self.rebooting_instance_count)?;
        }
        if self.succeeded_instance_count != 0 {
            os.write_int64(8, self.succeeded_instance_count)?;
        }
        if self.succeeded_reboot_required_instance_count != 0 {
            os.write_int64(9, self.succeeded_reboot_required_instance_count)?;
        }
        if self.failed_instance_count != 0 {
            os.write_int64(10, self.failed_instance_count)?;
        }
        if self.acked_instance_count != 0 {
            os.write_int64(11, self.acked_instance_count)?;
        }
        if self.timed_out_instance_count != 0 {
            os.write_int64(12, self.timed_out_instance_count)?;
        }
        if self.pre_patch_step_instance_count != 0 {
            os.write_int64(13, self.pre_patch_step_instance_count)?;
        }
        if self.post_patch_step_instance_count != 0 {
            os.write_int64(14, self.post_patch_step_instance_count)?;
        }
        if self.no_agent_detected_instance_count != 0 {
            os.write_int64(15, self.no_agent_detected_instance_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchJob_InstanceDetailsSummary {
        PatchJob_InstanceDetailsSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pending_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.pending_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.pending_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "inactive_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.inactive_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.inactive_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "notified_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.notified_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.notified_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "started_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.started_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.started_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "downloading_patches_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.downloading_patches_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.downloading_patches_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "applying_patches_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.applying_patches_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.applying_patches_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "rebooting_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.rebooting_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.rebooting_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "succeeded_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.succeeded_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.succeeded_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "succeeded_reboot_required_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.succeeded_reboot_required_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.succeeded_reboot_required_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "failed_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.failed_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.failed_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "acked_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.acked_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.acked_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timed_out_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.timed_out_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.timed_out_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pre_patch_step_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.pre_patch_step_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.pre_patch_step_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "post_patch_step_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.post_patch_step_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.post_patch_step_instance_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "no_agent_detected_instance_count",
                |m: &PatchJob_InstanceDetailsSummary| { &m.no_agent_detected_instance_count },
                |m: &mut PatchJob_InstanceDetailsSummary| { &mut m.no_agent_detected_instance_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchJob_InstanceDetailsSummary>(
                "PatchJob.InstanceDetailsSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchJob_InstanceDetailsSummary {
        static instance: ::protobuf::rt::LazyV2<PatchJob_InstanceDetailsSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchJob_InstanceDetailsSummary::new)
    }
}

impl ::protobuf::Clear for PatchJob_InstanceDetailsSummary {
    fn clear(&mut self) {
        self.pending_instance_count = 0;
        self.inactive_instance_count = 0;
        self.notified_instance_count = 0;
        self.started_instance_count = 0;
        self.downloading_patches_instance_count = 0;
        self.applying_patches_instance_count = 0;
        self.rebooting_instance_count = 0;
        self.succeeded_instance_count = 0;
        self.succeeded_reboot_required_instance_count = 0;
        self.failed_instance_count = 0;
        self.acked_instance_count = 0;
        self.timed_out_instance_count = 0;
        self.pre_patch_step_instance_count = 0;
        self.post_patch_step_instance_count = 0;
        self.no_agent_detected_instance_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchJob_InstanceDetailsSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchJob_InstanceDetailsSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PatchJob_State {
    STATE_UNSPECIFIED = 0,
    STARTED = 1,
    INSTANCE_LOOKUP = 2,
    PATCHING = 3,
    SUCCEEDED = 4,
    COMPLETED_WITH_ERRORS = 5,
    CANCELED = 6,
    TIMED_OUT = 7,
}

impl ::protobuf::ProtobufEnum for PatchJob_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatchJob_State> {
        match value {
            0 => ::std::option::Option::Some(PatchJob_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(PatchJob_State::STARTED),
            2 => ::std::option::Option::Some(PatchJob_State::INSTANCE_LOOKUP),
            3 => ::std::option::Option::Some(PatchJob_State::PATCHING),
            4 => ::std::option::Option::Some(PatchJob_State::SUCCEEDED),
            5 => ::std::option::Option::Some(PatchJob_State::COMPLETED_WITH_ERRORS),
            6 => ::std::option::Option::Some(PatchJob_State::CANCELED),
            7 => ::std::option::Option::Some(PatchJob_State::TIMED_OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PatchJob_State] = &[
            PatchJob_State::STATE_UNSPECIFIED,
            PatchJob_State::STARTED,
            PatchJob_State::INSTANCE_LOOKUP,
            PatchJob_State::PATCHING,
            PatchJob_State::SUCCEEDED,
            PatchJob_State::COMPLETED_WITH_ERRORS,
            PatchJob_State::CANCELED,
            PatchJob_State::TIMED_OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PatchJob_State>("PatchJob.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PatchJob_State {
}

impl ::std::default::Default for PatchJob_State {
    fn default() -> Self {
        PatchJob_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchJob_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchConfig {
    // message fields
    pub reboot_config: PatchConfig_RebootConfig,
    pub apt: ::protobuf::SingularPtrField<AptSettings>,
    pub yum: ::protobuf::SingularPtrField<YumSettings>,
    pub goo: ::protobuf::SingularPtrField<GooSettings>,
    pub zypper: ::protobuf::SingularPtrField<ZypperSettings>,
    pub windows_update: ::protobuf::SingularPtrField<WindowsUpdateSettings>,
    pub pre_step: ::protobuf::SingularPtrField<ExecStep>,
    pub post_step: ::protobuf::SingularPtrField<ExecStep>,
    pub mig_instances_allowed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchConfig {
    fn default() -> &'a PatchConfig {
        <PatchConfig as ::protobuf::Message>::default_instance()
    }
}

impl PatchConfig {
    pub fn new() -> PatchConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.PatchConfig.RebootConfig reboot_config = 1;


    pub fn get_reboot_config(&self) -> PatchConfig_RebootConfig {
        self.reboot_config
    }
    pub fn clear_reboot_config(&mut self) {
        self.reboot_config = PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_reboot_config(&mut self, v: PatchConfig_RebootConfig) {
        self.reboot_config = v;
    }

    // .google.cloud.osconfig.v1.AptSettings apt = 3;


    pub fn get_apt(&self) -> &AptSettings {
        self.apt.as_ref().unwrap_or_else(|| <AptSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_apt(&mut self) {
        self.apt.clear();
    }

    pub fn has_apt(&self) -> bool {
        self.apt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apt(&mut self, v: AptSettings) {
        self.apt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apt(&mut self) -> &mut AptSettings {
        if self.apt.is_none() {
            self.apt.set_default();
        }
        self.apt.as_mut().unwrap()
    }

    // Take field
    pub fn take_apt(&mut self) -> AptSettings {
        self.apt.take().unwrap_or_else(|| AptSettings::new())
    }

    // .google.cloud.osconfig.v1.YumSettings yum = 4;


    pub fn get_yum(&self) -> &YumSettings {
        self.yum.as_ref().unwrap_or_else(|| <YumSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_yum(&mut self) {
        self.yum.clear();
    }

    pub fn has_yum(&self) -> bool {
        self.yum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yum(&mut self, v: YumSettings) {
        self.yum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_yum(&mut self) -> &mut YumSettings {
        if self.yum.is_none() {
            self.yum.set_default();
        }
        self.yum.as_mut().unwrap()
    }

    // Take field
    pub fn take_yum(&mut self) -> YumSettings {
        self.yum.take().unwrap_or_else(|| YumSettings::new())
    }

    // .google.cloud.osconfig.v1.GooSettings goo = 5;


    pub fn get_goo(&self) -> &GooSettings {
        self.goo.as_ref().unwrap_or_else(|| <GooSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_goo(&mut self) {
        self.goo.clear();
    }

    pub fn has_goo(&self) -> bool {
        self.goo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goo(&mut self, v: GooSettings) {
        self.goo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_goo(&mut self) -> &mut GooSettings {
        if self.goo.is_none() {
            self.goo.set_default();
        }
        self.goo.as_mut().unwrap()
    }

    // Take field
    pub fn take_goo(&mut self) -> GooSettings {
        self.goo.take().unwrap_or_else(|| GooSettings::new())
    }

    // .google.cloud.osconfig.v1.ZypperSettings zypper = 6;


    pub fn get_zypper(&self) -> &ZypperSettings {
        self.zypper.as_ref().unwrap_or_else(|| <ZypperSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zypper(&mut self) {
        self.zypper.clear();
    }

    pub fn has_zypper(&self) -> bool {
        self.zypper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zypper(&mut self, v: ZypperSettings) {
        self.zypper = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zypper(&mut self) -> &mut ZypperSettings {
        if self.zypper.is_none() {
            self.zypper.set_default();
        }
        self.zypper.as_mut().unwrap()
    }

    // Take field
    pub fn take_zypper(&mut self) -> ZypperSettings {
        self.zypper.take().unwrap_or_else(|| ZypperSettings::new())
    }

    // .google.cloud.osconfig.v1.WindowsUpdateSettings windows_update = 7;


    pub fn get_windows_update(&self) -> &WindowsUpdateSettings {
        self.windows_update.as_ref().unwrap_or_else(|| <WindowsUpdateSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windows_update(&mut self) {
        self.windows_update.clear();
    }

    pub fn has_windows_update(&self) -> bool {
        self.windows_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windows_update(&mut self, v: WindowsUpdateSettings) {
        self.windows_update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windows_update(&mut self) -> &mut WindowsUpdateSettings {
        if self.windows_update.is_none() {
            self.windows_update.set_default();
        }
        self.windows_update.as_mut().unwrap()
    }

    // Take field
    pub fn take_windows_update(&mut self) -> WindowsUpdateSettings {
        self.windows_update.take().unwrap_or_else(|| WindowsUpdateSettings::new())
    }

    // .google.cloud.osconfig.v1.ExecStep pre_step = 8;


    pub fn get_pre_step(&self) -> &ExecStep {
        self.pre_step.as_ref().unwrap_or_else(|| <ExecStep as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pre_step(&mut self) {
        self.pre_step.clear();
    }

    pub fn has_pre_step(&self) -> bool {
        self.pre_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_step(&mut self, v: ExecStep) {
        self.pre_step = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_step(&mut self) -> &mut ExecStep {
        if self.pre_step.is_none() {
            self.pre_step.set_default();
        }
        self.pre_step.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_step(&mut self) -> ExecStep {
        self.pre_step.take().unwrap_or_else(|| ExecStep::new())
    }

    // .google.cloud.osconfig.v1.ExecStep post_step = 9;


    pub fn get_post_step(&self) -> &ExecStep {
        self.post_step.as_ref().unwrap_or_else(|| <ExecStep as ::protobuf::Message>::default_instance())
    }
    pub fn clear_post_step(&mut self) {
        self.post_step.clear();
    }

    pub fn has_post_step(&self) -> bool {
        self.post_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post_step(&mut self, v: ExecStep) {
        self.post_step = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post_step(&mut self) -> &mut ExecStep {
        if self.post_step.is_none() {
            self.post_step.set_default();
        }
        self.post_step.as_mut().unwrap()
    }

    // Take field
    pub fn take_post_step(&mut self) -> ExecStep {
        self.post_step.take().unwrap_or_else(|| ExecStep::new())
    }

    // bool mig_instances_allowed = 10;


    pub fn get_mig_instances_allowed(&self) -> bool {
        self.mig_instances_allowed
    }
    pub fn clear_mig_instances_allowed(&mut self) {
        self.mig_instances_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_mig_instances_allowed(&mut self, v: bool) {
        self.mig_instances_allowed = v;
    }
}

impl ::protobuf::Message for PatchConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.apt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.yum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.goo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.zypper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windows_update {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pre_step {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.post_step {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reboot_config, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.yum)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.goo)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zypper)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windows_update)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_step)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.post_step)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mig_instances_allowed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reboot_config != PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.reboot_config);
        }
        if let Some(ref v) = self.apt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.yum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.goo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.zypper.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windows_update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pre_step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.post_step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mig_instances_allowed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reboot_config != PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.reboot_config))?;
        }
        if let Some(ref v) = self.apt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.yum.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.goo.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.zypper.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windows_update.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pre_step.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.post_step.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mig_instances_allowed != false {
            os.write_bool(10, self.mig_instances_allowed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchConfig {
        PatchConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PatchConfig_RebootConfig>>(
                "reboot_config",
                |m: &PatchConfig| { &m.reboot_config },
                |m: &mut PatchConfig| { &mut m.reboot_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AptSettings>>(
                "apt",
                |m: &PatchConfig| { &m.apt },
                |m: &mut PatchConfig| { &mut m.apt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<YumSettings>>(
                "yum",
                |m: &PatchConfig| { &m.yum },
                |m: &mut PatchConfig| { &mut m.yum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GooSettings>>(
                "goo",
                |m: &PatchConfig| { &m.goo },
                |m: &mut PatchConfig| { &mut m.goo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZypperSettings>>(
                "zypper",
                |m: &PatchConfig| { &m.zypper },
                |m: &mut PatchConfig| { &mut m.zypper },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsUpdateSettings>>(
                "windows_update",
                |m: &PatchConfig| { &m.windows_update },
                |m: &mut PatchConfig| { &mut m.windows_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStep>>(
                "pre_step",
                |m: &PatchConfig| { &m.pre_step },
                |m: &mut PatchConfig| { &mut m.pre_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStep>>(
                "post_step",
                |m: &PatchConfig| { &m.post_step },
                |m: &mut PatchConfig| { &mut m.post_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mig_instances_allowed",
                |m: &PatchConfig| { &m.mig_instances_allowed },
                |m: &mut PatchConfig| { &mut m.mig_instances_allowed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchConfig>(
                "PatchConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchConfig {
        static instance: ::protobuf::rt::LazyV2<PatchConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchConfig::new)
    }
}

impl ::protobuf::Clear for PatchConfig {
    fn clear(&mut self) {
        self.reboot_config = PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED;
        self.apt.clear();
        self.yum.clear();
        self.goo.clear();
        self.zypper.clear();
        self.windows_update.clear();
        self.pre_step.clear();
        self.post_step.clear();
        self.mig_instances_allowed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PatchConfig_RebootConfig {
    REBOOT_CONFIG_UNSPECIFIED = 0,
    DEFAULT = 1,
    ALWAYS = 2,
    NEVER = 3,
}

impl ::protobuf::ProtobufEnum for PatchConfig_RebootConfig {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatchConfig_RebootConfig> {
        match value {
            0 => ::std::option::Option::Some(PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED),
            1 => ::std::option::Option::Some(PatchConfig_RebootConfig::DEFAULT),
            2 => ::std::option::Option::Some(PatchConfig_RebootConfig::ALWAYS),
            3 => ::std::option::Option::Some(PatchConfig_RebootConfig::NEVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PatchConfig_RebootConfig] = &[
            PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED,
            PatchConfig_RebootConfig::DEFAULT,
            PatchConfig_RebootConfig::ALWAYS,
            PatchConfig_RebootConfig::NEVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PatchConfig_RebootConfig>("PatchConfig.RebootConfig", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PatchConfig_RebootConfig {
}

impl ::std::default::Default for PatchConfig_RebootConfig {
    fn default() -> Self {
        PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConfig_RebootConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Instance {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Instance {
    fn default() -> &'a Instance {
        <Instance as ::protobuf::Message>::default_instance()
    }
}

impl Instance {
    pub fn new() -> Instance {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Instance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instance {
        Instance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Instance>(
                "Instance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Instance {
        static instance: ::protobuf::rt::LazyV2<Instance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Instance::new)
    }
}

impl ::protobuf::Clear for Instance {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Instance_PatchState {
    PATCH_STATE_UNSPECIFIED = 0,
    PENDING = 1,
    INACTIVE = 2,
    NOTIFIED = 3,
    STARTED = 4,
    DOWNLOADING_PATCHES = 5,
    APPLYING_PATCHES = 6,
    REBOOTING = 7,
    SUCCEEDED = 8,
    SUCCEEDED_REBOOT_REQUIRED = 9,
    FAILED = 10,
    ACKED = 11,
    TIMED_OUT = 12,
    RUNNING_PRE_PATCH_STEP = 13,
    RUNNING_POST_PATCH_STEP = 14,
    NO_AGENT_DETECTED = 15,
}

impl ::protobuf::ProtobufEnum for Instance_PatchState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Instance_PatchState> {
        match value {
            0 => ::std::option::Option::Some(Instance_PatchState::PATCH_STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Instance_PatchState::PENDING),
            2 => ::std::option::Option::Some(Instance_PatchState::INACTIVE),
            3 => ::std::option::Option::Some(Instance_PatchState::NOTIFIED),
            4 => ::std::option::Option::Some(Instance_PatchState::STARTED),
            5 => ::std::option::Option::Some(Instance_PatchState::DOWNLOADING_PATCHES),
            6 => ::std::option::Option::Some(Instance_PatchState::APPLYING_PATCHES),
            7 => ::std::option::Option::Some(Instance_PatchState::REBOOTING),
            8 => ::std::option::Option::Some(Instance_PatchState::SUCCEEDED),
            9 => ::std::option::Option::Some(Instance_PatchState::SUCCEEDED_REBOOT_REQUIRED),
            10 => ::std::option::Option::Some(Instance_PatchState::FAILED),
            11 => ::std::option::Option::Some(Instance_PatchState::ACKED),
            12 => ::std::option::Option::Some(Instance_PatchState::TIMED_OUT),
            13 => ::std::option::Option::Some(Instance_PatchState::RUNNING_PRE_PATCH_STEP),
            14 => ::std::option::Option::Some(Instance_PatchState::RUNNING_POST_PATCH_STEP),
            15 => ::std::option::Option::Some(Instance_PatchState::NO_AGENT_DETECTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Instance_PatchState] = &[
            Instance_PatchState::PATCH_STATE_UNSPECIFIED,
            Instance_PatchState::PENDING,
            Instance_PatchState::INACTIVE,
            Instance_PatchState::NOTIFIED,
            Instance_PatchState::STARTED,
            Instance_PatchState::DOWNLOADING_PATCHES,
            Instance_PatchState::APPLYING_PATCHES,
            Instance_PatchState::REBOOTING,
            Instance_PatchState::SUCCEEDED,
            Instance_PatchState::SUCCEEDED_REBOOT_REQUIRED,
            Instance_PatchState::FAILED,
            Instance_PatchState::ACKED,
            Instance_PatchState::TIMED_OUT,
            Instance_PatchState::RUNNING_PRE_PATCH_STEP,
            Instance_PatchState::RUNNING_POST_PATCH_STEP,
            Instance_PatchState::NO_AGENT_DETECTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Instance_PatchState>("Instance.PatchState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Instance_PatchState {
}

impl ::std::default::Default for Instance_PatchState {
    fn default() -> Self {
        Instance_PatchState::PATCH_STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Instance_PatchState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelPatchJobRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelPatchJobRequest {
    fn default() -> &'a CancelPatchJobRequest {
        <CancelPatchJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelPatchJobRequest {
    pub fn new() -> CancelPatchJobRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CancelPatchJobRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelPatchJobRequest {
        CancelPatchJobRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CancelPatchJobRequest| { &m.name },
                |m: &mut CancelPatchJobRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CancelPatchJobRequest>(
                "CancelPatchJobRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CancelPatchJobRequest {
        static instance: ::protobuf::rt::LazyV2<CancelPatchJobRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CancelPatchJobRequest::new)
    }
}

impl ::protobuf::Clear for CancelPatchJobRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelPatchJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelPatchJobRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AptSettings {
    // message fields
    pub field_type: AptSettings_Type,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_packages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AptSettings {
    fn default() -> &'a AptSettings {
        <AptSettings as ::protobuf::Message>::default_instance()
    }
}

impl AptSettings {
    pub fn new() -> AptSettings {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.AptSettings.Type type = 1;


    pub fn get_field_type(&self) -> AptSettings_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AptSettings_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AptSettings_Type) {
        self.field_type = v;
    }

    // repeated string excludes = 2;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_packages = 3;


    pub fn get_exclusive_packages(&self) -> &[::std::string::String] {
        &self.exclusive_packages
    }
    pub fn clear_exclusive_packages(&mut self) {
        self.exclusive_packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_packages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_packages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_packages
    }

    // Take field
    pub fn take_exclusive_packages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_packages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AptSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_packages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != AptSettings_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.exclusive_packages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != AptSettings_Type::TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        for v in &self.excludes {
            os.write_string(2, &v)?;
        };
        for v in &self.exclusive_packages {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AptSettings {
        AptSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AptSettings_Type>>(
                "type",
                |m: &AptSettings| { &m.field_type },
                |m: &mut AptSettings| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &AptSettings| { &m.excludes },
                |m: &mut AptSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_packages",
                |m: &AptSettings| { &m.exclusive_packages },
                |m: &mut AptSettings| { &mut m.exclusive_packages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AptSettings>(
                "AptSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AptSettings {
        static instance: ::protobuf::rt::LazyV2<AptSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AptSettings::new)
    }
}

impl ::protobuf::Clear for AptSettings {
    fn clear(&mut self) {
        self.field_type = AptSettings_Type::TYPE_UNSPECIFIED;
        self.excludes.clear();
        self.exclusive_packages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AptSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AptSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AptSettings_Type {
    TYPE_UNSPECIFIED = 0,
    DIST = 1,
    UPGRADE = 2,
}

impl ::protobuf::ProtobufEnum for AptSettings_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AptSettings_Type> {
        match value {
            0 => ::std::option::Option::Some(AptSettings_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AptSettings_Type::DIST),
            2 => ::std::option::Option::Some(AptSettings_Type::UPGRADE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AptSettings_Type] = &[
            AptSettings_Type::TYPE_UNSPECIFIED,
            AptSettings_Type::DIST,
            AptSettings_Type::UPGRADE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AptSettings_Type>("AptSettings.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AptSettings_Type {
}

impl ::std::default::Default for AptSettings_Type {
    fn default() -> Self {
        AptSettings_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AptSettings_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct YumSettings {
    // message fields
    pub security: bool,
    pub minimal: bool,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_packages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a YumSettings {
    fn default() -> &'a YumSettings {
        <YumSettings as ::protobuf::Message>::default_instance()
    }
}

impl YumSettings {
    pub fn new() -> YumSettings {
        ::std::default::Default::default()
    }

    // bool security = 1;


    pub fn get_security(&self) -> bool {
        self.security
    }
    pub fn clear_security(&mut self) {
        self.security = false;
    }

    // Param is passed by value, moved
    pub fn set_security(&mut self, v: bool) {
        self.security = v;
    }

    // bool minimal = 2;


    pub fn get_minimal(&self) -> bool {
        self.minimal
    }
    pub fn clear_minimal(&mut self) {
        self.minimal = false;
    }

    // Param is passed by value, moved
    pub fn set_minimal(&mut self, v: bool) {
        self.minimal = v;
    }

    // repeated string excludes = 3;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_packages = 4;


    pub fn get_exclusive_packages(&self) -> &[::std::string::String] {
        &self.exclusive_packages
    }
    pub fn clear_exclusive_packages(&mut self) {
        self.exclusive_packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_packages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_packages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_packages
    }

    // Take field
    pub fn take_exclusive_packages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_packages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for YumSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.security = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.minimal = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_packages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.security != false {
            my_size += 2;
        }
        if self.minimal != false {
            my_size += 2;
        }
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.exclusive_packages {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.security != false {
            os.write_bool(1, self.security)?;
        }
        if self.minimal != false {
            os.write_bool(2, self.minimal)?;
        }
        for v in &self.excludes {
            os.write_string(3, &v)?;
        };
        for v in &self.exclusive_packages {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> YumSettings {
        YumSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "security",
                |m: &YumSettings| { &m.security },
                |m: &mut YumSettings| { &mut m.security },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "minimal",
                |m: &YumSettings| { &m.minimal },
                |m: &mut YumSettings| { &mut m.minimal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &YumSettings| { &m.excludes },
                |m: &mut YumSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_packages",
                |m: &YumSettings| { &m.exclusive_packages },
                |m: &mut YumSettings| { &mut m.exclusive_packages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<YumSettings>(
                "YumSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static YumSettings {
        static instance: ::protobuf::rt::LazyV2<YumSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(YumSettings::new)
    }
}

impl ::protobuf::Clear for YumSettings {
    fn clear(&mut self) {
        self.security = false;
        self.minimal = false;
        self.excludes.clear();
        self.exclusive_packages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for YumSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for YumSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GooSettings {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GooSettings {
    fn default() -> &'a GooSettings {
        <GooSettings as ::protobuf::Message>::default_instance()
    }
}

impl GooSettings {
    pub fn new() -> GooSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GooSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GooSettings {
        GooSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GooSettings>(
                "GooSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GooSettings {
        static instance: ::protobuf::rt::LazyV2<GooSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GooSettings::new)
    }
}

impl ::protobuf::Clear for GooSettings {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GooSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GooSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZypperSettings {
    // message fields
    pub with_optional: bool,
    pub with_update: bool,
    pub categories: ::protobuf::RepeatedField<::std::string::String>,
    pub severities: ::protobuf::RepeatedField<::std::string::String>,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_patches: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZypperSettings {
    fn default() -> &'a ZypperSettings {
        <ZypperSettings as ::protobuf::Message>::default_instance()
    }
}

impl ZypperSettings {
    pub fn new() -> ZypperSettings {
        ::std::default::Default::default()
    }

    // bool with_optional = 1;


    pub fn get_with_optional(&self) -> bool {
        self.with_optional
    }
    pub fn clear_with_optional(&mut self) {
        self.with_optional = false;
    }

    // Param is passed by value, moved
    pub fn set_with_optional(&mut self, v: bool) {
        self.with_optional = v;
    }

    // bool with_update = 2;


    pub fn get_with_update(&self) -> bool {
        self.with_update
    }
    pub fn clear_with_update(&mut self) {
        self.with_update = false;
    }

    // Param is passed by value, moved
    pub fn set_with_update(&mut self, v: bool) {
        self.with_update = v;
    }

    // repeated string categories = 3;


    pub fn get_categories(&self) -> &[::std::string::String] {
        &self.categories
    }
    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.categories, ::protobuf::RepeatedField::new())
    }

    // repeated string severities = 4;


    pub fn get_severities(&self) -> &[::std::string::String] {
        &self.severities
    }
    pub fn clear_severities(&mut self) {
        self.severities.clear();
    }

    // Param is passed by value, moved
    pub fn set_severities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.severities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_severities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.severities
    }

    // Take field
    pub fn take_severities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.severities, ::protobuf::RepeatedField::new())
    }

    // repeated string excludes = 5;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_patches = 6;


    pub fn get_exclusive_patches(&self) -> &[::std::string::String] {
        &self.exclusive_patches
    }
    pub fn clear_exclusive_patches(&mut self) {
        self.exclusive_patches.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_patches(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_patches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_patches(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_patches
    }

    // Take field
    pub fn take_exclusive_patches(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_patches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ZypperSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_optional = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_update = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categories)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.severities)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_patches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.with_optional != false {
            my_size += 2;
        }
        if self.with_update != false {
            my_size += 2;
        }
        for value in &self.categories {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.severities {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.exclusive_patches {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.with_optional != false {
            os.write_bool(1, self.with_optional)?;
        }
        if self.with_update != false {
            os.write_bool(2, self.with_update)?;
        }
        for v in &self.categories {
            os.write_string(3, &v)?;
        };
        for v in &self.severities {
            os.write_string(4, &v)?;
        };
        for v in &self.excludes {
            os.write_string(5, &v)?;
        };
        for v in &self.exclusive_patches {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZypperSettings {
        ZypperSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "with_optional",
                |m: &ZypperSettings| { &m.with_optional },
                |m: &mut ZypperSettings| { &mut m.with_optional },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "with_update",
                |m: &ZypperSettings| { &m.with_update },
                |m: &mut ZypperSettings| { &mut m.with_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categories",
                |m: &ZypperSettings| { &m.categories },
                |m: &mut ZypperSettings| { &mut m.categories },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "severities",
                |m: &ZypperSettings| { &m.severities },
                |m: &mut ZypperSettings| { &mut m.severities },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &ZypperSettings| { &m.excludes },
                |m: &mut ZypperSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_patches",
                |m: &ZypperSettings| { &m.exclusive_patches },
                |m: &mut ZypperSettings| { &mut m.exclusive_patches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZypperSettings>(
                "ZypperSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZypperSettings {
        static instance: ::protobuf::rt::LazyV2<ZypperSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZypperSettings::new)
    }
}

impl ::protobuf::Clear for ZypperSettings {
    fn clear(&mut self) {
        self.with_optional = false;
        self.with_update = false;
        self.categories.clear();
        self.severities.clear();
        self.excludes.clear();
        self.exclusive_patches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZypperSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZypperSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsUpdateSettings {
    // message fields
    pub classifications: ::std::vec::Vec<WindowsUpdateSettings_Classification>,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_patches: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsUpdateSettings {
    fn default() -> &'a WindowsUpdateSettings {
        <WindowsUpdateSettings as ::protobuf::Message>::default_instance()
    }
}

impl WindowsUpdateSettings {
    pub fn new() -> WindowsUpdateSettings {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1.WindowsUpdateSettings.Classification classifications = 1;


    pub fn get_classifications(&self) -> &[WindowsUpdateSettings_Classification] {
        &self.classifications
    }
    pub fn clear_classifications(&mut self) {
        self.classifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_classifications(&mut self, v: ::std::vec::Vec<WindowsUpdateSettings_Classification>) {
        self.classifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_classifications(&mut self) -> &mut ::std::vec::Vec<WindowsUpdateSettings_Classification> {
        &mut self.classifications
    }

    // Take field
    pub fn take_classifications(&mut self) -> ::std::vec::Vec<WindowsUpdateSettings_Classification> {
        ::std::mem::replace(&mut self.classifications, ::std::vec::Vec::new())
    }

    // repeated string excludes = 2;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_patches = 3;


    pub fn get_exclusive_patches(&self) -> &[::std::string::String] {
        &self.exclusive_patches
    }
    pub fn clear_exclusive_patches(&mut self) {
        self.exclusive_patches.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_patches(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_patches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_patches(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_patches
    }

    // Take field
    pub fn take_exclusive_patches(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_patches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WindowsUpdateSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.classifications, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_patches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.classifications {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.exclusive_patches {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.classifications {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.excludes {
            os.write_string(2, &v)?;
        };
        for v in &self.exclusive_patches {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsUpdateSettings {
        WindowsUpdateSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WindowsUpdateSettings_Classification>>(
                "classifications",
                |m: &WindowsUpdateSettings| { &m.classifications },
                |m: &mut WindowsUpdateSettings| { &mut m.classifications },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &WindowsUpdateSettings| { &m.excludes },
                |m: &mut WindowsUpdateSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_patches",
                |m: &WindowsUpdateSettings| { &m.exclusive_patches },
                |m: &mut WindowsUpdateSettings| { &mut m.exclusive_patches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsUpdateSettings>(
                "WindowsUpdateSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsUpdateSettings {
        static instance: ::protobuf::rt::LazyV2<WindowsUpdateSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsUpdateSettings::new)
    }
}

impl ::protobuf::Clear for WindowsUpdateSettings {
    fn clear(&mut self) {
        self.classifications.clear();
        self.excludes.clear();
        self.exclusive_patches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsUpdateSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsUpdateSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WindowsUpdateSettings_Classification {
    CLASSIFICATION_UNSPECIFIED = 0,
    CRITICAL = 1,
    SECURITY = 2,
    DEFINITION = 3,
    DRIVER = 4,
    FEATURE_PACK = 5,
    SERVICE_PACK = 6,
    TOOL = 7,
    UPDATE_ROLLUP = 8,
    UPDATE = 9,
}

impl ::protobuf::ProtobufEnum for WindowsUpdateSettings_Classification {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WindowsUpdateSettings_Classification> {
        match value {
            0 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::CLASSIFICATION_UNSPECIFIED),
            1 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::CRITICAL),
            2 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::SECURITY),
            3 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::DEFINITION),
            4 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::DRIVER),
            5 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::FEATURE_PACK),
            6 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::SERVICE_PACK),
            7 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::TOOL),
            8 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::UPDATE_ROLLUP),
            9 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WindowsUpdateSettings_Classification] = &[
            WindowsUpdateSettings_Classification::CLASSIFICATION_UNSPECIFIED,
            WindowsUpdateSettings_Classification::CRITICAL,
            WindowsUpdateSettings_Classification::SECURITY,
            WindowsUpdateSettings_Classification::DEFINITION,
            WindowsUpdateSettings_Classification::DRIVER,
            WindowsUpdateSettings_Classification::FEATURE_PACK,
            WindowsUpdateSettings_Classification::SERVICE_PACK,
            WindowsUpdateSettings_Classification::TOOL,
            WindowsUpdateSettings_Classification::UPDATE_ROLLUP,
            WindowsUpdateSettings_Classification::UPDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WindowsUpdateSettings_Classification>("WindowsUpdateSettings.Classification", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WindowsUpdateSettings_Classification {
}

impl ::std::default::Default for WindowsUpdateSettings_Classification {
    fn default() -> Self {
        WindowsUpdateSettings_Classification::CLASSIFICATION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsUpdateSettings_Classification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecStep {
    // message fields
    pub linux_exec_step_config: ::protobuf::SingularPtrField<ExecStepConfig>,
    pub windows_exec_step_config: ::protobuf::SingularPtrField<ExecStepConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecStep {
    fn default() -> &'a ExecStep {
        <ExecStep as ::protobuf::Message>::default_instance()
    }
}

impl ExecStep {
    pub fn new() -> ExecStep {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.ExecStepConfig linux_exec_step_config = 1;


    pub fn get_linux_exec_step_config(&self) -> &ExecStepConfig {
        self.linux_exec_step_config.as_ref().unwrap_or_else(|| <ExecStepConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_linux_exec_step_config(&mut self) {
        self.linux_exec_step_config.clear();
    }

    pub fn has_linux_exec_step_config(&self) -> bool {
        self.linux_exec_step_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linux_exec_step_config(&mut self, v: ExecStepConfig) {
        self.linux_exec_step_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linux_exec_step_config(&mut self) -> &mut ExecStepConfig {
        if self.linux_exec_step_config.is_none() {
            self.linux_exec_step_config.set_default();
        }
        self.linux_exec_step_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_linux_exec_step_config(&mut self) -> ExecStepConfig {
        self.linux_exec_step_config.take().unwrap_or_else(|| ExecStepConfig::new())
    }

    // .google.cloud.osconfig.v1.ExecStepConfig windows_exec_step_config = 2;


    pub fn get_windows_exec_step_config(&self) -> &ExecStepConfig {
        self.windows_exec_step_config.as_ref().unwrap_or_else(|| <ExecStepConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windows_exec_step_config(&mut self) {
        self.windows_exec_step_config.clear();
    }

    pub fn has_windows_exec_step_config(&self) -> bool {
        self.windows_exec_step_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windows_exec_step_config(&mut self, v: ExecStepConfig) {
        self.windows_exec_step_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windows_exec_step_config(&mut self) -> &mut ExecStepConfig {
        if self.windows_exec_step_config.is_none() {
            self.windows_exec_step_config.set_default();
        }
        self.windows_exec_step_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_windows_exec_step_config(&mut self) -> ExecStepConfig {
        self.windows_exec_step_config.take().unwrap_or_else(|| ExecStepConfig::new())
    }
}

impl ::protobuf::Message for ExecStep {
    fn is_initialized(&self) -> bool {
        for v in &self.linux_exec_step_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windows_exec_step_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linux_exec_step_config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windows_exec_step_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.linux_exec_step_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windows_exec_step_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.linux_exec_step_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windows_exec_step_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecStep {
        ExecStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStepConfig>>(
                "linux_exec_step_config",
                |m: &ExecStep| { &m.linux_exec_step_config },
                |m: &mut ExecStep| { &mut m.linux_exec_step_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStepConfig>>(
                "windows_exec_step_config",
                |m: &ExecStep| { &m.windows_exec_step_config },
                |m: &mut ExecStep| { &mut m.windows_exec_step_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecStep>(
                "ExecStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecStep {
        static instance: ::protobuf::rt::LazyV2<ExecStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecStep::new)
    }
}

impl ::protobuf::Clear for ExecStep {
    fn clear(&mut self) {
        self.linux_exec_step_config.clear();
        self.windows_exec_step_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecStepConfig {
    // message fields
    pub allowed_success_codes: ::std::vec::Vec<i32>,
    pub interpreter: ExecStepConfig_Interpreter,
    // message oneof groups
    pub executable: ::std::option::Option<ExecStepConfig_oneof_executable>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecStepConfig {
    fn default() -> &'a ExecStepConfig {
        <ExecStepConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExecStepConfig_oneof_executable {
    local_path(::std::string::String),
    gcs_object(GcsObject),
}

impl ExecStepConfig {
    pub fn new() -> ExecStepConfig {
        ::std::default::Default::default()
    }

    // string local_path = 1;


    pub fn get_local_path(&self) -> &str {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_local_path(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_local_path(&self) -> bool {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local_path(&mut self, v: ::std::string::String) {
        self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(_)) = self.executable {
        } else {
            self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(::std::string::String::new()));
        }
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local_path(&mut self) -> ::std::string::String {
        if self.has_local_path() {
            match self.executable.take() {
                ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.cloud.osconfig.v1.GcsObject gcs_object = 2;


    pub fn get_gcs_object(&self) -> &GcsObject {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(ref v)) => v,
            _ => <GcsObject as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_object(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_gcs_object(&self) -> bool {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_object(&mut self, v: GcsObject) {
        self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_object(&mut self) -> &mut GcsObject {
        if let ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(_)) = self.executable {
        } else {
            self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(GcsObject::new()));
        }
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_object(&mut self) -> GcsObject {
        if self.has_gcs_object() {
            match self.executable.take() {
                ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(v)) => v,
                _ => panic!(),
            }
        } else {
            GcsObject::new()
        }
    }

    // repeated int32 allowed_success_codes = 3;


    pub fn get_allowed_success_codes(&self) -> &[i32] {
        &self.allowed_success_codes
    }
    pub fn clear_allowed_success_codes(&mut self) {
        self.allowed_success_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_success_codes(&mut self, v: ::std::vec::Vec<i32>) {
        self.allowed_success_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_success_codes(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.allowed_success_codes
    }

    // Take field
    pub fn take_allowed_success_codes(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.allowed_success_codes, ::std::vec::Vec::new())
    }

    // .google.cloud.osconfig.v1.ExecStepConfig.Interpreter interpreter = 4;


    pub fn get_interpreter(&self) -> ExecStepConfig_Interpreter {
        self.interpreter
    }
    pub fn clear_interpreter(&mut self) {
        self.interpreter = ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_interpreter(&mut self, v: ExecStepConfig_Interpreter) {
        self.interpreter = v;
    }
}

impl ::protobuf::Message for ExecStepConfig {
    fn is_initialized(&self) -> bool {
        if let Some(ExecStepConfig_oneof_executable::gcs_object(ref v)) = self.executable {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.allowed_success_codes)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.interpreter, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_success_codes {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.interpreter != ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.interpreter);
        }
        if let ::std::option::Option::Some(ref v) = self.executable {
            match v {
                &ExecStepConfig_oneof_executable::local_path(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &ExecStepConfig_oneof_executable::gcs_object(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_success_codes {
            os.write_int32(3, *v)?;
        };
        if self.interpreter != ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.interpreter))?;
        }
        if let ::std::option::Option::Some(ref v) = self.executable {
            match v {
                &ExecStepConfig_oneof_executable::local_path(ref v) => {
                    os.write_string(1, v)?;
                },
                &ExecStepConfig_oneof_executable::gcs_object(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecStepConfig {
        ExecStepConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "local_path",
                ExecStepConfig::has_local_path,
                ExecStepConfig::get_local_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GcsObject>(
                "gcs_object",
                ExecStepConfig::has_gcs_object,
                ExecStepConfig::get_gcs_object,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "allowed_success_codes",
                |m: &ExecStepConfig| { &m.allowed_success_codes },
                |m: &mut ExecStepConfig| { &mut m.allowed_success_codes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExecStepConfig_Interpreter>>(
                "interpreter",
                |m: &ExecStepConfig| { &m.interpreter },
                |m: &mut ExecStepConfig| { &mut m.interpreter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecStepConfig>(
                "ExecStepConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecStepConfig {
        static instance: ::protobuf::rt::LazyV2<ExecStepConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecStepConfig::new)
    }
}

impl ::protobuf::Clear for ExecStepConfig {
    fn clear(&mut self) {
        self.executable = ::std::option::Option::None;
        self.executable = ::std::option::Option::None;
        self.allowed_success_codes.clear();
        self.interpreter = ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecStepConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecStepConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExecStepConfig_Interpreter {
    INTERPRETER_UNSPECIFIED = 0,
    SHELL = 1,
    POWERSHELL = 2,
}

impl ::protobuf::ProtobufEnum for ExecStepConfig_Interpreter {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExecStepConfig_Interpreter> {
        match value {
            0 => ::std::option::Option::Some(ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED),
            1 => ::std::option::Option::Some(ExecStepConfig_Interpreter::SHELL),
            2 => ::std::option::Option::Some(ExecStepConfig_Interpreter::POWERSHELL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExecStepConfig_Interpreter] = &[
            ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED,
            ExecStepConfig_Interpreter::SHELL,
            ExecStepConfig_Interpreter::POWERSHELL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExecStepConfig_Interpreter>("ExecStepConfig.Interpreter", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExecStepConfig_Interpreter {
}

impl ::std::default::Default for ExecStepConfig_Interpreter {
    fn default() -> Self {
        ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecStepConfig_Interpreter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsObject {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation_number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsObject {
    fn default() -> &'a GcsObject {
        <GcsObject as ::protobuf::Message>::default_instance()
    }
}

impl GcsObject {
    pub fn new() -> GcsObject {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation_number = 3;


    pub fn get_generation_number(&self) -> i64 {
        self.generation_number
    }
    pub fn clear_generation_number(&mut self) {
        self.generation_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation_number(&mut self, v: i64) {
        self.generation_number = v;
    }
}

impl ::protobuf::Message for GcsObject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation_number != 0 {
            os.write_int64(3, self.generation_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsObject {
        GcsObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GcsObject| { &m.bucket },
                |m: &mut GcsObject| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &GcsObject| { &m.object },
                |m: &mut GcsObject| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation_number",
                |m: &GcsObject| { &m.generation_number },
                |m: &mut GcsObject| { &mut m.generation_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsObject>(
                "GcsObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsObject {
        static instance: ::protobuf::rt::LazyV2<GcsObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsObject::new)
    }
}

impl ::protobuf::Clear for GcsObject {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchInstanceFilter {
    // message fields
    pub all: bool,
    pub group_labels: ::protobuf::RepeatedField<PatchInstanceFilter_GroupLabel>,
    pub zones: ::protobuf::RepeatedField<::std::string::String>,
    pub instances: ::protobuf::RepeatedField<::std::string::String>,
    pub instance_name_prefixes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchInstanceFilter {
    fn default() -> &'a PatchInstanceFilter {
        <PatchInstanceFilter as ::protobuf::Message>::default_instance()
    }
}

impl PatchInstanceFilter {
    pub fn new() -> PatchInstanceFilter {
        ::std::default::Default::default()
    }

    // bool all = 1;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }

    // repeated .google.cloud.osconfig.v1.PatchInstanceFilter.GroupLabel group_labels = 2;


    pub fn get_group_labels(&self) -> &[PatchInstanceFilter_GroupLabel] {
        &self.group_labels
    }
    pub fn clear_group_labels(&mut self) {
        self.group_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_labels(&mut self, v: ::protobuf::RepeatedField<PatchInstanceFilter_GroupLabel>) {
        self.group_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_group_labels(&mut self) -> &mut ::protobuf::RepeatedField<PatchInstanceFilter_GroupLabel> {
        &mut self.group_labels
    }

    // Take field
    pub fn take_group_labels(&mut self) -> ::protobuf::RepeatedField<PatchInstanceFilter_GroupLabel> {
        ::std::mem::replace(&mut self.group_labels, ::protobuf::RepeatedField::new())
    }

    // repeated string zones = 3;


    pub fn get_zones(&self) -> &[::std::string::String] {
        &self.zones
    }
    pub fn clear_zones(&mut self) {
        self.zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_zones(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_zones(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.zones
    }

    // Take field
    pub fn take_zones(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.zones, ::protobuf::RepeatedField::new())
    }

    // repeated string instances = 4;


    pub fn get_instances(&self) -> &[::std::string::String] {
        &self.instances
    }
    pub fn clear_instances(&mut self) {
        self.instances.clear();
    }

    // Param is passed by value, moved
    pub fn set_instances(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.instances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instances(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.instances
    }

    // Take field
    pub fn take_instances(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.instances, ::protobuf::RepeatedField::new())
    }

    // repeated string instance_name_prefixes = 5;


    pub fn get_instance_name_prefixes(&self) -> &[::std::string::String] {
        &self.instance_name_prefixes
    }
    pub fn clear_instance_name_prefixes(&mut self) {
        self.instance_name_prefixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance_name_prefixes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.instance_name_prefixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instance_name_prefixes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.instance_name_prefixes
    }

    // Take field
    pub fn take_instance_name_prefixes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.instance_name_prefixes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PatchInstanceFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.group_labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.group_labels)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.zones)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.instances)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.instance_name_prefixes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.all != false {
            my_size += 2;
        }
        for value in &self.group_labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.zones {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.instances {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.instance_name_prefixes {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.all != false {
            os.write_bool(1, self.all)?;
        }
        for v in &self.group_labels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.zones {
            os.write_string(3, &v)?;
        };
        for v in &self.instances {
            os.write_string(4, &v)?;
        };
        for v in &self.instance_name_prefixes {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchInstanceFilter {
        PatchInstanceFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "all",
                |m: &PatchInstanceFilter| { &m.all },
                |m: &mut PatchInstanceFilter| { &mut m.all },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchInstanceFilter_GroupLabel>>(
                "group_labels",
                |m: &PatchInstanceFilter| { &m.group_labels },
                |m: &mut PatchInstanceFilter| { &mut m.group_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zones",
                |m: &PatchInstanceFilter| { &m.zones },
                |m: &mut PatchInstanceFilter| { &mut m.zones },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instances",
                |m: &PatchInstanceFilter| { &m.instances },
                |m: &mut PatchInstanceFilter| { &mut m.instances },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instance_name_prefixes",
                |m: &PatchInstanceFilter| { &m.instance_name_prefixes },
                |m: &mut PatchInstanceFilter| { &mut m.instance_name_prefixes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchInstanceFilter>(
                "PatchInstanceFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchInstanceFilter {
        static instance: ::protobuf::rt::LazyV2<PatchInstanceFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchInstanceFilter::new)
    }
}

impl ::protobuf::Clear for PatchInstanceFilter {
    fn clear(&mut self) {
        self.all = false;
        self.group_labels.clear();
        self.zones.clear();
        self.instances.clear();
        self.instance_name_prefixes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchInstanceFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInstanceFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchInstanceFilter_GroupLabel {
    // message fields
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchInstanceFilter_GroupLabel {
    fn default() -> &'a PatchInstanceFilter_GroupLabel {
        <PatchInstanceFilter_GroupLabel as ::protobuf::Message>::default_instance()
    }
}

impl PatchInstanceFilter_GroupLabel {
    pub fn new() -> PatchInstanceFilter_GroupLabel {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1.PatchInstanceFilter.GroupLabel.LabelsEntry labels = 1;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PatchInstanceFilter_GroupLabel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchInstanceFilter_GroupLabel {
        PatchInstanceFilter_GroupLabel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &PatchInstanceFilter_GroupLabel| { &m.labels },
                |m: &mut PatchInstanceFilter_GroupLabel| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchInstanceFilter_GroupLabel>(
                "PatchInstanceFilter.GroupLabel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchInstanceFilter_GroupLabel {
        static instance: ::protobuf::rt::LazyV2<PatchInstanceFilter_GroupLabel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchInstanceFilter_GroupLabel::new)
    }
}

impl ::protobuf::Clear for PatchInstanceFilter_GroupLabel {
    fn clear(&mut self) {
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchInstanceFilter_GroupLabel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInstanceFilter_GroupLabel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchRollout {
    // message fields
    pub mode: PatchRollout_Mode,
    pub disruption_budget: ::protobuf::SingularPtrField<super::osconfig_common::FixedOrPercent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchRollout {
    fn default() -> &'a PatchRollout {
        <PatchRollout as ::protobuf::Message>::default_instance()
    }
}

impl PatchRollout {
    pub fn new() -> PatchRollout {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.PatchRollout.Mode mode = 1;


    pub fn get_mode(&self) -> PatchRollout_Mode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = PatchRollout_Mode::MODE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: PatchRollout_Mode) {
        self.mode = v;
    }

    // .google.cloud.osconfig.v1.FixedOrPercent disruption_budget = 2;


    pub fn get_disruption_budget(&self) -> &super::osconfig_common::FixedOrPercent {
        self.disruption_budget.as_ref().unwrap_or_else(|| <super::osconfig_common::FixedOrPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_disruption_budget(&mut self) {
        self.disruption_budget.clear();
    }

    pub fn has_disruption_budget(&self) -> bool {
        self.disruption_budget.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disruption_budget(&mut self, v: super::osconfig_common::FixedOrPercent) {
        self.disruption_budget = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disruption_budget(&mut self) -> &mut super::osconfig_common::FixedOrPercent {
        if self.disruption_budget.is_none() {
            self.disruption_budget.set_default();
        }
        self.disruption_budget.as_mut().unwrap()
    }

    // Take field
    pub fn take_disruption_budget(&mut self) -> super::osconfig_common::FixedOrPercent {
        self.disruption_budget.take().unwrap_or_else(|| super::osconfig_common::FixedOrPercent::new())
    }
}

impl ::protobuf::Message for PatchRollout {
    fn is_initialized(&self) -> bool {
        for v in &self.disruption_budget {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.disruption_budget)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mode != PatchRollout_Mode::MODE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.mode);
        }
        if let Some(ref v) = self.disruption_budget.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mode != PatchRollout_Mode::MODE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if let Some(ref v) = self.disruption_budget.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchRollout {
        PatchRollout::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PatchRollout_Mode>>(
                "mode",
                |m: &PatchRollout| { &m.mode },
                |m: &mut PatchRollout| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::osconfig_common::FixedOrPercent>>(
                "disruption_budget",
                |m: &PatchRollout| { &m.disruption_budget },
                |m: &mut PatchRollout| { &mut m.disruption_budget },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchRollout>(
                "PatchRollout",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchRollout {
        static instance: ::protobuf::rt::LazyV2<PatchRollout> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchRollout::new)
    }
}

impl ::protobuf::Clear for PatchRollout {
    fn clear(&mut self) {
        self.mode = PatchRollout_Mode::MODE_UNSPECIFIED;
        self.disruption_budget.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchRollout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchRollout {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PatchRollout_Mode {
    MODE_UNSPECIFIED = 0,
    ZONE_BY_ZONE = 1,
    CONCURRENT_ZONES = 2,
}

impl ::protobuf::ProtobufEnum for PatchRollout_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatchRollout_Mode> {
        match value {
            0 => ::std::option::Option::Some(PatchRollout_Mode::MODE_UNSPECIFIED),
            1 => ::std::option::Option::Some(PatchRollout_Mode::ZONE_BY_ZONE),
            2 => ::std::option::Option::Some(PatchRollout_Mode::CONCURRENT_ZONES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PatchRollout_Mode] = &[
            PatchRollout_Mode::MODE_UNSPECIFIED,
            PatchRollout_Mode::ZONE_BY_ZONE,
            PatchRollout_Mode::CONCURRENT_ZONES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PatchRollout_Mode>("PatchRollout.Mode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PatchRollout_Mode {
}

impl ::std::default::Default for PatchRollout_Mode {
    fn default() -> Self {
        PatchRollout_Mode::MODE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchRollout_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)google/cloud/osconfig/v1/patch_jobs.proto\x12\x18google.cloud.osconfi\
    g.v1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.p\
    roto\x1a.google/cloud/osconfig/v1/osconfig_common.proto\x1a\x1egoogle/pr\
    otobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xe3\x03\n\
    \x16ExecutePatchJobRequest\x12K\n\x06parent\x18\x01\x20\x01(\tR\x06paren\
    tB3\xfaA-\n+cloudresourcemanager.googleapis.com/Project\xe0A\x02\x12\x20\
    \n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12[\n\x0finstance_\
    filter\x18\x07\x20\x01(\x0b2-.google.cloud.osconfig.v1.PatchInstanceFilt\
    erR\x0einstanceFilterB\x03\xe0A\x02\x12H\n\x0cpatch_config\x18\x04\x20\
    \x01(\x0b2%.google.cloud.osconfig.v1.PatchConfigR\x0bpatchConfig\x125\n\
    \x08duration\x18\x05\x20\x01(\x0b2\x19.google.protobuf.DurationR\x08dura\
    tion\x12\x17\n\x07dry_run\x18\x06\x20\x01(\x08R\x06dryRun\x12!\n\x0cdisp\
    lay_name\x18\x08\x20\x01(\tR\x0bdisplayName\x12@\n\x07rollout\x18\t\x20\
    \x01(\x0b2&.google.cloud.osconfig.v1.PatchRolloutR\x07rollout\"R\n\x12Ge\
    tPatchJobRequest\x12<\n\x04name\x18\x01\x20\x01(\tR\x04nameB(\xfaA\"\n\
    \x20osconfig.googleapis.com/PatchJob\xe0A\x02\"\xba\x01\n\"ListPatchJobI\
    nstanceDetailsRequest\x12@\n\x06parent\x18\x01\x20\x01(\tR\x06parentB(\
    \xfaA\"\n\x20osconfig.googleapis.com/PatchJob\xe0A\x02\x12\x1b\n\tpage_s\
    ize\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\
    \x01(\tR\tpageToken\x12\x16\n\x06filter\x18\x04\x20\x01(\tR\x06filter\"\
    \xbd\x01\n#ListPatchJobInstanceDetailsResponse\x12n\n\x1apatch_job_insta\
    nce_details\x18\x01\x20\x03(\x0b21.google.cloud.osconfig.v1.PatchJobInst\
    anceDetailsR\x17patchJobInstanceDetails\x12&\n\x0fnext_page_token\x18\
    \x02\x20\x01(\tR\rnextPageToken\"\x92\x02\n\x17PatchJobInstanceDetails\
    \x128\n\x04name\x18\x01\x20\x01(\tR\x04nameB$\xfaA!\n\x1fcompute.googlea\
    pis.com/Instance\x12,\n\x12instance_system_id\x18\x02\x20\x01(\tR\x10ins\
    tanceSystemId\x12C\n\x05state\x18\x03\x20\x01(\x0e2-.google.cloud.osconf\
    ig.v1.Instance.PatchStateR\x05state\x12%\n\x0efailure_reason\x18\x04\x20\
    \x01(\tR\rfailureReason\x12#\n\rattempt_count\x18\x05\x20\x01(\x03R\x0ca\
    ttemptCount\"\xb7\x01\n\x14ListPatchJobsRequest\x12K\n\x06parent\x18\x01\
    \x20\x01(\tR\x06parentB3\xfaA-\n+cloudresourcemanager.googleapis.com/Pro\
    ject\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\x12\x16\n\x06filter\
    \x18\x04\x20\x01(\tR\x06filter\"\x82\x01\n\x15ListPatchJobsResponse\x12A\
    \n\npatch_jobs\x18\x01\x20\x03(\x0b2\".google.cloud.osconfig.v1.PatchJob\
    R\tpatchJobs\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToke\
    n\"\x9f\x10\n\x08PatchJob\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12!\n\x0cdisplay_name\x18\x0e\x20\x01(\tR\x0bdisplayName\x12\x20\n\x0b\
    description\x18\x02\x20\x01(\tR\x0bdescription\x12;\n\x0bcreate_time\x18\
    \x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\x0b\
    update_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nupdate\
    Time\x12>\n\x05state\x18\x05\x20\x01(\x0e2(.google.cloud.osconfig.v1.Pat\
    chJob.StateR\x05state\x12V\n\x0finstance_filter\x18\r\x20\x01(\x0b2-.goo\
    gle.cloud.osconfig.v1.PatchInstanceFilterR\x0einstanceFilter\x12H\n\x0cp\
    atch_config\x18\x07\x20\x01(\x0b2%.google.cloud.osconfig.v1.PatchConfigR\
    \x0bpatchConfig\x125\n\x08duration\x18\x08\x20\x01(\x0b2\x19.google.prot\
    obuf.DurationR\x08duration\x12s\n\x18instance_details_summary\x18\t\x20\
    \x01(\x0b29.google.cloud.osconfig.v1.PatchJob.InstanceDetailsSummaryR\
    \x16instanceDetailsSummary\x12\x17\n\x07dry_run\x18\n\x20\x01(\x08R\x06d\
    ryRun\x12#\n\rerror_message\x18\x0b\x20\x01(\tR\x0cerrorMessage\x12)\n\
    \x10percent_complete\x18\x0c\x20\x01(\x01R\x0fpercentComplete\x12Z\n\x10\
    patch_deployment\x18\x0f\x20\x01(\tR\x0fpatchDeploymentB/\xfaA)\n'osconf\
    ig.googleapis.com/PatchDeployment\xe0A\x03\x12@\n\x07rollout\x18\x10\x20\
    \x01(\x0b2&.google.cloud.osconfig.v1.PatchRolloutR\x07rollout\x1a\xc1\
    \x07\n\x16InstanceDetailsSummary\x124\n\x16pending_instance_count\x18\
    \x01\x20\x01(\x03R\x14pendingInstanceCount\x126\n\x17inactive_instance_c\
    ount\x18\x02\x20\x01(\x03R\x15inactiveInstanceCount\x126\n\x17notified_i\
    nstance_count\x18\x03\x20\x01(\x03R\x15notifiedInstanceCount\x124\n\x16s\
    tarted_instance_count\x18\x04\x20\x01(\x03R\x14startedInstanceCount\x12K\
    \n\"downloading_patches_instance_count\x18\x05\x20\x01(\x03R\x1fdownload\
    ingPatchesInstanceCount\x12E\n\x1fapplying_patches_instance_count\x18\
    \x06\x20\x01(\x03R\x1capplyingPatchesInstanceCount\x128\n\x18rebooting_i\
    nstance_count\x18\x07\x20\x01(\x03R\x16rebootingInstanceCount\x128\n\x18\
    succeeded_instance_count\x18\x08\x20\x01(\x03R\x16succeededInstanceCount\
    \x12V\n(succeeded_reboot_required_instance_count\x18\t\x20\x01(\x03R$suc\
    ceededRebootRequiredInstanceCount\x122\n\x15failed_instance_count\x18\n\
    \x20\x01(\x03R\x13failedInstanceCount\x120\n\x14acked_instance_count\x18\
    \x0b\x20\x01(\x03R\x12ackedInstanceCount\x127\n\x18timed_out_instance_co\
    unt\x18\x0c\x20\x01(\x03R\x15timedOutInstanceCount\x12@\n\x1dpre_patch_s\
    tep_instance_count\x18\r\x20\x01(\x03R\x19prePatchStepInstanceCount\x12B\
    \n\x1epost_patch_step_instance_count\x18\x0e\x20\x01(\x03R\x1apostPatchS\
    tepInstanceCount\x12F\n\x20no_agent_detected_instance_count\x18\x0f\x20\
    \x01(\x03R\x1cnoAgentDetectedInstanceCount\"\x95\x01\n\x05State\x12\x15\
    \n\x11STATE_UNSPECIFIED\x10\0\x12\x0b\n\x07STARTED\x10\x01\x12\x13\n\x0f\
    INSTANCE_LOOKUP\x10\x02\x12\x0c\n\x08PATCHING\x10\x03\x12\r\n\tSUCCEEDED\
    \x10\x04\x12\x19\n\x15COMPLETED_WITH_ERRORS\x10\x05\x12\x0c\n\x08CANCELE\
    D\x10\x06\x12\r\n\tTIMED_OUT\x10\x07:O\xeaAL\n\x20osconfig.googleapis.co\
    m/PatchJob\x12(projects/{project}/patchJobs/{patch_job}\"\xb2\x05\n\x0bP\
    atchConfig\x12W\n\rreboot_config\x18\x01\x20\x01(\x0e22.google.cloud.osc\
    onfig.v1.PatchConfig.RebootConfigR\x0crebootConfig\x127\n\x03apt\x18\x03\
    \x20\x01(\x0b2%.google.cloud.osconfig.v1.AptSettingsR\x03apt\x127\n\x03y\
    um\x18\x04\x20\x01(\x0b2%.google.cloud.osconfig.v1.YumSettingsR\x03yum\
    \x127\n\x03goo\x18\x05\x20\x01(\x0b2%.google.cloud.osconfig.v1.GooSettin\
    gsR\x03goo\x12@\n\x06zypper\x18\x06\x20\x01(\x0b2(.google.cloud.osconfig\
    .v1.ZypperSettingsR\x06zypper\x12V\n\x0ewindows_update\x18\x07\x20\x01(\
    \x0b2/.google.cloud.osconfig.v1.WindowsUpdateSettingsR\rwindowsUpdate\
    \x12=\n\x08pre_step\x18\x08\x20\x01(\x0b2\".google.cloud.osconfig.v1.Exe\
    cStepR\x07preStep\x12?\n\tpost_step\x18\t\x20\x01(\x0b2\".google.cloud.o\
    sconfig.v1.ExecStepR\x08postStep\x122\n\x15mig_instances_allowed\x18\n\
    \x20\x01(\x08R\x13migInstancesAllowed\"Q\n\x0cRebootConfig\x12\x1d\n\x19\
    REBOOT_CONFIG_UNSPECIFIED\x10\0\x12\x0b\n\x07DEFAULT\x10\x01\x12\n\n\x06\
    ALWAYS\x10\x02\x12\t\n\x05NEVER\x10\x03\"\xce\x02\n\x08Instance\"\xc1\
    \x02\n\nPatchState\x12\x1b\n\x17PATCH_STATE_UNSPECIFIED\x10\0\x12\x0b\n\
    \x07PENDING\x10\x01\x12\x0c\n\x08INACTIVE\x10\x02\x12\x0c\n\x08NOTIFIED\
    \x10\x03\x12\x0b\n\x07STARTED\x10\x04\x12\x17\n\x13DOWNLOADING_PATCHES\
    \x10\x05\x12\x14\n\x10APPLYING_PATCHES\x10\x06\x12\r\n\tREBOOTING\x10\
    \x07\x12\r\n\tSUCCEEDED\x10\x08\x12\x1d\n\x19SUCCEEDED_REBOOT_REQUIRED\
    \x10\t\x12\n\n\x06FAILED\x10\n\x12\t\n\x05ACKED\x10\x0b\x12\r\n\tTIMED_O\
    UT\x10\x0c\x12\x1a\n\x16RUNNING_PRE_PATCH_STEP\x10\r\x12\x1b\n\x17RUNNIN\
    G_POST_PATCH_STEP\x10\x0e\x12\x15\n\x11NO_AGENT_DETECTED\x10\x0f\"U\n\
    \x15CancelPatchJobRequest\x12<\n\x04name\x18\x01\x20\x01(\tR\x04nameB(\
    \xfaA\"\n\x20osconfig.googleapis.com/PatchJob\xe0A\x02\"\xcd\x01\n\x0bAp\
    tSettings\x12>\n\x04type\x18\x01\x20\x01(\x0e2*.google.cloud.osconfig.v1\
    .AptSettings.TypeR\x04type\x12\x1a\n\x08excludes\x18\x02\x20\x03(\tR\x08\
    excludes\x12-\n\x12exclusive_packages\x18\x03\x20\x03(\tR\x11exclusivePa\
    ckages\"3\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\x08\n\x04DIS\
    T\x10\x01\x12\x0b\n\x07UPGRADE\x10\x02\"\x8e\x01\n\x0bYumSettings\x12\
    \x1a\n\x08security\x18\x01\x20\x01(\x08R\x08security\x12\x18\n\x07minima\
    l\x18\x02\x20\x01(\x08R\x07minimal\x12\x1a\n\x08excludes\x18\x03\x20\x03\
    (\tR\x08excludes\x12-\n\x12exclusive_packages\x18\x04\x20\x03(\tR\x11exc\
    lusivePackages\"\r\n\x0bGooSettings\"\xdf\x01\n\x0eZypperSettings\x12#\n\
    \rwith_optional\x18\x01\x20\x01(\x08R\x0cwithOptional\x12\x1f\n\x0bwith_\
    update\x18\x02\x20\x01(\x08R\nwithUpdate\x12\x1e\n\ncategories\x18\x03\
    \x20\x03(\tR\ncategories\x12\x1e\n\nseverities\x18\x04\x20\x03(\tR\nseve\
    rities\x12\x1a\n\x08excludes\x18\x05\x20\x03(\tR\x08excludes\x12+\n\x11e\
    xclusive_patches\x18\x06\x20\x03(\tR\x10exclusivePatches\"\x82\x03\n\x15\
    WindowsUpdateSettings\x12h\n\x0fclassifications\x18\x01\x20\x03(\x0e2>.g\
    oogle.cloud.osconfig.v1.WindowsUpdateSettings.ClassificationR\x0fclassif\
    ications\x12\x1a\n\x08excludes\x18\x02\x20\x03(\tR\x08excludes\x12+\n\
    \x11exclusive_patches\x18\x03\x20\x03(\tR\x10exclusivePatches\"\xb5\x01\
    \n\x0eClassification\x12\x1e\n\x1aCLASSIFICATION_UNSPECIFIED\x10\0\x12\
    \x0c\n\x08CRITICAL\x10\x01\x12\x0c\n\x08SECURITY\x10\x02\x12\x0e\n\nDEFI\
    NITION\x10\x03\x12\n\n\x06DRIVER\x10\x04\x12\x10\n\x0cFEATURE_PACK\x10\
    \x05\x12\x10\n\x0cSERVICE_PACK\x10\x06\x12\x08\n\x04TOOL\x10\x07\x12\x11\
    \n\rUPDATE_ROLLUP\x10\x08\x12\n\n\x06UPDATE\x10\t\"\xcc\x01\n\x08ExecSte\
    p\x12]\n\x16linux_exec_step_config\x18\x01\x20\x01(\x0b2(.google.cloud.o\
    sconfig.v1.ExecStepConfigR\x13linuxExecStepConfig\x12a\n\x18windows_exec\
    _step_config\x18\x02\x20\x01(\x0b2(.google.cloud.osconfig.v1.ExecStepCon\
    figR\x15windowsExecStepConfig\"\xd8\x02\n\x0eExecStepConfig\x12\x1f\n\nl\
    ocal_path\x18\x01\x20\x01(\tH\0R\tlocalPath\x12D\n\ngcs_object\x18\x02\
    \x20\x01(\x0b2#.google.cloud.osconfig.v1.GcsObjectH\0R\tgcsObject\x122\n\
    \x15allowed_success_codes\x18\x03\x20\x03(\x05R\x13allowedSuccessCodes\
    \x12V\n\x0binterpreter\x18\x04\x20\x01(\x0e24.google.cloud.osconfig.v1.E\
    xecStepConfig.InterpreterR\x0binterpreter\"E\n\x0bInterpreter\x12\x1b\n\
    \x17INTERPRETER_UNSPECIFIED\x10\0\x12\t\n\x05SHELL\x10\x01\x12\x0e\n\nPO\
    WERSHELL\x10\x02B\x0c\n\nexecutable\"w\n\tGcsObject\x12\x1b\n\x06bucket\
    \x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06object\x18\x02\
    \x20\x01(\tR\x06objectB\x03\xe0A\x02\x120\n\x11generation_number\x18\x03\
    \x20\x01(\x03R\x10generationNumberB\x03\xe0A\x02\"\x96\x03\n\x13PatchIns\
    tanceFilter\x12\x10\n\x03all\x18\x01\x20\x01(\x08R\x03all\x12[\n\x0cgrou\
    p_labels\x18\x02\x20\x03(\x0b28.google.cloud.osconfig.v1.PatchInstanceFi\
    lter.GroupLabelR\x0bgroupLabels\x12\x14\n\x05zones\x18\x03\x20\x03(\tR\
    \x05zones\x12\x1c\n\tinstances\x18\x04\x20\x03(\tR\tinstances\x124\n\x16\
    instance_name_prefixes\x18\x05\x20\x03(\tR\x14instanceNamePrefixes\x1a\
    \xa5\x01\n\nGroupLabel\x12\\\n\x06labels\x18\x01\x20\x03(\x0b2D.google.c\
    loud.osconfig.v1.PatchInstanceFilter.GroupLabel.LabelsEntryR\x06labels\
    \x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xec\x01\n\x0cPa\
    tchRollout\x12?\n\x04mode\x18\x01\x20\x01(\x0e2+.google.cloud.osconfig.v\
    1.PatchRollout.ModeR\x04mode\x12U\n\x11disruption_budget\x18\x02\x20\x01\
    (\x0b2(.google.cloud.osconfig.v1.FixedOrPercentR\x10disruptionBudget\"D\
    \n\x04Mode\x12\x14\n\x10MODE_UNSPECIFIED\x10\0\x12\x10\n\x0cZONE_BY_ZONE\
    \x10\x01\x12\x14\n\x10CONCURRENT_ZONES\x10\x02B\xb7\x01\n\x1ccom.google.\
    cloud.osconfig.v1B\tPatchJobsZ8cloud.google.com/go/osconfig/apiv1/osconf\
    igpb;osconfigpb\xaa\x02\x18Google.Cloud.OsConfig.V1\xca\x02\x18Google\\C\
    loud\\OsConfig\\V1\xea\x02\x1bGoogle::Cloud::OsConfig::V1J\xbe\xd8\x01\n\
    \x07\x12\x05\x0e\0\xe5\x05\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\
    \xb1\x04\x20Copyright\x202020\x20Google\x20LLC\n\n\x20Licensed\x20under\
    \x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\
    \n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compli\
    ance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\
    \x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.\
    org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\
    \x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distrib\
    uted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\
    \x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\
    \x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\
    \x02\x12\x03\x10\0!\n\t\n\x02\x03\0\x12\x03\x12\0)\n\t\n\x02\x03\x01\x12\
    \x03\x13\0#\n\t\n\x02\x03\x02\x12\x03\x14\08\n\t\n\x02\x03\x03\x12\x03\
    \x15\0(\n\t\n\x02\x03\x04\x12\x03\x16\0)\n\x08\n\x01\x08\x12\x03\x18\05\
    \n\t\n\x02\x08%\x12\x03\x18\05\n\x08\n\x01\x08\x12\x03\x19\0O\n\t\n\x02\
    \x08\x0b\x12\x03\x19\0O\n\x08\n\x01\x08\x12\x03\x1a\0*\n\t\n\x02\x08\x08\
    \x12\x03\x1a\0*\n\x08\n\x01\x08\x12\x03\x1b\05\n\t\n\x02\x08\x01\x12\x03\
    \x1b\05\n\x08\n\x01\x08\x12\x03\x1c\05\n\t\n\x02\x08)\x12\x03\x1c\05\n\
    \x08\n\x01\x08\x12\x03\x1d\04\n\t\n\x02\x08-\x12\x03\x1d\04\nV\n\x02\x04\
    \0\x12\x04!\0D\x01\x1aJ\x20A\x20request\x20message\x20to\x20initiate\x20\
    patching\x20across\x20Compute\x20Engine\n\x20instances.\n\n\n\n\x03\x04\
    \0\x01\x12\x03!\x08\x1e\nY\n\x04\x04\0\x02\0\x12\x04#\x02(\x04\x1aK\x20R\
    equired.\x20The\x20project\x20in\x20which\x20to\x20run\x20this\x20patch\
    \x20in\x20the\x20form\x20`projects/*`\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03#\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03#\t\x0f\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03#\x12\x13\n\r\n\x05\x04\0\x02\0\x08\x12\x04#\x14(\
    \x03\n\x0f\n\x08\x04\0\x02\0\x08\x9c\x08\0\x12\x03$\x04*\n\x0f\n\x07\x04\
    \0\x02\0\x08\x9f\x08\x12\x04%\x04'\x05\nf\n\x04\x04\0\x02\x01\x12\x03,\
    \x02\x19\x1aY\x20Description\x20of\x20the\x20patch\x20job.\x20Length\x20\
    of\x20the\x20description\x20is\x20limited\n\x20to\x201024\x20characters.\
    \n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03,\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03,\t\x14\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03,\x17\x18\n\
    u\n\x04\x04\0\x02\x02\x12\x040\x021/\x1ag\x20Required.\x20Instances\x20t\
    o\x20patch,\x20either\x20explicitly\x20or\x20filtered\x20by\x20some\n\
    \x20criteria\x20such\x20as\x20zone\x20or\x20labels.\n\n\x0c\n\x05\x04\0\
    \x02\x02\x06\x12\x030\x02\x15\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x030\x16\
    %\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x030()\n\x0c\n\x05\x04\0\x02\x02\x08\
    \x12\x031\x06.\n\x0f\n\x08\x04\0\x02\x02\x08\x9c\x08\0\x12\x031\x07-\nv\
    \n\x04\x04\0\x02\x03\x12\x035\x02\x1f\x1ai\x20Patch\x20configuration\x20\
    being\x20applied.\x20If\x20omitted,\x20instances\x20are\n\x20patched\x20\
    using\x20the\x20default\x20configurations.\n\n\x0c\n\x05\x04\0\x02\x03\
    \x06\x12\x035\x02\r\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x035\x0e\x1a\n\x0c\
    \n\x05\x04\0\x02\x03\x03\x12\x035\x1d\x1e\n\\\n\x04\x04\0\x02\x04\x12\
    \x039\x02(\x1aO\x20Duration\x20of\x20the\x20patch\x20job.\x20After\x20th\
    e\x20duration\x20ends,\x20the\x20patch\x20job\n\x20times\x20out.\n\n\x0c\
    \n\x05\x04\0\x02\x04\x06\x12\x039\x02\x1a\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x039\x1b#\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x039&'\n]\n\x04\x04\0\
    \x02\x05\x12\x03=\x02\x13\x1aP\x20If\x20this\x20patch\x20is\x20a\x20dry-\
    run\x20only,\x20instances\x20are\x20contacted\x20but\n\x20will\x20do\x20\
    nothing.\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03=\x02\x06\n\x0c\n\x05\
    \x04\0\x02\x05\x01\x12\x03=\x07\x0e\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x03=\x11\x12\nP\n\x04\x04\0\x02\x06\x12\x03@\x02\x1a\x1aC\x20Display\
    \x20name\x20for\x20this\x20patch\x20job.\x20This\x20does\x20not\x20have\
    \x20to\x20be\x20unique.\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03@\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03@\t\x15\n\x0c\n\x05\x04\0\x02\x06\
    \x03\x12\x03@\x18\x19\n1\n\x04\x04\0\x02\x07\x12\x03C\x02\x1b\x1a$\x20Ro\
    llout\x20strategy\x20of\x20the\x20patch\x20job.\n\n\x0c\n\x05\x04\0\x02\
    \x07\x06\x12\x03C\x02\x0e\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03C\x0f\x16\
    \n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03C\x19\x1a\n>\n\x02\x04\x01\x12\x04\
    G\0O\x01\x1a2\x20Request\x20to\x20get\x20an\x20active\x20or\x20completed\
    \x20patch\x20job.\n\n\n\n\x03\x04\x01\x01\x12\x03G\x08\x1a\nP\n\x04\x04\
    \x01\x02\0\x12\x04I\x02N\x04\x1aB\x20Required.\x20Name\x20of\x20the\x20p\
    atch\x20in\x20the\x20form\x20`projects/*/patchJobs/*`\n\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03I\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03I\t\
    \r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03I\x10\x11\n\r\n\x05\x04\x01\x02\
    \0\x08\x12\x04I\x12N\x03\n\x0f\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\x03\
    J\x04*\n\x0f\n\x07\x04\x01\x02\0\x08\x9f\x08\x12\x04K\x04M\x05\nU\n\x02\
    \x04\x02\x12\x04R\0g\x01\x1aI\x20Request\x20to\x20list\x20details\x20for\
    \x20all\x20instances\x20that\x20are\x20part\x20of\x20a\x20patch\x20job.\
    \n\n\n\n\x03\x04\x02\x01\x12\x03R\x08*\nd\n\x04\x04\x02\x02\0\x12\x04U\
    \x02Z\x04\x1aV\x20Required.\x20The\x20parent\x20for\x20the\x20instances\
    \x20are\x20in\x20the\x20form\x20of\n\x20`projects/*/patchJobs/*`.\n\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03U\x02\x08\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03U\t\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03U\x12\x13\n\r\n\
    \x05\x04\x02\x02\0\x08\x12\x04U\x14Z\x03\n\x0f\n\x08\x04\x02\x02\0\x08\
    \x9c\x08\0\x12\x03V\x04*\n\x0f\n\x07\x04\x02\x02\0\x08\x9f\x08\x12\x04W\
    \x04Y\x05\nY\n\x04\x04\x02\x02\x01\x12\x03]\x02\x16\x1aL\x20The\x20maxim\
    um\x20number\x20of\x20instance\x20details\x20records\x20to\x20return.\
    \x20\x20Default\x20is\x20100.\n\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03]\
    \x02\x07\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03]\x08\x11\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03]\x14\x15\nx\n\x04\x04\x02\x02\x02\x12\x03a\
    \x02\x18\x1ak\x20A\x20pagination\x20token\x20returned\x20from\x20a\x20pr\
    evious\x20call\n\x20that\x20indicates\x20where\x20this\x20listing\x20sho\
    uld\x20continue\x20from.\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03a\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03a\t\x13\n\x0c\n\x05\x04\x02\
    \x02\x02\x03\x12\x03a\x16\x17\n\xac\x01\n\x04\x04\x02\x02\x03\x12\x03f\
    \x02\x14\x1a\x9e\x01\x20A\x20filter\x20expression\x20that\x20filters\x20\
    results\x20listed\x20in\x20the\x20response.\x20This\n\x20field\x20suppor\
    ts\x20filtering\x20results\x20by\x20instance\x20zone,\x20name,\x20state,\
    \x20or\n\x20`failure_reason`.\n\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03f\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03f\t\x0f\n\x0c\n\x05\x04\
    \x02\x02\x03\x03\x12\x03f\x12\x13\nS\n\x02\x04\x03\x12\x04j\0p\x01\x1aG\
    \x20A\x20response\x20message\x20for\x20listing\x20the\x20instances\x20de\
    tails\x20for\x20a\x20patch\x20job.\n\n\n\n\x03\x04\x03\x01\x12\x03j\x08+\
    \n)\n\x04\x04\x03\x02\0\x12\x03l\x02B\x1a\x1c\x20A\x20list\x20of\x20inst\
    ance\x20status.\n\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03l\x02\n\n\x0c\n\
    \x05\x04\x03\x02\0\x06\x12\x03l\x0b\"\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03l#=\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03l@A\nS\n\x04\x04\x03\x02\
    \x01\x12\x03o\x02\x1d\x1aF\x20A\x20pagination\x20token\x20that\x20can\
    \x20be\x20used\x20to\x20get\x20the\x20next\x20page\x20of\x20results.\n\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03o\t\x18\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03o\x1b\x1c\
    \n\x90\x02\n\x02\x04\x04\x12\x05v\0\x88\x01\x01\x1a\x82\x02\x20Patch\x20\
    details\x20for\x20a\x20VM\x20instance.\x20For\x20more\x20information\x20\
    about\x20reviewing\x20VM\n\x20instance\x20details,\x20see\n\x20[Listing\
    \x20all\x20VM\x20instance\x20details\x20for\x20a\x20specific\x20patch\n\
    \x20job](https://cloud.google.com/compute/docs/os-patch-management/manag\
    e-patch-jobs#list-instance-details).\n\n\n\n\x03\x04\x04\x01\x12\x03v\
    \x08\x1f\nN\n\x04\x04\x04\x02\0\x12\x04x\x02z\x05\x1a@\x20The\x20instanc\
    e\x20name\x20in\x20the\x20form\x20`projects/*/zones/*/instances/*`\n\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03x\x02\x08\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03x\t\r\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03x\x10\x11\n\r\n\
    \x05\x04\x04\x02\0\x08\x12\x04x\x12z\x04\n\x0f\n\x07\x04\x04\x02\0\x08\
    \x9f\x08\x12\x04x\x13z\x03\na\n\x04\x04\x04\x02\x01\x12\x03~\x02\x20\x1a\
    T\x20The\x20unique\x20identifier\x20for\x20the\x20instance.\x20This\x20i\
    dentifier\x20is\n\x20defined\x20by\x20the\x20server.\n\n\x0c\n\x05\x04\
    \x04\x02\x01\x05\x12\x03~\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x03~\t\x1b\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03~\x1e\x1f\n0\n\x04\
    \x04\x04\x02\x02\x12\x04\x81\x01\x02\x20\x1a\"\x20Current\x20state\x20of\
    \x20instance\x20patch.\n\n\r\n\x05\x04\x04\x02\x02\x06\x12\x04\x81\x01\
    \x02\x15\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\x81\x01\x16\x1b\n\r\n\x05\
    \x04\x04\x02\x02\x03\x12\x04\x81\x01\x1e\x1f\nC\n\x04\x04\x04\x02\x03\
    \x12\x04\x84\x01\x02\x1c\x1a5\x20If\x20the\x20patch\x20fails,\x20this\
    \x20field\x20provides\x20the\x20reason.\n\n\r\n\x05\x04\x04\x02\x03\x05\
    \x12\x04\x84\x01\x02\x08\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\x84\x01\t\
    \x17\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\x84\x01\x1a\x1b\nY\n\x04\x04\
    \x04\x02\x04\x12\x04\x87\x01\x02\x1a\x1aK\x20The\x20number\x20of\x20time\
    s\x20the\x20agent\x20that\x20the\x20agent\x20attempts\x20to\x20apply\x20\
    the\x20patch.\n\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\x87\x01\x02\x07\n\
    \r\n\x05\x04\x04\x02\x04\x01\x12\x04\x87\x01\x08\x15\n\r\n\x05\x04\x04\
    \x02\x04\x03\x12\x04\x87\x01\x18\x19\n9\n\x02\x04\x05\x12\x06\x8b\x01\0\
    \x9f\x01\x01\x1a+\x20A\x20request\x20message\x20for\x20listing\x20patch\
    \x20jobs.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x8b\x01\x08\x1c\n7\n\x04\x04\
    \x05\x02\0\x12\x06\x8d\x01\x02\x92\x01\x04\x1a'\x20Required.\x20In\x20th\
    e\x20form\x20of\x20`projects/*`\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\
    \x8d\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x8d\x01\t\x0f\n\r\n\
    \x05\x04\x05\x02\0\x03\x12\x04\x8d\x01\x12\x13\n\x0f\n\x05\x04\x05\x02\0\
    \x08\x12\x06\x8d\x01\x14\x92\x01\x03\n\x10\n\x08\x04\x05\x02\0\x08\x9c\
    \x08\0\x12\x04\x8e\x01\x04*\n\x11\n\x07\x04\x05\x02\0\x08\x9f\x08\x12\
    \x06\x8f\x01\x04\x91\x01\x05\n@\n\x04\x04\x05\x02\x01\x12\x04\x95\x01\
    \x02\x16\x1a2\x20The\x20maximum\x20number\x20of\x20instance\x20status\
    \x20to\x20return.\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x95\x01\x02\
    \x07\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x95\x01\x08\x11\n\r\n\x05\x04\
    \x05\x02\x01\x03\x12\x04\x95\x01\x14\x15\ny\n\x04\x04\x05\x02\x02\x12\
    \x04\x99\x01\x02\x18\x1ak\x20A\x20pagination\x20token\x20returned\x20fro\
    m\x20a\x20previous\x20call\n\x20that\x20indicates\x20where\x20this\x20li\
    sting\x20should\x20continue\x20from.\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\
    \x04\x99\x01\x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\x99\x01\t\x13\
    \n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x99\x01\x16\x17\n\xc6\x01\n\x04\
    \x04\x05\x02\x03\x12\x04\x9e\x01\x02\x14\x1a\xb7\x01\x20If\x20provided,\
    \x20this\x20field\x20specifies\x20the\x20criteria\x20that\x20must\x20be\
    \x20met\x20by\x20patch\n\x20jobs\x20to\x20be\x20included\x20in\x20the\
    \x20response.\n\x20Currently,\x20filtering\x20is\x20only\x20available\
    \x20on\x20the\x20patch_deployment\x20field.\n\n\r\n\x05\x04\x05\x02\x03\
    \x05\x12\x04\x9e\x01\x02\x08\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\x9e\
    \x01\t\x0f\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x9e\x01\x12\x13\n:\n\
    \x02\x04\x06\x12\x06\xa2\x01\0\xa8\x01\x01\x1a,\x20A\x20response\x20mess\
    age\x20for\x20listing\x20patch\x20jobs.\n\n\x0b\n\x03\x04\x06\x01\x12\
    \x04\xa2\x01\x08\x1d\n'\n\x04\x04\x06\x02\0\x12\x04\xa4\x01\x02#\x1a\x19\
    \x20The\x20list\x20of\x20patch\x20jobs.\n\n\r\n\x05\x04\x06\x02\0\x04\
    \x12\x04\xa4\x01\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xa4\x01\x0b\
    \x13\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xa4\x01\x14\x1e\n\r\n\x05\x04\
    \x06\x02\0\x03\x12\x04\xa4\x01!\"\nT\n\x04\x04\x06\x02\x01\x12\x04\xa7\
    \x01\x02\x1d\x1aF\x20A\x20pagination\x20token\x20that\x20can\x20be\x20us\
    ed\x20to\x20get\x20the\x20next\x20page\x20of\x20results.\n\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xa7\x01\t\x18\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xa7\x01\x1b\
    \x1c\n\xf3\x02\n\x02\x04\x07\x12\x06\xb3\x01\0\xc1\x02\x01\x1a\xe4\x02\
    \x20A\x20high\x20level\x20representation\x20of\x20a\x20patch\x20job\x20t\
    hat\x20is\x20either\x20in\x20progress\n\x20or\x20has\x20completed.\n\n\
    \x20Instance\x20details\x20are\x20not\x20included\x20in\x20the\x20job.\
    \x20To\x20paginate\x20through\x20instance\n\x20details,\x20use\x20ListPa\
    tchJobInstanceDetails.\n\n\x20For\x20more\x20information\x20about\x20pat\
    ch\x20jobs,\x20see\n\x20[Creating\x20patch\n\x20jobs](https://cloud.goog\
    le.com/compute/docs/os-patch-management/create-patch-job).\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xb3\x01\x08\x10\n\r\n\x03\x04\x07\x07\x12\x06\xb4\
    \x01\x02\xb7\x01\x04\n\x0f\n\x05\x04\x07\x07\x9d\x08\x12\x06\xb4\x01\x02\
    \xb7\x01\x04\n_\n\x04\x04\x07\x04\0\x12\x06\xbb\x01\x02\xd3\x01\x03\x1aO\
    \x20Enumeration\x20of\x20the\x20various\x20states\x20a\x20patch\x20job\
    \x20passes\x20through\x20as\x20it\n\x20executes.\n\n\r\n\x05\x04\x07\x04\
    \0\x01\x12\x04\xbb\x01\x07\x0c\n*\n\x06\x04\x07\x04\0\x02\0\x12\x04\xbd\
    \x01\x04\x1a\x1a\x1a\x20State\x20must\x20be\x20specified.\n\n\x0f\n\x07\
    \x04\x07\x04\0\x02\0\x01\x12\x04\xbd\x01\x04\x15\n\x0f\n\x07\x04\x07\x04\
    \0\x02\0\x02\x12\x04\xbd\x01\x18\x19\n;\n\x06\x04\x07\x04\0\x02\x01\x12\
    \x04\xc0\x01\x04\x10\x1a+\x20The\x20patch\x20job\x20was\x20successfully\
    \x20initiated.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x01\x01\x12\x04\xc0\x01\
    \x04\x0b\n\x0f\n\x07\x04\x07\x04\0\x02\x01\x02\x12\x04\xc0\x01\x0e\x0f\n\
    L\n\x06\x04\x07\x04\0\x02\x02\x12\x04\xc3\x01\x04\x18\x1a<\x20The\x20pat\
    ch\x20job\x20is\x20looking\x20up\x20instances\x20to\x20run\x20the\x20pat\
    ch\x20on.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x02\x01\x12\x04\xc3\x01\x04\
    \x13\n\x0f\n\x07\x04\x07\x04\0\x02\x02\x02\x12\x04\xc3\x01\x16\x17\n.\n\
    \x06\x04\x07\x04\0\x02\x03\x12\x04\xc6\x01\x04\x11\x1a\x1e\x20Instances\
    \x20are\x20being\x20patched.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x03\x01\x12\
    \x04\xc6\x01\x04\x0c\n\x0f\n\x07\x04\x07\x04\0\x02\x03\x02\x12\x04\xc6\
    \x01\x0f\x10\n3\n\x06\x04\x07\x04\0\x02\x04\x12\x04\xc9\x01\x04\x12\x1a#\
    \x20Patch\x20job\x20completed\x20successfully.\n\n\x0f\n\x07\x04\x07\x04\
    \0\x02\x04\x01\x12\x04\xc9\x01\x04\r\n\x0f\n\x07\x04\x07\x04\0\x02\x04\
    \x02\x12\x04\xc9\x01\x10\x11\n<\n\x06\x04\x07\x04\0\x02\x05\x12\x04\xcc\
    \x01\x04\x1e\x1a,\x20Patch\x20job\x20completed\x20but\x20there\x20were\
    \x20errors.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x05\x01\x12\x04\xcc\x01\x04\
    \x19\n\x0f\n\x07\x04\x07\x04\0\x02\x05\x02\x12\x04\xcc\x01\x1c\x1d\n-\n\
    \x06\x04\x07\x04\0\x02\x06\x12\x04\xcf\x01\x04\x11\x1a\x1d\x20The\x20pat\
    ch\x20job\x20was\x20canceled.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x06\x01\
    \x12\x04\xcf\x01\x04\x0c\n\x0f\n\x07\x04\x07\x04\0\x02\x06\x02\x12\x04\
    \xcf\x01\x0f\x10\n*\n\x06\x04\x07\x04\0\x02\x07\x12\x04\xd2\x01\x04\x12\
    \x1a\x1a\x20The\x20patch\x20job\x20timed\x20out.\n\n\x0f\n\x07\x04\x07\
    \x04\0\x02\x07\x01\x12\x04\xd2\x01\x04\r\n\x0f\n\x07\x04\x07\x04\0\x02\
    \x07\x02\x12\x04\xd2\x01\x10\x11\n\x95\x02\n\x04\x04\x07\x03\0\x12\x06\
    \xd9\x01\x02\x88\x02\x03\x1a\x84\x02\x20A\x20summary\x20of\x20the\x20cur\
    rent\x20patch\x20state\x20across\x20all\x20instances\x20that\x20this\x20\
    patch\n\x20job\x20affects.\x20Contains\x20counts\x20of\x20instances\x20i\
    n\x20different\x20states.\x20These\x20states\n\x20map\x20to\x20`Instance\
    PatchState`.\x20List\x20patch\x20job\x20instance\x20details\x20to\x20see\
    \x20the\n\x20specific\x20states\x20of\x20each\x20instance.\n\n\r\n\x05\
    \x04\x07\x03\0\x01\x12\x04\xd9\x01\n\x20\n8\n\x06\x04\x07\x03\0\x02\0\
    \x12\x04\xdb\x01\x04%\x1a(\x20Number\x20of\x20instances\x20pending\x20pa\
    tch\x20job.\n\n\x0f\n\x07\x04\x07\x03\0\x02\0\x05\x12\x04\xdb\x01\x04\t\
    \n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\xdb\x01\n\x20\n\x0f\n\x07\
    \x04\x07\x03\0\x02\0\x03\x12\x04\xdb\x01#$\n8\n\x06\x04\x07\x03\0\x02\
    \x01\x12\x04\xde\x01\x04&\x1a(\x20Number\x20of\x20instances\x20that\x20a\
    re\x20inactive.\n\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x04\xde\x01\
    \x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x04\xde\x01\n!\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x03\x12\x04\xde\x01$%\n?\n\x06\x04\x07\x03\0\
    \x02\x02\x12\x04\xe1\x01\x04&\x1a/\x20Number\x20of\x20instances\x20notif\
    ied\x20about\x20patch\x20job.\n\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x05\
    \x12\x04\xe1\x01\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x01\x12\x04\xe1\
    \x01\n!\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x03\x12\x04\xe1\x01$%\n8\n\x06\
    \x04\x07\x03\0\x02\x03\x12\x04\xe4\x01\x04%\x1a(\x20Number\x20of\x20inst\
    ances\x20that\x20have\x20started.\n\n\x0f\n\x07\x04\x07\x03\0\x02\x03\
    \x05\x12\x04\xe4\x01\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x01\x12\x04\
    \xe4\x01\n\x20\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x03\x12\x04\xe4\x01#$\n\
    C\n\x06\x04\x07\x03\0\x02\x04\x12\x04\xe7\x01\x041\x1a3\x20Number\x20of\
    \x20instances\x20that\x20are\x20downloading\x20patches.\n\n\x0f\n\x07\
    \x04\x07\x03\0\x02\x04\x05\x12\x04\xe7\x01\x04\t\n\x0f\n\x07\x04\x07\x03\
    \0\x02\x04\x01\x12\x04\xe7\x01\n,\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x03\
    \x12\x04\xe7\x01/0\n@\n\x06\x04\x07\x03\0\x02\x05\x12\x04\xea\x01\x04.\
    \x1a0\x20Number\x20of\x20instances\x20that\x20are\x20applying\x20patches\
    .\n\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x05\x12\x04\xea\x01\x04\t\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x05\x01\x12\x04\xea\x01\n)\n\x0f\n\x07\x04\x07\
    \x03\0\x02\x05\x03\x12\x04\xea\x01,-\n0\n\x06\x04\x07\x03\0\x02\x06\x12\
    \x04\xed\x01\x04'\x1a\x20\x20Number\x20of\x20instances\x20rebooting.\n\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x06\x05\x12\x04\xed\x01\x04\t\n\x0f\n\x07\
    \x04\x07\x03\0\x02\x06\x01\x12\x04\xed\x01\n\"\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x06\x03\x12\x04\xed\x01%&\nG\n\x06\x04\x07\x03\0\x02\x07\x12\x04\
    \xf0\x01\x04'\x1a7\x20Number\x20of\x20instances\x20that\x20have\x20compl\
    eted\x20successfully.\n\n\x0f\n\x07\x04\x07\x03\0\x02\x07\x05\x12\x04\
    \xf0\x01\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\x07\x01\x12\x04\xf0\x01\n\"\
    \n\x0f\n\x07\x04\x07\x03\0\x02\x07\x03\x12\x04\xf0\x01%&\n:\n\x06\x04\
    \x07\x03\0\x02\x08\x12\x04\xf3\x01\x047\x1a*\x20Number\x20of\x20instance\
    s\x20that\x20require\x20reboot.\n\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x05\
    \x12\x04\xf3\x01\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x01\x12\x04\xf3\
    \x01\n2\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x03\x12\x04\xf3\x0156\n2\n\x06\
    \x04\x07\x03\0\x02\t\x12\x04\xf6\x01\x04%\x1a\"\x20Number\x20of\x20insta\
    nces\x20that\x20failed.\n\n\x0f\n\x07\x04\x07\x03\0\x02\t\x05\x12\x04\
    \xf6\x01\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\t\x01\x12\x04\xf6\x01\n\x1f\
    \n\x0f\n\x07\x04\x07\x03\0\x02\t\x03\x12\x04\xf6\x01\"$\nM\n\x06\x04\x07\
    \x03\0\x02\n\x12\x04\xf9\x01\x04$\x1a=\x20Number\x20of\x20instances\x20t\
    hat\x20have\x20acked\x20and\x20will\x20start\x20shortly.\n\n\x0f\n\x07\
    \x04\x07\x03\0\x02\n\x05\x12\x04\xf9\x01\x04\t\n\x0f\n\x07\x04\x07\x03\0\
    \x02\n\x01\x12\x04\xf9\x01\n\x1e\n\x0f\n\x07\x04\x07\x03\0\x02\n\x03\x12\
    \x04\xf9\x01!#\nZ\n\x06\x04\x07\x03\0\x02\x0b\x12\x04\xfc\x01\x04(\x1aJ\
    \x20Number\x20of\x20instances\x20that\x20exceeded\x20the\x20time\x20out\
    \x20while\x20applying\x20the\x20patch.\n\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x0b\x05\x12\x04\xfc\x01\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x01\x12\
    \x04\xfc\x01\n\"\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x03\x12\x04\xfc\x01%'\
    \nJ\n\x06\x04\x07\x03\0\x02\x0c\x12\x04\xff\x01\x04-\x1a:\x20Number\x20o\
    f\x20instances\x20that\x20are\x20running\x20the\x20pre-patch\x20step.\n\
    \n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x05\x12\x04\xff\x01\x04\t\n\x0f\n\x07\
    \x04\x07\x03\0\x02\x0c\x01\x12\x04\xff\x01\n'\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x0c\x03\x12\x04\xff\x01*,\nK\n\x06\x04\x07\x03\0\x02\r\x12\x04\x82\
    \x02\x04.\x1a;\x20Number\x20of\x20instances\x20that\x20are\x20running\
    \x20the\x20post-patch\x20step.\n\n\x0f\n\x07\x04\x07\x03\0\x02\r\x05\x12\
    \x04\x82\x02\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\r\x01\x12\x04\x82\x02\n\
    (\n\x0f\n\x07\x04\x07\x03\0\x02\r\x03\x12\x04\x82\x02+-\n\xb4\x01\n\x06\
    \x04\x07\x03\0\x02\x0e\x12\x04\x87\x02\x040\x1a\xa3\x01\x20Number\x20of\
    \x20instances\x20that\x20do\x20not\x20appear\x20to\x20be\x20running\x20t\
    he\x20agent.\x20Check\x20to\n\x20ensure\x20that\x20the\x20agent\x20is\
    \x20installed,\x20running,\x20and\x20able\x20to\x20communicate\x20with\n\
    \x20the\x20service.\n\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x05\x12\x04\x87\
    \x02\x04\t\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x01\x12\x04\x87\x02\n*\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x0e\x03\x12\x04\x87\x02-/\nZ\n\x04\x04\x07\
    \x02\0\x12\x04\x8c\x02\x02\x12\x1aL\x20Unique\x20identifier\x20for\x20th\
    is\x20patch\x20job\x20in\x20the\x20form\n\x20`projects/*/patchJobs/*`\n\
    \n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x8c\x02\x02\x08\n\r\n\x05\x04\x07\
    \x02\0\x01\x12\x04\x8c\x02\t\r\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x8c\
    \x02\x10\x11\nQ\n\x04\x04\x07\x02\x01\x12\x04\x8f\x02\x02\x1b\x1aC\x20Di\
    splay\x20name\x20for\x20this\x20patch\x20job.\x20This\x20is\x20not\x20a\
    \x20unique\x20identifier.\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\x8f\
    \x02\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x8f\x02\t\x15\n\r\n\
    \x05\x04\x07\x02\x01\x03\x12\x04\x8f\x02\x18\x1a\ng\n\x04\x04\x07\x02\
    \x02\x12\x04\x93\x02\x02\x19\x1aY\x20Description\x20of\x20the\x20patch\
    \x20job.\x20Length\x20of\x20the\x20description\x20is\x20limited\n\x20to\
    \x201024\x20characters.\n\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\x93\x02\
    \x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\x93\x02\t\x14\n\r\n\x05\
    \x04\x07\x02\x02\x03\x12\x04\x93\x02\x17\x18\n0\n\x04\x04\x07\x02\x03\
    \x12\x04\x96\x02\x02,\x1a\"\x20Time\x20this\x20patch\x20job\x20was\x20cr\
    eated.\n\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\x96\x02\x02\x1b\n\r\n\x05\
    \x04\x07\x02\x03\x01\x12\x04\x96\x02\x1c'\n\r\n\x05\x04\x07\x02\x03\x03\
    \x12\x04\x96\x02*+\n5\n\x04\x04\x07\x02\x04\x12\x04\x99\x02\x02,\x1a'\
    \x20Last\x20time\x20this\x20patch\x20job\x20was\x20updated.\n\n\r\n\x05\
    \x04\x07\x02\x04\x06\x12\x04\x99\x02\x02\x1b\n\r\n\x05\x04\x07\x02\x04\
    \x01\x12\x04\x99\x02\x1c'\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\x99\x02*\
    +\n2\n\x04\x04\x07\x02\x05\x12\x04\x9c\x02\x02\x12\x1a$\x20The\x20curren\
    t\x20state\x20of\x20the\x20PatchJob.\n\n\r\n\x05\x04\x07\x02\x05\x06\x12\
    \x04\x9c\x02\x02\x07\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\x9c\x02\x08\r\
    \n\r\n\x05\x04\x07\x02\x05\x03\x12\x04\x9c\x02\x10\x11\n#\n\x04\x04\x07\
    \x02\x06\x12\x04\x9f\x02\x02+\x1a\x15\x20Instances\x20to\x20patch.\n\n\r\
    \n\x05\x04\x07\x02\x06\x06\x12\x04\x9f\x02\x02\x15\n\r\n\x05\x04\x07\x02\
    \x06\x01\x12\x04\x9f\x02\x16%\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\x9f\
    \x02(*\n2\n\x04\x04\x07\x02\x07\x12\x04\xa2\x02\x02\x1f\x1a$\x20Patch\
    \x20configuration\x20being\x20applied.\n\n\r\n\x05\x04\x07\x02\x07\x06\
    \x12\x04\xa2\x02\x02\r\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xa2\x02\x0e\
    \x1a\n\r\n\x05\x04\x07\x02\x07\x03\x12\x04\xa2\x02\x1d\x1e\n]\n\x04\x04\
    \x07\x02\x08\x12\x04\xa6\x02\x02(\x1aO\x20Duration\x20of\x20the\x20patch\
    \x20job.\x20After\x20the\x20duration\x20ends,\x20the\n\x20patch\x20job\
    \x20times\x20out.\n\n\r\n\x05\x04\x07\x02\x08\x06\x12\x04\xa6\x02\x02\
    \x1a\n\r\n\x05\x04\x07\x02\x08\x01\x12\x04\xa6\x02\x1b#\n\r\n\x05\x04\
    \x07\x02\x08\x03\x12\x04\xa6\x02&'\n,\n\x04\x04\x07\x02\t\x12\x04\xa9\
    \x02\x026\x1a\x1e\x20Summary\x20of\x20instance\x20details.\n\n\r\n\x05\
    \x04\x07\x02\t\x06\x12\x04\xa9\x02\x02\x18\n\r\n\x05\x04\x07\x02\t\x01\
    \x12\x04\xa9\x02\x191\n\r\n\x05\x04\x07\x02\t\x03\x12\x04\xa9\x0245\n\
    \x87\x01\n\x04\x04\x07\x02\n\x12\x04\xad\x02\x02\x14\x1ay\x20If\x20this\
    \x20patch\x20job\x20is\x20a\x20dry\x20run,\x20the\x20agent\x20reports\
    \x20that\x20it\x20has\n\x20finished\x20without\x20running\x20any\x20upda\
    tes\x20on\x20the\x20VM\x20instance.\n\n\r\n\x05\x04\x07\x02\n\x05\x12\
    \x04\xad\x02\x02\x06\n\r\n\x05\x04\x07\x02\n\x01\x12\x04\xad\x02\x07\x0e\
    \n\r\n\x05\x04\x07\x02\n\x03\x12\x04\xad\x02\x11\x13\n_\n\x04\x04\x07\
    \x02\x0b\x12\x04\xb1\x02\x02\x1c\x1aQ\x20If\x20this\x20patch\x20job\x20f\
    ailed,\x20this\x20message\x20provides\x20information\x20about\x20the\n\
    \x20failure.\n\n\r\n\x05\x04\x07\x02\x0b\x05\x12\x04\xb1\x02\x02\x08\n\r\
    \n\x05\x04\x07\x02\x0b\x01\x12\x04\xb1\x02\t\x16\n\r\n\x05\x04\x07\x02\
    \x0b\x03\x12\x04\xb1\x02\x19\x1b\n~\n\x04\x04\x07\x02\x0c\x12\x04\xb5\
    \x02\x02\x1f\x1ap\x20Reflects\x20the\x20overall\x20progress\x20of\x20the\
    \x20patch\x20job\x20in\x20the\x20range\x20of\n\x200.0\x20being\x20no\x20\
    progress\x20to\x20100.0\x20being\x20complete.\n\n\r\n\x05\x04\x07\x02\
    \x0c\x05\x12\x04\xb5\x02\x02\x08\n\r\n\x05\x04\x07\x02\x0c\x01\x12\x04\
    \xb5\x02\t\x19\n\r\n\x05\x04\x07\x02\x0c\x03\x12\x04\xb5\x02\x1c\x1e\nX\
    \n\x04\x04\x07\x02\r\x12\x06\xb8\x02\x02\xbd\x02\x04\x1aH\x20Output\x20o\
    nly.\x20Name\x20of\x20the\x20patch\x20deployment\x20that\x20created\x20t\
    his\x20patch\x20job.\n\n\r\n\x05\x04\x07\x02\r\x05\x12\x04\xb8\x02\x02\
    \x08\n\r\n\x05\x04\x07\x02\r\x01\x12\x04\xb8\x02\t\x19\n\r\n\x05\x04\x07\
    \x02\r\x03\x12\x04\xb8\x02\x1c\x1e\n\x0f\n\x05\x04\x07\x02\r\x08\x12\x06\
    \xb8\x02\x1f\xbd\x02\x03\n\x10\n\x08\x04\x07\x02\r\x08\x9c\x08\0\x12\x04\
    \xb9\x02\x04-\n\x11\n\x07\x04\x07\x02\r\x08\x9f\x08\x12\x06\xba\x02\x04\
    \xbc\x02\x05\n/\n\x04\x04\x07\x02\x0e\x12\x04\xc0\x02\x02\x1c\x1a!\x20Ro\
    llout\x20strategy\x20being\x20applied.\n\n\r\n\x05\x04\x07\x02\x0e\x06\
    \x12\x04\xc0\x02\x02\x0e\n\r\n\x05\x04\x07\x02\x0e\x01\x12\x04\xc0\x02\
    \x0f\x16\n\r\n\x05\x04\x07\x02\x0e\x03\x12\x04\xc0\x02\x19\x1b\nu\n\x02\
    \x04\x08\x12\x06\xc5\x02\0\xf6\x02\x01\x1ag\x20Patch\x20configuration\
    \x20specifications.\x20Contains\x20details\x20on\x20how\x20to\x20apply\
    \x20the\n\x20patch(es)\x20to\x20a\x20VM\x20instance.\n\n\x0b\n\x03\x04\
    \x08\x01\x12\x04\xc5\x02\x08\x13\n-\n\x04\x04\x08\x04\0\x12\x06\xc7\x02\
    \x02\xd6\x02\x03\x1a\x1d\x20Post-patch\x20reboot\x20settings.\n\n\r\n\
    \x05\x04\x08\x04\0\x01\x12\x04\xc7\x02\x07\x13\n2\n\x06\x04\x08\x04\0\
    \x02\0\x12\x04\xc9\x02\x04\"\x1a\"\x20The\x20default\x20behavior\x20is\
    \x20DEFAULT.\n\n\x0f\n\x07\x04\x08\x04\0\x02\0\x01\x12\x04\xc9\x02\x04\
    \x1d\n\x0f\n\x07\x04\x08\x04\0\x02\0\x02\x12\x04\xc9\x02\x20!\n\x8e\x02\
    \n\x06\x04\x08\x04\0\x02\x01\x12\x04\xcf\x02\x04\x10\x1a\xfd\x01\x20The\
    \x20agent\x20decides\x20if\x20a\x20reboot\x20is\x20necessary\x20by\x20ch\
    ecking\x20signals\x20such\x20as\n\x20registry\x20keys\x20on\x20Windows\
    \x20or\x20`/var/run/reboot-required`\x20on\x20APT\x20based\n\x20systems.\
    \x20On\x20RPM\x20based\x20systems,\x20a\x20set\x20of\x20core\x20system\
    \x20package\x20install\x20times\n\x20are\x20compared\x20with\x20system\
    \x20boot\x20time.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x04\xcf\
    \x02\x04\x0b\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x02\x12\x04\xcf\x02\x0e\
    \x0f\nG\n\x06\x04\x08\x04\0\x02\x02\x12\x04\xd2\x02\x04\x0f\x1a7\x20Alwa\
    ys\x20reboot\x20the\x20machine\x20after\x20the\x20update\x20completes.\n\
    \n\x0f\n\x07\x04\x08\x04\0\x02\x02\x01\x12\x04\xd2\x02\x04\n\n\x0f\n\x07\
    \x04\x08\x04\0\x02\x02\x02\x12\x04\xd2\x02\r\x0e\nF\n\x06\x04\x08\x04\0\
    \x02\x03\x12\x04\xd5\x02\x04\x0e\x1a6\x20Never\x20reboot\x20the\x20machi\
    ne\x20after\x20the\x20update\x20completes.\n\n\x0f\n\x07\x04\x08\x04\0\
    \x02\x03\x01\x12\x04\xd5\x02\x04\t\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x02\
    \x12\x04\xd5\x02\x0c\r\n+\n\x04\x04\x08\x02\0\x12\x04\xd9\x02\x02!\x1a\
    \x1d\x20Post-patch\x20reboot\x20settings.\n\n\r\n\x05\x04\x08\x02\0\x06\
    \x12\x04\xd9\x02\x02\x0e\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xd9\x02\x0f\
    \x1c\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xd9\x02\x1f\x20\na\n\x04\x04\
    \x08\x02\x01\x12\x04\xdd\x02\x02\x16\x1aS\x20Apt\x20update\x20settings.\
    \x20Use\x20this\x20setting\x20to\x20override\x20the\x20default\x20`apt`\
    \x20patch\n\x20rules.\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xdd\x02\
    \x02\r\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xdd\x02\x0e\x11\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\xdd\x02\x14\x15\na\n\x04\x04\x08\x02\x02\
    \x12\x04\xe1\x02\x02\x16\x1aS\x20Yum\x20update\x20settings.\x20Use\x20th\
    is\x20setting\x20to\x20override\x20the\x20default\x20`yum`\x20patch\n\
    \x20rules.\n\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xe1\x02\x02\r\n\r\n\
    \x05\x04\x08\x02\x02\x01\x12\x04\xe1\x02\x0e\x11\n\r\n\x05\x04\x08\x02\
    \x02\x03\x12\x04\xe1\x02\x14\x15\na\n\x04\x04\x08\x02\x03\x12\x04\xe5\
    \x02\x02\x16\x1aS\x20Goo\x20update\x20settings.\x20Use\x20this\x20settin\
    g\x20to\x20override\x20the\x20default\x20`goo`\x20patch\n\x20rules.\n\n\
    \r\n\x05\x04\x08\x02\x03\x06\x12\x04\xe5\x02\x02\r\n\r\n\x05\x04\x08\x02\
    \x03\x01\x12\x04\xe5\x02\x0e\x11\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\
    \xe5\x02\x14\x15\ng\n\x04\x04\x08\x02\x04\x12\x04\xe9\x02\x02\x1c\x1aY\
    \x20Zypper\x20update\x20settings.\x20Use\x20this\x20setting\x20to\x20ove\
    rride\x20the\x20default\x20`zypper`\n\x20patch\x20rules.\n\n\r\n\x05\x04\
    \x08\x02\x04\x06\x12\x04\xe9\x02\x02\x10\n\r\n\x05\x04\x08\x02\x04\x01\
    \x12\x04\xe9\x02\x11\x17\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xe9\x02\
    \x1a\x1b\n[\n\x04\x04\x08\x02\x05\x12\x04\xec\x02\x02+\x1aM\x20Windows\
    \x20update\x20settings.\x20Use\x20this\x20override\x20the\x20default\x20\
    windows\x20patch\x20rules.\n\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\xec\
    \x02\x02\x17\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xec\x02\x18&\n\r\n\
    \x05\x04\x08\x02\x05\x03\x12\x04\xec\x02)*\n>\n\x04\x04\x08\x02\x06\x12\
    \x04\xef\x02\x02\x18\x1a0\x20The\x20`ExecStep`\x20to\x20run\x20before\
    \x20the\x20patch\x20update.\n\n\r\n\x05\x04\x08\x02\x06\x06\x12\x04\xef\
    \x02\x02\n\n\r\n\x05\x04\x08\x02\x06\x01\x12\x04\xef\x02\x0b\x13\n\r\n\
    \x05\x04\x08\x02\x06\x03\x12\x04\xef\x02\x16\x17\n=\n\x04\x04\x08\x02\
    \x07\x12\x04\xf2\x02\x02\x19\x1a/\x20The\x20`ExecStep`\x20to\x20run\x20a\
    fter\x20the\x20patch\x20update.\n\n\r\n\x05\x04\x08\x02\x07\x06\x12\x04\
    \xf2\x02\x02\n\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\xf2\x02\x0b\x14\n\r\
    \n\x05\x04\x08\x02\x07\x03\x12\x04\xf2\x02\x17\x18\nN\n\x04\x04\x08\x02\
    \x08\x12\x04\xf5\x02\x02\"\x1a@\x20Allows\x20the\x20patch\x20job\x20to\
    \x20run\x20on\x20Managed\x20instance\x20groups\x20(MIGs).\n\n\r\n\x05\
    \x04\x08\x02\x08\x05\x12\x04\xf5\x02\x02\x06\n\r\n\x05\x04\x08\x02\x08\
    \x01\x12\x04\xf5\x02\x07\x1c\n\r\n\x05\x04\x08\x02\x08\x03\x12\x04\xf5\
    \x02\x1f!\n3\n\x02\x04\t\x12\x06\xf9\x02\0\xae\x03\x01\x1a%\x20Namespace\
    \x20for\x20instance\x20state\x20enums.\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xf9\x02\x08\x10\n-\n\x04\x04\t\x04\0\x12\x06\xfb\x02\x02\xad\x03\x03\
    \x1a\x1d\x20Patch\x20state\x20of\x20an\x20instance.\n\n\r\n\x05\x04\t\
    \x04\0\x01\x12\x04\xfb\x02\x07\x11\n\x1e\n\x06\x04\t\x04\0\x02\0\x12\x04\
    \xfd\x02\x04\x20\x1a\x0e\x20Unspecified.\n\n\x0f\n\x07\x04\t\x04\0\x02\0\
    \x01\x12\x04\xfd\x02\x04\x1b\n\x0f\n\x07\x04\t\x04\0\x02\0\x02\x12\x04\
    \xfd\x02\x1e\x1f\n3\n\x06\x04\t\x04\0\x02\x01\x12\x04\x80\x03\x04\x10\
    \x1a#\x20The\x20instance\x20is\x20not\x20yet\x20notified.\n\n\x0f\n\x07\
    \x04\t\x04\0\x02\x01\x01\x12\x04\x80\x03\x04\x0b\n\x0f\n\x07\x04\t\x04\0\
    \x02\x01\x02\x12\x04\x80\x03\x0e\x0f\n=\n\x06\x04\t\x04\0\x02\x02\x12\
    \x04\x83\x03\x04\x11\x1a-\x20Instance\x20is\x20inactive\x20and\x20cannot\
    \x20be\x20patched.\n\n\x0f\n\x07\x04\t\x04\0\x02\x02\x01\x12\x04\x83\x03\
    \x04\x0c\n\x0f\n\x07\x04\t\x04\0\x02\x02\x02\x12\x04\x83\x03\x0f\x10\nE\
    \n\x06\x04\t\x04\0\x02\x03\x12\x04\x86\x03\x04\x11\x1a5\x20The\x20instan\
    ce\x20is\x20notified\x20that\x20it\x20should\x20be\x20patched.\n\n\x0f\n\
    \x07\x04\t\x04\0\x02\x03\x01\x12\x04\x86\x03\x04\x0c\n\x0f\n\x07\x04\t\
    \x04\0\x02\x03\x02\x12\x04\x86\x03\x0f\x10\n@\n\x06\x04\t\x04\0\x02\x04\
    \x12\x04\x89\x03\x04\x10\x1a0\x20The\x20instance\x20has\x20started\x20th\
    e\x20patching\x20process.\n\n\x0f\n\x07\x04\t\x04\0\x02\x04\x01\x12\x04\
    \x89\x03\x04\x0b\n\x0f\n\x07\x04\t\x04\0\x02\x04\x02\x12\x04\x89\x03\x0e\
    \x0f\n6\n\x06\x04\t\x04\0\x02\x05\x12\x04\x8c\x03\x04\x1c\x1a&\x20The\
    \x20instance\x20is\x20downloading\x20patches.\n\n\x0f\n\x07\x04\t\x04\0\
    \x02\x05\x01\x12\x04\x8c\x03\x04\x17\n\x0f\n\x07\x04\t\x04\0\x02\x05\x02\
    \x12\x04\x8c\x03\x1a\x1b\n3\n\x06\x04\t\x04\0\x02\x06\x12\x04\x8f\x03\
    \x04\x19\x1a#\x20The\x20instance\x20is\x20applying\x20patches.\n\n\x0f\n\
    \x07\x04\t\x04\0\x02\x06\x01\x12\x04\x8f\x03\x04\x14\n\x0f\n\x07\x04\t\
    \x04\0\x02\x06\x02\x12\x04\x8f\x03\x17\x18\n,\n\x06\x04\t\x04\0\x02\x07\
    \x12\x04\x92\x03\x04\x12\x1a\x1c\x20The\x20instance\x20is\x20rebooting.\
    \n\n\x0f\n\x07\x04\t\x04\0\x02\x07\x01\x12\x04\x92\x03\x04\r\n\x0f\n\x07\
    \x04\t\x04\0\x02\x07\x02\x12\x04\x92\x03\x10\x11\n>\n\x06\x04\t\x04\0\
    \x02\x08\x12\x04\x95\x03\x04\x12\x1a.\x20The\x20instance\x20has\x20compl\
    eted\x20applying\x20patches.\n\n\x0f\n\x07\x04\t\x04\0\x02\x08\x01\x12\
    \x04\x95\x03\x04\r\n\x0f\n\x07\x04\t\x04\0\x02\x08\x02\x12\x04\x95\x03\
    \x10\x11\nW\n\x06\x04\t\x04\0\x02\t\x12\x04\x98\x03\x04\"\x1aG\x20The\
    \x20instance\x20has\x20completed\x20applying\x20patches\x20but\x20a\x20r\
    eboot\x20is\x20required.\n\n\x0f\n\x07\x04\t\x04\0\x02\t\x01\x12\x04\x98\
    \x03\x04\x1d\n\x0f\n\x07\x04\t\x04\0\x02\t\x02\x12\x04\x98\x03\x20!\n=\n\
    \x06\x04\t\x04\0\x02\n\x12\x04\x9b\x03\x04\x10\x1a-\x20The\x20instance\
    \x20has\x20failed\x20to\x20apply\x20the\x20patch.\n\n\x0f\n\x07\x04\t\
    \x04\0\x02\n\x01\x12\x04\x9b\x03\x04\n\n\x0f\n\x07\x04\t\x04\0\x02\n\x02\
    \x12\x04\x9b\x03\r\x0f\nM\n\x06\x04\t\x04\0\x02\x0b\x12\x04\x9e\x03\x04\
    \x0f\x1a=\x20The\x20instance\x20acked\x20the\x20notification\x20and\x20w\
    ill\x20start\x20shortly.\n\n\x0f\n\x07\x04\t\x04\0\x02\x0b\x01\x12\x04\
    \x9e\x03\x04\t\n\x0f\n\x07\x04\t\x04\0\x02\x0b\x02\x12\x04\x9e\x03\x0c\
    \x0e\nN\n\x06\x04\t\x04\0\x02\x0c\x12\x04\xa1\x03\x04\x13\x1a>\x20The\
    \x20instance\x20exceeded\x20the\x20time\x20out\x20while\x20applying\x20t\
    he\x20patch.\n\n\x0f\n\x07\x04\t\x04\0\x02\x0c\x01\x12\x04\xa1\x03\x04\r\
    \n\x0f\n\x07\x04\t\x04\0\x02\x0c\x02\x12\x04\xa1\x03\x10\x12\n=\n\x06\
    \x04\t\x04\0\x02\r\x12\x04\xa4\x03\x04\x20\x1a-\x20The\x20instance\x20is\
    \x20running\x20the\x20pre-patch\x20step.\n\n\x0f\n\x07\x04\t\x04\0\x02\r\
    \x01\x12\x04\xa4\x03\x04\x1a\n\x0f\n\x07\x04\t\x04\0\x02\r\x02\x12\x04\
    \xa4\x03\x1d\x1f\n>\n\x06\x04\t\x04\0\x02\x0e\x12\x04\xa7\x03\x04!\x1a.\
    \x20The\x20instance\x20is\x20running\x20the\x20post-patch\x20step.\n\n\
    \x0f\n\x07\x04\t\x04\0\x02\x0e\x01\x12\x04\xa7\x03\x04\x1b\n\x0f\n\x07\
    \x04\t\x04\0\x02\x0e\x02\x12\x04\xa7\x03\x1e\x20\n\xac\x01\n\x06\x04\t\
    \x04\0\x02\x0f\x12\x04\xac\x03\x04\x1b\x1a\x9b\x01\x20The\x20service\x20\
    could\x20not\x20detect\x20the\x20presence\x20of\x20the\x20agent.\x20Chec\
    k\x20to\x20ensure\n\x20that\x20the\x20agent\x20is\x20installed,\x20runni\
    ng,\x20and\x20able\x20to\x20communicate\x20with\x20the\n\x20service.\n\n\
    \x0f\n\x07\x04\t\x04\0\x02\x0f\x01\x12\x04\xac\x03\x04\x15\n\x0f\n\x07\
    \x04\t\x04\0\x02\x0f\x02\x12\x04\xac\x03\x18\x1a\n2\n\x02\x04\n\x12\x06\
    \xb1\x03\0\xb9\x03\x01\x1a$\x20Message\x20for\x20canceling\x20a\x20patch\
    \x20job.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xb1\x03\x08\x1d\nR\n\x04\x04\n\
    \x02\0\x12\x06\xb3\x03\x02\xb8\x03\x04\x1aB\x20Required.\x20Name\x20of\
    \x20the\x20patch\x20in\x20the\x20form\x20`projects/*/patchJobs/*`\n\n\r\
    \n\x05\x04\n\x02\0\x05\x12\x04\xb3\x03\x02\x08\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\xb3\x03\t\r\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb3\x03\x10\x11\n\
    \x0f\n\x05\x04\n\x02\0\x08\x12\x06\xb3\x03\x12\xb8\x03\x03\n\x10\n\x08\
    \x04\n\x02\0\x08\x9c\x08\0\x12\x04\xb4\x03\x04*\n\x11\n\x07\x04\n\x02\0\
    \x08\x9f\x08\x12\x06\xb5\x03\x04\xb7\x03\x05\n\x9c\x01\n\x02\x04\x0b\x12\
    \x06\xbd\x03\0\xd6\x03\x01\x1a\x8d\x01\x20Apt\x20patching\x20is\x20compl\
    eted\x20by\x20executing\x20`apt-get\x20update\x20&&\x20apt-get\n\x20upgr\
    ade`.\x20Additional\x20options\x20can\x20be\x20set\x20to\x20control\x20h\
    ow\x20this\x20is\x20executed.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xbd\x03\
    \x08\x13\n!\n\x04\x04\x0b\x04\0\x12\x06\xbf\x03\x02\xc8\x03\x03\x1a\x11\
    \x20Apt\x20patch\x20type.\n\n\r\n\x05\x04\x0b\x04\0\x01\x12\x04\xbf\x03\
    \x07\x0b\n8\n\x06\x04\x0b\x04\0\x02\0\x12\x04\xc1\x03\x04\x19\x1a(\x20By\
    \x20default,\x20upgrade\x20will\x20be\x20performed.\n\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\0\x01\x12\x04\xc1\x03\x04\x14\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\0\x02\x12\x04\xc1\x03\x17\x18\n.\n\x06\x04\x0b\x04\0\x02\x01\x12\
    \x04\xc4\x03\x04\r\x1a\x1e\x20Runs\x20`apt-get\x20dist-upgrade`.\n\n\x0f\
    \n\x07\x04\x0b\x04\0\x02\x01\x01\x12\x04\xc4\x03\x04\x08\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\x01\x02\x12\x04\xc4\x03\x0b\x0c\n)\n\x06\x04\x0b\x04\0\
    \x02\x02\x12\x04\xc7\x03\x04\x10\x1a\x19\x20Runs\x20`apt-get\x20upgrade`\
    .\n\n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x01\x12\x04\xc7\x03\x04\x0b\n\x0f\
    \n\x07\x04\x0b\x04\0\x02\x02\x02\x12\x04\xc7\x03\x0e\x0f\nn\n\x04\x04\
    \x0b\x02\0\x12\x04\xcc\x03\x02\x10\x1a`\x20By\x20changing\x20the\x20type\
    \x20to\x20DIST,\x20the\x20patching\x20is\x20performed\n\x20using\x20`apt\
    -get\x20dist-upgrade`\x20instead.\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\
    \xcc\x03\x02\x06\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xcc\x03\x07\x0b\n\r\
    \n\x05\x04\x0b\x02\0\x03\x12\x04\xcc\x03\x0e\x0f\nX\n\x04\x04\x0b\x02\
    \x01\x12\x04\xcf\x03\x02\x1f\x1aJ\x20List\x20of\x20packages\x20to\x20exc\
    lude\x20from\x20update.\x20These\x20packages\x20will\x20be\x20excluded\n\
    \n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xcf\x03\x02\n\n\r\n\x05\x04\x0b\
    \x02\x01\x05\x12\x04\xcf\x03\x0b\x11\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\xcf\x03\x12\x1a\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xcf\x03\x1d\
    \x1e\n\xf7\x01\n\x04\x04\x0b\x02\x02\x12\x04\xd5\x03\x02)\x1a\xe8\x01\
    \x20An\x20exclusive\x20list\x20of\x20packages\x20to\x20be\x20updated.\
    \x20These\x20are\x20the\x20only\x20packages\n\x20that\x20will\x20be\x20u\
    pdated.\x20If\x20these\x20packages\x20are\x20not\x20installed,\x20they\
    \x20will\x20be\n\x20ignored.\x20This\x20field\x20cannot\x20be\x20specifi\
    ed\x20with\x20any\x20other\x20patch\x20configuration\n\x20fields.\n\n\r\
    \n\x05\x04\x0b\x02\x02\x04\x12\x04\xd5\x03\x02\n\n\r\n\x05\x04\x0b\x02\
    \x02\x05\x12\x04\xd5\x03\x0b\x11\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\
    \xd5\x03\x12$\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xd5\x03'(\n\xc2\x01\
    \n\x02\x04\x0c\x12\x06\xdc\x03\0\xed\x03\x01\x1a\xb3\x01\x20Yum\x20patch\
    ing\x20is\x20performed\x20by\x20executing\x20`yum\x20update`.\x20Additio\
    nal\x20options\n\x20can\x20be\x20set\x20to\x20control\x20how\x20this\x20\
    is\x20executed.\n\n\x20Note\x20that\x20not\x20all\x20settings\x20are\x20\
    supported\x20on\x20all\x20platforms.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\
    \xdc\x03\x08\x13\n\\\n\x04\x04\x0c\x02\0\x12\x04\xdf\x03\x02\x14\x1aN\
    \x20Adds\x20the\x20`--security`\x20flag\x20to\x20`yum\x20update`.\x20Not\
    \x20supported\x20on\n\x20all\x20platforms.\n\n\r\n\x05\x04\x0c\x02\0\x05\
    \x12\x04\xdf\x03\x02\x06\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xdf\x03\x07\
    \x0f\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xdf\x03\x12\x13\nE\n\x04\x04\
    \x0c\x02\x01\x12\x04\xe2\x03\x02\x13\x1a7\x20Will\x20cause\x20patch\x20t\
    o\x20run\x20`yum\x20update-minimal`\x20instead.\n\n\r\n\x05\x04\x0c\x02\
    \x01\x05\x12\x04\xe2\x03\x02\x06\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\
    \xe2\x03\x07\x0e\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xe2\x03\x11\x12\n\
    x\n\x04\x04\x0c\x02\x02\x12\x04\xe6\x03\x02\x1f\x1aj\x20List\x20of\x20pa\
    ckages\x20to\x20exclude\x20from\x20update.\x20These\x20packages\x20are\
    \x20excluded\x20by\n\x20using\x20the\x20yum\x20`--exclude`\x20flag.\n\n\
    \r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xe6\x03\x02\n\n\r\n\x05\x04\x0c\x02\
    \x02\x05\x12\x04\xe6\x03\x0b\x11\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\
    \xe6\x03\x12\x1a\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xe6\x03\x1d\x1e\n\
    \xf9\x01\n\x04\x04\x0c\x02\x03\x12\x04\xec\x03\x02)\x1a\xea\x01\x20An\
    \x20exclusive\x20list\x20of\x20packages\x20to\x20be\x20updated.\x20These\
    \x20are\x20the\x20only\x20packages\n\x20that\x20will\x20be\x20updated.\
    \x20If\x20these\x20packages\x20are\x20not\x20installed,\x20they\x20will\
    \x20be\n\x20ignored.\x20This\x20field\x20must\x20not\x20be\x20specified\
    \x20with\x20any\x20other\x20patch\n\x20configuration\x20fields.\n\n\r\n\
    \x05\x04\x0c\x02\x03\x04\x12\x04\xec\x03\x02\n\n\r\n\x05\x04\x0c\x02\x03\
    \x05\x12\x04\xec\x03\x0b\x11\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xec\
    \x03\x12$\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xec\x03'(\nF\n\x02\x04\r\
    \x12\x04\xf0\x03\0\x16\x1a:\x20Googet\x20patching\x20is\x20performed\x20\
    by\x20running\x20`googet\x20update`.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xf0\
    \x03\x08\x13\n|\n\x02\x04\x0e\x12\x06\xf4\x03\0\x8a\x04\x01\x1an\x20Zypp\
    er\x20patching\x20is\x20performed\x20by\x20running\x20`zypper\x20patch`.\
    \n\x20See\x20also\x20https://en.opensuse.org/SDB:Zypper_manual.\n\n\x0b\
    \n\x03\x04\x0e\x01\x12\x04\xf4\x03\x08\x16\nB\n\x04\x04\x0e\x02\0\x12\
    \x04\xf6\x03\x02\x19\x1a4\x20Adds\x20the\x20`--with-optional`\x20flag\
    \x20to\x20`zypper\x20patch`.\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xf6\
    \x03\x02\x06\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xf6\x03\x07\x14\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\xf6\x03\x17\x18\nA\n\x04\x04\x0e\x02\x01\
    \x12\x04\xf9\x03\x02\x17\x1a3\x20Adds\x20the\x20`--with-update`\x20flag,\
    \x20to\x20`zypper\x20patch`.\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xf9\
    \x03\x02\x06\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xf9\x03\x07\x12\n\r\n\
    \x05\x04\x0e\x02\x01\x03\x12\x04\xf9\x03\x15\x16\nz\n\x04\x04\x0e\x02\
    \x02\x12\x04\xfd\x03\x02!\x1al\x20Install\x20only\x20patches\x20with\x20\
    these\x20categories.\n\x20Common\x20categories\x20include\x20security,\
    \x20recommended,\x20and\x20feature.\n\n\r\n\x05\x04\x0e\x02\x02\x04\x12\
    \x04\xfd\x03\x02\n\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xfd\x03\x0b\x11\
    \n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xfd\x03\x12\x1c\n\r\n\x05\x04\x0e\
    \x02\x02\x03\x12\x04\xfd\x03\x1f\x20\n~\n\x04\x04\x0e\x02\x03\x12\x04\
    \x81\x04\x02!\x1ap\x20Install\x20only\x20patches\x20with\x20these\x20sev\
    erities.\n\x20Common\x20severities\x20include\x20critical,\x20important,\
    \x20moderate,\x20and\x20low.\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\x81\
    \x04\x02\n\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\x81\x04\x0b\x11\n\r\n\
    \x05\x04\x0e\x02\x03\x01\x12\x04\x81\x04\x12\x1c\n\r\n\x05\x04\x0e\x02\
    \x03\x03\x12\x04\x81\x04\x1f\x20\n7\n\x04\x04\x0e\x02\x04\x12\x04\x84\
    \x04\x02\x1f\x1a)\x20List\x20of\x20patches\x20to\x20exclude\x20from\x20u\
    pdate.\n\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\x84\x04\x02\n\n\r\n\x05\
    \x04\x0e\x02\x04\x05\x12\x04\x84\x04\x0b\x11\n\r\n\x05\x04\x0e\x02\x04\
    \x01\x12\x04\x84\x04\x12\x1a\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x84\
    \x04\x1d\x1e\n\xe8\x01\n\x04\x04\x0e\x02\x05\x12\x04\x89\x04\x02(\x1a\
    \xd9\x01\x20An\x20exclusive\x20list\x20of\x20patches\x20to\x20be\x20upda\
    ted.\x20These\x20are\x20the\x20only\x20patches\n\x20that\x20will\x20be\
    \x20installed\x20using\x20'zypper\x20patch\x20patch:<patch_name>'\x20com\
    mand.\n\x20This\x20field\x20must\x20not\x20be\x20used\x20with\x20any\x20\
    other\x20patch\x20configuration\x20fields.\n\n\r\n\x05\x04\x0e\x02\x05\
    \x04\x12\x04\x89\x04\x02\n\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\x89\x04\
    \x0b\x11\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\x89\x04\x12#\n\r\n\x05\
    \x04\x0e\x02\x05\x03\x12\x04\x89\x04&'\nM\n\x02\x04\x0f\x12\x06\x8d\x04\
    \0\xcd\x04\x01\x1a?\x20Windows\x20patching\x20is\x20performed\x20using\
    \x20the\x20Windows\x20Update\x20Agent.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \x8d\x04\x08\x1d\n\xc6\x01\n\x04\x04\x0f\x04\0\x12\x06\x91\x04\x02\xc0\
    \x04\x03\x1a\xb5\x01\x20Microsoft\x20Windows\x20update\x20classification\
    s\x20as\x20defined\x20in\n\x20[1]\n\x20https://support.microsoft.com/en-\
    us/help/824684/description-of-the-standard-terminology-that-is-used-to-d\
    escribe-micro\n\n\r\n\x05\x04\x0f\x04\0\x01\x12\x04\x91\x04\x07\x15\nS\n\
    \x06\x04\x0f\x04\0\x02\0\x12\x04\x93\x04\x04#\x1aC\x20Invalid.\x20If\x20\
    classifications\x20are\x20included,\x20they\x20must\x20be\x20specified.\
    \n\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x01\x12\x04\x93\x04\x04\x1e\n\x0f\n\
    \x07\x04\x0f\x04\0\x02\0\x02\x12\x04\x93\x04!\"\nz\n\x06\x04\x0f\x04\0\
    \x02\x01\x12\x04\x97\x04\x04\x11\x1aj\x20\"A\x20widely\x20released\x20fi\
    x\x20for\x20a\x20specific\x20problem\x20that\x20addresses\x20a\x20critic\
    al,\n\x20non-security-related\x20bug.\"\x20[1]\n\n\x0f\n\x07\x04\x0f\x04\
    \0\x02\x01\x01\x12\x04\x97\x04\x04\x0c\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\
    \x02\x12\x04\x97\x04\x0f\x10\n\x8d\x02\n\x06\x04\x0f\x04\0\x02\x02\x12\
    \x04\x9d\x04\x04\x11\x1a\xfc\x01\x20\"A\x20widely\x20released\x20fix\x20\
    for\x20a\x20product-specific,\x20security-related\n\x20vulnerability.\
    \x20Security\x20vulnerabilities\x20are\x20rated\x20by\x20their\x20severi\
    ty.\x20The\n\x20severity\x20rating\x20is\x20indicated\x20in\x20the\x20Mi\
    crosoft\x20security\x20bulletin\x20as\n\x20critical,\x20important,\x20mo\
    derate,\x20or\x20low.\"\x20[1]\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x01\
    \x12\x04\x9d\x04\x04\x0c\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x02\x12\x04\
    \x9d\x04\x0f\x10\n\x94\x02\n\x06\x04\x0f\x04\0\x02\x03\x12\x04\xa3\x04\
    \x04\x13\x1a\x83\x02\x20\"A\x20widely\x20released\x20and\x20frequent\x20\
    software\x20update\x20that\x20contains\x20additions\n\x20to\x20a\x20prod\
    uct's\x20definition\x20database.\x20Definition\x20databases\x20are\x20of\
    ten\x20used\n\x20to\x20detect\x20objects\x20that\x20have\x20specific\x20\
    attributes,\x20such\x20as\x20malicious\x20code,\n\x20phishing\x20website\
    s,\x20or\x20junk\x20mail.\"\x20[1]\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\
    \x01\x12\x04\xa3\x04\x04\x0e\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\x02\x12\
    \x04\xa3\x04\x11\x12\nP\n\x06\x04\x0f\x04\0\x02\x04\x12\x04\xa6\x04\x04\
    \x0f\x1a@\x20\"Software\x20that\x20controls\x20the\x20input\x20and\x20ou\
    tput\x20of\x20a\x20device.\"\x20[1]\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x04\
    \x01\x12\x04\xa6\x04\x04\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x04\x02\x12\x04\
    \xa6\x04\r\x0e\n\xb8\x01\n\x06\x04\x0f\x04\0\x02\x05\x12\x04\xab\x04\x04\
    \x15\x1a\xa7\x01\x20\"New\x20product\x20functionality\x20that\x20is\x20f\
    irst\x20distributed\x20outside\x20the\x20context\n\x20of\x20a\x20product\
    \x20release\x20and\x20that\x20is\x20typically\x20included\x20in\x20the\
    \x20next\x20full\n\x20product\x20release.\"\x20[1]\n\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\x05\x01\x12\x04\xab\x04\x04\x10\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x05\x02\x12\x04\xab\x04\x13\x14\n\xda\x02\n\x06\x04\x0f\x04\0\x02\x06\
    \x12\x04\xb2\x04\x04\x15\x1a\xc9\x02\x20\"A\x20tested,\x20cumulative\x20\
    set\x20of\x20all\x20hotfixes,\x20security\x20updates,\x20critical\n\x20u\
    pdates,\x20and\x20updates.\x20Additionally,\x20service\x20packs\x20may\
    \x20contain\x20additional\n\x20fixes\x20for\x20problems\x20that\x20are\
    \x20found\x20internally\x20since\x20the\x20release\x20of\x20the\n\x20pro\
    duct.\x20Service\x20packs\x20my\x20also\x20contain\x20a\x20limited\x20nu\
    mber\x20of\n\x20customer-requested\x20design\x20changes\x20or\x20feature\
    s.\"\x20[1]\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x06\x01\x12\x04\xb2\x04\x04\
    \x10\n\x0f\n\x07\x04\x0f\x04\0\x02\x06\x02\x12\x04\xb2\x04\x13\x14\nX\n\
    \x06\x04\x0f\x04\0\x02\x07\x12\x04\xb5\x04\x04\r\x1aH\x20\"A\x20utility\
    \x20or\x20feature\x20that\x20helps\x20complete\x20a\x20task\x20or\x20set\
    \x20of\x20tasks.\"\x20[1]\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x07\x01\x12\
    \x04\xb5\x04\x04\x08\n\x0f\n\x07\x04\x0f\x04\0\x02\x07\x02\x12\x04\xb5\
    \x04\x0b\x0c\n\xa9\x02\n\x06\x04\x0f\x04\0\x02\x08\x12\x04\xbb\x04\x04\
    \x16\x1a\x98\x02\x20\"A\x20tested,\x20cumulative\x20set\x20of\x20hotfixe\
    s,\x20security\x20updates,\x20critical\n\x20updates,\x20and\x20updates\
    \x20that\x20are\x20packaged\x20together\x20for\x20easy\x20deployment.\
    \x20A\n\x20rollup\x20generally\x20targets\x20a\x20specific\x20area,\x20s\
    uch\x20as\x20security,\x20or\x20a\n\x20component\x20of\x20a\x20product,\
    \x20such\x20as\x20Internet\x20Information\x20Services\x20(IIS).\"\x20[1]\
    \n\n\x0f\n\x07\x04\x0f\x04\0\x02\x08\x01\x12\x04\xbb\x04\x04\x11\n\x0f\n\
    \x07\x04\x0f\x04\0\x02\x08\x02\x12\x04\xbb\x04\x14\x15\n\x83\x01\n\x06\
    \x04\x0f\x04\0\x02\t\x12\x04\xbf\x04\x04\x0f\x1as\x20\"A\x20widely\x20re\
    leased\x20fix\x20for\x20a\x20specific\x20problem.\x20An\x20update\x20add\
    resses\x20a\n\x20noncritical,\x20non-security-related\x20bug.\"\x20[1]\n\
    \n\x0f\n\x07\x04\x0f\x04\0\x02\t\x01\x12\x04\xbf\x04\x04\n\n\x0f\n\x07\
    \x04\x0f\x04\0\x02\t\x02\x12\x04\xbf\x04\r\x0e\no\n\x04\x04\x0f\x02\0\
    \x12\x04\xc4\x04\x02.\x1aa\x20Only\x20apply\x20updates\x20of\x20these\
    \x20windows\x20update\x20classifications.\x20If\x20empty,\x20all\n\x20up\
    dates\x20are\x20applied.\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xc4\x04\
    \x02\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xc4\x04\x0b\x19\n\r\n\x05\x04\
    \x0f\x02\0\x01\x12\x04\xc4\x04\x1a)\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \xc4\x04,-\n3\n\x04\x04\x0f\x02\x01\x12\x04\xc7\x04\x02\x1f\x1a%\x20List\
    \x20of\x20KBs\x20to\x20exclude\x20from\x20update.\n\n\r\n\x05\x04\x0f\
    \x02\x01\x04\x12\x04\xc7\x04\x02\n\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\
    \xc7\x04\x0b\x11\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xc7\x04\x12\x1a\n\
    \r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xc7\x04\x1d\x1e\n\xa8\x01\n\x04\x04\
    \x0f\x02\x02\x12\x04\xcc\x04\x02(\x1a\x99\x01\x20An\x20exclusive\x20list\
    \x20of\x20kbs\x20to\x20be\x20updated.\x20These\x20are\x20the\x20only\x20\
    patches\n\x20that\x20will\x20be\x20updated.\x20This\x20field\x20must\x20\
    not\x20be\x20used\x20with\x20other\n\x20patch\x20configurations.\n\n\r\n\
    \x05\x04\x0f\x02\x02\x04\x12\x04\xcc\x04\x02\n\n\r\n\x05\x04\x0f\x02\x02\
    \x05\x12\x04\xcc\x04\x0b\x11\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xcc\
    \x04\x12#\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xcc\x04&'\n>\n\x02\x04\
    \x10\x12\x06\xd0\x04\0\xd6\x04\x01\x1a0\x20A\x20step\x20that\x20runs\x20\
    an\x20executable\x20for\x20a\x20PatchJob.\n\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\xd0\x04\x08\x10\nN\n\x04\x04\x10\x02\0\x12\x04\xd2\x04\x02,\x1a@\
    \x20The\x20ExecStepConfig\x20for\x20all\x20Linux\x20VMs\x20targeted\x20b\
    y\x20the\x20PatchJob.\n\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xd2\x04\x02\
    \x10\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xd2\x04\x11'\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xd2\x04*+\nP\n\x04\x04\x10\x02\x01\x12\x04\xd5\x04\
    \x02.\x1aB\x20The\x20ExecStepConfig\x20for\x20all\x20Windows\x20VMs\x20t\
    argeted\x20by\x20the\x20PatchJob.\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\
    \x04\xd5\x04\x02\x10\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xd5\x04\x11)\
    \n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd5\x04,-\n6\n\x02\x04\x11\x12\
    \x06\xd9\x04\0\xfc\x04\x01\x1a(\x20Common\x20configurations\x20for\x20an\
    \x20ExecStep.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xd9\x04\x08\x16\n=\n\x04\
    \x04\x11\x04\0\x12\x06\xdb\x04\x02\xe8\x04\x03\x1a-\x20The\x20interprete\
    r\x20used\x20to\x20execute\x20the\x20a\x20file.\n\n\r\n\x05\x04\x11\x04\
    \0\x01\x12\x04\xdb\x04\x07\x12\n\xa9\x01\n\x06\x04\x11\x04\0\x02\0\x12\
    \x04\xdf\x04\x04\x20\x1a\x98\x01\x20Invalid\x20for\x20a\x20Windows\x20Ex\
    ecStepConfig.\x20For\x20a\x20Linux\x20ExecStepConfig,\x20the\n\x20interp\
    reter\x20will\x20be\x20parsed\x20from\x20the\x20shebang\x20line\x20of\
    \x20the\x20script\x20if\n\x20unspecified.\n\n\x0f\n\x07\x04\x11\x04\0\
    \x02\0\x01\x12\x04\xdf\x04\x04\x1b\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\
    \x12\x04\xdf\x04\x1e\x1f\na\n\x06\x04\x11\x04\0\x02\x01\x12\x04\xe3\x04\
    \x04\x0e\x1aQ\x20Indicates\x20that\x20the\x20script\x20is\x20run\x20with\
    \x20`/bin/sh`\x20on\x20Linux\x20and\x20`cmd`\n\x20on\x20Windows.\n\n\x0f\
    \n\x07\x04\x11\x04\0\x02\x01\x01\x12\x04\xe3\x04\x04\t\n\x0f\n\x07\x04\
    \x11\x04\0\x02\x01\x02\x12\x04\xe3\x04\x0c\r\n\x87\x01\n\x06\x04\x11\x04\
    \0\x02\x02\x12\x04\xe7\x04\x04\x13\x1aw\x20Indicates\x20that\x20the\x20f\
    ile\x20is\x20run\x20with\x20PowerShell\x20flags\n\x20`-NonInteractive`,\
    \x20`-NoProfile`,\x20and\x20`-ExecutionPolicy\x20Bypass`.\n\n\x0f\n\x07\
    \x04\x11\x04\0\x02\x02\x01\x12\x04\xe7\x04\x04\x0e\n\x0f\n\x07\x04\x11\
    \x04\0\x02\x02\x02\x12\x04\xe7\x04\x11\x12\n-\n\x04\x04\x11\x08\0\x12\
    \x06\xeb\x04\x02\xf1\x04\x03\x1a\x1d\x20Location\x20of\x20the\x20executa\
    ble.\n\n\r\n\x05\x04\x11\x08\0\x01\x12\x04\xeb\x04\x08\x12\n=\n\x04\x04\
    \x11\x02\0\x12\x04\xed\x04\x04\x1a\x1a/\x20An\x20absolute\x20path\x20to\
    \x20the\x20executable\x20on\x20the\x20VM.\n\n\r\n\x05\x04\x11\x02\0\x05\
    \x12\x04\xed\x04\x04\n\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xed\x04\x0b\
    \x15\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xed\x04\x18\x19\nA\n\x04\x04\
    \x11\x02\x01\x12\x04\xf0\x04\x04\x1d\x1a3\x20A\x20Cloud\x20Storage\x20ob\
    ject\x20containing\x20the\x20executable.\n\n\r\n\x05\x04\x11\x02\x01\x06\
    \x12\x04\xf0\x04\x04\r\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xf0\x04\x0e\
    \x18\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xf0\x04\x1b\x1c\nw\n\x04\x04\
    \x11\x02\x02\x12\x04\xf5\x04\x02+\x1ai\x20Defaults\x20to\x20[0].\x20A\
    \x20list\x20of\x20possible\x20return\x20values\x20that\x20the\n\x20execu\
    tion\x20can\x20return\x20to\x20indicate\x20a\x20success.\n\n\r\n\x05\x04\
    \x11\x02\x02\x04\x12\x04\xf5\x04\x02\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\
    \x04\xf5\x04\x0b\x10\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xf5\x04\x11&\
    \n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xf5\x04)*\n\xfb\x01\n\x04\x04\x11\
    \x02\x03\x12\x04\xfb\x04\x02\x1e\x1a\xec\x01\x20The\x20script\x20interpr\
    eter\x20to\x20use\x20to\x20run\x20the\x20script.\x20If\x20no\x20interpre\
    ter\x20is\n\x20specified\x20the\x20script\x20will\x20be\x20executed\x20d\
    irectly,\x20which\x20will\x20likely\n\x20only\x20succeed\x20for\x20scrip\
    ts\x20with\x20[shebang\x20lines]\n\x20(https://en.wikipedia.org/wiki/She\
    bang_\\(Unix\\)).\n\n\r\n\x05\x04\x11\x02\x03\x06\x12\x04\xfb\x04\x02\r\
    \n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xfb\x04\x0e\x19\n\r\n\x05\x04\x11\
    \x02\x03\x03\x12\x04\xfb\x04\x1c\x1d\n4\n\x02\x04\x12\x12\x06\xff\x04\0\
    \x89\x05\x01\x1a&\x20Cloud\x20Storage\x20object\x20representation.\n\n\
    \x0b\n\x03\x04\x12\x01\x12\x04\xff\x04\x08\x11\n=\n\x04\x04\x12\x02\0\
    \x12\x04\x81\x05\x02=\x1a/\x20Required.\x20Bucket\x20of\x20the\x20Cloud\
    \x20Storage\x20object.\n\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x81\x05\x02\
    \x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x81\x05\t\x0f\n\r\n\x05\x04\x12\
    \x02\0\x03\x12\x04\x81\x05\x12\x13\n\r\n\x05\x04\x12\x02\0\x08\x12\x04\
    \x81\x05\x14<\n\x10\n\x08\x04\x12\x02\0\x08\x9c\x08\0\x12\x04\x81\x05\
    \x15;\n;\n\x04\x04\x12\x02\x01\x12\x04\x84\x05\x02=\x1a-\x20Required.\
    \x20Name\x20of\x20the\x20Cloud\x20Storage\x20object.\n\n\r\n\x05\x04\x12\
    \x02\x01\x05\x12\x04\x84\x05\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\
    \x04\x84\x05\t\x0f\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\x84\x05\x12\x13\
    \n\r\n\x05\x04\x12\x02\x01\x08\x12\x04\x84\x05\x14<\n\x10\n\x08\x04\x12\
    \x02\x01\x08\x9c\x08\0\x12\x04\x84\x05\x15;\n\x9f\x01\n\x04\x04\x12\x02\
    \x02\x12\x04\x88\x05\x02G\x1a\x90\x01\x20Required.\x20Generation\x20numb\
    er\x20of\x20the\x20Cloud\x20Storage\x20object.\x20This\x20is\x20used\x20\
    to\n\x20ensure\x20that\x20the\x20ExecStep\x20specified\x20by\x20this\x20\
    PatchJob\x20does\x20not\x20change.\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\
    \x04\x88\x05\x02\x07\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x88\x05\x08\
    \x19\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\x88\x05\x1c\x1d\n\r\n\x05\x04\
    \x12\x02\x02\x08\x12\x04\x88\x05\x1eF\n\x10\n\x08\x04\x12\x02\x02\x08\
    \x9c\x08\0\x12\x04\x88\x05\x1fE\n\xe4\x01\n\x02\x04\x13\x12\x06\x8f\x05\
    \0\xb4\x05\x01\x1a\xd5\x01\x20A\x20filter\x20to\x20target\x20VM\x20insta\
    nces\x20for\x20patching.\x20The\x20targeted\n\x20VMs\x20must\x20meet\x20\
    all\x20criteria\x20specified.\x20So\x20if\x20both\x20labels\x20and\x20zo\
    nes\x20are\n\x20specified,\x20the\x20patch\x20job\x20targets\x20only\x20\
    VMs\x20with\x20those\x20labels\x20and\x20in\x20those\n\x20zones.\n\n\x0b\
    \n\x03\x04\x13\x01\x12\x04\x8f\x05\x08\x1b\n\xd8\x03\n\x04\x04\x13\x03\0\
    \x12\x06\x98\x05\x02\x9c\x05\x03\x1a\xc7\x03\x20Targets\x20a\x20group\
    \x20of\x20VM\x20instances\x20by\x20using\x20their\x20[assigned\n\x20labe\
    ls](https://cloud.google.com/compute/docs/labeling-resources).\x20Labels\
    \n\x20are\x20key-value\x20pairs.\x20A\x20`GroupLabel`\x20is\x20a\x20comb\
    ination\x20of\x20labels\n\x20that\x20is\x20used\x20to\x20target\x20VMs\
    \x20for\x20a\x20patch\x20job.\n\n\x20For\x20example,\x20a\x20patch\x20jo\
    b\x20can\x20target\x20VMs\x20that\x20have\x20the\x20following\n\x20`Grou\
    pLabel`:\x20`{\"env\":\"test\",\x20\"app\":\"web\"}`.\x20This\x20means\
    \x20that\x20the\x20patch\x20job\n\x20is\x20applied\x20to\x20VMs\x20that\
    \x20have\x20both\x20the\x20labels\x20`env=test`\x20and\x20`app=web`.\n\n\
    \r\n\x05\x04\x13\x03\0\x01\x12\x04\x98\x05\n\x14\nw\n\x06\x04\x13\x03\0\
    \x02\0\x12\x04\x9b\x05\x04#\x1ag\x20Compute\x20Engine\x20instance\x20lab\
    els\x20that\x20must\x20be\x20present\x20for\x20a\x20VM\n\x20instance\x20\
    to\x20be\x20targeted\x20by\x20this\x20filter.\n\n\x0f\n\x07\x04\x13\x03\
    \0\x02\0\x06\x12\x04\x9b\x05\x04\x17\n\x0f\n\x07\x04\x13\x03\0\x02\0\x01\
    \x12\x04\x9b\x05\x18\x1e\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\x9b\
    \x05!\"\na\n\x04\x04\x13\x02\0\x12\x04\xa0\x05\x02\x0f\x1aS\x20Target\
    \x20all\x20VM\x20instances\x20in\x20the\x20project.\x20If\x20true,\x20no\
    \x20other\x20criteria\x20is\n\x20permitted.\n\n\r\n\x05\x04\x13\x02\0\
    \x05\x12\x04\xa0\x05\x02\x06\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xa0\x05\
    \x07\n\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xa0\x05\r\x0e\n\x83\x01\n\x04\
    \x04\x13\x02\x01\x12\x04\xa4\x05\x02'\x1au\x20Targets\x20VM\x20instances\
    \x20matching\x20ANY\x20of\x20these\x20GroupLabels.\x20This\x20allows\n\
    \x20targeting\x20of\x20disparate\x20groups\x20of\x20VM\x20instances.\n\n\
    \r\n\x05\x04\x13\x02\x01\x04\x12\x04\xa4\x05\x02\n\n\r\n\x05\x04\x13\x02\
    \x01\x06\x12\x04\xa4\x05\x0b\x15\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\
    \xa4\x05\x16\"\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xa4\x05%&\nl\n\x04\
    \x04\x13\x02\x02\x12\x04\xa8\x05\x02\x1c\x1a^\x20Targets\x20VM\x20instan\
    ces\x20in\x20ANY\x20of\x20these\x20zones.\x20Leave\x20empty\x20to\x20tar\
    get\x20VM\n\x20instances\x20in\x20any\x20zone.\n\n\r\n\x05\x04\x13\x02\
    \x02\x04\x12\x04\xa8\x05\x02\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xa8\
    \x05\x0b\x11\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xa8\x05\x12\x17\n\r\n\
    \x05\x04\x13\x02\x02\x03\x12\x04\xa8\x05\x1a\x1b\n\xc1\x02\n\x04\x04\x13\
    \x02\x03\x12\x04\xae\x05\x02\x20\x1a\xb2\x02\x20Targets\x20any\x20of\x20\
    the\x20VM\x20instances\x20specified.\x20Instances\x20are\x20specified\
    \x20by\x20their\n\x20URI\x20in\x20the\x20form\x20`zones/[ZONE]/instances\
    /[INSTANCE_NAME]`,\n\x20`projects/[PROJECT_ID]/zones/[ZONE]/instances/[I\
    NSTANCE_NAME]`,\x20or\n\x20`https://www.googleapis.com/compute/v1/projec\
    ts/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`\n\n\r\n\x05\x04\
    \x13\x02\x03\x04\x12\x04\xae\x05\x02\n\n\r\n\x05\x04\x13\x02\x03\x05\x12\
    \x04\xae\x05\x0b\x11\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xae\x05\x12\
    \x1b\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xae\x05\x1e\x1f\n\xb4\x01\n\
    \x04\x04\x13\x02\x04\x12\x04\xb3\x05\x02-\x1a\xa5\x01\x20Targets\x20VMs\
    \x20whose\x20name\x20starts\x20with\x20one\x20of\x20these\x20prefixes.\
    \x20Similar\x20to\n\x20labels,\x20this\x20is\x20another\x20way\x20to\x20\
    group\x20VMs\x20when\x20targeting\x20configs,\x20for\n\x20example\x20pre\
    fix=\"prod-\".\n\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\xb3\x05\x02\n\n\r\
    \n\x05\x04\x13\x02\x04\x05\x12\x04\xb3\x05\x0b\x11\n\r\n\x05\x04\x13\x02\
    \x04\x01\x12\x04\xb3\x05\x12(\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xb3\
    \x05+,\n\x96\x01\n\x02\x04\x14\x12\x06\xb8\x05\0\xe5\x05\x01\x1a\x87\x01\
    \x20Patch\x20rollout\x20configuration\x20specifications.\x20Contains\x20\
    details\x20on\x20the\n\x20concurrency\x20control\x20when\x20applying\x20\
    patch(es)\x20to\x20all\x20targeted\x20VMs.\n\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\xb8\x05\x08\x14\n&\n\x04\x04\x14\x04\0\x12\x06\xba\x05\x02\xc8\x05\
    \x03\x1a\x16\x20Type\x20of\x20the\x20rollout.\n\n\r\n\x05\x04\x14\x04\0\
    \x01\x12\x04\xba\x05\x07\x0b\n)\n\x06\x04\x14\x04\0\x02\0\x12\x04\xbc\
    \x05\x04\x19\x1a\x19\x20Mode\x20must\x20be\x20specified.\n\n\x0f\n\x07\
    \x04\x14\x04\0\x02\0\x01\x12\x04\xbc\x05\x04\x14\n\x0f\n\x07\x04\x14\x04\
    \0\x02\0\x02\x12\x04\xbc\x05\x17\x18\n\x87\x03\n\x06\x04\x14\x04\0\x02\
    \x01\x12\x04\xc4\x05\x04\x15\x1a\xf6\x02\x20Patches\x20are\x20applied\
    \x20one\x20zone\x20at\x20a\x20time.\x20The\x20patch\x20job\x20begins\x20\
    in\x20the\n\x20region\x20with\x20the\x20lowest\x20number\x20of\x20target\
    ed\x20VMs.\x20Within\x20the\x20region,\n\x20patching\x20begins\x20in\x20\
    the\x20zone\x20with\x20the\x20lowest\x20number\x20of\x20targeted\x20VMs.\
    \x20If\n\x20multiple\x20regions\x20(or\x20zones\x20within\x20a\x20region\
    )\x20have\x20the\x20same\x20number\x20of\n\x20targeted\x20VMs,\x20a\x20t\
    ie-breaker\x20is\x20achieved\x20by\x20sorting\x20the\x20regions\x20or\
    \x20zones\n\x20in\x20alphabetical\x20order.\n\n\x0f\n\x07\x04\x14\x04\0\
    \x02\x01\x01\x12\x04\xc4\x05\x04\x10\n\x0f\n\x07\x04\x14\x04\0\x02\x01\
    \x02\x12\x04\xc4\x05\x13\x14\nK\n\x06\x04\x14\x04\0\x02\x02\x12\x04\xc7\
    \x05\x04\x19\x1a;\x20Patches\x20are\x20applied\x20to\x20VMs\x20in\x20all\
    \x20zones\x20at\x20the\x20same\x20time.\n\n\x0f\n\x07\x04\x14\x04\0\x02\
    \x02\x01\x12\x04\xc7\x05\x04\x14\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x02\
    \x12\x04\xc7\x05\x17\x18\n*\n\x04\x04\x14\x02\0\x12\x04\xcb\x05\x02\x10\
    \x1a\x1c\x20Mode\x20of\x20the\x20patch\x20rollout.\n\n\r\n\x05\x04\x14\
    \x02\0\x06\x12\x04\xcb\x05\x02\x06\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\
    \xcb\x05\x07\x0b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xcb\x05\x0e\x0f\n\
    \x91\n\n\x04\x04\x14\x02\x01\x12\x04\xe4\x05\x02'\x1a\x82\n\x20The\x20ma\
    ximum\x20number\x20(or\x20percentage)\x20of\x20VMs\x20per\x20zone\x20to\
    \x20disrupt\x20at\x20any\x20given\n\x20moment.\x20The\x20number\x20of\
    \x20VMs\x20calculated\x20from\x20multiplying\x20the\x20percentage\x20by\
    \x20the\n\x20total\x20number\x20of\x20VMs\x20in\x20a\x20zone\x20is\x20ro\
    unded\x20up.\n\n\x20During\x20patching,\x20a\x20VM\x20is\x20considered\
    \x20disrupted\x20from\x20the\x20time\x20the\x20agent\x20is\n\x20notified\
    \x20to\x20begin\x20until\x20patching\x20has\x20completed.\x20This\x20dis\
    ruption\x20time\n\x20includes\x20the\x20time\x20to\x20complete\x20reboot\
    \x20and\x20any\x20post-patch\x20steps.\n\n\x20A\x20VM\x20contributes\x20\
    to\x20the\x20disruption\x20budget\x20if\x20its\x20patching\x20operation\
    \x20fails\n\x20either\x20when\x20applying\x20the\x20patches,\x20running\
    \x20pre\x20or\x20post\x20patch\x20steps,\x20or\x20if\x20it\n\x20fails\
    \x20to\x20respond\x20with\x20a\x20success\x20notification\x20before\x20t\
    iming\x20out.\x20VMs\x20that\n\x20are\x20not\x20running\x20or\x20do\x20n\
    ot\x20have\x20an\x20active\x20agent\x20do\x20not\x20count\x20toward\x20t\
    his\n\x20disruption\x20budget.\n\n\x20For\x20zone-by-zone\x20rollouts,\
    \x20if\x20the\x20disruption\x20budget\x20in\x20a\x20zone\x20is\x20exceed\
    ed,\n\x20the\x20patch\x20job\x20stops,\x20because\x20continuing\x20to\
    \x20the\x20next\x20zone\x20requires\n\x20completion\x20of\x20the\x20patc\
    h\x20process\x20in\x20the\x20previous\x20zone.\n\n\x20For\x20example,\
    \x20if\x20the\x20disruption\x20budget\x20has\x20a\x20fixed\x20value\x20o\
    f\x20`10`,\x20and\x208\x20VMs\n\x20fail\x20to\x20patch\x20in\x20the\x20c\
    urrent\x20zone,\x20the\x20patch\x20job\x20continues\x20to\x20patch\x202\
    \x20VMs\n\x20at\x20a\x20time\x20until\x20the\x20zone\x20is\x20completed.\
    \x20When\x20that\x20zone\x20is\x20completed\n\x20successfully,\x20patchi\
    ng\x20begins\x20with\x2010\x20VMs\x20at\x20a\x20time\x20in\x20the\x20nex\
    t\x20zone.\x20If\x2010\n\x20VMs\x20in\x20the\x20next\x20zone\x20fail\x20\
    to\x20patch,\x20the\x20patch\x20job\x20stops.\n\n\r\n\x05\x04\x14\x02\
    \x01\x06\x12\x04\xe4\x05\x02\x10\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\
    \xe4\x05\x11\"\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xe4\x05%&b\x06proto\
    3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
