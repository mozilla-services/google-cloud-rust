// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1/os_policy.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy {
    // message fields
    pub id: ::std::string::String,
    pub description: ::std::string::String,
    pub mode: OSPolicy_Mode,
    pub resource_groups: ::protobuf::RepeatedField<OSPolicy_ResourceGroup>,
    pub allow_no_resource_group_match: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy {
    fn default() -> &'a OSPolicy {
        <OSPolicy as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy {
    pub fn new() -> OSPolicy {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.OSPolicy.Mode mode = 3;


    pub fn get_mode(&self) -> OSPolicy_Mode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = OSPolicy_Mode::MODE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: OSPolicy_Mode) {
        self.mode = v;
    }

    // repeated .google.cloud.osconfig.v1.OSPolicy.ResourceGroup resource_groups = 4;


    pub fn get_resource_groups(&self) -> &[OSPolicy_ResourceGroup] {
        &self.resource_groups
    }
    pub fn clear_resource_groups(&mut self) {
        self.resource_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_groups(&mut self, v: ::protobuf::RepeatedField<OSPolicy_ResourceGroup>) {
        self.resource_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_groups(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicy_ResourceGroup> {
        &mut self.resource_groups
    }

    // Take field
    pub fn take_resource_groups(&mut self) -> ::protobuf::RepeatedField<OSPolicy_ResourceGroup> {
        ::std::mem::replace(&mut self.resource_groups, ::protobuf::RepeatedField::new())
    }

    // bool allow_no_resource_group_match = 5;


    pub fn get_allow_no_resource_group_match(&self) -> bool {
        self.allow_no_resource_group_match
    }
    pub fn clear_allow_no_resource_group_match(&mut self) {
        self.allow_no_resource_group_match = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_no_resource_group_match(&mut self, v: bool) {
        self.allow_no_resource_group_match = v;
    }
}

impl ::protobuf::Message for OSPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resource_groups)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_no_resource_group_match = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.mode != OSPolicy_Mode::MODE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.mode);
        }
        for value in &self.resource_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.allow_no_resource_group_match != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.mode != OSPolicy_Mode::MODE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        for v in &self.resource_groups {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.allow_no_resource_group_match != false {
            os.write_bool(5, self.allow_no_resource_group_match)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy {
        OSPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &OSPolicy| { &m.id },
                |m: &mut OSPolicy| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &OSPolicy| { &m.description },
                |m: &mut OSPolicy| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicy_Mode>>(
                "mode",
                |m: &OSPolicy| { &m.mode },
                |m: &mut OSPolicy| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_ResourceGroup>>(
                "resource_groups",
                |m: &OSPolicy| { &m.resource_groups },
                |m: &mut OSPolicy| { &mut m.resource_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_no_resource_group_match",
                |m: &OSPolicy| { &m.allow_no_resource_group_match },
                |m: &mut OSPolicy| { &mut m.allow_no_resource_group_match },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy>(
                "OSPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy {
        static instance: ::protobuf::rt::LazyV2<OSPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy::new)
    }
}

impl ::protobuf::Clear for OSPolicy {
    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.mode = OSPolicy_Mode::MODE_UNSPECIFIED;
        self.resource_groups.clear();
        self.allow_no_resource_group_match = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_InventoryFilter {
    // message fields
    pub os_short_name: ::std::string::String,
    pub os_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_InventoryFilter {
    fn default() -> &'a OSPolicy_InventoryFilter {
        <OSPolicy_InventoryFilter as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_InventoryFilter {
    pub fn new() -> OSPolicy_InventoryFilter {
        ::std::default::Default::default()
    }

    // string os_short_name = 1;


    pub fn get_os_short_name(&self) -> &str {
        &self.os_short_name
    }
    pub fn clear_os_short_name(&mut self) {
        self.os_short_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_short_name(&mut self, v: ::std::string::String) {
        self.os_short_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_short_name(&mut self) -> &mut ::std::string::String {
        &mut self.os_short_name
    }

    // Take field
    pub fn take_os_short_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_short_name, ::std::string::String::new())
    }

    // string os_version = 2;


    pub fn get_os_version(&self) -> &str {
        &self.os_version
    }
    pub fn clear_os_version(&mut self) {
        self.os_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_version(&mut self, v: ::std::string::String) {
        self.os_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version(&mut self) -> &mut ::std::string::String {
        &mut self.os_version
    }

    // Take field
    pub fn take_os_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_InventoryFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_short_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.os_short_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os_short_name);
        }
        if !self.os_version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.os_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.os_short_name.is_empty() {
            os.write_string(1, &self.os_short_name)?;
        }
        if !self.os_version.is_empty() {
            os.write_string(2, &self.os_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_InventoryFilter {
        OSPolicy_InventoryFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_short_name",
                |m: &OSPolicy_InventoryFilter| { &m.os_short_name },
                |m: &mut OSPolicy_InventoryFilter| { &mut m.os_short_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_version",
                |m: &OSPolicy_InventoryFilter| { &m.os_version },
                |m: &mut OSPolicy_InventoryFilter| { &mut m.os_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_InventoryFilter>(
                "OSPolicy.InventoryFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_InventoryFilter {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_InventoryFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_InventoryFilter::new)
    }
}

impl ::protobuf::Clear for OSPolicy_InventoryFilter {
    fn clear(&mut self) {
        self.os_short_name.clear();
        self.os_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_InventoryFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_InventoryFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource {
    // message fields
    pub id: ::std::string::String,
    // message oneof groups
    pub resource_type: ::std::option::Option<OSPolicy_Resource_oneof_resource_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource {
    fn default() -> &'a OSPolicy_Resource {
        <OSPolicy_Resource as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OSPolicy_Resource_oneof_resource_type {
    pkg(OSPolicy_Resource_PackageResource),
    repository(OSPolicy_Resource_RepositoryResource),
    exec(OSPolicy_Resource_ExecResource),
    file(OSPolicy_Resource_FileResource),
}

impl OSPolicy_Resource {
    pub fn new() -> OSPolicy_Resource {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource pkg = 2;


    pub fn get_pkg(&self) -> &OSPolicy_Resource_PackageResource {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pkg(&mut self) {
        self.resource_type = ::std::option::Option::None;
    }

    pub fn has_pkg(&self) -> bool {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pkg(&mut self, v: OSPolicy_Resource_PackageResource) {
        self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pkg(&mut self) -> &mut OSPolicy_Resource_PackageResource {
        if let ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(_)) = self.resource_type {
        } else {
            self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(OSPolicy_Resource_PackageResource::new()));
        }
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pkg(&mut self) -> OSPolicy_Resource_PackageResource {
        if self.has_pkg() {
            match self.resource_type.take() {
                ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource repository = 3;


    pub fn get_repository(&self) -> &OSPolicy_Resource_RepositoryResource {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(ref v)) => v,
            _ => <OSPolicy_Resource_RepositoryResource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_repository(&mut self) {
        self.resource_type = ::std::option::Option::None;
    }

    pub fn has_repository(&self) -> bool {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_repository(&mut self, v: OSPolicy_Resource_RepositoryResource) {
        self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(v))
    }

    // Mutable pointer to the field.
    pub fn mut_repository(&mut self) -> &mut OSPolicy_Resource_RepositoryResource {
        if let ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(_)) = self.resource_type {
        } else {
            self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(OSPolicy_Resource_RepositoryResource::new()));
        }
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_repository(&mut self) -> OSPolicy_Resource_RepositoryResource {
        if self.has_repository() {
            match self.resource_type.take() {
                ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_RepositoryResource::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource exec = 4;


    pub fn get_exec(&self) -> &OSPolicy_Resource_ExecResource {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(ref v)) => v,
            _ => <OSPolicy_Resource_ExecResource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exec(&mut self) {
        self.resource_type = ::std::option::Option::None;
    }

    pub fn has_exec(&self) -> bool {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exec(&mut self, v: OSPolicy_Resource_ExecResource) {
        self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exec(&mut self) -> &mut OSPolicy_Resource_ExecResource {
        if let ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(_)) = self.resource_type {
        } else {
            self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(OSPolicy_Resource_ExecResource::new()));
        }
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exec(&mut self) -> OSPolicy_Resource_ExecResource {
        if self.has_exec() {
            match self.resource_type.take() {
                ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_ExecResource::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.FileResource file = 5;


    pub fn get_file(&self) -> &OSPolicy_Resource_FileResource {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(ref v)) => v,
            _ => <OSPolicy_Resource_FileResource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_file(&mut self) {
        self.resource_type = ::std::option::Option::None;
    }

    pub fn has_file(&self) -> bool {
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: OSPolicy_Resource_FileResource) {
        self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file(&mut self) -> &mut OSPolicy_Resource_FileResource {
        if let ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(_)) = self.resource_type {
        } else {
            self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(OSPolicy_Resource_FileResource::new()));
        }
        match self.resource_type {
            ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file(&mut self) -> OSPolicy_Resource_FileResource {
        if self.has_file() {
            match self.resource_type.take() {
                ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_FileResource::new()
        }
    }
}

impl ::protobuf::Message for OSPolicy_Resource {
    fn is_initialized(&self) -> bool {
        if let Some(OSPolicy_Resource_oneof_resource_type::pkg(ref v)) = self.resource_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_oneof_resource_type::repository(ref v)) = self.resource_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_oneof_resource_type::exec(ref v)) = self.resource_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_oneof_resource_type::file(ref v)) = self.resource_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::pkg(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::repository(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::exec(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.resource_type = ::std::option::Option::Some(OSPolicy_Resource_oneof_resource_type::file(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let ::std::option::Option::Some(ref v) = self.resource_type {
            match v {
                &OSPolicy_Resource_oneof_resource_type::pkg(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_oneof_resource_type::repository(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_oneof_resource_type::exec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_oneof_resource_type::file(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.resource_type {
            match v {
                &OSPolicy_Resource_oneof_resource_type::pkg(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_oneof_resource_type::repository(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_oneof_resource_type::exec(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_oneof_resource_type::file(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource {
        OSPolicy_Resource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &OSPolicy_Resource| { &m.id },
                |m: &mut OSPolicy_Resource| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource>(
                "pkg",
                OSPolicy_Resource::has_pkg,
                OSPolicy_Resource::get_pkg,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_RepositoryResource>(
                "repository",
                OSPolicy_Resource::has_repository,
                OSPolicy_Resource::get_repository,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_ExecResource>(
                "exec",
                OSPolicy_Resource::has_exec,
                OSPolicy_Resource::get_exec,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_FileResource>(
                "file",
                OSPolicy_Resource::has_file,
                OSPolicy_Resource::get_file,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource>(
                "OSPolicy.Resource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource {
    fn clear(&mut self) {
        self.id.clear();
        self.resource_type = ::std::option::Option::None;
        self.resource_type = ::std::option::Option::None;
        self.resource_type = ::std::option::Option::None;
        self.resource_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_File {
    // message fields
    pub allow_insecure: bool,
    // message oneof groups
    pub field_type: ::std::option::Option<OSPolicy_Resource_File_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_File {
    fn default() -> &'a OSPolicy_Resource_File {
        <OSPolicy_Resource_File as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OSPolicy_Resource_File_oneof_type {
    remote(OSPolicy_Resource_File_Remote),
    gcs(OSPolicy_Resource_File_Gcs),
    local_path(::std::string::String),
}

impl OSPolicy_Resource_File {
    pub fn new() -> OSPolicy_Resource_File {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.File.Remote remote = 1;


    pub fn get_remote(&self) -> &OSPolicy_Resource_File_Remote {
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(ref v)) => v,
            _ => <OSPolicy_Resource_File_Remote as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_remote(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_remote(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote(&mut self, v: OSPolicy_Resource_File_Remote) {
        self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote(&mut self) -> &mut OSPolicy_Resource_File_Remote {
        if let ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(OSPolicy_Resource_File_Remote::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote(&mut self) -> OSPolicy_Resource_File_Remote {
        if self.has_remote() {
            match self.field_type.take() {
                ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_File_Remote::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.File.Gcs gcs = 2;


    pub fn get_gcs(&self) -> &OSPolicy_Resource_File_Gcs {
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(ref v)) => v,
            _ => <OSPolicy_Resource_File_Gcs as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_gcs(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs(&mut self, v: OSPolicy_Resource_File_Gcs) {
        self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs(&mut self) -> &mut OSPolicy_Resource_File_Gcs {
        if let ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(OSPolicy_Resource_File_Gcs::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs(&mut self) -> OSPolicy_Resource_File_Gcs {
        if self.has_gcs() {
            match self.field_type.take() {
                ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_File_Gcs::new()
        }
    }

    // string local_path = 3;


    pub fn get_local_path(&self) -> &str {
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_local_path(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_local_path(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local_path(&mut self, v: ::std::string::String) {
        self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(::std::string::String::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local_path(&mut self) -> ::std::string::String {
        if self.has_local_path() {
            match self.field_type.take() {
                ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool allow_insecure = 4;


    pub fn get_allow_insecure(&self) -> bool {
        self.allow_insecure
    }
    pub fn clear_allow_insecure(&mut self) {
        self.allow_insecure = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_insecure(&mut self, v: bool) {
        self.allow_insecure = v;
    }
}

impl ::protobuf::Message for OSPolicy_Resource_File {
    fn is_initialized(&self) -> bool {
        if let Some(OSPolicy_Resource_File_oneof_type::remote(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_File_oneof_type::gcs(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::remote(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::gcs(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(OSPolicy_Resource_File_oneof_type::local_path(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_insecure = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.allow_insecure != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &OSPolicy_Resource_File_oneof_type::remote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_File_oneof_type::gcs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_File_oneof_type::local_path(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.allow_insecure != false {
            os.write_bool(4, self.allow_insecure)?;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &OSPolicy_Resource_File_oneof_type::remote(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_File_oneof_type::gcs(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_File_oneof_type::local_path(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_File {
        OSPolicy_Resource_File::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_File_Remote>(
                "remote",
                OSPolicy_Resource_File::has_remote,
                OSPolicy_Resource_File::get_remote,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_File_Gcs>(
                "gcs",
                OSPolicy_Resource_File::has_gcs,
                OSPolicy_Resource_File::get_gcs,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "local_path",
                OSPolicy_Resource_File::has_local_path,
                OSPolicy_Resource_File::get_local_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_insecure",
                |m: &OSPolicy_Resource_File| { &m.allow_insecure },
                |m: &mut OSPolicy_Resource_File| { &mut m.allow_insecure },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_File>(
                "OSPolicy.Resource.File",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_File {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_File> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_File::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_File {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.allow_insecure = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_File {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_File_Remote {
    // message fields
    pub uri: ::std::string::String,
    pub sha256_checksum: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_File_Remote {
    fn default() -> &'a OSPolicy_Resource_File_Remote {
        <OSPolicy_Resource_File_Remote as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_File_Remote {
    pub fn new() -> OSPolicy_Resource_File_Remote {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // string sha256_checksum = 2;


    pub fn get_sha256_checksum(&self) -> &str {
        &self.sha256_checksum
    }
    pub fn clear_sha256_checksum(&mut self) {
        self.sha256_checksum.clear();
    }

    // Param is passed by value, moved
    pub fn set_sha256_checksum(&mut self, v: ::std::string::String) {
        self.sha256_checksum = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha256_checksum(&mut self) -> &mut ::std::string::String {
        &mut self.sha256_checksum
    }

    // Take field
    pub fn take_sha256_checksum(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sha256_checksum, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_File_Remote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sha256_checksum)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        if !self.sha256_checksum.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sha256_checksum);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        if !self.sha256_checksum.is_empty() {
            os.write_string(2, &self.sha256_checksum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_File_Remote {
        OSPolicy_Resource_File_Remote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &OSPolicy_Resource_File_Remote| { &m.uri },
                |m: &mut OSPolicy_Resource_File_Remote| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sha256_checksum",
                |m: &OSPolicy_Resource_File_Remote| { &m.sha256_checksum },
                |m: &mut OSPolicy_Resource_File_Remote| { &mut m.sha256_checksum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_File_Remote>(
                "OSPolicy.Resource.File.Remote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_File_Remote {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_File_Remote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_File_Remote::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_File_Remote {
    fn clear(&mut self) {
        self.uri.clear();
        self.sha256_checksum.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_File_Remote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_File_Remote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_File_Gcs {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_File_Gcs {
    fn default() -> &'a OSPolicy_Resource_File_Gcs {
        <OSPolicy_Resource_File_Gcs as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_File_Gcs {
    pub fn new() -> OSPolicy_Resource_File_Gcs {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 3;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }
}

impl ::protobuf::Message for OSPolicy_Resource_File_Gcs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(3, self.generation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_File_Gcs {
        OSPolicy_Resource_File_Gcs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &OSPolicy_Resource_File_Gcs| { &m.bucket },
                |m: &mut OSPolicy_Resource_File_Gcs| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &OSPolicy_Resource_File_Gcs| { &m.object },
                |m: &mut OSPolicy_Resource_File_Gcs| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &OSPolicy_Resource_File_Gcs| { &m.generation },
                |m: &mut OSPolicy_Resource_File_Gcs| { &mut m.generation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_File_Gcs>(
                "OSPolicy.Resource.File.Gcs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_File_Gcs {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_File_Gcs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_File_Gcs::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_File_Gcs {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_File_Gcs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_File_Gcs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource {
    // message fields
    pub desired_state: OSPolicy_Resource_PackageResource_DesiredState,
    // message oneof groups
    pub system_package: ::std::option::Option<OSPolicy_Resource_PackageResource_oneof_system_package>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource {
    fn default() -> &'a OSPolicy_Resource_PackageResource {
        <OSPolicy_Resource_PackageResource as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OSPolicy_Resource_PackageResource_oneof_system_package {
    apt(OSPolicy_Resource_PackageResource_APT),
    deb(OSPolicy_Resource_PackageResource_Deb),
    yum(OSPolicy_Resource_PackageResource_YUM),
    zypper(OSPolicy_Resource_PackageResource_Zypper),
    rpm(OSPolicy_Resource_PackageResource_RPM),
    googet(OSPolicy_Resource_PackageResource_GooGet),
    msi(OSPolicy_Resource_PackageResource_MSI),
}

impl OSPolicy_Resource_PackageResource {
    pub fn new() -> OSPolicy_Resource_PackageResource {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.DesiredState desired_state = 1;


    pub fn get_desired_state(&self) -> OSPolicy_Resource_PackageResource_DesiredState {
        self.desired_state
    }
    pub fn clear_desired_state(&mut self) {
        self.desired_state = OSPolicy_Resource_PackageResource_DesiredState::DESIRED_STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_desired_state(&mut self, v: OSPolicy_Resource_PackageResource_DesiredState) {
        self.desired_state = v;
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.APT apt = 2;


    pub fn get_apt(&self) -> &OSPolicy_Resource_PackageResource_APT {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource_APT as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_apt(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_apt(&self) -> bool {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apt(&mut self, v: OSPolicy_Resource_PackageResource_APT) {
        self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apt(&mut self) -> &mut OSPolicy_Resource_PackageResource_APT {
        if let ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(_)) = self.system_package {
        } else {
            self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(OSPolicy_Resource_PackageResource_APT::new()));
        }
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apt(&mut self) -> OSPolicy_Resource_PackageResource_APT {
        if self.has_apt() {
            match self.system_package.take() {
                ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource_APT::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.Deb deb = 3;


    pub fn get_deb(&self) -> &OSPolicy_Resource_PackageResource_Deb {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource_Deb as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_deb(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_deb(&self) -> bool {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deb(&mut self, v: OSPolicy_Resource_PackageResource_Deb) {
        self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(v))
    }

    // Mutable pointer to the field.
    pub fn mut_deb(&mut self) -> &mut OSPolicy_Resource_PackageResource_Deb {
        if let ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(_)) = self.system_package {
        } else {
            self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(OSPolicy_Resource_PackageResource_Deb::new()));
        }
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deb(&mut self) -> OSPolicy_Resource_PackageResource_Deb {
        if self.has_deb() {
            match self.system_package.take() {
                ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource_Deb::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.YUM yum = 4;


    pub fn get_yum(&self) -> &OSPolicy_Resource_PackageResource_YUM {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource_YUM as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_yum(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_yum(&self) -> bool {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_yum(&mut self, v: OSPolicy_Resource_PackageResource_YUM) {
        self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_yum(&mut self) -> &mut OSPolicy_Resource_PackageResource_YUM {
        if let ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(_)) = self.system_package {
        } else {
            self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(OSPolicy_Resource_PackageResource_YUM::new()));
        }
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_yum(&mut self) -> OSPolicy_Resource_PackageResource_YUM {
        if self.has_yum() {
            match self.system_package.take() {
                ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource_YUM::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.Zypper zypper = 5;


    pub fn get_zypper(&self) -> &OSPolicy_Resource_PackageResource_Zypper {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource_Zypper as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_zypper(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_zypper(&self) -> bool {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_zypper(&mut self, v: OSPolicy_Resource_PackageResource_Zypper) {
        self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(v))
    }

    // Mutable pointer to the field.
    pub fn mut_zypper(&mut self) -> &mut OSPolicy_Resource_PackageResource_Zypper {
        if let ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(_)) = self.system_package {
        } else {
            self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(OSPolicy_Resource_PackageResource_Zypper::new()));
        }
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_zypper(&mut self) -> OSPolicy_Resource_PackageResource_Zypper {
        if self.has_zypper() {
            match self.system_package.take() {
                ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource_Zypper::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.RPM rpm = 6;


    pub fn get_rpm(&self) -> &OSPolicy_Resource_PackageResource_RPM {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource_RPM as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rpm(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_rpm(&self) -> bool {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rpm(&mut self, v: OSPolicy_Resource_PackageResource_RPM) {
        self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rpm(&mut self) -> &mut OSPolicy_Resource_PackageResource_RPM {
        if let ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(_)) = self.system_package {
        } else {
            self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(OSPolicy_Resource_PackageResource_RPM::new()));
        }
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rpm(&mut self) -> OSPolicy_Resource_PackageResource_RPM {
        if self.has_rpm() {
            match self.system_package.take() {
                ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource_RPM::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.GooGet googet = 7;


    pub fn get_googet(&self) -> &OSPolicy_Resource_PackageResource_GooGet {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource_GooGet as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_googet(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_googet(&self) -> bool {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_googet(&mut self, v: OSPolicy_Resource_PackageResource_GooGet) {
        self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_googet(&mut self) -> &mut OSPolicy_Resource_PackageResource_GooGet {
        if let ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(_)) = self.system_package {
        } else {
            self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(OSPolicy_Resource_PackageResource_GooGet::new()));
        }
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_googet(&mut self) -> OSPolicy_Resource_PackageResource_GooGet {
        if self.has_googet() {
            match self.system_package.take() {
                ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource_GooGet::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.MSI msi = 8;


    pub fn get_msi(&self) -> &OSPolicy_Resource_PackageResource_MSI {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(ref v)) => v,
            _ => <OSPolicy_Resource_PackageResource_MSI as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_msi(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_msi(&self) -> bool {
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_msi(&mut self, v: OSPolicy_Resource_PackageResource_MSI) {
        self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_msi(&mut self) -> &mut OSPolicy_Resource_PackageResource_MSI {
        if let ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(_)) = self.system_package {
        } else {
            self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(OSPolicy_Resource_PackageResource_MSI::new()));
        }
        match self.system_package {
            ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_msi(&mut self) -> OSPolicy_Resource_PackageResource_MSI {
        if self.has_msi() {
            match self.system_package.take() {
                ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_PackageResource_MSI::new()
        }
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource {
    fn is_initialized(&self) -> bool {
        if let Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(ref v)) = self.system_package {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(ref v)) = self.system_package {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(ref v)) = self.system_package {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(ref v)) = self.system_package {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(ref v)) = self.system_package {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(ref v)) = self.system_package {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(ref v)) = self.system_package {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.desired_state, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::apt(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::deb(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::yum(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::zypper(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::rpm(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::googet(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_package = ::std::option::Option::Some(OSPolicy_Resource_PackageResource_oneof_system_package::msi(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.desired_state != OSPolicy_Resource_PackageResource_DesiredState::DESIRED_STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.desired_state);
        }
        if let ::std::option::Option::Some(ref v) = self.system_package {
            match v {
                &OSPolicy_Resource_PackageResource_oneof_system_package::apt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::deb(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::yum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::zypper(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::rpm(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::googet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::msi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.desired_state != OSPolicy_Resource_PackageResource_DesiredState::DESIRED_STATE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.desired_state))?;
        }
        if let ::std::option::Option::Some(ref v) = self.system_package {
            match v {
                &OSPolicy_Resource_PackageResource_oneof_system_package::apt(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::deb(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::yum(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::zypper(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::rpm(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::googet(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_PackageResource_oneof_system_package::msi(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource {
        OSPolicy_Resource_PackageResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicy_Resource_PackageResource_DesiredState>>(
                "desired_state",
                |m: &OSPolicy_Resource_PackageResource| { &m.desired_state },
                |m: &mut OSPolicy_Resource_PackageResource| { &mut m.desired_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource_APT>(
                "apt",
                OSPolicy_Resource_PackageResource::has_apt,
                OSPolicy_Resource_PackageResource::get_apt,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource_Deb>(
                "deb",
                OSPolicy_Resource_PackageResource::has_deb,
                OSPolicy_Resource_PackageResource::get_deb,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource_YUM>(
                "yum",
                OSPolicy_Resource_PackageResource::has_yum,
                OSPolicy_Resource_PackageResource::get_yum,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource_Zypper>(
                "zypper",
                OSPolicy_Resource_PackageResource::has_zypper,
                OSPolicy_Resource_PackageResource::get_zypper,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource_RPM>(
                "rpm",
                OSPolicy_Resource_PackageResource::has_rpm,
                OSPolicy_Resource_PackageResource::get_rpm,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource_GooGet>(
                "googet",
                OSPolicy_Resource_PackageResource::has_googet,
                OSPolicy_Resource_PackageResource::get_googet,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_PackageResource_MSI>(
                "msi",
                OSPolicy_Resource_PackageResource::has_msi,
                OSPolicy_Resource_PackageResource::get_msi,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource>(
                "OSPolicy.Resource.PackageResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource {
    fn clear(&mut self) {
        self.desired_state = OSPolicy_Resource_PackageResource_DesiredState::DESIRED_STATE_UNSPECIFIED;
        self.system_package = ::std::option::Option::None;
        self.system_package = ::std::option::Option::None;
        self.system_package = ::std::option::Option::None;
        self.system_package = ::std::option::Option::None;
        self.system_package = ::std::option::Option::None;
        self.system_package = ::std::option::Option::None;
        self.system_package = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource_Deb {
    // message fields
    pub source: ::protobuf::SingularPtrField<OSPolicy_Resource_File>,
    pub pull_deps: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource_Deb {
    fn default() -> &'a OSPolicy_Resource_PackageResource_Deb {
        <OSPolicy_Resource_PackageResource_Deb as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_PackageResource_Deb {
    pub fn new() -> OSPolicy_Resource_PackageResource_Deb {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.File source = 1;


    pub fn get_source(&self) -> &OSPolicy_Resource_File {
        self.source.as_ref().unwrap_or_else(|| <OSPolicy_Resource_File as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: OSPolicy_Resource_File) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut OSPolicy_Resource_File {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> OSPolicy_Resource_File {
        self.source.take().unwrap_or_else(|| OSPolicy_Resource_File::new())
    }

    // bool pull_deps = 2;


    pub fn get_pull_deps(&self) -> bool {
        self.pull_deps
    }
    pub fn clear_pull_deps(&mut self) {
        self.pull_deps = false;
    }

    // Param is passed by value, moved
    pub fn set_pull_deps(&mut self, v: bool) {
        self.pull_deps = v;
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource_Deb {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pull_deps = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.pull_deps != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.pull_deps != false {
            os.write_bool(2, self.pull_deps)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource_Deb {
        OSPolicy_Resource_PackageResource_Deb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_Resource_File>>(
                "source",
                |m: &OSPolicy_Resource_PackageResource_Deb| { &m.source },
                |m: &mut OSPolicy_Resource_PackageResource_Deb| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pull_deps",
                |m: &OSPolicy_Resource_PackageResource_Deb| { &m.pull_deps },
                |m: &mut OSPolicy_Resource_PackageResource_Deb| { &mut m.pull_deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_Deb>(
                "OSPolicy.Resource.PackageResource.Deb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource_Deb {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource_Deb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource_Deb::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource_Deb {
    fn clear(&mut self) {
        self.source.clear();
        self.pull_deps = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource_Deb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_Deb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource_APT {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource_APT {
    fn default() -> &'a OSPolicy_Resource_PackageResource_APT {
        <OSPolicy_Resource_PackageResource_APT as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_PackageResource_APT {
    pub fn new() -> OSPolicy_Resource_PackageResource_APT {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource_APT {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource_APT {
        OSPolicy_Resource_PackageResource_APT::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OSPolicy_Resource_PackageResource_APT| { &m.name },
                |m: &mut OSPolicy_Resource_PackageResource_APT| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_APT>(
                "OSPolicy.Resource.PackageResource.APT",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource_APT {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource_APT> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource_APT::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource_APT {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource_APT {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_APT {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource_RPM {
    // message fields
    pub source: ::protobuf::SingularPtrField<OSPolicy_Resource_File>,
    pub pull_deps: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource_RPM {
    fn default() -> &'a OSPolicy_Resource_PackageResource_RPM {
        <OSPolicy_Resource_PackageResource_RPM as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_PackageResource_RPM {
    pub fn new() -> OSPolicy_Resource_PackageResource_RPM {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.File source = 1;


    pub fn get_source(&self) -> &OSPolicy_Resource_File {
        self.source.as_ref().unwrap_or_else(|| <OSPolicy_Resource_File as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: OSPolicy_Resource_File) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut OSPolicy_Resource_File {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> OSPolicy_Resource_File {
        self.source.take().unwrap_or_else(|| OSPolicy_Resource_File::new())
    }

    // bool pull_deps = 2;


    pub fn get_pull_deps(&self) -> bool {
        self.pull_deps
    }
    pub fn clear_pull_deps(&mut self) {
        self.pull_deps = false;
    }

    // Param is passed by value, moved
    pub fn set_pull_deps(&mut self, v: bool) {
        self.pull_deps = v;
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource_RPM {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pull_deps = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.pull_deps != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.pull_deps != false {
            os.write_bool(2, self.pull_deps)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource_RPM {
        OSPolicy_Resource_PackageResource_RPM::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_Resource_File>>(
                "source",
                |m: &OSPolicy_Resource_PackageResource_RPM| { &m.source },
                |m: &mut OSPolicy_Resource_PackageResource_RPM| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pull_deps",
                |m: &OSPolicy_Resource_PackageResource_RPM| { &m.pull_deps },
                |m: &mut OSPolicy_Resource_PackageResource_RPM| { &mut m.pull_deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_RPM>(
                "OSPolicy.Resource.PackageResource.RPM",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource_RPM {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource_RPM> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource_RPM::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource_RPM {
    fn clear(&mut self) {
        self.source.clear();
        self.pull_deps = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource_RPM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_RPM {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource_YUM {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource_YUM {
    fn default() -> &'a OSPolicy_Resource_PackageResource_YUM {
        <OSPolicy_Resource_PackageResource_YUM as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_PackageResource_YUM {
    pub fn new() -> OSPolicy_Resource_PackageResource_YUM {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource_YUM {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource_YUM {
        OSPolicy_Resource_PackageResource_YUM::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OSPolicy_Resource_PackageResource_YUM| { &m.name },
                |m: &mut OSPolicy_Resource_PackageResource_YUM| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_YUM>(
                "OSPolicy.Resource.PackageResource.YUM",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource_YUM {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource_YUM> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource_YUM::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource_YUM {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource_YUM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_YUM {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource_Zypper {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource_Zypper {
    fn default() -> &'a OSPolicy_Resource_PackageResource_Zypper {
        <OSPolicy_Resource_PackageResource_Zypper as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_PackageResource_Zypper {
    pub fn new() -> OSPolicy_Resource_PackageResource_Zypper {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource_Zypper {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource_Zypper {
        OSPolicy_Resource_PackageResource_Zypper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OSPolicy_Resource_PackageResource_Zypper| { &m.name },
                |m: &mut OSPolicy_Resource_PackageResource_Zypper| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_Zypper>(
                "OSPolicy.Resource.PackageResource.Zypper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource_Zypper {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource_Zypper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource_Zypper::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource_Zypper {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource_Zypper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_Zypper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource_GooGet {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource_GooGet {
    fn default() -> &'a OSPolicy_Resource_PackageResource_GooGet {
        <OSPolicy_Resource_PackageResource_GooGet as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_PackageResource_GooGet {
    pub fn new() -> OSPolicy_Resource_PackageResource_GooGet {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource_GooGet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource_GooGet {
        OSPolicy_Resource_PackageResource_GooGet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OSPolicy_Resource_PackageResource_GooGet| { &m.name },
                |m: &mut OSPolicy_Resource_PackageResource_GooGet| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_GooGet>(
                "OSPolicy.Resource.PackageResource.GooGet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource_GooGet {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource_GooGet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource_GooGet::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource_GooGet {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource_GooGet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_GooGet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_PackageResource_MSI {
    // message fields
    pub source: ::protobuf::SingularPtrField<OSPolicy_Resource_File>,
    pub properties: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_PackageResource_MSI {
    fn default() -> &'a OSPolicy_Resource_PackageResource_MSI {
        <OSPolicy_Resource_PackageResource_MSI as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_PackageResource_MSI {
    pub fn new() -> OSPolicy_Resource_PackageResource_MSI {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.File source = 1;


    pub fn get_source(&self) -> &OSPolicy_Resource_File {
        self.source.as_ref().unwrap_or_else(|| <OSPolicy_Resource_File as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: OSPolicy_Resource_File) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut OSPolicy_Resource_File {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> OSPolicy_Resource_File {
        self.source.take().unwrap_or_else(|| OSPolicy_Resource_File::new())
    }

    // repeated string properties = 2;


    pub fn get_properties(&self) -> &[::std::string::String] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_PackageResource_MSI {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.properties {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_PackageResource_MSI {
        OSPolicy_Resource_PackageResource_MSI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_Resource_File>>(
                "source",
                |m: &OSPolicy_Resource_PackageResource_MSI| { &m.source },
                |m: &mut OSPolicy_Resource_PackageResource_MSI| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "properties",
                |m: &OSPolicy_Resource_PackageResource_MSI| { &m.properties },
                |m: &mut OSPolicy_Resource_PackageResource_MSI| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_MSI>(
                "OSPolicy.Resource.PackageResource.MSI",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_PackageResource_MSI {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_PackageResource_MSI> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_PackageResource_MSI::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_PackageResource_MSI {
    fn clear(&mut self) {
        self.source.clear();
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_PackageResource_MSI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_MSI {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicy_Resource_PackageResource_DesiredState {
    DESIRED_STATE_UNSPECIFIED = 0,
    INSTALLED = 1,
    REMOVED = 2,
}

impl ::protobuf::ProtobufEnum for OSPolicy_Resource_PackageResource_DesiredState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicy_Resource_PackageResource_DesiredState> {
        match value {
            0 => ::std::option::Option::Some(OSPolicy_Resource_PackageResource_DesiredState::DESIRED_STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicy_Resource_PackageResource_DesiredState::INSTALLED),
            2 => ::std::option::Option::Some(OSPolicy_Resource_PackageResource_DesiredState::REMOVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicy_Resource_PackageResource_DesiredState] = &[
            OSPolicy_Resource_PackageResource_DesiredState::DESIRED_STATE_UNSPECIFIED,
            OSPolicy_Resource_PackageResource_DesiredState::INSTALLED,
            OSPolicy_Resource_PackageResource_DesiredState::REMOVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicy_Resource_PackageResource_DesiredState>("OSPolicy.Resource.PackageResource.DesiredState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicy_Resource_PackageResource_DesiredState {
}

impl ::std::default::Default for OSPolicy_Resource_PackageResource_DesiredState {
    fn default() -> Self {
        OSPolicy_Resource_PackageResource_DesiredState::DESIRED_STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_PackageResource_DesiredState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_RepositoryResource {
    // message oneof groups
    pub repository: ::std::option::Option<OSPolicy_Resource_RepositoryResource_oneof_repository>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_RepositoryResource {
    fn default() -> &'a OSPolicy_Resource_RepositoryResource {
        <OSPolicy_Resource_RepositoryResource as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OSPolicy_Resource_RepositoryResource_oneof_repository {
    apt(OSPolicy_Resource_RepositoryResource_AptRepository),
    yum(OSPolicy_Resource_RepositoryResource_YumRepository),
    zypper(OSPolicy_Resource_RepositoryResource_ZypperRepository),
    goo(OSPolicy_Resource_RepositoryResource_GooRepository),
}

impl OSPolicy_Resource_RepositoryResource {
    pub fn new() -> OSPolicy_Resource_RepositoryResource {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.AptRepository apt = 1;


    pub fn get_apt(&self) -> &OSPolicy_Resource_RepositoryResource_AptRepository {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(ref v)) => v,
            _ => <OSPolicy_Resource_RepositoryResource_AptRepository as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_apt(&mut self) {
        self.repository = ::std::option::Option::None;
    }

    pub fn has_apt(&self) -> bool {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apt(&mut self, v: OSPolicy_Resource_RepositoryResource_AptRepository) {
        self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apt(&mut self) -> &mut OSPolicy_Resource_RepositoryResource_AptRepository {
        if let ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(_)) = self.repository {
        } else {
            self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(OSPolicy_Resource_RepositoryResource_AptRepository::new()));
        }
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apt(&mut self) -> OSPolicy_Resource_RepositoryResource_AptRepository {
        if self.has_apt() {
            match self.repository.take() {
                ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_RepositoryResource_AptRepository::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.YumRepository yum = 2;


    pub fn get_yum(&self) -> &OSPolicy_Resource_RepositoryResource_YumRepository {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(ref v)) => v,
            _ => <OSPolicy_Resource_RepositoryResource_YumRepository as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_yum(&mut self) {
        self.repository = ::std::option::Option::None;
    }

    pub fn has_yum(&self) -> bool {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_yum(&mut self, v: OSPolicy_Resource_RepositoryResource_YumRepository) {
        self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_yum(&mut self) -> &mut OSPolicy_Resource_RepositoryResource_YumRepository {
        if let ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(_)) = self.repository {
        } else {
            self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(OSPolicy_Resource_RepositoryResource_YumRepository::new()));
        }
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_yum(&mut self) -> OSPolicy_Resource_RepositoryResource_YumRepository {
        if self.has_yum() {
            match self.repository.take() {
                ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_RepositoryResource_YumRepository::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.ZypperRepository zypper = 3;


    pub fn get_zypper(&self) -> &OSPolicy_Resource_RepositoryResource_ZypperRepository {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(ref v)) => v,
            _ => <OSPolicy_Resource_RepositoryResource_ZypperRepository as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_zypper(&mut self) {
        self.repository = ::std::option::Option::None;
    }

    pub fn has_zypper(&self) -> bool {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_zypper(&mut self, v: OSPolicy_Resource_RepositoryResource_ZypperRepository) {
        self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(v))
    }

    // Mutable pointer to the field.
    pub fn mut_zypper(&mut self) -> &mut OSPolicy_Resource_RepositoryResource_ZypperRepository {
        if let ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(_)) = self.repository {
        } else {
            self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(OSPolicy_Resource_RepositoryResource_ZypperRepository::new()));
        }
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_zypper(&mut self) -> OSPolicy_Resource_RepositoryResource_ZypperRepository {
        if self.has_zypper() {
            match self.repository.take() {
                ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_RepositoryResource_ZypperRepository::new()
        }
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.GooRepository goo = 4;


    pub fn get_goo(&self) -> &OSPolicy_Resource_RepositoryResource_GooRepository {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(ref v)) => v,
            _ => <OSPolicy_Resource_RepositoryResource_GooRepository as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_goo(&mut self) {
        self.repository = ::std::option::Option::None;
    }

    pub fn has_goo(&self) -> bool {
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_goo(&mut self, v: OSPolicy_Resource_RepositoryResource_GooRepository) {
        self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_goo(&mut self) -> &mut OSPolicy_Resource_RepositoryResource_GooRepository {
        if let ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(_)) = self.repository {
        } else {
            self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(OSPolicy_Resource_RepositoryResource_GooRepository::new()));
        }
        match self.repository {
            ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_goo(&mut self) -> OSPolicy_Resource_RepositoryResource_GooRepository {
        if self.has_goo() {
            match self.repository.take() {
                ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_RepositoryResource_GooRepository::new()
        }
    }
}

impl ::protobuf::Message for OSPolicy_Resource_RepositoryResource {
    fn is_initialized(&self) -> bool {
        if let Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(ref v)) = self.repository {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(ref v)) = self.repository {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(ref v)) = self.repository {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(ref v)) = self.repository {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::apt(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::yum(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.repository = ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_oneof_repository::goo(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.repository {
            match v {
                &OSPolicy_Resource_RepositoryResource_oneof_repository::apt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_RepositoryResource_oneof_repository::yum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_RepositoryResource_oneof_repository::goo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.repository {
            match v {
                &OSPolicy_Resource_RepositoryResource_oneof_repository::apt(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_RepositoryResource_oneof_repository::yum(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_RepositoryResource_oneof_repository::zypper(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_RepositoryResource_oneof_repository::goo(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_RepositoryResource {
        OSPolicy_Resource_RepositoryResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_RepositoryResource_AptRepository>(
                "apt",
                OSPolicy_Resource_RepositoryResource::has_apt,
                OSPolicy_Resource_RepositoryResource::get_apt,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_RepositoryResource_YumRepository>(
                "yum",
                OSPolicy_Resource_RepositoryResource::has_yum,
                OSPolicy_Resource_RepositoryResource::get_yum,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_RepositoryResource_ZypperRepository>(
                "zypper",
                OSPolicy_Resource_RepositoryResource::has_zypper,
                OSPolicy_Resource_RepositoryResource::get_zypper,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_RepositoryResource_GooRepository>(
                "goo",
                OSPolicy_Resource_RepositoryResource::has_goo,
                OSPolicy_Resource_RepositoryResource::get_goo,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_RepositoryResource>(
                "OSPolicy.Resource.RepositoryResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_RepositoryResource {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_RepositoryResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_RepositoryResource::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_RepositoryResource {
    fn clear(&mut self) {
        self.repository = ::std::option::Option::None;
        self.repository = ::std::option::Option::None;
        self.repository = ::std::option::Option::None;
        self.repository = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_RepositoryResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_RepositoryResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_RepositoryResource_AptRepository {
    // message fields
    pub archive_type: OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType,
    pub uri: ::std::string::String,
    pub distribution: ::std::string::String,
    pub components: ::protobuf::RepeatedField<::std::string::String>,
    pub gpg_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_RepositoryResource_AptRepository {
    fn default() -> &'a OSPolicy_Resource_RepositoryResource_AptRepository {
        <OSPolicy_Resource_RepositoryResource_AptRepository as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_RepositoryResource_AptRepository {
    pub fn new() -> OSPolicy_Resource_RepositoryResource_AptRepository {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType archive_type = 1;


    pub fn get_archive_type(&self) -> OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType {
        self.archive_type
    }
    pub fn clear_archive_type(&mut self) {
        self.archive_type = OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::ARCHIVE_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_archive_type(&mut self, v: OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType) {
        self.archive_type = v;
    }

    // string uri = 2;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // string distribution = 3;


    pub fn get_distribution(&self) -> &str {
        &self.distribution
    }
    pub fn clear_distribution(&mut self) {
        self.distribution.clear();
    }

    // Param is passed by value, moved
    pub fn set_distribution(&mut self, v: ::std::string::String) {
        self.distribution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_distribution(&mut self) -> &mut ::std::string::String {
        &mut self.distribution
    }

    // Take field
    pub fn take_distribution(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.distribution, ::std::string::String::new())
    }

    // repeated string components = 4;


    pub fn get_components(&self) -> &[::std::string::String] {
        &self.components
    }
    pub fn clear_components(&mut self) {
        self.components.clear();
    }

    // Param is passed by value, moved
    pub fn set_components(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.components = v;
    }

    // Mutable pointer to the field.
    pub fn mut_components(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.components
    }

    // Take field
    pub fn take_components(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.components, ::protobuf::RepeatedField::new())
    }

    // string gpg_key = 5;


    pub fn get_gpg_key(&self) -> &str {
        &self.gpg_key
    }
    pub fn clear_gpg_key(&mut self) {
        self.gpg_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_gpg_key(&mut self, v: ::std::string::String) {
        self.gpg_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gpg_key(&mut self) -> &mut ::std::string::String {
        &mut self.gpg_key
    }

    // Take field
    pub fn take_gpg_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gpg_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_RepositoryResource_AptRepository {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.archive_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.distribution)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.components)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gpg_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.archive_type != OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::ARCHIVE_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.archive_type);
        }
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uri);
        }
        if !self.distribution.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.distribution);
        }
        for value in &self.components {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.gpg_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.gpg_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.archive_type != OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::ARCHIVE_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.archive_type))?;
        }
        if !self.uri.is_empty() {
            os.write_string(2, &self.uri)?;
        }
        if !self.distribution.is_empty() {
            os.write_string(3, &self.distribution)?;
        }
        for v in &self.components {
            os.write_string(4, &v)?;
        };
        if !self.gpg_key.is_empty() {
            os.write_string(5, &self.gpg_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_RepositoryResource_AptRepository {
        OSPolicy_Resource_RepositoryResource_AptRepository::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType>>(
                "archive_type",
                |m: &OSPolicy_Resource_RepositoryResource_AptRepository| { &m.archive_type },
                |m: &mut OSPolicy_Resource_RepositoryResource_AptRepository| { &mut m.archive_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &OSPolicy_Resource_RepositoryResource_AptRepository| { &m.uri },
                |m: &mut OSPolicy_Resource_RepositoryResource_AptRepository| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "distribution",
                |m: &OSPolicy_Resource_RepositoryResource_AptRepository| { &m.distribution },
                |m: &mut OSPolicy_Resource_RepositoryResource_AptRepository| { &mut m.distribution },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "components",
                |m: &OSPolicy_Resource_RepositoryResource_AptRepository| { &m.components },
                |m: &mut OSPolicy_Resource_RepositoryResource_AptRepository| { &mut m.components },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gpg_key",
                |m: &OSPolicy_Resource_RepositoryResource_AptRepository| { &m.gpg_key },
                |m: &mut OSPolicy_Resource_RepositoryResource_AptRepository| { &mut m.gpg_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_RepositoryResource_AptRepository>(
                "OSPolicy.Resource.RepositoryResource.AptRepository",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_RepositoryResource_AptRepository {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_RepositoryResource_AptRepository> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_RepositoryResource_AptRepository::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_RepositoryResource_AptRepository {
    fn clear(&mut self) {
        self.archive_type = OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::ARCHIVE_TYPE_UNSPECIFIED;
        self.uri.clear();
        self.distribution.clear();
        self.components.clear();
        self.gpg_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_RepositoryResource_AptRepository {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_RepositoryResource_AptRepository {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType {
    ARCHIVE_TYPE_UNSPECIFIED = 0,
    DEB = 1,
    DEB_SRC = 2,
}

impl ::protobuf::ProtobufEnum for OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType> {
        match value {
            0 => ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::ARCHIVE_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::DEB),
            2 => ::std::option::Option::Some(OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::DEB_SRC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType] = &[
            OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::ARCHIVE_TYPE_UNSPECIFIED,
            OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::DEB,
            OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::DEB_SRC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType>("OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType {
}

impl ::std::default::Default for OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType {
    fn default() -> Self {
        OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType::ARCHIVE_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_RepositoryResource_AptRepository_ArchiveType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_RepositoryResource_YumRepository {
    // message fields
    pub id: ::std::string::String,
    pub display_name: ::std::string::String,
    pub base_url: ::std::string::String,
    pub gpg_keys: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_RepositoryResource_YumRepository {
    fn default() -> &'a OSPolicy_Resource_RepositoryResource_YumRepository {
        <OSPolicy_Resource_RepositoryResource_YumRepository as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_RepositoryResource_YumRepository {
    pub fn new() -> OSPolicy_Resource_RepositoryResource_YumRepository {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string base_url = 3;


    pub fn get_base_url(&self) -> &str {
        &self.base_url
    }
    pub fn clear_base_url(&mut self) {
        self.base_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_url(&mut self, v: ::std::string::String) {
        self.base_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_url(&mut self) -> &mut ::std::string::String {
        &mut self.base_url
    }

    // Take field
    pub fn take_base_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_url, ::std::string::String::new())
    }

    // repeated string gpg_keys = 4;


    pub fn get_gpg_keys(&self) -> &[::std::string::String] {
        &self.gpg_keys
    }
    pub fn clear_gpg_keys(&mut self) {
        self.gpg_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_gpg_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.gpg_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gpg_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.gpg_keys
    }

    // Take field
    pub fn take_gpg_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.gpg_keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_RepositoryResource_YumRepository {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_url)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.gpg_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if !self.base_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.base_url);
        }
        for value in &self.gpg_keys {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if !self.base_url.is_empty() {
            os.write_string(3, &self.base_url)?;
        }
        for v in &self.gpg_keys {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_RepositoryResource_YumRepository {
        OSPolicy_Resource_RepositoryResource_YumRepository::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &OSPolicy_Resource_RepositoryResource_YumRepository| { &m.id },
                |m: &mut OSPolicy_Resource_RepositoryResource_YumRepository| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &OSPolicy_Resource_RepositoryResource_YumRepository| { &m.display_name },
                |m: &mut OSPolicy_Resource_RepositoryResource_YumRepository| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "base_url",
                |m: &OSPolicy_Resource_RepositoryResource_YumRepository| { &m.base_url },
                |m: &mut OSPolicy_Resource_RepositoryResource_YumRepository| { &mut m.base_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gpg_keys",
                |m: &OSPolicy_Resource_RepositoryResource_YumRepository| { &m.gpg_keys },
                |m: &mut OSPolicy_Resource_RepositoryResource_YumRepository| { &mut m.gpg_keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_RepositoryResource_YumRepository>(
                "OSPolicy.Resource.RepositoryResource.YumRepository",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_RepositoryResource_YumRepository {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_RepositoryResource_YumRepository> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_RepositoryResource_YumRepository::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_RepositoryResource_YumRepository {
    fn clear(&mut self) {
        self.id.clear();
        self.display_name.clear();
        self.base_url.clear();
        self.gpg_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_RepositoryResource_YumRepository {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_RepositoryResource_YumRepository {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_RepositoryResource_ZypperRepository {
    // message fields
    pub id: ::std::string::String,
    pub display_name: ::std::string::String,
    pub base_url: ::std::string::String,
    pub gpg_keys: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_RepositoryResource_ZypperRepository {
    fn default() -> &'a OSPolicy_Resource_RepositoryResource_ZypperRepository {
        <OSPolicy_Resource_RepositoryResource_ZypperRepository as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_RepositoryResource_ZypperRepository {
    pub fn new() -> OSPolicy_Resource_RepositoryResource_ZypperRepository {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string base_url = 3;


    pub fn get_base_url(&self) -> &str {
        &self.base_url
    }
    pub fn clear_base_url(&mut self) {
        self.base_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_url(&mut self, v: ::std::string::String) {
        self.base_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_url(&mut self) -> &mut ::std::string::String {
        &mut self.base_url
    }

    // Take field
    pub fn take_base_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_url, ::std::string::String::new())
    }

    // repeated string gpg_keys = 4;


    pub fn get_gpg_keys(&self) -> &[::std::string::String] {
        &self.gpg_keys
    }
    pub fn clear_gpg_keys(&mut self) {
        self.gpg_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_gpg_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.gpg_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gpg_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.gpg_keys
    }

    // Take field
    pub fn take_gpg_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.gpg_keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_RepositoryResource_ZypperRepository {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_url)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.gpg_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if !self.base_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.base_url);
        }
        for value in &self.gpg_keys {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if !self.base_url.is_empty() {
            os.write_string(3, &self.base_url)?;
        }
        for v in &self.gpg_keys {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_RepositoryResource_ZypperRepository {
        OSPolicy_Resource_RepositoryResource_ZypperRepository::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &OSPolicy_Resource_RepositoryResource_ZypperRepository| { &m.id },
                |m: &mut OSPolicy_Resource_RepositoryResource_ZypperRepository| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &OSPolicy_Resource_RepositoryResource_ZypperRepository| { &m.display_name },
                |m: &mut OSPolicy_Resource_RepositoryResource_ZypperRepository| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "base_url",
                |m: &OSPolicy_Resource_RepositoryResource_ZypperRepository| { &m.base_url },
                |m: &mut OSPolicy_Resource_RepositoryResource_ZypperRepository| { &mut m.base_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gpg_keys",
                |m: &OSPolicy_Resource_RepositoryResource_ZypperRepository| { &m.gpg_keys },
                |m: &mut OSPolicy_Resource_RepositoryResource_ZypperRepository| { &mut m.gpg_keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_RepositoryResource_ZypperRepository>(
                "OSPolicy.Resource.RepositoryResource.ZypperRepository",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_RepositoryResource_ZypperRepository {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_RepositoryResource_ZypperRepository> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_RepositoryResource_ZypperRepository::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_RepositoryResource_ZypperRepository {
    fn clear(&mut self) {
        self.id.clear();
        self.display_name.clear();
        self.base_url.clear();
        self.gpg_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_RepositoryResource_ZypperRepository {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_RepositoryResource_ZypperRepository {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_RepositoryResource_GooRepository {
    // message fields
    pub name: ::std::string::String,
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_RepositoryResource_GooRepository {
    fn default() -> &'a OSPolicy_Resource_RepositoryResource_GooRepository {
        <OSPolicy_Resource_RepositoryResource_GooRepository as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_RepositoryResource_GooRepository {
    pub fn new() -> OSPolicy_Resource_RepositoryResource_GooRepository {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_RepositoryResource_GooRepository {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_RepositoryResource_GooRepository {
        OSPolicy_Resource_RepositoryResource_GooRepository::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OSPolicy_Resource_RepositoryResource_GooRepository| { &m.name },
                |m: &mut OSPolicy_Resource_RepositoryResource_GooRepository| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &OSPolicy_Resource_RepositoryResource_GooRepository| { &m.url },
                |m: &mut OSPolicy_Resource_RepositoryResource_GooRepository| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_RepositoryResource_GooRepository>(
                "OSPolicy.Resource.RepositoryResource.GooRepository",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_RepositoryResource_GooRepository {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_RepositoryResource_GooRepository> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_RepositoryResource_GooRepository::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_RepositoryResource_GooRepository {
    fn clear(&mut self) {
        self.name.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_RepositoryResource_GooRepository {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_RepositoryResource_GooRepository {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_ExecResource {
    // message fields
    pub validate: ::protobuf::SingularPtrField<OSPolicy_Resource_ExecResource_Exec>,
    pub enforce: ::protobuf::SingularPtrField<OSPolicy_Resource_ExecResource_Exec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_ExecResource {
    fn default() -> &'a OSPolicy_Resource_ExecResource {
        <OSPolicy_Resource_ExecResource as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_Resource_ExecResource {
    pub fn new() -> OSPolicy_Resource_ExecResource {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec validate = 1;


    pub fn get_validate(&self) -> &OSPolicy_Resource_ExecResource_Exec {
        self.validate.as_ref().unwrap_or_else(|| <OSPolicy_Resource_ExecResource_Exec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_validate(&mut self) {
        self.validate.clear();
    }

    pub fn has_validate(&self) -> bool {
        self.validate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validate(&mut self, v: OSPolicy_Resource_ExecResource_Exec) {
        self.validate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validate(&mut self) -> &mut OSPolicy_Resource_ExecResource_Exec {
        if self.validate.is_none() {
            self.validate.set_default();
        }
        self.validate.as_mut().unwrap()
    }

    // Take field
    pub fn take_validate(&mut self) -> OSPolicy_Resource_ExecResource_Exec {
        self.validate.take().unwrap_or_else(|| OSPolicy_Resource_ExecResource_Exec::new())
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec enforce = 2;


    pub fn get_enforce(&self) -> &OSPolicy_Resource_ExecResource_Exec {
        self.enforce.as_ref().unwrap_or_else(|| <OSPolicy_Resource_ExecResource_Exec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_enforce(&mut self) {
        self.enforce.clear();
    }

    pub fn has_enforce(&self) -> bool {
        self.enforce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enforce(&mut self, v: OSPolicy_Resource_ExecResource_Exec) {
        self.enforce = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enforce(&mut self) -> &mut OSPolicy_Resource_ExecResource_Exec {
        if self.enforce.is_none() {
            self.enforce.set_default();
        }
        self.enforce.as_mut().unwrap()
    }

    // Take field
    pub fn take_enforce(&mut self) -> OSPolicy_Resource_ExecResource_Exec {
        self.enforce.take().unwrap_or_else(|| OSPolicy_Resource_ExecResource_Exec::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_ExecResource {
    fn is_initialized(&self) -> bool {
        for v in &self.validate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enforce {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.validate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.enforce)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.validate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.enforce.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.validate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.enforce.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_ExecResource {
        OSPolicy_Resource_ExecResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_Resource_ExecResource_Exec>>(
                "validate",
                |m: &OSPolicy_Resource_ExecResource| { &m.validate },
                |m: &mut OSPolicy_Resource_ExecResource| { &mut m.validate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_Resource_ExecResource_Exec>>(
                "enforce",
                |m: &OSPolicy_Resource_ExecResource| { &m.enforce },
                |m: &mut OSPolicy_Resource_ExecResource| { &mut m.enforce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_ExecResource>(
                "OSPolicy.Resource.ExecResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_ExecResource {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_ExecResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_ExecResource::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_ExecResource {
    fn clear(&mut self) {
        self.validate.clear();
        self.enforce.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_ExecResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_ExecResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_ExecResource_Exec {
    // message fields
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    pub interpreter: OSPolicy_Resource_ExecResource_Exec_Interpreter,
    pub output_file_path: ::std::string::String,
    // message oneof groups
    pub source: ::std::option::Option<OSPolicy_Resource_ExecResource_Exec_oneof_source>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_ExecResource_Exec {
    fn default() -> &'a OSPolicy_Resource_ExecResource_Exec {
        <OSPolicy_Resource_ExecResource_Exec as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OSPolicy_Resource_ExecResource_Exec_oneof_source {
    file(OSPolicy_Resource_File),
    script(::std::string::String),
}

impl OSPolicy_Resource_ExecResource_Exec {
    pub fn new() -> OSPolicy_Resource_ExecResource_Exec {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.File file = 1;


    pub fn get_file(&self) -> &OSPolicy_Resource_File {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(ref v)) => v,
            _ => <OSPolicy_Resource_File as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_file(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_file(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: OSPolicy_Resource_File) {
        self.source = ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file(&mut self) -> &mut OSPolicy_Resource_File {
        if let ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(OSPolicy_Resource_File::new()));
        }
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file(&mut self) -> OSPolicy_Resource_File {
        if self.has_file() {
            match self.source.take() {
                ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_File::new()
        }
    }

    // string script = 2;


    pub fn get_script(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_script(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_script(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::string::String {
        if self.has_script() {
            match self.source.take() {
                ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated string args = 3;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec.Interpreter interpreter = 4;


    pub fn get_interpreter(&self) -> OSPolicy_Resource_ExecResource_Exec_Interpreter {
        self.interpreter
    }
    pub fn clear_interpreter(&mut self) {
        self.interpreter = OSPolicy_Resource_ExecResource_Exec_Interpreter::INTERPRETER_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_interpreter(&mut self, v: OSPolicy_Resource_ExecResource_Exec_Interpreter) {
        self.interpreter = v;
    }

    // string output_file_path = 5;


    pub fn get_output_file_path(&self) -> &str {
        &self.output_file_path
    }
    pub fn clear_output_file_path(&mut self) {
        self.output_file_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_file_path(&mut self, v: ::std::string::String) {
        self.output_file_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_file_path(&mut self) -> &mut ::std::string::String {
        &mut self.output_file_path
    }

    // Take field
    pub fn take_output_file_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output_file_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_ExecResource_Exec {
    fn is_initialized(&self) -> bool {
        if let Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(ref v)) = self.source {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::file(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_oneof_source::script(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.interpreter, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output_file_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.interpreter != OSPolicy_Resource_ExecResource_Exec_Interpreter::INTERPRETER_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.interpreter);
        }
        if !self.output_file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.output_file_path);
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &OSPolicy_Resource_ExecResource_Exec_oneof_source::file(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_ExecResource_Exec_oneof_source::script(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.args {
            os.write_string(3, &v)?;
        };
        if self.interpreter != OSPolicy_Resource_ExecResource_Exec_Interpreter::INTERPRETER_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.interpreter))?;
        }
        if !self.output_file_path.is_empty() {
            os.write_string(5, &self.output_file_path)?;
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &OSPolicy_Resource_ExecResource_Exec_oneof_source::file(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_ExecResource_Exec_oneof_source::script(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_ExecResource_Exec {
        OSPolicy_Resource_ExecResource_Exec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_File>(
                "file",
                OSPolicy_Resource_ExecResource_Exec::has_file,
                OSPolicy_Resource_ExecResource_Exec::get_file,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "script",
                OSPolicy_Resource_ExecResource_Exec::has_script,
                OSPolicy_Resource_ExecResource_Exec::get_script,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "args",
                |m: &OSPolicy_Resource_ExecResource_Exec| { &m.args },
                |m: &mut OSPolicy_Resource_ExecResource_Exec| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicy_Resource_ExecResource_Exec_Interpreter>>(
                "interpreter",
                |m: &OSPolicy_Resource_ExecResource_Exec| { &m.interpreter },
                |m: &mut OSPolicy_Resource_ExecResource_Exec| { &mut m.interpreter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output_file_path",
                |m: &OSPolicy_Resource_ExecResource_Exec| { &m.output_file_path },
                |m: &mut OSPolicy_Resource_ExecResource_Exec| { &mut m.output_file_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_ExecResource_Exec>(
                "OSPolicy.Resource.ExecResource.Exec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_ExecResource_Exec {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_ExecResource_Exec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_ExecResource_Exec::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_ExecResource_Exec {
    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.args.clear();
        self.interpreter = OSPolicy_Resource_ExecResource_Exec_Interpreter::INTERPRETER_UNSPECIFIED;
        self.output_file_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_ExecResource_Exec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_ExecResource_Exec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicy_Resource_ExecResource_Exec_Interpreter {
    INTERPRETER_UNSPECIFIED = 0,
    NONE = 1,
    SHELL = 2,
    POWERSHELL = 3,
}

impl ::protobuf::ProtobufEnum for OSPolicy_Resource_ExecResource_Exec_Interpreter {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicy_Resource_ExecResource_Exec_Interpreter> {
        match value {
            0 => ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_Interpreter::INTERPRETER_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_Interpreter::NONE),
            2 => ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_Interpreter::SHELL),
            3 => ::std::option::Option::Some(OSPolicy_Resource_ExecResource_Exec_Interpreter::POWERSHELL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicy_Resource_ExecResource_Exec_Interpreter] = &[
            OSPolicy_Resource_ExecResource_Exec_Interpreter::INTERPRETER_UNSPECIFIED,
            OSPolicy_Resource_ExecResource_Exec_Interpreter::NONE,
            OSPolicy_Resource_ExecResource_Exec_Interpreter::SHELL,
            OSPolicy_Resource_ExecResource_Exec_Interpreter::POWERSHELL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicy_Resource_ExecResource_Exec_Interpreter>("OSPolicy.Resource.ExecResource.Exec.Interpreter", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicy_Resource_ExecResource_Exec_Interpreter {
}

impl ::std::default::Default for OSPolicy_Resource_ExecResource_Exec_Interpreter {
    fn default() -> Self {
        OSPolicy_Resource_ExecResource_Exec_Interpreter::INTERPRETER_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_ExecResource_Exec_Interpreter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_Resource_FileResource {
    // message fields
    pub path: ::std::string::String,
    pub state: OSPolicy_Resource_FileResource_DesiredState,
    pub permissions: ::std::string::String,
    // message oneof groups
    pub source: ::std::option::Option<OSPolicy_Resource_FileResource_oneof_source>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_Resource_FileResource {
    fn default() -> &'a OSPolicy_Resource_FileResource {
        <OSPolicy_Resource_FileResource as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OSPolicy_Resource_FileResource_oneof_source {
    file(OSPolicy_Resource_File),
    content(::std::string::String),
}

impl OSPolicy_Resource_FileResource {
    pub fn new() -> OSPolicy_Resource_FileResource {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.File file = 1;


    pub fn get_file(&self) -> &OSPolicy_Resource_File {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(ref v)) => v,
            _ => <OSPolicy_Resource_File as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_file(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_file(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: OSPolicy_Resource_File) {
        self.source = ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file(&mut self) -> &mut OSPolicy_Resource_File {
        if let ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(OSPolicy_Resource_File::new()));
        }
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file(&mut self) -> OSPolicy_Resource_File {
        if self.has_file() {
            match self.source.take() {
                ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicy_Resource_File::new()
        }
    }

    // string content = 2;


    pub fn get_content(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_content(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_content(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(v))
    }

    // Mutable pointer to the field.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        if self.has_content() {
            match self.source.take() {
                ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string path = 3;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1.OSPolicy.Resource.FileResource.DesiredState state = 4;


    pub fn get_state(&self) -> OSPolicy_Resource_FileResource_DesiredState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = OSPolicy_Resource_FileResource_DesiredState::DESIRED_STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: OSPolicy_Resource_FileResource_DesiredState) {
        self.state = v;
    }

    // string permissions = 5;


    pub fn get_permissions(&self) -> &str {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::std::string::String) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permissions(&mut self) -> &mut ::std::string::String {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permissions, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicy_Resource_FileResource {
    fn is_initialized(&self) -> bool {
        if let Some(OSPolicy_Resource_FileResource_oneof_source::file(ref v)) = self.source {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::file(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(OSPolicy_Resource_FileResource_oneof_source::content(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        if self.state != OSPolicy_Resource_FileResource_DesiredState::DESIRED_STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.state);
        }
        if !self.permissions.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.permissions);
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &OSPolicy_Resource_FileResource_oneof_source::file(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OSPolicy_Resource_FileResource_oneof_source::content(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        if self.state != OSPolicy_Resource_FileResource_DesiredState::DESIRED_STATE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if !self.permissions.is_empty() {
            os.write_string(5, &self.permissions)?;
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &OSPolicy_Resource_FileResource_oneof_source::file(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OSPolicy_Resource_FileResource_oneof_source::content(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_Resource_FileResource {
        OSPolicy_Resource_FileResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicy_Resource_File>(
                "file",
                OSPolicy_Resource_FileResource::has_file,
                OSPolicy_Resource_FileResource::get_file,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "content",
                OSPolicy_Resource_FileResource::has_content,
                OSPolicy_Resource_FileResource::get_content,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &OSPolicy_Resource_FileResource| { &m.path },
                |m: &mut OSPolicy_Resource_FileResource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicy_Resource_FileResource_DesiredState>>(
                "state",
                |m: &OSPolicy_Resource_FileResource| { &m.state },
                |m: &mut OSPolicy_Resource_FileResource| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permissions",
                |m: &OSPolicy_Resource_FileResource| { &m.permissions },
                |m: &mut OSPolicy_Resource_FileResource| { &mut m.permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_Resource_FileResource>(
                "OSPolicy.Resource.FileResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_Resource_FileResource {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_Resource_FileResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_Resource_FileResource::new)
    }
}

impl ::protobuf::Clear for OSPolicy_Resource_FileResource {
    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.path.clear();
        self.state = OSPolicy_Resource_FileResource_DesiredState::DESIRED_STATE_UNSPECIFIED;
        self.permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_Resource_FileResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_FileResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicy_Resource_FileResource_DesiredState {
    DESIRED_STATE_UNSPECIFIED = 0,
    PRESENT = 1,
    ABSENT = 2,
    CONTENTS_MATCH = 3,
}

impl ::protobuf::ProtobufEnum for OSPolicy_Resource_FileResource_DesiredState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicy_Resource_FileResource_DesiredState> {
        match value {
            0 => ::std::option::Option::Some(OSPolicy_Resource_FileResource_DesiredState::DESIRED_STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicy_Resource_FileResource_DesiredState::PRESENT),
            2 => ::std::option::Option::Some(OSPolicy_Resource_FileResource_DesiredState::ABSENT),
            3 => ::std::option::Option::Some(OSPolicy_Resource_FileResource_DesiredState::CONTENTS_MATCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicy_Resource_FileResource_DesiredState] = &[
            OSPolicy_Resource_FileResource_DesiredState::DESIRED_STATE_UNSPECIFIED,
            OSPolicy_Resource_FileResource_DesiredState::PRESENT,
            OSPolicy_Resource_FileResource_DesiredState::ABSENT,
            OSPolicy_Resource_FileResource_DesiredState::CONTENTS_MATCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicy_Resource_FileResource_DesiredState>("OSPolicy.Resource.FileResource.DesiredState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicy_Resource_FileResource_DesiredState {
}

impl ::std::default::Default for OSPolicy_Resource_FileResource_DesiredState {
    fn default() -> Self {
        OSPolicy_Resource_FileResource_DesiredState::DESIRED_STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Resource_FileResource_DesiredState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicy_ResourceGroup {
    // message fields
    pub inventory_filters: ::protobuf::RepeatedField<OSPolicy_InventoryFilter>,
    pub resources: ::protobuf::RepeatedField<OSPolicy_Resource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicy_ResourceGroup {
    fn default() -> &'a OSPolicy_ResourceGroup {
        <OSPolicy_ResourceGroup as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicy_ResourceGroup {
    pub fn new() -> OSPolicy_ResourceGroup {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1.OSPolicy.InventoryFilter inventory_filters = 1;


    pub fn get_inventory_filters(&self) -> &[OSPolicy_InventoryFilter] {
        &self.inventory_filters
    }
    pub fn clear_inventory_filters(&mut self) {
        self.inventory_filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory_filters(&mut self, v: ::protobuf::RepeatedField<OSPolicy_InventoryFilter>) {
        self.inventory_filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventory_filters(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicy_InventoryFilter> {
        &mut self.inventory_filters
    }

    // Take field
    pub fn take_inventory_filters(&mut self) -> ::protobuf::RepeatedField<OSPolicy_InventoryFilter> {
        ::std::mem::replace(&mut self.inventory_filters, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.osconfig.v1.OSPolicy.Resource resources = 2;


    pub fn get_resources(&self) -> &[OSPolicy_Resource] {
        &self.resources
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<OSPolicy_Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicy_Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<OSPolicy_Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OSPolicy_ResourceGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.inventory_filters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inventory_filters)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.inventory_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.inventory_filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.resources {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicy_ResourceGroup {
        OSPolicy_ResourceGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_InventoryFilter>>(
                "inventory_filters",
                |m: &OSPolicy_ResourceGroup| { &m.inventory_filters },
                |m: &mut OSPolicy_ResourceGroup| { &mut m.inventory_filters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicy_Resource>>(
                "resources",
                |m: &OSPolicy_ResourceGroup| { &m.resources },
                |m: &mut OSPolicy_ResourceGroup| { &mut m.resources },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicy_ResourceGroup>(
                "OSPolicy.ResourceGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicy_ResourceGroup {
        static instance: ::protobuf::rt::LazyV2<OSPolicy_ResourceGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicy_ResourceGroup::new)
    }
}

impl ::protobuf::Clear for OSPolicy_ResourceGroup {
    fn clear(&mut self) {
        self.inventory_filters.clear();
        self.resources.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicy_ResourceGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_ResourceGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicy_Mode {
    MODE_UNSPECIFIED = 0,
    VALIDATION = 1,
    ENFORCEMENT = 2,
}

impl ::protobuf::ProtobufEnum for OSPolicy_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicy_Mode> {
        match value {
            0 => ::std::option::Option::Some(OSPolicy_Mode::MODE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicy_Mode::VALIDATION),
            2 => ::std::option::Option::Some(OSPolicy_Mode::ENFORCEMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicy_Mode] = &[
            OSPolicy_Mode::MODE_UNSPECIFIED,
            OSPolicy_Mode::VALIDATION,
            OSPolicy_Mode::ENFORCEMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicy_Mode>("OSPolicy.Mode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicy_Mode {
}

impl ::std::default::Default for OSPolicy_Mode {
    fn default() -> Self {
        OSPolicy_Mode::MODE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicy_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(google/cloud/osconfig/v1/os_policy.proto\x12\x18google.cloud.osconfig\
    .v1\x1a\x1fgoogle/api/field_behavior.proto\"\xe7%\n\x08OSPolicy\x12\x13\
    \n\x02id\x18\x01\x20\x01(\tR\x02idB\x03\xe0A\x02\x12\x20\n\x0bdescriptio\
    n\x18\x02\x20\x01(\tR\x0bdescription\x12@\n\x04mode\x18\x03\x20\x01(\x0e\
    2'.google.cloud.osconfig.v1.OSPolicy.ModeR\x04modeB\x03\xe0A\x02\x12^\n\
    \x0fresource_groups\x18\x04\x20\x03(\x0b20.google.cloud.osconfig.v1.OSPo\
    licy.ResourceGroupR\x0eresourceGroupsB\x03\xe0A\x02\x12@\n\x1dallow_no_r\
    esource_group_match\x18\x05\x20\x01(\x08R\x19allowNoResourceGroupMatch\
    \x1aY\n\x0fInventoryFilter\x12'\n\ros_short_name\x18\x01\x20\x01(\tR\x0b\
    osShortNameB\x03\xe0A\x02\x12\x1d\n\nos_version\x18\x02\x20\x01(\tR\tosV\
    ersion\x1a\xe2\x20\n\x08Resource\x12\x13\n\x02id\x18\x01\x20\x01(\tR\x02\
    idB\x03\xe0A\x02\x12O\n\x03pkg\x18\x02\x20\x01(\x0b2;.google.cloud.oscon\
    fig.v1.OSPolicy.Resource.PackageResourceH\0R\x03pkg\x12`\n\nrepository\
    \x18\x03\x20\x01(\x0b2>.google.cloud.osconfig.v1.OSPolicy.Resource.Repos\
    itoryResourceH\0R\nrepository\x12N\n\x04exec\x18\x04\x20\x01(\x0b28.goog\
    le.cloud.osconfig.v1.OSPolicy.Resource.ExecResourceH\0R\x04exec\x12N\n\
    \x04file\x18\x05\x20\x01(\x0b28.google.cloud.osconfig.v1.OSPolicy.Resour\
    ce.FileResourceH\0R\x04file\x1a\x9e\x03\n\x04File\x12Q\n\x06remote\x18\
    \x01\x20\x01(\x0b27.google.cloud.osconfig.v1.OSPolicy.Resource.File.Remo\
    teH\0R\x06remote\x12H\n\x03gcs\x18\x02\x20\x01(\x0b24.google.cloud.oscon\
    fig.v1.OSPolicy.Resource.File.GcsH\0R\x03gcs\x12\x1f\n\nlocal_path\x18\
    \x03\x20\x01(\tH\0R\tlocalPath\x12%\n\x0eallow_insecure\x18\x04\x20\x01(\
    \x08R\rallowInsecure\x1aH\n\x06Remote\x12\x15\n\x03uri\x18\x01\x20\x01(\
    \tR\x03uriB\x03\xe0A\x02\x12'\n\x0fsha256_checksum\x18\x02\x20\x01(\tR\
    \x0esha256Checksum\x1a_\n\x03Gcs\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\
    \x06bucketB\x03\xe0A\x02\x12\x1b\n\x06object\x18\x02\x20\x01(\tR\x06obje\
    ctB\x03\xe0A\x02\x12\x1e\n\ngeneration\x18\x03\x20\x01(\x03R\ngeneration\
    B\x06\n\x04type\x1a\xa9\n\n\x0fPackageResource\x12r\n\rdesired_state\x18\
    \x01\x20\x01(\x0e2H.google.cloud.osconfig.v1.OSPolicy.Resource.PackageRe\
    source.DesiredStateR\x0cdesiredStateB\x03\xe0A\x02\x12S\n\x03apt\x18\x02\
    \x20\x01(\x0b2?.google.cloud.osconfig.v1.OSPolicy.Resource.PackageResour\
    ce.APTH\0R\x03apt\x12S\n\x03deb\x18\x03\x20\x01(\x0b2?.google.cloud.osco\
    nfig.v1.OSPolicy.Resource.PackageResource.DebH\0R\x03deb\x12S\n\x03yum\
    \x18\x04\x20\x01(\x0b2?.google.cloud.osconfig.v1.OSPolicy.Resource.Packa\
    geResource.YUMH\0R\x03yum\x12\\\n\x06zypper\x18\x05\x20\x01(\x0b2B.googl\
    e.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.ZypperH\0R\x06zypp\
    er\x12S\n\x03rpm\x18\x06\x20\x01(\x0b2?.google.cloud.osconfig.v1.OSPolic\
    y.Resource.PackageResource.RPMH\0R\x03rpm\x12\\\n\x06googet\x18\x07\x20\
    \x01(\x0b2B.google.cloud.osconfig.v1.OSPolicy.Resource.PackageResource.G\
    ooGetH\0R\x06googet\x12S\n\x03msi\x18\x08\x20\x01(\x0b2?.google.cloud.os\
    config.v1.OSPolicy.Resource.PackageResource.MSIH\0R\x03msi\x1aq\n\x03Deb\
    \x12M\n\x06source\x18\x01\x20\x01(\x0b20.google.cloud.osconfig.v1.OSPoli\
    cy.Resource.FileR\x06sourceB\x03\xe0A\x02\x12\x1b\n\tpull_deps\x18\x02\
    \x20\x01(\x08R\x08pullDeps\x1a\x1e\n\x03APT\x12\x17\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB\x03\xe0A\x02\x1aq\n\x03RPM\x12M\n\x06source\x18\
    \x01\x20\x01(\x0b20.google.cloud.osconfig.v1.OSPolicy.Resource.FileR\x06\
    sourceB\x03\xe0A\x02\x12\x1b\n\tpull_deps\x18\x02\x20\x01(\x08R\x08pullD\
    eps\x1a\x1e\n\x03YUM\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x03\
    \xe0A\x02\x1a!\n\x06Zypper\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04name\
    B\x03\xe0A\x02\x1a!\n\x06GooGet\x12\x17\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\x03\xe0A\x02\x1at\n\x03MSI\x12M\n\x06source\x18\x01\x20\x01(\
    \x0b20.google.cloud.osconfig.v1.OSPolicy.Resource.FileR\x06sourceB\x03\
    \xe0A\x02\x12\x1e\n\nproperties\x18\x02\x20\x03(\tR\nproperties\"I\n\x0c\
    DesiredState\x12\x1d\n\x19DESIRED_STATE_UNSPECIFIED\x10\0\x12\r\n\tINSTA\
    LLED\x10\x01\x12\x0b\n\x07REMOVED\x10\x02B\x10\n\x0esystem_package\x1a\
    \xd7\x08\n\x12RepositoryResource\x12`\n\x03apt\x18\x01\x20\x01(\x0b2L.go\
    ogle.cloud.osconfig.v1.OSPolicy.Resource.RepositoryResource.AptRepositor\
    yH\0R\x03apt\x12`\n\x03yum\x18\x02\x20\x01(\x0b2L.google.cloud.osconfig.\
    v1.OSPolicy.Resource.RepositoryResource.YumRepositoryH\0R\x03yum\x12i\n\
    \x06zypper\x18\x03\x20\x01(\x0b2O.google.cloud.osconfig.v1.OSPolicy.Reso\
    urce.RepositoryResource.ZypperRepositoryH\0R\x06zypper\x12`\n\x03goo\x18\
    \x04\x20\x01(\x0b2L.google.cloud.osconfig.v1.OSPolicy.Resource.Repositor\
    yResource.GooRepositoryH\0R\x03goo\x1a\xd3\x02\n\rAptRepository\x12\x80\
    \x01\n\x0carchive_type\x18\x01\x20\x01(\x0e2X.google.cloud.osconfig.v1.O\
    SPolicy.Resource.RepositoryResource.AptRepository.ArchiveTypeR\x0barchiv\
    eTypeB\x03\xe0A\x02\x12\x15\n\x03uri\x18\x02\x20\x01(\tR\x03uriB\x03\xe0\
    A\x02\x12'\n\x0cdistribution\x18\x03\x20\x01(\tR\x0cdistributionB\x03\
    \xe0A\x02\x12#\n\ncomponents\x18\x04\x20\x03(\tR\ncomponentsB\x03\xe0A\
    \x02\x12\x17\n\x07gpg_key\x18\x05\x20\x01(\tR\x06gpgKey\"A\n\x0bArchiveT\
    ype\x12\x1c\n\x18ARCHIVE_TYPE_UNSPECIFIED\x10\0\x12\x07\n\x03DEB\x10\x01\
    \x12\x0b\n\x07DEB_SRC\x10\x02\x1a\x82\x01\n\rYumRepository\x12\x13\n\x02\
    id\x18\x01\x20\x01(\tR\x02idB\x03\xe0A\x02\x12!\n\x0cdisplay_name\x18\
    \x02\x20\x01(\tR\x0bdisplayName\x12\x1e\n\x08base_url\x18\x03\x20\x01(\t\
    R\x07baseUrlB\x03\xe0A\x02\x12\x19\n\x08gpg_keys\x18\x04\x20\x03(\tR\x07\
    gpgKeys\x1a\x85\x01\n\x10ZypperRepository\x12\x13\n\x02id\x18\x01\x20\
    \x01(\tR\x02idB\x03\xe0A\x02\x12!\n\x0cdisplay_name\x18\x02\x20\x01(\tR\
    \x0bdisplayName\x12\x1e\n\x08base_url\x18\x03\x20\x01(\tR\x07baseUrlB\
    \x03\xe0A\x02\x12\x19\n\x08gpg_keys\x18\x04\x20\x03(\tR\x07gpgKeys\x1a?\
    \n\rGooRepository\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x03\xe0\
    A\x02\x12\x15\n\x03url\x18\x02\x20\x01(\tR\x03urlB\x03\xe0A\x02B\x0c\n\n\
    repository\x1a\xbd\x04\n\x0cExecResource\x12^\n\x08validate\x18\x01\x20\
    \x01(\x0b2=.google.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.Exec\
    R\x08validateB\x03\xe0A\x02\x12W\n\x07enforce\x18\x02\x20\x01(\x0b2=.goo\
    gle.cloud.osconfig.v1.OSPolicy.Resource.ExecResource.ExecR\x07enforce\
    \x1a\xf3\x02\n\x04Exec\x12F\n\x04file\x18\x01\x20\x01(\x0b20.google.clou\
    d.osconfig.v1.OSPolicy.Resource.FileH\0R\x04file\x12\x18\n\x06script\x18\
    \x02\x20\x01(\tH\0R\x06script\x12\x12\n\x04args\x18\x03\x20\x03(\tR\x04a\
    rgs\x12p\n\x0binterpreter\x18\x04\x20\x01(\x0e2I.google.cloud.osconfig.v\
    1.OSPolicy.Resource.ExecResource.Exec.InterpreterR\x0binterpreterB\x03\
    \xe0A\x02\x12(\n\x10output_file_path\x18\x05\x20\x01(\tR\x0eoutputFilePa\
    th\"O\n\x0bInterpreter\x12\x1b\n\x17INTERPRETER_UNSPECIFIED\x10\0\x12\
    \x08\n\x04NONE\x10\x01\x12\t\n\x05SHELL\x10\x02\x12\x0e\n\nPOWERSHELL\
    \x10\x03B\x08\n\x06source\x1a\xf5\x02\n\x0cFileResource\x12F\n\x04file\
    \x18\x01\x20\x01(\x0b20.google.cloud.osconfig.v1.OSPolicy.Resource.FileH\
    \0R\x04file\x12\x1a\n\x07content\x18\x02\x20\x01(\tH\0R\x07content\x12\
    \x17\n\x04path\x18\x03\x20\x01(\tR\x04pathB\x03\xe0A\x02\x12`\n\x05state\
    \x18\x04\x20\x01(\x0e2E.google.cloud.osconfig.v1.OSPolicy.Resource.FileR\
    esource.DesiredStateR\x05stateB\x03\xe0A\x02\x12\x20\n\x0bpermissions\
    \x18\x05\x20\x01(\tR\x0bpermissions\"Z\n\x0cDesiredState\x12\x1d\n\x19DE\
    SIRED_STATE_UNSPECIFIED\x10\0\x12\x0b\n\x07PRESENT\x10\x01\x12\n\n\x06AB\
    SENT\x10\x02\x12\x12\n\x0eCONTENTS_MATCH\x10\x03B\x08\n\x06sourceB\x0f\n\
    \rresource_type\x1a\xc0\x01\n\rResourceGroup\x12_\n\x11inventory_filters\
    \x18\x01\x20\x03(\x0b22.google.cloud.osconfig.v1.OSPolicy.InventoryFilte\
    rR\x10inventoryFilters\x12N\n\tresources\x18\x02\x20\x03(\x0b2+.google.c\
    loud.osconfig.v1.OSPolicy.ResourceR\tresourcesB\x03\xe0A\x02\"=\n\x04Mod\
    e\x12\x14\n\x10MODE_UNSPECIFIED\x10\0\x12\x0e\n\nVALIDATION\x10\x01\x12\
    \x0f\n\x0bENFORCEMENT\x10\x02B\xbd\x01\n\x1ccom.google.cloud.osconfig.v1\
    B\rOsPolicyProtoP\x01Z8cloud.google.com/go/osconfig/apiv1/osconfigpb;osc\
    onfigpb\xaa\x02\x18Google.Cloud.OsConfig.V1\xca\x02\x18Google\\Cloud\\Os\
    Config\\V1\xea\x02\x1bGoogle::Cloud::OsConfig::V1J\xed\xae\x01\n\x07\x12\
    \x05\x0e\0\xa3\x04\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\
    \x20Copyright\x202021\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\
    \x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20y\
    ou\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\
    \x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\
    \x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/li\
    censes/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\
    \x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\
    \x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20\
    IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20A\
    NY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20Li\
    cense\x20for\x20the\x20specific\x20language\x20governing\x20permissions\
    \x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\
    \x12\x03\x10\0!\n\t\n\x02\x03\0\x12\x03\x12\0)\n\x08\n\x01\x08\x12\x03\
    \x14\05\n\t\n\x02\x08%\x12\x03\x14\05\n\x08\n\x01\x08\x12\x03\x15\0O\n\t\
    \n\x02\x08\x0b\x12\x03\x15\0O\n\x08\n\x01\x08\x12\x03\x16\0\"\n\t\n\x02\
    \x08\n\x12\x03\x16\0\"\n\x08\n\x01\x08\x12\x03\x17\0.\n\t\n\x02\x08\x08\
    \x12\x03\x17\0.\n\x08\n\x01\x08\x12\x03\x18\05\n\t\n\x02\x08\x01\x12\x03\
    \x18\05\n\x08\n\x01\x08\x12\x03\x19\05\n\t\n\x02\x08)\x12\x03\x19\05\n\
    \x08\n\x01\x08\x12\x03\x1a\04\n\t\n\x02\x08-\x12\x03\x1a\04\nM\n\x02\x04\
    \0\x12\x05\x1d\0\xa3\x04\x01\x1a@\x20An\x20OS\x20policy\x20defines\x20th\
    e\x20desired\x20state\x20configuration\x20for\x20a\x20VM.\n\n\n\n\x03\
    \x04\0\x01\x12\x03\x1d\x08\x10\n\x1b\n\x04\x04\0\x04\0\x12\x04\x1f\x02+\
    \x03\x1a\r\x20Policy\x20mode\n\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03\x1f\
    \x07\x0b\n\x1d\n\x06\x04\0\x04\0\x02\0\x12\x03!\x04\x19\x1a\x0e\x20Inval\
    id\x20mode\n\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03!\x04\x14\n\x0e\n\
    \x07\x04\0\x04\0\x02\0\x02\x12\x03!\x17\x18\n\xd6\x01\n\x06\x04\0\x04\0\
    \x02\x01\x12\x03&\x04\x13\x1a\xc6\x01\x20This\x20mode\x20checks\x20if\
    \x20the\x20configuration\x20resources\x20in\x20the\x20policy\x20are\x20i\
    n\n\x20their\x20desired\x20state.\x20No\x20actions\x20are\x20performed\
    \x20if\x20they\x20are\x20not\x20in\x20the\n\x20desired\x20state.\x20This\
    \x20mode\x20is\x20used\x20for\x20reporting\x20purposes.\n\n\x0e\n\x07\
    \x04\0\x04\0\x02\x01\x01\x12\x03&\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\
    \x01\x02\x12\x03&\x11\x12\n\x94\x01\n\x06\x04\0\x04\0\x02\x02\x12\x03*\
    \x04\x14\x1a\x84\x01\x20This\x20mode\x20checks\x20if\x20the\x20configura\
    tion\x20resources\x20in\x20the\x20policy\x20are\x20in\n\x20their\x20desi\
    red\x20state,\x20and\x20if\x20not,\x20enforces\x20the\x20desired\x20stat\
    e.\n\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03*\x04\x0f\n\x0e\n\x07\
    \x04\0\x04\0\x02\x02\x02\x12\x03*\x12\x13\nL\n\x04\x04\0\x03\0\x12\x04.\
    \x02:\x03\x1a>\x20Filtering\x20criteria\x20to\x20select\x20VMs\x20based\
    \x20on\x20inventory\x20details.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03.\n\
    \x19\n,\n\x06\x04\0\x03\0\x02\0\x12\x030\x04F\x1a\x1d\x20Required.\x20Th\
    e\x20OS\x20short\x20name\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x030\
    \x04\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x030\x0b\x18\n\x0e\n\x07\
    \x04\0\x03\0\x02\0\x03\x12\x030\x1b\x1c\n\x0e\n\x07\x04\0\x03\0\x02\0\
    \x08\x12\x030\x1dE\n\x11\n\n\x04\0\x03\0\x02\0\x08\x9c\x08\0\x12\x030\
    \x1eD\n\x8f\x02\n\x06\x04\0\x03\0\x02\x01\x12\x039\x04\x1a\x1a\xff\x01\
    \x20The\x20OS\x20version\n\n\x20Prefix\x20matches\x20are\x20supported\
    \x20if\x20asterisk(*)\x20is\x20provided\x20as\x20the\n\x20last\x20charac\
    ter.\x20For\x20example,\x20to\x20match\x20all\x20versions\x20with\x20a\
    \x20major\n\x20version\x20of\x20`7`,\x20specify\x20the\x20following\x20v\
    alue\x20for\x20this\x20field\x20`7.*`\n\n\x20An\x20empty\x20string\x20ma\
    tches\x20all\x20OS\x20versions.\n\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\
    \x12\x039\x04\n\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x039\x0b\x15\n\
    \x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x039\x18\x19\n\xce\x02\n\x04\x04\
    \0\x03\x01\x12\x05B\x02\xe4\x03\x03\x1a\xbe\x02\x20An\x20OS\x20policy\
    \x20resource\x20is\x20used\x20to\x20define\x20the\x20desired\x20state\
    \x20configuration\n\x20and\x20provides\x20a\x20specific\x20functionality\
    \x20like\x20installing/removing\x20packages,\n\x20executing\x20a\x20scri\
    pt\x20etc.\n\n\x20The\x20system\x20ensures\x20that\x20resources\x20are\
    \x20always\x20in\x20their\x20desired\x20state\x20by\n\x20taking\x20neces\
    sary\x20actions\x20if\x20they\x20have\x20drifted\x20from\x20their\x20des\
    ired\x20state.\n\n\x0c\n\x05\x04\0\x03\x01\x01\x12\x03B\n\x12\n)\n\x06\
    \x04\0\x03\x01\x03\0\x12\x04D\x04m\x05\x1a\x19\x20A\x20remote\x20or\x20l\
    ocal\x20file.\n\n\x0e\n\x07\x04\0\x03\x01\x03\0\x01\x12\x03D\x0c\x10\n<\
    \n\x08\x04\0\x03\x01\x03\0\x03\0\x12\x04F\x06M\x07\x1a*\x20Specifies\x20\
    a\x20file\x20available\x20via\x20some\x20URI.\n\n\x10\n\t\x04\0\x03\x01\
    \x03\0\x03\0\x01\x12\x03F\x0e\x14\n\xa1\x01\n\n\x04\0\x03\x01\x03\0\x03\
    \0\x02\0\x12\x03I\x08@\x1a\x8d\x01\x20Required.\x20URI\x20from\x20which\
    \x20to\x20fetch\x20the\x20object.\x20It\x20should\x20contain\x20both\n\
    \x20the\x20protocol\x20and\x20path\x20following\x20the\x20format\x20`{pr\
    otocol}://{location}`.\n\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\0\x02\0\x05\
    \x12\x03I\x08\x0e\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\0\x02\0\x01\x12\
    \x03I\x0f\x12\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\0\x02\0\x03\x12\x03I\
    \x15\x16\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\0\x02\0\x08\x12\x03I\x17?\n\
    \x15\n\x0e\x04\0\x03\x01\x03\0\x03\0\x02\0\x08\x9c\x08\0\x12\x03I\x18>\n\
    8\n\n\x04\0\x03\x01\x03\0\x03\0\x02\x01\x12\x03L\x08#\x1a%\x20SHA256\x20\
    checksum\x20of\x20the\x20remote\x20file.\n\n\x12\n\x0b\x04\0\x03\x01\x03\
    \0\x03\0\x02\x01\x05\x12\x03L\x08\x0e\n\x12\n\x0b\x04\0\x03\x01\x03\0\
    \x03\0\x02\x01\x01\x12\x03L\x0f\x1e\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\
    \0\x02\x01\x03\x12\x03L!\"\nI\n\x08\x04\0\x03\x01\x03\0\x03\x01\x12\x04P\
    \x06Y\x07\x1a7\x20Specifies\x20a\x20file\x20available\x20as\x20a\x20Clou\
    d\x20Storage\x20Object.\n\n\x10\n\t\x04\0\x03\x01\x03\0\x03\x01\x01\x12\
    \x03P\x0e\x11\nB\n\n\x04\0\x03\x01\x03\0\x03\x01\x02\0\x12\x03R\x08C\x1a\
    /\x20Required.\x20Bucket\x20of\x20the\x20Cloud\x20Storage\x20object.\n\n\
    \x12\n\x0b\x04\0\x03\x01\x03\0\x03\x01\x02\0\x05\x12\x03R\x08\x0e\n\x12\
    \n\x0b\x04\0\x03\x01\x03\0\x03\x01\x02\0\x01\x12\x03R\x0f\x15\n\x12\n\
    \x0b\x04\0\x03\x01\x03\0\x03\x01\x02\0\x03\x12\x03R\x18\x19\n\x12\n\x0b\
    \x04\0\x03\x01\x03\0\x03\x01\x02\0\x08\x12\x03R\x1aB\n\x15\n\x0e\x04\0\
    \x03\x01\x03\0\x03\x01\x02\0\x08\x9c\x08\0\x12\x03R\x1bA\n@\n\n\x04\0\
    \x03\x01\x03\0\x03\x01\x02\x01\x12\x03U\x08C\x1a-\x20Required.\x20Name\
    \x20of\x20the\x20Cloud\x20Storage\x20object.\n\n\x12\n\x0b\x04\0\x03\x01\
    \x03\0\x03\x01\x02\x01\x05\x12\x03U\x08\x0e\n\x12\n\x0b\x04\0\x03\x01\
    \x03\0\x03\x01\x02\x01\x01\x12\x03U\x0f\x15\n\x12\n\x0b\x04\0\x03\x01\
    \x03\0\x03\x01\x02\x01\x03\x12\x03U\x18\x19\n\x12\n\x0b\x04\0\x03\x01\
    \x03\0\x03\x01\x02\x01\x08\x12\x03U\x1aB\n\x15\n\x0e\x04\0\x03\x01\x03\0\
    \x03\x01\x02\x01\x08\x9c\x08\0\x12\x03U\x1bA\nC\n\n\x04\0\x03\x01\x03\0\
    \x03\x01\x02\x02\x12\x03X\x08\x1d\x1a0\x20Generation\x20number\x20of\x20\
    the\x20Cloud\x20Storage\x20object.\n\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\
    \x01\x02\x02\x05\x12\x03X\x08\r\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\x01\
    \x02\x02\x01\x12\x03X\x0e\x18\n\x12\n\x0b\x04\0\x03\x01\x03\0\x03\x01\
    \x02\x02\x03\x12\x03X\x1b\x1c\n,\n\x08\x04\0\x03\x01\x03\0\x08\0\x12\x04\
    \\\x06e\x07\x1a\x1a\x20A\x20specific\x20type\x20of\x20file.\n\n\x10\n\t\
    \x04\0\x03\x01\x03\0\x08\0\x01\x12\x03\\\x0c\x10\n)\n\x08\x04\0\x03\x01\
    \x03\0\x02\0\x12\x03^\x08\x1a\x1a\x18\x20A\x20generic\x20remote\x20file.\
    \n\n\x10\n\t\x04\0\x03\x01\x03\0\x02\0\x06\x12\x03^\x08\x0e\n\x10\n\t\
    \x04\0\x03\x01\x03\0\x02\0\x01\x12\x03^\x0f\x15\n\x10\n\t\x04\0\x03\x01\
    \x03\0\x02\0\x03\x12\x03^\x18\x19\n*\n\x08\x04\0\x03\x01\x03\0\x02\x01\
    \x12\x03a\x08\x14\x1a\x19\x20A\x20Cloud\x20Storage\x20object.\n\n\x10\n\
    \t\x04\0\x03\x01\x03\0\x02\x01\x06\x12\x03a\x08\x0b\n\x10\n\t\x04\0\x03\
    \x01\x03\0\x02\x01\x01\x12\x03a\x0c\x0f\n\x10\n\t\x04\0\x03\x01\x03\0\
    \x02\x01\x03\x12\x03a\x12\x13\n5\n\x08\x04\0\x03\x01\x03\0\x02\x02\x12\
    \x03d\x08\x1e\x1a$\x20A\x20local\x20path\x20within\x20the\x20VM\x20to\
    \x20use.\n\n\x10\n\t\x04\0\x03\x01\x03\0\x02\x02\x05\x12\x03d\x08\x0e\n\
    \x10\n\t\x04\0\x03\x01\x03\0\x02\x02\x01\x12\x03d\x0f\x19\n\x10\n\t\x04\
    \0\x03\x01\x03\0\x02\x02\x03\x12\x03d\x1c\x1d\n\xd3\x01\n\x08\x04\0\x03\
    \x01\x03\0\x02\x03\x12\x03l\x06\x1e\x1a\xc1\x01\x20Defaults\x20to\x20fal\
    se.\x20When\x20false,\x20files\x20are\x20subject\x20to\x20validations\n\
    \x20based\x20on\x20the\x20file\x20type:\n\n\x20Remote:\x20A\x20checksum\
    \x20must\x20be\x20specified.\n\x20Cloud\x20Storage:\x20An\x20object\x20g\
    eneration\x20number\x20must\x20be\x20specified.\n\n\x10\n\t\x04\0\x03\
    \x01\x03\0\x02\x03\x05\x12\x03l\x06\n\n\x10\n\t\x04\0\x03\x01\x03\0\x02\
    \x03\x01\x12\x03l\x0b\x19\n\x10\n\t\x04\0\x03\x01\x03\0\x02\x03\x03\x12\
    \x03l\x1c\x1d\n<\n\x06\x04\0\x03\x01\x03\x01\x12\x05p\x04\xdc\x01\x05\
    \x1a+\x20A\x20resource\x20that\x20manages\x20a\x20system\x20package.\n\n\
    \x0e\n\x07\x04\0\x03\x01\x03\x01\x01\x12\x03p\x0c\x1b\nS\n\x08\x04\0\x03\
    \x01\x03\x01\x04\0\x12\x04r\x06|\x07\x1aA\x20The\x20desired\x20state\x20\
    that\x20the\x20OS\x20Config\x20agent\x20maintains\x20on\x20the\x20VM.\n\
    \n\x10\n\t\x04\0\x03\x01\x03\x01\x04\0\x01\x12\x03r\x0b\x17\n,\n\n\x04\0\
    \x03\x01\x03\x01\x04\0\x02\0\x12\x03t\x08&\x1a\x19\x20Unspecified\x20is\
    \x20invalid.\n\n\x12\n\x0b\x04\0\x03\x01\x03\x01\x04\0\x02\0\x01\x12\x03\
    t\x08!\n\x12\n\x0b\x04\0\x03\x01\x03\x01\x04\0\x02\0\x02\x12\x03t$%\n:\n\
    \n\x04\0\x03\x01\x03\x01\x04\0\x02\x01\x12\x03w\x08\x16\x1a'\x20Ensure\
    \x20that\x20the\x20package\x20is\x20installed.\n\n\x12\n\x0b\x04\0\x03\
    \x01\x03\x01\x04\0\x02\x01\x01\x12\x03w\x08\x11\n\x12\n\x0b\x04\0\x03\
    \x01\x03\x01\x04\0\x02\x01\x02\x12\x03w\x14\x15\nh\n\n\x04\0\x03\x01\x03\
    \x01\x04\0\x02\x02\x12\x03{\x08\x14\x1aU\x20The\x20agent\x20ensures\x20t\
    hat\x20the\x20package\x20is\x20not\x20installed\x20and\n\x20uninstalls\
    \x20it\x20if\x20detected.\n\n\x12\n\x0b\x04\0\x03\x01\x03\x01\x04\0\x02\
    \x02\x01\x12\x03{\x08\x0f\n\x12\n\x0b\x04\0\x03\x01\x03\x01\x04\0\x02\
    \x02\x02\x12\x03{\x12\x13\nT\n\x08\x04\0\x03\x01\x03\x01\x03\0\x12\x05\
    \x7f\x06\x88\x01\x07\x1aA\x20A\x20deb\x20package\x20file.\x20dpkg\x20pac\
    kages\x20only\x20support\x20INSTALLED\x20state.\n\n\x10\n\t\x04\0\x03\
    \x01\x03\x01\x03\0\x01\x12\x03\x7f\x0e\x11\n.\n\n\x04\0\x03\x01\x03\x01\
    \x03\0\x02\0\x12\x04\x81\x01\x08A\x1a\x1a\x20Required.\x20A\x20deb\x20pa\
    ckage.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\0\x02\0\x06\x12\x04\x81\
    \x01\x08\x0c\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\0\x02\0\x01\x12\x04\
    \x81\x01\r\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\0\x02\0\x03\x12\x04\
    \x81\x01\x16\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\0\x02\0\x08\x12\
    \x04\x81\x01\x18@\n\x16\n\x0e\x04\0\x03\x01\x03\x01\x03\0\x02\0\x08\x9c\
    \x08\0\x12\x04\x81\x01\x19?\n\xb8\x01\n\n\x04\0\x03\x01\x03\x01\x03\0\
    \x02\x01\x12\x04\x87\x01\x08\x1b\x1a\xa3\x01\x20Whether\x20dependencies\
    \x20should\x20also\x20be\x20installed.\n\x20-\x20install\x20when\x20fals\
    e:\x20`dpkg\x20-i\x20package`\n\x20-\x20install\x20when\x20true:\x20`apt\
    -get\x20update\x20&&\x20apt-get\x20-y\x20install\n\x20package.deb`\n\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x01\x03\0\x02\x01\x05\x12\x04\x87\x01\x08\
    \x0c\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\0\x02\x01\x01\x12\x04\x87\x01\
    \r\x16\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\0\x02\x01\x03\x12\x04\x87\
    \x01\x19\x1a\n\x8f\x01\n\x08\x04\0\x03\x01\x03\x01\x03\x01\x12\x06\x8d\
    \x01\x06\x90\x01\x07\x1a{\x20A\x20package\x20managed\x20by\x20APT.\n\x20\
    -\x20install:\x20`apt-get\x20update\x20&&\x20apt-get\x20-y\x20install\
    \x20[name]`\n\x20-\x20remove:\x20`apt-get\x20-y\x20remove\x20[name]`\n\n\
    \x11\n\t\x04\0\x03\x01\x03\x01\x03\x01\x01\x12\x04\x8d\x01\x0e\x11\n-\n\
    \n\x04\0\x03\x01\x03\x01\x03\x01\x02\0\x12\x04\x8f\x01\x08A\x1a\x19\x20R\
    equired.\x20Package\x20name.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x01\
    \x02\0\x05\x12\x04\x8f\x01\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\
    \x01\x02\0\x01\x12\x04\x8f\x01\x0f\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x01\
    \x03\x01\x02\0\x03\x12\x04\x8f\x01\x16\x17\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x01\x03\x01\x02\0\x08\x12\x04\x8f\x01\x18@\n\x16\n\x0e\x04\0\x03\x01\
    \x03\x01\x03\x01\x02\0\x08\x9c\x08\0\x12\x04\x8f\x01\x19?\nU\n\x08\x04\0\
    \x03\x01\x03\x01\x03\x02\x12\x06\x93\x01\x06\x9c\x01\x07\x1aA\x20An\x20R\
    PM\x20package\x20file.\x20RPM\x20packages\x20only\x20support\x20INSTALLE\
    D\x20state.\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x03\x02\x01\x12\x04\x93\
    \x01\x0e\x11\n/\n\n\x04\0\x03\x01\x03\x01\x03\x02\x02\0\x12\x04\x95\x01\
    \x08A\x1a\x1b\x20Required.\x20An\x20rpm\x20package.\n\n\x13\n\x0b\x04\0\
    \x03\x01\x03\x01\x03\x02\x02\0\x06\x12\x04\x95\x01\x08\x0c\n\x13\n\x0b\
    \x04\0\x03\x01\x03\x01\x03\x02\x02\0\x01\x12\x04\x95\x01\r\x13\n\x13\n\
    \x0b\x04\0\x03\x01\x03\x01\x03\x02\x02\0\x03\x12\x04\x95\x01\x16\x17\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x02\x02\0\x08\x12\x04\x95\x01\x18@\
    \n\x16\n\x0e\x04\0\x03\x01\x03\x01\x03\x02\x02\0\x08\x9c\x08\0\x12\x04\
    \x95\x01\x19?\n\xdd\x01\n\n\x04\0\x03\x01\x03\x01\x03\x02\x02\x01\x12\
    \x04\x9b\x01\x08\x1b\x1a\xc8\x01\x20Whether\x20dependencies\x20should\
    \x20also\x20be\x20installed.\n\x20-\x20install\x20when\x20false:\x20`rpm\
    \x20--upgrade\x20--replacepkgs\x20package.rpm`\n\x20-\x20install\x20when\
    \x20true:\x20`yum\x20-y\x20install\x20package.rpm`\x20or\n\x20`zypper\
    \x20-y\x20install\x20package.rpm`\n\n\x13\n\x0b\x04\0\x03\x01\x03\x01\
    \x03\x02\x02\x01\x05\x12\x04\x9b\x01\x08\x0c\n\x13\n\x0b\x04\0\x03\x01\
    \x03\x01\x03\x02\x02\x01\x01\x12\x04\x9b\x01\r\x16\n\x13\n\x0b\x04\0\x03\
    \x01\x03\x01\x03\x02\x02\x01\x03\x12\x04\x9b\x01\x19\x1a\nw\n\x08\x04\0\
    \x03\x01\x03\x01\x03\x03\x12\x06\xa1\x01\x06\xa4\x01\x07\x1ac\x20A\x20pa\
    ckage\x20managed\x20by\x20YUM.\n\x20-\x20install:\x20`yum\x20-y\x20insta\
    ll\x20package`\n\x20-\x20remove:\x20`yum\x20-y\x20remove\x20package`\n\n\
    \x11\n\t\x04\0\x03\x01\x03\x01\x03\x03\x01\x12\x04\xa1\x01\x0e\x11\n-\n\
    \n\x04\0\x03\x01\x03\x01\x03\x03\x02\0\x12\x04\xa3\x01\x08A\x1a\x19\x20R\
    equired.\x20Package\x20name.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x03\
    \x02\0\x05\x12\x04\xa3\x01\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\
    \x03\x02\0\x01\x12\x04\xa3\x01\x0f\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x01\
    \x03\x03\x02\0\x03\x12\x04\xa3\x01\x16\x17\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x01\x03\x03\x02\0\x08\x12\x04\xa3\x01\x18@\n\x16\n\x0e\x04\0\x03\x01\
    \x03\x01\x03\x03\x02\0\x08\x9c\x08\0\x12\x04\xa3\x01\x19?\n|\n\x08\x04\0\
    \x03\x01\x03\x01\x03\x04\x12\x06\xa9\x01\x06\xac\x01\x07\x1ah\x20A\x20pa\
    ckage\x20managed\x20by\x20Zypper.\n\x20-\x20install:\x20`zypper\x20-y\
    \x20install\x20package`\n\x20-\x20remove:\x20`zypper\x20-y\x20rm\x20pack\
    age`\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x03\x04\x01\x12\x04\xa9\x01\x0e\
    \x14\n-\n\n\x04\0\x03\x01\x03\x01\x03\x04\x02\0\x12\x04\xab\x01\x08A\x1a\
    \x19\x20Required.\x20Package\x20name.\n\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x01\x03\x04\x02\0\x05\x12\x04\xab\x01\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\
    \x03\x01\x03\x04\x02\0\x01\x12\x04\xab\x01\x0f\x13\n\x13\n\x0b\x04\0\x03\
    \x01\x03\x01\x03\x04\x02\0\x03\x12\x04\xab\x01\x16\x17\n\x13\n\x0b\x04\0\
    \x03\x01\x03\x01\x03\x04\x02\0\x08\x12\x04\xab\x01\x18@\n\x16\n\x0e\x04\
    \0\x03\x01\x03\x01\x03\x04\x02\0\x08\x9c\x08\0\x12\x04\xab\x01\x19?\n\
    \x90\x01\n\x08\x04\0\x03\x01\x03\x01\x03\x05\x12\x06\xb1\x01\x06\xb4\x01\
    \x07\x1a|\x20A\x20package\x20managed\x20by\x20GooGet.\n\x20-\x20install:\
    \x20`googet\x20-noconfirm\x20install\x20package`\n\x20-\x20remove:\x20`g\
    ooget\x20-noconfirm\x20remove\x20package`\n\n\x11\n\t\x04\0\x03\x01\x03\
    \x01\x03\x05\x01\x12\x04\xb1\x01\x0e\x14\n-\n\n\x04\0\x03\x01\x03\x01\
    \x03\x05\x02\0\x12\x04\xb3\x01\x08A\x1a\x19\x20Required.\x20Package\x20n\
    ame.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x05\x02\0\x05\x12\x04\xb3\
    \x01\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x05\x02\0\x01\x12\x04\
    \xb3\x01\x0f\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x05\x02\0\x03\x12\
    \x04\xb3\x01\x16\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x05\x02\0\x08\
    \x12\x04\xb3\x01\x18@\n\x16\n\x0e\x04\0\x03\x01\x03\x01\x03\x05\x02\0\
    \x08\x9c\x08\0\x12\x04\xb3\x01\x19?\nP\n\x08\x04\0\x03\x01\x03\x01\x03\
    \x06\x12\x06\xb7\x01\x06\xc0\x01\x07\x1a<\x20An\x20MSI\x20package.\x20MS\
    I\x20packages\x20only\x20support\x20INSTALLED\x20state.\n\n\x11\n\t\x04\
    \0\x03\x01\x03\x01\x03\x06\x01\x12\x04\xb7\x01\x0e\x11\n0\n\n\x04\0\x03\
    \x01\x03\x01\x03\x06\x02\0\x12\x04\xb9\x01\x08A\x1a\x1c\x20Required.\x20\
    The\x20MSI\x20package.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x06\x02\0\
    \x06\x12\x04\xb9\x01\x08\x0c\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x06\
    \x02\0\x01\x12\x04\xb9\x01\r\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\
    \x06\x02\0\x03\x12\x04\xb9\x01\x16\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x01\
    \x03\x06\x02\0\x08\x12\x04\xb9\x01\x18@\n\x16\n\x0e\x04\0\x03\x01\x03\
    \x01\x03\x06\x02\0\x08\x9c\x08\0\x12\x04\xb9\x01\x19?\n\xc1\x01\n\n\x04\
    \0\x03\x01\x03\x01\x03\x06\x02\x01\x12\x04\xbf\x01\x08'\x1a\xac\x01\x20A\
    dditional\x20properties\x20to\x20use\x20during\x20installation.\n\x20Thi\
    s\x20should\x20be\x20in\x20the\x20format\x20of\x20Property=Setting.\n\
    \x20Appended\x20to\x20the\x20defaults\x20of\x20`ACTION=INSTALL\n\x20REBO\
    OT=ReallySuppress`.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x06\x02\x01\
    \x04\x12\x04\xbf\x01\x08\x10\n\x13\n\x0b\x04\0\x03\x01\x03\x01\x03\x06\
    \x02\x01\x05\x12\x04\xbf\x01\x11\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x01\
    \x03\x06\x02\x01\x01\x12\x04\xbf\x01\x18\"\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x01\x03\x06\x02\x01\x03\x12\x04\xbf\x01%&\n[\n\x08\x04\0\x03\x01\x03\
    \x01\x02\0\x12\x04\xc3\x01\x06N\x1aI\x20Required.\x20The\x20desired\x20s\
    tate\x20the\x20agent\x20should\x20maintain\x20for\x20this\x20package.\n\
    \n\x11\n\t\x04\0\x03\x01\x03\x01\x02\0\x06\x12\x04\xc3\x01\x06\x12\n\x11\
    \n\t\x04\0\x03\x01\x03\x01\x02\0\x01\x12\x04\xc3\x01\x13\x20\n\x11\n\t\
    \x04\0\x03\x01\x03\x01\x02\0\x03\x12\x04\xc3\x01#$\n\x11\n\t\x04\0\x03\
    \x01\x03\x01\x02\0\x08\x12\x04\xc3\x01%M\n\x14\n\x0c\x04\0\x03\x01\x03\
    \x01\x02\0\x08\x9c\x08\0\x12\x04\xc3\x01&L\n'\n\x08\x04\0\x03\x01\x03\
    \x01\x08\0\x12\x06\xc6\x01\x06\xdb\x01\x07\x1a\x13\x20A\x20system\x20pac\
    kage.\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x08\0\x01\x12\x04\xc6\x01\x0c\
    \x1a\n-\n\x08\x04\0\x03\x01\x03\x01\x02\x01\x12\x04\xc8\x01\x08\x14\x1a\
    \x1b\x20A\x20package\x20managed\x20by\x20Apt.\n\n\x11\n\t\x04\0\x03\x01\
    \x03\x01\x02\x01\x06\x12\x04\xc8\x01\x08\x0b\n\x11\n\t\x04\0\x03\x01\x03\
    \x01\x02\x01\x01\x12\x04\xc8\x01\x0c\x0f\n\x11\n\t\x04\0\x03\x01\x03\x01\
    \x02\x01\x03\x12\x04\xc8\x01\x12\x13\n'\n\x08\x04\0\x03\x01\x03\x01\x02\
    \x02\x12\x04\xcb\x01\x08\x14\x1a\x15\x20A\x20deb\x20package\x20file.\n\n\
    \x11\n\t\x04\0\x03\x01\x03\x01\x02\x02\x06\x12\x04\xcb\x01\x08\x0b\n\x11\
    \n\t\x04\0\x03\x01\x03\x01\x02\x02\x01\x12\x04\xcb\x01\x0c\x0f\n\x11\n\t\
    \x04\0\x03\x01\x03\x01\x02\x02\x03\x12\x04\xcb\x01\x12\x13\n-\n\x08\x04\
    \0\x03\x01\x03\x01\x02\x03\x12\x04\xce\x01\x08\x14\x1a\x1b\x20A\x20packa\
    ge\x20managed\x20by\x20YUM.\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x03\
    \x06\x12\x04\xce\x01\x08\x0b\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x03\x01\
    \x12\x04\xce\x01\x0c\x0f\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x03\x03\x12\
    \x04\xce\x01\x12\x13\n0\n\x08\x04\0\x03\x01\x03\x01\x02\x04\x12\x04\xd1\
    \x01\x08\x1a\x1a\x1e\x20A\x20package\x20managed\x20by\x20Zypper.\n\n\x11\
    \n\t\x04\0\x03\x01\x03\x01\x02\x04\x06\x12\x04\xd1\x01\x08\x0e\n\x11\n\t\
    \x04\0\x03\x01\x03\x01\x02\x04\x01\x12\x04\xd1\x01\x0f\x15\n\x11\n\t\x04\
    \0\x03\x01\x03\x01\x02\x04\x03\x12\x04\xd1\x01\x18\x19\n(\n\x08\x04\0\
    \x03\x01\x03\x01\x02\x05\x12\x04\xd4\x01\x08\x14\x1a\x16\x20An\x20rpm\
    \x20package\x20file.\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x05\x06\x12\
    \x04\xd4\x01\x08\x0b\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x05\x01\x12\x04\
    \xd4\x01\x0c\x0f\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x05\x03\x12\x04\xd4\
    \x01\x12\x13\n0\n\x08\x04\0\x03\x01\x03\x01\x02\x06\x12\x04\xd7\x01\x08\
    \x1a\x1a\x1e\x20A\x20package\x20managed\x20by\x20GooGet.\n\n\x11\n\t\x04\
    \0\x03\x01\x03\x01\x02\x06\x06\x12\x04\xd7\x01\x08\x0e\n\x11\n\t\x04\0\
    \x03\x01\x03\x01\x02\x06\x01\x12\x04\xd7\x01\x0f\x15\n\x11\n\t\x04\0\x03\
    \x01\x03\x01\x02\x06\x03\x12\x04\xd7\x01\x18\x19\n#\n\x08\x04\0\x03\x01\
    \x03\x01\x02\x07\x12\x04\xda\x01\x08\x14\x1a\x11\x20An\x20MSI\x20package\
    .\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x07\x06\x12\x04\xda\x01\x08\x0b\
    \n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x07\x01\x12\x04\xda\x01\x0c\x0f\n\
    \x11\n\t\x04\0\x03\x01\x03\x01\x02\x07\x03\x12\x04\xda\x01\x12\x13\nA\n\
    \x06\x04\0\x03\x01\x03\x02\x12\x06\xdf\x01\x04\xc3\x02\x05\x1a/\x20A\x20\
    resource\x20that\x20manages\x20a\x20package\x20repository.\n\n\x0f\n\x07\
    \x04\0\x03\x01\x03\x02\x01\x12\x04\xdf\x01\x0c\x1e\n\xaf\x01\n\x08\x04\0\
    \x03\x01\x03\x02\x03\0\x12\x06\xe3\x01\x06\x80\x02\x07\x1a\x9a\x01\x20Re\
    presents\x20a\x20single\x20apt\x20package\x20repository.\x20These\x20wil\
    l\x20be\x20added\x20to\n\x20a\x20repo\x20file\x20that\x20will\x20be\x20m\
    anaged\x20at\n\x20`/etc/apt/sources.list.d/google_osconfig.list`.\n\n\
    \x11\n\t\x04\0\x03\x01\x03\x02\x03\0\x01\x12\x04\xe3\x01\x0e\x1b\n(\n\n\
    \x04\0\x03\x01\x03\x02\x03\0\x04\0\x12\x06\xe5\x01\x08\xee\x01\t\x1a\x12\
    \x20Type\x20of\x20archive.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x04\
    \0\x01\x12\x04\xe5\x01\r\x18\n/\n\x0c\x04\0\x03\x01\x03\x02\x03\0\x04\0\
    \x02\0\x12\x04\xe7\x01\n'\x1a\x19\x20Unspecified\x20is\x20invalid.\n\n\
    \x15\n\r\x04\0\x03\x01\x03\x02\x03\0\x04\0\x02\0\x01\x12\x04\xe7\x01\n\"\
    \n\x15\n\r\x04\0\x03\x01\x03\x02\x03\0\x04\0\x02\0\x02\x12\x04\xe7\x01%&\
    \nM\n\x0c\x04\0\x03\x01\x03\x02\x03\0\x04\0\x02\x01\x12\x04\xea\x01\n\
    \x12\x1a7\x20Deb\x20indicates\x20that\x20the\x20archive\x20contains\x20b\
    inary\x20files.\n\n\x15\n\r\x04\0\x03\x01\x03\x02\x03\0\x04\0\x02\x01\
    \x01\x12\x04\xea\x01\n\r\n\x15\n\r\x04\0\x03\x01\x03\x02\x03\0\x04\0\x02\
    \x01\x02\x12\x04\xea\x01\x10\x11\nQ\n\x0c\x04\0\x03\x01\x03\x02\x03\0\
    \x04\0\x02\x02\x12\x04\xed\x01\n\x16\x1a;\x20Deb-src\x20indicates\x20tha\
    t\x20the\x20archive\x20contains\x20source\x20files.\n\n\x15\n\r\x04\0\
    \x03\x01\x03\x02\x03\0\x04\0\x02\x02\x01\x12\x04\xed\x01\n\x11\n\x15\n\r\
    \x04\0\x03\x01\x03\x02\x03\0\x04\0\x02\x02\x02\x12\x04\xed\x01\x14\x15\n\
    I\n\n\x04\0\x03\x01\x03\x02\x03\0\x02\0\x12\x04\xf1\x01\x08N\x1a5\x20Req\
    uired.\x20Type\x20of\x20archive\x20files\x20in\x20this\x20repository.\n\
    \n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\0\x06\x12\x04\xf1\x01\x08\
    \x13\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\0\x01\x12\x04\xf1\x01\
    \x14\x20\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\0\x03\x12\x04\xf1\
    \x01#$\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\0\x08\x12\x04\xf1\x01\
    %M\n\x16\n\x0e\x04\0\x03\x01\x03\x02\x03\0\x02\0\x08\x9c\x08\0\x12\x04\
    \xf1\x01&L\n8\n\n\x04\0\x03\x01\x03\x02\x03\0\x02\x01\x12\x04\xf4\x01\
    \x08@\x1a$\x20Required.\x20URI\x20for\x20this\x20repository.\n\n\x13\n\
    \x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x01\x05\x12\x04\xf4\x01\x08\x0e\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x01\x01\x12\x04\xf4\x01\x0f\
    \x12\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x01\x03\x12\x04\xf4\x01\
    \x15\x16\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x01\x08\x12\x04\xf4\
    \x01\x17?\n\x16\n\x0e\x04\0\x03\x01\x03\x02\x03\0\x02\x01\x08\x9c\x08\0\
    \x12\x04\xf4\x01\x18>\n@\n\n\x04\0\x03\x01\x03\x02\x03\0\x02\x02\x12\x04\
    \xf7\x01\x08I\x1a,\x20Required.\x20Distribution\x20of\x20this\x20reposit\
    ory.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x02\x05\x12\x04\xf7\
    \x01\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x02\x01\x12\x04\
    \xf7\x01\x0f\x1b\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x02\x03\x12\
    \x04\xf7\x01\x1e\x1f\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x02\x08\
    \x12\x04\xf7\x01\x20H\n\x16\n\x0e\x04\0\x03\x01\x03\x02\x03\0\x02\x02\
    \x08\x9c\x08\0\x12\x04\xf7\x01!G\nh\n\n\x04\0\x03\x01\x03\x02\x03\0\x02\
    \x03\x12\x04\xfb\x01\x08P\x1aT\x20Required.\x20List\x20of\x20components\
    \x20for\x20this\x20repository.\x20Must\x20contain\x20at\n\x20least\x20on\
    e\x20item.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x03\x04\x12\x04\
    \xfb\x01\x08\x10\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x03\x05\x12\
    \x04\xfb\x01\x11\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x03\x01\
    \x12\x04\xfb\x01\x18\"\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x03\
    \x03\x12\x04\xfb\x01%&\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x03\
    \x08\x12\x04\xfb\x01'O\n\x16\n\x0e\x04\0\x03\x01\x03\x02\x03\0\x02\x03\
    \x08\x9c\x08\0\x12\x04\xfb\x01(N\n\x96\x01\n\n\x04\0\x03\x01\x03\x02\x03\
    \0\x02\x04\x12\x04\xff\x01\x08\x1b\x1a\x81\x01\x20URI\x20of\x20the\x20ke\
    y\x20file\x20for\x20this\x20repository.\x20The\x20agent\x20maintains\x20\
    a\n\x20keyring\x20at\x20`/etc/apt/trusted.gpg.d/osconfig_agent_managed.g\
    pg`.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x04\x05\x12\x04\xff\
    \x01\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x04\x01\x12\x04\
    \xff\x01\x0f\x16\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\0\x02\x04\x03\x12\
    \x04\xff\x01\x19\x1a\n\x9f\x01\n\x08\x04\0\x03\x01\x03\x02\x03\x01\x12\
    \x06\x85\x02\x06\x94\x02\x07\x1a\x8a\x01\x20Represents\x20a\x20single\
    \x20yum\x20package\x20repository.\x20These\x20are\x20added\x20to\x20a\n\
    \x20repo\x20file\x20that\x20is\x20managed\x20at\n\x20`/etc/yum.repos.d/g\
    oogle_osconfig.repo`.\n\n\x11\n\t\x04\0\x03\x01\x03\x02\x03\x01\x01\x12\
    \x04\x85\x02\x0e\x1b\n\x8c\x02\n\n\x04\0\x03\x01\x03\x02\x03\x01\x02\0\
    \x12\x04\x8a\x02\x08?\x1a\xf7\x01\x20Required.\x20A\x20one\x20word,\x20u\
    nique\x20name\x20for\x20this\x20repository.\x20This\x20is\x20\x20the\n\
    \x20`repo\x20id`\x20in\x20the\x20yum\x20config\x20file\x20and\x20also\
    \x20the\x20`display_name`\x20if\n\x20`display_name`\x20is\x20omitted.\
    \x20This\x20id\x20is\x20also\x20used\x20as\x20the\x20unique\n\x20identif\
    ier\x20when\x20checking\x20for\x20resource\x20conflicts.\n\n\x13\n\x0b\
    \x04\0\x03\x01\x03\x02\x03\x01\x02\0\x05\x12\x04\x8a\x02\x08\x0e\n\x13\n\
    \x0b\x04\0\x03\x01\x03\x02\x03\x01\x02\0\x01\x12\x04\x8a\x02\x0f\x11\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x01\x02\0\x03\x12\x04\x8a\x02\x14\
    \x15\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x01\x02\0\x08\x12\x04\x8a\x02\
    \x16>\n\x16\n\x0e\x04\0\x03\x01\x03\x02\x03\x01\x02\0\x08\x9c\x08\0\x12\
    \x04\x8a\x02\x17=\n9\n\n\x04\0\x03\x01\x03\x02\x03\x01\x02\x01\x12\x04\
    \x8d\x02\x08\x20\x1a%\x20The\x20display\x20name\x20of\x20the\x20reposito\
    ry.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x01\x02\x01\x05\x12\x04\x8d\
    \x02\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x01\x02\x01\x01\x12\
    \x04\x8d\x02\x0f\x1b\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x01\x02\x01\
    \x03\x12\x04\x8d\x02\x1e\x1f\nI\n\n\x04\0\x03\x01\x03\x02\x03\x01\x02\
    \x02\x12\x04\x90\x02\x08E\x1a5\x20Required.\x20The\x20location\x20of\x20\
    the\x20repository\x20directory.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\
    \x01\x02\x02\x05\x12\x04\x90\x02\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x02\x03\x01\x02\x02\x01\x12\x04\x90\x02\x0f\x17\n\x13\n\x0b\x04\0\x03\
    \x01\x03\x02\x03\x01\x02\x02\x03\x12\x04\x90\x02\x1a\x1b\n\x13\n\x0b\x04\
    \0\x03\x01\x03\x02\x03\x01\x02\x02\x08\x12\x04\x90\x02\x1cD\n\x16\n\x0e\
    \x04\0\x03\x01\x03\x02\x03\x01\x02\x02\x08\x9c\x08\0\x12\x04\x90\x02\x1d\
    C\n'\n\n\x04\0\x03\x01\x03\x02\x03\x01\x02\x03\x12\x04\x93\x02\x08%\x1a\
    \x13\x20URIs\x20of\x20GPG\x20keys.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\
    \x03\x01\x02\x03\x04\x12\x04\x93\x02\x08\x10\n\x13\n\x0b\x04\0\x03\x01\
    \x03\x02\x03\x01\x02\x03\x05\x12\x04\x93\x02\x11\x17\n\x13\n\x0b\x04\0\
    \x03\x01\x03\x02\x03\x01\x02\x03\x01\x12\x04\x93\x02\x18\x20\n\x13\n\x0b\
    \x04\0\x03\x01\x03\x02\x03\x01\x02\x03\x03\x12\x04\x93\x02#$\n\xa3\x01\n\
    \x08\x04\0\x03\x01\x03\x02\x03\x02\x12\x06\x99\x02\x06\xa8\x02\x07\x1a\
    \x8e\x01\x20Represents\x20a\x20single\x20zypper\x20package\x20repository\
    .\x20These\x20are\x20added\x20to\x20a\n\x20repo\x20file\x20that\x20is\
    \x20managed\x20at\n\x20`/etc/zypp/repos.d/google_osconfig.repo`.\n\n\x11\
    \n\t\x04\0\x03\x01\x03\x02\x03\x02\x01\x12\x04\x99\x02\x0e\x1e\n\x91\x02\
    \n\n\x04\0\x03\x01\x03\x02\x03\x02\x02\0\x12\x04\x9e\x02\x08?\x1a\xfc\
    \x01\x20Required.\x20A\x20one\x20word,\x20unique\x20name\x20for\x20this\
    \x20repository.\x20This\x20is\x20the\n\x20`repo\x20id`\x20in\x20the\x20z\
    ypper\x20config\x20file\x20and\x20also\x20the\x20`display_name`\x20if\n\
    \x20`display_name`\x20is\x20omitted.\x20This\x20id\x20is\x20also\x20used\
    \x20as\x20the\x20unique\n\x20identifier\x20when\x20checking\x20for\x20Gu\
    estPolicy\x20conflicts.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\
    \0\x05\x12\x04\x9e\x02\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\
    \x02\0\x01\x12\x04\x9e\x02\x0f\x11\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\
    \x02\x02\0\x03\x12\x04\x9e\x02\x14\x15\n\x13\n\x0b\x04\0\x03\x01\x03\x02\
    \x03\x02\x02\0\x08\x12\x04\x9e\x02\x16>\n\x16\n\x0e\x04\0\x03\x01\x03\
    \x02\x03\x02\x02\0\x08\x9c\x08\0\x12\x04\x9e\x02\x17=\n9\n\n\x04\0\x03\
    \x01\x03\x02\x03\x02\x02\x01\x12\x04\xa1\x02\x08\x20\x1a%\x20The\x20disp\
    lay\x20name\x20of\x20the\x20repository.\n\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x02\x03\x02\x02\x01\x05\x12\x04\xa1\x02\x08\x0e\n\x13\n\x0b\x04\0\x03\
    \x01\x03\x02\x03\x02\x02\x01\x01\x12\x04\xa1\x02\x0f\x1b\n\x13\n\x0b\x04\
    \0\x03\x01\x03\x02\x03\x02\x02\x01\x03\x12\x04\xa1\x02\x1e\x1f\nI\n\n\
    \x04\0\x03\x01\x03\x02\x03\x02\x02\x02\x12\x04\xa4\x02\x08E\x1a5\x20Requ\
    ired.\x20The\x20location\x20of\x20the\x20repository\x20directory.\n\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\x02\x05\x12\x04\xa4\x02\x08\
    \x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\x02\x01\x12\x04\xa4\
    \x02\x0f\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\x02\x03\x12\
    \x04\xa4\x02\x1a\x1b\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\x02\
    \x08\x12\x04\xa4\x02\x1cD\n\x16\n\x0e\x04\0\x03\x01\x03\x02\x03\x02\x02\
    \x02\x08\x9c\x08\0\x12\x04\xa4\x02\x1dC\n'\n\n\x04\0\x03\x01\x03\x02\x03\
    \x02\x02\x03\x12\x04\xa7\x02\x08%\x1a\x13\x20URIs\x20of\x20GPG\x20keys.\
    \n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\x03\x04\x12\x04\xa7\x02\
    \x08\x10\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\x03\x05\x12\x04\
    \xa7\x02\x11\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\x03\x01\
    \x12\x04\xa7\x02\x18\x20\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x02\x02\
    \x03\x03\x12\x04\xa7\x02#$\n\xa3\x01\n\x08\x04\0\x03\x01\x03\x02\x03\x03\
    \x12\x06\xad\x02\x06\xb3\x02\x07\x1a\x8e\x01\x20Represents\x20a\x20Goo\
    \x20package\x20repository.\x20These\x20are\x20added\x20to\x20a\x20repo\
    \x20file\n\x20that\x20is\x20managed\x20at\n\x20`C:/ProgramData/GooGet/re\
    pos/google_osconfig.repo`.\n\n\x11\n\t\x04\0\x03\x01\x03\x02\x03\x03\x01\
    \x12\x04\xad\x02\x0e\x1b\n;\n\n\x04\0\x03\x01\x03\x02\x03\x03\x02\0\x12\
    \x04\xaf\x02\x08A\x1a'\x20Required.\x20The\x20name\x20of\x20the\x20repos\
    itory.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x03\x02\0\x05\x12\x04\xaf\
    \x02\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x03\x02\0\x01\x12\x04\
    \xaf\x02\x0f\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x03\x02\0\x03\x12\
    \x04\xaf\x02\x16\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x03\x02\0\x08\
    \x12\x04\xaf\x02\x18@\n\x16\n\x0e\x04\0\x03\x01\x03\x02\x03\x03\x02\0\
    \x08\x9c\x08\0\x12\x04\xaf\x02\x19?\n:\n\n\x04\0\x03\x01\x03\x02\x03\x03\
    \x02\x01\x12\x04\xb2\x02\x08@\x1a&\x20Required.\x20The\x20url\x20of\x20t\
    he\x20repository.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x03\x02\x01\
    \x05\x12\x04\xb2\x02\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x02\x03\x03\
    \x02\x01\x01\x12\x04\xb2\x02\x0f\x12\n\x13\n\x0b\x04\0\x03\x01\x03\x02\
    \x03\x03\x02\x01\x03\x12\x04\xb2\x02\x15\x16\n\x13\n\x0b\x04\0\x03\x01\
    \x03\x02\x03\x03\x02\x01\x08\x12\x04\xb2\x02\x17?\n\x16\n\x0e\x04\0\x03\
    \x01\x03\x02\x03\x03\x02\x01\x08\x9c\x08\0\x12\x04\xb2\x02\x18>\n4\n\x08\
    \x04\0\x03\x01\x03\x02\x08\0\x12\x06\xb6\x02\x06\xc2\x02\x07\x1a\x20\x20\
    A\x20specific\x20type\x20of\x20repository.\n\n\x11\n\t\x04\0\x03\x01\x03\
    \x02\x08\0\x01\x12\x04\xb6\x02\x0c\x16\n&\n\x08\x04\0\x03\x01\x03\x02\
    \x02\0\x12\x04\xb8\x02\x08\x1e\x1a\x14\x20An\x20Apt\x20Repository.\n\n\
    \x11\n\t\x04\0\x03\x01\x03\x02\x02\0\x06\x12\x04\xb8\x02\x08\x15\n\x11\n\
    \t\x04\0\x03\x01\x03\x02\x02\0\x01\x12\x04\xb8\x02\x16\x19\n\x11\n\t\x04\
    \0\x03\x01\x03\x02\x02\0\x03\x12\x04\xb8\x02\x1c\x1d\n%\n\x08\x04\0\x03\
    \x01\x03\x02\x02\x01\x12\x04\xbb\x02\x08\x1e\x1a\x13\x20A\x20Yum\x20Repo\
    sitory.\n\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x01\x06\x12\x04\xbb\x02\
    \x08\x15\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x01\x01\x12\x04\xbb\x02\x16\
    \x19\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x01\x03\x12\x04\xbb\x02\x1c\x1d\
    \n(\n\x08\x04\0\x03\x01\x03\x02\x02\x02\x12\x04\xbe\x02\x08$\x1a\x16\x20\
    A\x20Zypper\x20Repository.\n\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x02\x06\
    \x12\x04\xbe\x02\x08\x18\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x02\x01\x12\
    \x04\xbe\x02\x19\x1f\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x02\x03\x12\x04\
    \xbe\x02\"#\n%\n\x08\x04\0\x03\x01\x03\x02\x02\x03\x12\x04\xc1\x02\x08\
    \x1e\x1a\x13\x20A\x20Goo\x20Repository.\n\n\x11\n\t\x04\0\x03\x01\x03\
    \x02\x02\x03\x06\x12\x04\xc1\x02\x08\x15\n\x11\n\t\x04\0\x03\x01\x03\x02\
    \x02\x03\x01\x12\x04\xc1\x02\x16\x19\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\
    \x03\x03\x12\x04\xc1\x02\x1c\x1d\n\x8a\x0b\n\x06\x04\0\x03\x01\x03\x03\
    \x12\x06\xdf\x02\x04\x99\x03\x05\x1a\xf7\n\x20A\x20resource\x20that\x20a\
    llows\x20executing\x20scripts\x20on\x20the\x20VM.\n\n\x20The\x20`ExecRes\
    ource`\x20has\x202\x20stages:\x20`validate`\x20and\x20`enforce`\x20and\
    \x20both\x20stages\n\x20accept\x20a\x20script\x20as\x20an\x20argument\
    \x20to\x20execute.\n\n\x20When\x20the\x20`ExecResource`\x20is\x20applied\
    \x20by\x20the\x20agent,\x20it\x20first\x20executes\x20the\n\x20script\
    \x20in\x20the\x20`validate`\x20stage.\x20The\x20`validate`\x20stage\x20c\
    an\x20signal\x20that\x20the\n\x20`ExecResource`\x20is\x20already\x20in\
    \x20the\x20desired\x20state\x20by\x20returning\x20an\x20exit\x20code\n\
    \x20of\x20`100`.\x20If\x20the\x20`ExecResource`\x20is\x20not\x20in\x20th\
    e\x20desired\x20state,\x20it\x20should\n\x20return\x20an\x20exit\x20code\
    \x20of\x20`101`.\x20Any\x20other\x20exit\x20code\x20returned\x20by\x20th\
    is\x20stage\n\x20is\x20considered\x20an\x20error.\n\n\x20If\x20the\x20`E\
    xecResource`\x20is\x20not\x20in\x20the\x20desired\x20state\x20based\x20o\
    n\x20the\x20exit\x20code\n\x20from\x20the\x20`validate`\x20stage,\x20the\
    \x20agent\x20proceeds\x20to\x20execute\x20the\x20script\x20from\n\x20the\
    \x20`enforce`\x20stage.\x20If\x20the\x20`ExecResource`\x20is\x20already\
    \x20in\x20the\x20desired\n\x20state,\x20the\x20`enforce`\x20stage\x20wil\
    l\x20not\x20be\x20run.\n\x20Similar\x20to\x20`validate`\x20stage,\x20the\
    \x20`enforce`\x20stage\x20should\x20return\x20an\x20exit\n\x20code\x20of\
    \x20`100`\x20to\x20indicate\x20that\x20the\x20resource\x20in\x20now\x20i\
    n\x20its\x20desired\x20state.\n\x20Any\x20other\x20exit\x20code\x20is\
    \x20considered\x20an\x20error.\n\n\x20NOTE:\x20An\x20exit\x20code\x20of\
    \x20`100`\x20was\x20chosen\x20over\x20`0`\x20(and\x20`101`\x20vs\x20`1`)\
    \x20to\n\x20have\x20an\x20explicit\x20indicator\x20of\x20`in\x20desired\
    \x20state`,\x20`not\x20in\x20desired\x20state`\n\x20and\x20errors.\x20Be\
    cause,\x20for\x20example,\x20Powershell\x20will\x20always\x20return\x20a\
    n\x20exit\n\x20code\x20of\x20`0`\x20unless\x20an\x20`exit`\x20statement\
    \x20is\x20provided\x20in\x20the\x20script.\x20So,\x20for\n\x20reasons\
    \x20of\x20consistency\x20and\x20being\x20explicit,\x20exit\x20codes\x20`\
    100`\x20and\x20`101`\n\x20were\x20chosen.\n\n\x0f\n\x07\x04\0\x03\x01\
    \x03\x03\x01\x12\x04\xdf\x02\x0c\x18\n2\n\x08\x04\0\x03\x01\x03\x03\x03\
    \0\x12\x06\xe1\x02\x06\x8d\x03\x07\x1a\x1e\x20A\x20file\x20or\x20script\
    \x20to\x20execute.\n\n\x11\n\t\x04\0\x03\x01\x03\x03\x03\0\x01\x12\x04\
    \xe1\x02\x0e\x12\n/\n\n\x04\0\x03\x01\x03\x03\x03\0\x04\0\x12\x06\xe3\
    \x02\x08\xf4\x02\t\x1a\x19\x20The\x20interpreter\x20to\x20use.\n\n\x13\n\
    \x0b\x04\0\x03\x01\x03\x03\x03\0\x04\0\x01\x12\x04\xe3\x02\r\x18\nP\n\
    \x0c\x04\0\x03\x01\x03\x03\x03\0\x04\0\x02\0\x12\x04\xe5\x02\n&\x1a:\x20\
    Invalid\x20value,\x20the\x20request\x20will\x20return\x20validation\x20e\
    rror.\n\n\x15\n\r\x04\0\x03\x01\x03\x03\x03\0\x04\0\x02\0\x01\x12\x04\
    \xe5\x02\n!\n\x15\n\r\x04\0\x03\x01\x03\x03\x03\0\x04\0\x02\0\x02\x12\
    \x04\xe5\x02$%\n\x98\x02\n\x0c\x04\0\x03\x01\x03\x03\x03\0\x04\0\x02\x01\
    \x12\x04\xec\x02\n\x13\x1a\x81\x02\x20If\x20an\x20interpreter\x20is\x20n\
    ot\x20specified,\x20the\n\x20source\x20is\x20executed\x20directly.\x20Th\
    is\x20execution,\x20without\x20an\n\x20interpreter,\x20only\x20succeeds\
    \x20for\x20executables\x20and\x20scripts\x20that\x20have\x20<a\n\x20href\
    =\"https://en.wikipedia.org/wiki/Shebang_(Unix)\"\n\x20class=\"external\
    \">shebang\x20lines</a>.\n\n\x15\n\r\x04\0\x03\x01\x03\x03\x03\0\x04\0\
    \x02\x01\x01\x12\x04\xec\x02\n\x0e\n\x15\n\r\x04\0\x03\x01\x03\x03\x03\0\
    \x04\0\x02\x01\x02\x12\x04\xec\x02\x11\x12\ni\n\x0c\x04\0\x03\x01\x03\
    \x03\x03\0\x04\0\x02\x02\x12\x04\xf0\x02\n\x14\x1aS\x20Indicates\x20that\
    \x20the\x20script\x20runs\x20with\x20`/bin/sh`\x20on\x20Linux\x20and\n\
    \x20`cmd.exe`\x20on\x20Windows.\n\n\x15\n\r\x04\0\x03\x01\x03\x03\x03\0\
    \x04\0\x02\x02\x01\x12\x04\xf0\x02\n\x0f\n\x15\n\r\x04\0\x03\x01\x03\x03\
    \x03\0\x04\0\x02\x02\x02\x12\x04\xf0\x02\x12\x13\nG\n\x0c\x04\0\x03\x01\
    \x03\x03\x03\0\x04\0\x02\x03\x12\x04\xf3\x02\n\x19\x1a1\x20Indicates\x20\
    that\x20the\x20script\x20runs\x20with\x20PowerShell.\n\n\x15\n\r\x04\0\
    \x03\x01\x03\x03\x03\0\x04\0\x02\x03\x01\x12\x04\xf3\x02\n\x14\n\x15\n\r\
    \x04\0\x03\x01\x03\x03\x03\0\x04\0\x02\x03\x02\x12\x04\xf3\x02\x17\x18\n\
    (\n\n\x04\0\x03\x01\x03\x03\x03\0\x08\0\x12\x06\xf7\x02\x08\xfe\x02\t\
    \x1a\x12\x20What\x20to\x20execute.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x03\
    \x03\0\x08\0\x01\x12\x04\xf7\x02\x0e\x14\n-\n\n\x04\0\x03\x01\x03\x03\
    \x03\0\x02\0\x12\x04\xf9\x02\n\x18\x1a\x19\x20A\x20remote\x20or\x20local\
    \x20file.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\0\x06\x12\x04\
    \xf9\x02\n\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\0\x01\x12\x04\
    \xf9\x02\x0f\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\0\x03\x12\
    \x04\xf9\x02\x16\x17\n^\n\n\x04\0\x03\x01\x03\x03\x03\0\x02\x01\x12\x04\
    \xfd\x02\n\x1c\x1aJ\x20An\x20inline\x20script.\n\x20The\x20size\x20of\
    \x20the\x20script\x20is\x20limited\x20to\x201024\x20characters.\n\n\x13\
    \n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\x01\x05\x12\x04\xfd\x02\n\x10\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\x01\x01\x12\x04\xfd\x02\x11\
    \x17\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\x01\x03\x12\x04\xfd\x02\
    \x1a\x1b\nP\n\n\x04\0\x03\x01\x03\x03\x03\0\x02\x02\x12\x04\x81\x03\x08!\
    \x1a<\x20Optional\x20arguments\x20to\x20pass\x20to\x20the\x20source\x20d\
    uring\x20execution.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\x02\
    \x04\x12\x04\x81\x03\x08\x10\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\
    \x02\x05\x12\x04\x81\x03\x11\x17\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\
    \x02\x02\x01\x12\x04\x81\x03\x18\x1c\n\x13\n\x0b\x04\0\x03\x01\x03\x03\
    \x03\0\x02\x02\x03\x12\x04\x81\x03\x1f\x20\n>\n\n\x04\0\x03\x01\x03\x03\
    \x03\0\x02\x03\x12\x04\x84\x03\x08M\x1a*\x20Required.\x20The\x20script\
    \x20interpreter\x20to\x20use.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\
    \x02\x03\x06\x12\x04\x84\x03\x08\x13\n\x13\n\x0b\x04\0\x03\x01\x03\x03\
    \x03\0\x02\x03\x01\x12\x04\x84\x03\x14\x1f\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x03\x03\0\x02\x03\x03\x12\x04\x84\x03\"#\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x03\x03\0\x02\x03\x08\x12\x04\x84\x03$L\n\x16\n\x0e\x04\0\x03\x01\x03\
    \x03\x03\0\x02\x03\x08\x9c\x08\0\x12\x04\x84\x03%K\n\xcc\x02\n\n\x04\0\
    \x03\x01\x03\x03\x03\0\x02\x04\x12\x04\x8c\x03\x08$\x1a\xb7\x02\x20Only\
    \x20recorded\x20for\x20enforce\x20Exec.\n\x20Path\x20to\x20an\x20output\
    \x20file\x20(that\x20is\x20created\x20by\x20this\x20Exec)\x20whose\n\x20\
    content\x20will\x20be\x20recorded\x20in\x20OSPolicyResourceCompliance\
    \x20after\x20a\n\x20successful\x20run.\x20Absence\x20or\x20failure\x20to\
    \x20read\x20this\x20file\x20will\x20result\x20in\n\x20this\x20ExecResour\
    ce\x20being\x20non-compliant.\x20Output\x20file\x20size\x20is\x20limited\
    \x20to\n\x20100K\x20bytes.\n\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\x02\
    \x04\x05\x12\x04\x8c\x03\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\x03\x03\x03\0\
    \x02\x04\x01\x12\x04\x8c\x03\x0f\x1f\n\x13\n\x0b\x04\0\x03\x01\x03\x03\
    \x03\0\x02\x04\x03\x12\x04\x8c\x03\"#\n\x83\x02\n\x08\x04\0\x03\x01\x03\
    \x03\x02\0\x12\x04\x93\x03\x06A\x1a\xf0\x01\x20Required.\x20What\x20to\
    \x20run\x20to\x20validate\x20this\x20resource\x20is\x20in\x20the\x20desi\
    red\n\x20state.\x20An\x20exit\x20code\x20of\x20100\x20indicates\x20\"in\
    \x20desired\x20state\",\x20and\x20exit\x20code\n\x20of\x20101\x20indicat\
    es\x20\"not\x20in\x20desired\x20state\".\x20Any\x20other\x20exit\x20code\
    \x20indicates\n\x20a\x20failure\x20running\x20validate.\n\n\x11\n\t\x04\
    \0\x03\x01\x03\x03\x02\0\x06\x12\x04\x93\x03\x06\n\n\x11\n\t\x04\0\x03\
    \x01\x03\x03\x02\0\x01\x12\x04\x93\x03\x0b\x13\n\x11\n\t\x04\0\x03\x01\
    \x03\x03\x02\0\x03\x12\x04\x93\x03\x16\x17\n\x11\n\t\x04\0\x03\x01\x03\
    \x03\x02\0\x08\x12\x04\x93\x03\x18@\n\x14\n\x0c\x04\0\x03\x01\x03\x03\
    \x02\0\x08\x9c\x08\0\x12\x04\x93\x03\x19?\n\xb3\x01\n\x08\x04\0\x03\x01\
    \x03\x03\x02\x01\x12\x04\x98\x03\x06\x17\x1a\xa0\x01\x20What\x20to\x20ru\
    n\x20to\x20bring\x20this\x20resource\x20into\x20the\x20desired\x20state.\
    \n\x20An\x20exit\x20code\x20of\x20100\x20indicates\x20\"success\",\x20an\
    y\x20other\x20exit\x20code\x20indicates\n\x20a\x20failure\x20running\x20\
    enforce.\n\n\x11\n\t\x04\0\x03\x01\x03\x03\x02\x01\x06\x12\x04\x98\x03\
    \x06\n\n\x11\n\t\x04\0\x03\x01\x03\x03\x02\x01\x01\x12\x04\x98\x03\x0b\
    \x12\n\x11\n\t\x04\0\x03\x01\x03\x03\x02\x01\x03\x12\x04\x98\x03\x15\x16\
    \n@\n\x06\x04\0\x03\x01\x03\x04\x12\x06\x9c\x03\x04\xcb\x03\x05\x1a.\x20\
    A\x20resource\x20that\x20manages\x20the\x20state\x20of\x20a\x20file.\n\n\
    \x0f\n\x07\x04\0\x03\x01\x03\x04\x01\x12\x04\x9c\x03\x0c\x18\n0\n\x08\
    \x04\0\x03\x01\x03\x04\x04\0\x12\x06\x9e\x03\x06\xab\x03\x07\x1a\x1c\x20\
    Desired\x20state\x20of\x20the\x20file.\n\n\x11\n\t\x04\0\x03\x01\x03\x04\
    \x04\0\x01\x12\x04\x9e\x03\x0b\x17\n-\n\n\x04\0\x03\x01\x03\x04\x04\0\
    \x02\0\x12\x04\xa0\x03\x08&\x1a\x19\x20Unspecified\x20is\x20invalid.\n\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x04\x04\0\x02\0\x01\x12\x04\xa0\x03\x08!\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x04\x04\0\x02\0\x02\x12\x04\xa0\x03$%\n5\n\
    \n\x04\0\x03\x01\x03\x04\x04\0\x02\x01\x12\x04\xa3\x03\x08\x14\x1a!\x20E\
    nsure\x20file\x20at\x20path\x20is\x20present.\n\n\x13\n\x0b\x04\0\x03\
    \x01\x03\x04\x04\0\x02\x01\x01\x12\x04\xa3\x03\x08\x0f\n\x13\n\x0b\x04\0\
    \x03\x01\x03\x04\x04\0\x02\x01\x02\x12\x04\xa3\x03\x12\x13\n4\n\n\x04\0\
    \x03\x01\x03\x04\x04\0\x02\x02\x12\x04\xa6\x03\x08\x13\x1a\x20\x20Ensure\
    \x20file\x20at\x20path\x20is\x20absent.\n\n\x13\n\x0b\x04\0\x03\x01\x03\
    \x04\x04\0\x02\x02\x01\x12\x04\xa6\x03\x08\x0e\n\x13\n\x0b\x04\0\x03\x01\
    \x03\x04\x04\0\x02\x02\x02\x12\x04\xa6\x03\x11\x12\nv\n\n\x04\0\x03\x01\
    \x03\x04\x04\0\x02\x03\x12\x04\xaa\x03\x08\x1b\x1ab\x20Ensure\x20the\x20\
    contents\x20of\x20the\x20file\x20at\x20path\x20matches.\x20If\x20the\x20\
    file\x20does\n\x20not\x20exist\x20it\x20will\x20be\x20created.\n\n\x13\n\
    \x0b\x04\0\x03\x01\x03\x04\x04\0\x02\x03\x01\x12\x04\xaa\x03\x08\x16\n\
    \x13\n\x0b\x04\0\x03\x01\x03\x04\x04\0\x02\x03\x02\x12\x04\xaa\x03\x19\
    \x1a\n>\n\x08\x04\0\x03\x01\x03\x04\x08\0\x12\x06\xae\x03\x06\xb5\x03\
    \x07\x1a*\x20The\x20source\x20for\x20the\x20contents\x20of\x20the\x20fil\
    e.\n\n\x11\n\t\x04\0\x03\x01\x03\x04\x08\0\x01\x12\x04\xae\x03\x0c\x12\n\
    -\n\x08\x04\0\x03\x01\x03\x04\x02\0\x12\x04\xb0\x03\x08\x16\x1a\x1b\x20A\
    \x20remote\x20or\x20local\x20source.\n\n\x11\n\t\x04\0\x03\x01\x03\x04\
    \x02\0\x06\x12\x04\xb0\x03\x08\x0c\n\x11\n\t\x04\0\x03\x01\x03\x04\x02\0\
    \x01\x12\x04\xb0\x03\r\x11\n\x11\n\t\x04\0\x03\x01\x03\x04\x02\0\x03\x12\
    \x04\xb0\x03\x14\x15\ng\n\x08\x04\0\x03\x01\x03\x04\x02\x01\x12\x04\xb4\
    \x03\x08\x1b\x1aU\x20A\x20a\x20file\x20with\x20this\x20content.\n\x20The\
    \x20size\x20of\x20the\x20content\x20is\x20limited\x20to\x201024\x20chara\
    cters.\n\n\x11\n\t\x04\0\x03\x01\x03\x04\x02\x01\x05\x12\x04\xb4\x03\x08\
    \x0e\n\x11\n\t\x04\0\x03\x01\x03\x04\x02\x01\x01\x12\x04\xb4\x03\x0f\x16\
    \n\x11\n\t\x04\0\x03\x01\x03\x04\x02\x01\x03\x12\x04\xb4\x03\x19\x1a\nJ\
    \n\x08\x04\0\x03\x01\x03\x04\x02\x02\x12\x04\xb8\x03\x06?\x1a8\x20Requir\
    ed.\x20The\x20absolute\x20path\x20of\x20the\x20file\x20within\x20the\x20\
    VM.\n\n\x11\n\t\x04\0\x03\x01\x03\x04\x02\x02\x05\x12\x04\xb8\x03\x06\
    \x0c\n\x11\n\t\x04\0\x03\x01\x03\x04\x02\x02\x01\x12\x04\xb8\x03\r\x11\n\
    \x11\n\t\x04\0\x03\x01\x03\x04\x02\x02\x03\x12\x04\xb8\x03\x14\x15\n\x11\
    \n\t\x04\0\x03\x01\x03\x04\x02\x02\x08\x12\x04\xb8\x03\x16>\n\x14\n\x0c\
    \x04\0\x03\x01\x03\x04\x02\x02\x08\x9c\x08\0\x12\x04\xb8\x03\x17=\n8\n\
    \x08\x04\0\x03\x01\x03\x04\x02\x03\x12\x04\xbb\x03\x06F\x1a&\x20Required\
    .\x20Desired\x20state\x20of\x20the\x20file.\n\n\x11\n\t\x04\0\x03\x01\
    \x03\x04\x02\x03\x06\x12\x04\xbb\x03\x06\x12\n\x11\n\t\x04\0\x03\x01\x03\
    \x04\x02\x03\x01\x12\x04\xbb\x03\x13\x18\n\x11\n\t\x04\0\x03\x01\x03\x04\
    \x02\x03\x03\x12\x04\xbb\x03\x1b\x1c\n\x11\n\t\x04\0\x03\x01\x03\x04\x02\
    \x03\x08\x12\x04\xbb\x03\x1dE\n\x14\n\x0c\x04\0\x03\x01\x03\x04\x02\x03\
    \x08\x9c\x08\0\x12\x04\xbb\x03\x1eD\n\xc7\x04\n\x08\x04\0\x03\x01\x03\
    \x04\x02\x04\x12\x04\xca\x03\x06\x1d\x1a\xb4\x04\x20Consists\x20of\x20th\
    ree\x20octal\x20digits\x20which\x20represent,\x20in\n\x20order,\x20the\
    \x20permissions\x20of\x20the\x20owner,\x20group,\x20and\x20other\x20user\
    s\x20for\x20the\n\x20file\x20(similarly\x20to\x20the\x20numeric\x20mode\
    \x20used\x20in\x20the\x20linux\x20chmod\n\x20utility).\x20Each\x20digit\
    \x20represents\x20a\x20three\x20bit\x20number\x20with\x20the\x204\x20bit\
    \n\x20corresponding\x20to\x20the\x20read\x20permissions,\x20the\x202\x20\
    bit\x20corresponds\x20to\x20the\n\x20write\x20bit,\x20and\x20the\x20one\
    \x20bit\x20corresponds\x20to\x20the\x20execute\x20permission.\n\x20Defau\
    lt\x20behavior\x20is\x20755.\n\n\x20Below\x20are\x20some\x20examples\x20\
    of\x20permissions\x20and\x20their\x20associated\x20values:\n\x20read,\
    \x20write,\x20and\x20execute:\x207\n\x20read\x20and\x20execute:\x205\n\
    \x20read\x20and\x20write:\x206\n\x20read\x20only:\x204\n\n\x11\n\t\x04\0\
    \x03\x01\x03\x04\x02\x04\x05\x12\x04\xca\x03\x06\x0c\n\x11\n\t\x04\0\x03\
    \x01\x03\x04\x02\x04\x01\x12\x04\xca\x03\r\x18\n\x11\n\t\x04\0\x03\x01\
    \x03\x04\x02\x04\x03\x12\x04\xca\x03\x1b\x1c\n\xa3\x02\n\x06\x04\0\x03\
    \x01\x02\0\x12\x04\xd4\x03\x04;\x1a\x92\x02\x20Required.\x20The\x20id\
    \x20of\x20the\x20resource\x20with\x20the\x20following\x20restrictions:\n\
    \n\x20*\x20Must\x20contain\x20only\x20lowercase\x20letters,\x20numbers,\
    \x20and\x20hyphens.\n\x20*\x20Must\x20start\x20with\x20a\x20letter.\n\
    \x20*\x20Must\x20be\x20between\x201-63\x20characters.\n\x20*\x20Must\x20\
    end\x20with\x20a\x20number\x20or\x20a\x20letter.\n\x20*\x20Must\x20be\
    \x20unique\x20within\x20the\x20OS\x20policy.\n\n\x0f\n\x07\x04\0\x03\x01\
    \x02\0\x05\x12\x04\xd4\x03\x04\n\n\x0f\n\x07\x04\0\x03\x01\x02\0\x01\x12\
    \x04\xd4\x03\x0b\r\n\x0f\n\x07\x04\0\x03\x01\x02\0\x03\x12\x04\xd4\x03\
    \x10\x11\n\x0f\n\x07\x04\0\x03\x01\x02\0\x08\x12\x04\xd4\x03\x12:\n\x12\
    \n\n\x04\0\x03\x01\x02\0\x08\x9c\x08\0\x12\x04\xd4\x03\x139\n\"\n\x06\
    \x04\0\x03\x01\x08\0\x12\x06\xd7\x03\x04\xe3\x03\x05\x1a\x10\x20Resource\
    \x20type.\n\n\x0f\n\x07\x04\0\x03\x01\x08\0\x01\x12\x04\xd7\x03\n\x17\n\
    \"\n\x06\x04\0\x03\x01\x02\x01\x12\x04\xd9\x03\x06\x1e\x1a\x12\x20Packag\
    e\x20resource\n\n\x0f\n\x07\x04\0\x03\x01\x02\x01\x06\x12\x04\xd9\x03\
    \x06\x15\n\x0f\n\x07\x04\0\x03\x01\x02\x01\x01\x12\x04\xd9\x03\x16\x19\n\
    \x0f\n\x07\x04\0\x03\x01\x02\x01\x03\x12\x04\xd9\x03\x1c\x1d\n-\n\x06\
    \x04\0\x03\x01\x02\x02\x12\x04\xdc\x03\x06(\x1a\x1d\x20Package\x20reposi\
    tory\x20resource\n\n\x0f\n\x07\x04\0\x03\x01\x02\x02\x06\x12\x04\xdc\x03\
    \x06\x18\n\x0f\n\x07\x04\0\x03\x01\x02\x02\x01\x12\x04\xdc\x03\x19#\n\
    \x0f\n\x07\x04\0\x03\x01\x02\x02\x03\x12\x04\xdc\x03&'\n\x1f\n\x06\x04\0\
    \x03\x01\x02\x03\x12\x04\xdf\x03\x06\x1c\x1a\x0f\x20Exec\x20resource\n\n\
    \x0f\n\x07\x04\0\x03\x01\x02\x03\x06\x12\x04\xdf\x03\x06\x12\n\x0f\n\x07\
    \x04\0\x03\x01\x02\x03\x01\x12\x04\xdf\x03\x13\x17\n\x0f\n\x07\x04\0\x03\
    \x01\x02\x03\x03\x12\x04\xdf\x03\x1a\x1b\n\x1f\n\x06\x04\0\x03\x01\x02\
    \x04\x12\x04\xe2\x03\x06\x1c\x1a\x0f\x20File\x20resource\n\n\x0f\n\x07\
    \x04\0\x03\x01\x02\x04\x06\x12\x04\xe2\x03\x06\x12\n\x0f\n\x07\x04\0\x03\
    \x01\x02\x04\x01\x12\x04\xe2\x03\x13\x17\n\x0f\n\x07\x04\0\x03\x01\x02\
    \x04\x03\x12\x04\xe2\x03\x1a\x1b\n\x86\x03\n\x04\x04\0\x03\x02\x12\x06\
    \xee\x03\x02\x81\x04\x03\x1a\xf5\x02\x20Resource\x20groups\x20provide\
    \x20a\x20mechanism\x20to\x20group\x20OS\x20policy\x20resources.\n\n\x20R\
    esource\x20groups\x20enable\x20OS\x20policy\x20authors\x20to\x20create\
    \x20a\x20single\x20OS\x20policy\n\x20to\x20be\x20applied\x20to\x20VMs\
    \x20running\x20different\x20operating\x20Systems.\n\n\x20When\x20the\x20\
    OS\x20policy\x20is\x20applied\x20to\x20a\x20target\x20VM,\x20the\x20appr\
    opriate\x20resource\n\x20group\x20within\x20the\x20OS\x20policy\x20is\
    \x20selected\x20based\x20on\x20the\x20`OSFilter`\x20specified\n\x20withi\
    n\x20the\x20resource\x20group.\n\n\r\n\x05\x04\0\x03\x02\x01\x12\x04\xee\
    \x03\n\x17\n\xa3\x04\n\x06\x04\0\x03\x02\x02\0\x12\x04\xfc\x03\x043\x1a\
    \x92\x04\x20List\x20of\x20inventory\x20filters\x20for\x20the\x20resource\
    \x20group.\n\n\x20The\x20resources\x20in\x20this\x20resource\x20group\
    \x20are\x20applied\x20to\x20the\x20target\x20VM\x20if\x20it\n\x20satisfi\
    es\x20at\x20least\x20one\x20of\x20the\x20following\x20inventory\x20filte\
    rs.\n\n\x20For\x20example,\x20to\x20apply\x20this\x20resource\x20group\
    \x20to\x20VMs\x20running\x20either\x20`RHEL`\x20or\n\x20`CentOS`\x20oper\
    ating\x20systems,\x20specify\x202\x20items\x20for\x20the\x20list\x20with\
    \x20following\n\x20values:\n\x20inventory_filters[0].os_short_name='rhel\
    '\x20and\n\x20inventory_filters[1].os_short_name='centos'\n\n\x20If\x20t\
    he\x20list\x20is\x20empty,\x20this\x20resource\x20group\x20will\x20be\
    \x20applied\x20to\x20the\x20target\n\x20VM\x20unconditionally.\n\n\x0f\n\
    \x07\x04\0\x03\x02\x02\0\x04\x12\x04\xfc\x03\x04\x0c\n\x0f\n\x07\x04\0\
    \x03\x02\x02\0\x06\x12\x04\xfc\x03\r\x1c\n\x0f\n\x07\x04\0\x03\x02\x02\0\
    \x01\x12\x04\xfc\x03\x1d.\n\x0f\n\x07\x04\0\x03\x02\x02\0\x03\x12\x04\
    \xfc\x0312\n\x91\x01\n\x06\x04\0\x03\x02\x02\x01\x12\x04\x80\x04\x04M\
    \x1a\x80\x01\x20Required.\x20List\x20of\x20resources\x20configured\x20fo\
    r\x20this\x20resource\x20group.\n\x20The\x20resources\x20are\x20executed\
    \x20in\x20the\x20exact\x20order\x20specified\x20here.\n\n\x0f\n\x07\x04\
    \0\x03\x02\x02\x01\x04\x12\x04\x80\x04\x04\x0c\n\x0f\n\x07\x04\0\x03\x02\
    \x02\x01\x06\x12\x04\x80\x04\r\x15\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x01\
    \x12\x04\x80\x04\x16\x1f\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x03\x12\x04\
    \x80\x04\"#\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x08\x12\x04\x80\x04$L\n\
    \x12\n\n\x04\0\x03\x02\x02\x01\x08\x9c\x08\0\x12\x04\x80\x04%K\n\xa3\x02\
    \n\x04\x04\0\x02\0\x12\x04\x8a\x04\x029\x1a\x94\x02\x20Required.\x20The\
    \x20id\x20of\x20the\x20OS\x20policy\x20with\x20the\x20following\x20restr\
    ictions:\n\n\x20*\x20Must\x20contain\x20only\x20lowercase\x20letters,\
    \x20numbers,\x20and\x20hyphens.\n\x20*\x20Must\x20start\x20with\x20a\x20\
    letter.\n\x20*\x20Must\x20be\x20between\x201-63\x20characters.\n\x20*\
    \x20Must\x20end\x20with\x20a\x20number\x20or\x20a\x20letter.\n\x20*\x20M\
    ust\x20be\x20unique\x20within\x20the\x20assignment.\n\n\r\n\x05\x04\0\
    \x02\0\x05\x12\x04\x8a\x04\x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x8a\
    \x04\t\x0b\n\r\n\x05\x04\0\x02\0\x03\x12\x04\x8a\x04\x0e\x0f\n\r\n\x05\
    \x04\0\x02\0\x08\x12\x04\x8a\x04\x108\n\x10\n\x08\x04\0\x02\0\x08\x9c\
    \x08\0\x12\x04\x8a\x04\x117\n]\n\x04\x04\0\x02\x01\x12\x04\x8e\x04\x02\
    \x19\x1aO\x20Policy\x20description.\n\x20Length\x20of\x20the\x20descript\
    ion\x20is\x20limited\x20to\x201024\x20characters.\n\n\r\n\x05\x04\0\x02\
    \x01\x05\x12\x04\x8e\x04\x02\x08\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\x8e\
    \x04\t\x14\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x8e\x04\x17\x18\n%\n\x04\
    \x04\0\x02\x02\x12\x04\x91\x04\x029\x1a\x17\x20Required.\x20Policy\x20mo\
    de\n\n\r\n\x05\x04\0\x02\x02\x06\x12\x04\x91\x04\x02\x06\n\r\n\x05\x04\0\
    \x02\x02\x01\x12\x04\x91\x04\x07\x0b\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\
    \x91\x04\x0e\x0f\n\r\n\x05\x04\0\x02\x02\x08\x12\x04\x91\x04\x108\n\x10\
    \n\x08\x04\0\x02\x02\x08\x9c\x08\0\x12\x04\x91\x04\x117\n\xa8\x03\n\x04\
    \x04\0\x02\x03\x12\x06\x9b\x04\x02\x9c\x04/\x1a\x97\x03\x20Required.\x20\
    List\x20of\x20resource\x20groups\x20for\x20the\x20policy.\n\x20For\x20a\
    \x20particular\x20VM,\x20resource\x20groups\x20are\x20evaluated\x20in\
    \x20the\x20order\x20specified\n\x20and\x20the\x20first\x20resource\x20gr\
    oup\x20that\x20is\x20applicable\x20is\x20selected\x20and\x20the\x20rest\
    \n\x20are\x20ignored.\n\n\x20If\x20none\x20of\x20the\x20resource\x20grou\
    ps\x20are\x20applicable\x20for\x20a\x20VM,\x20the\x20VM\x20is\n\x20consi\
    dered\x20to\x20be\x20non-compliant\x20w.r.t\x20this\x20policy.\x20This\
    \x20behavior\x20can\x20be\n\x20toggled\x20by\x20the\x20flag\x20`allow_no\
    _resource_group_match`\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\x9b\x04\x02\
    \n\n\r\n\x05\x04\0\x02\x03\x06\x12\x04\x9b\x04\x0b\x18\n\r\n\x05\x04\0\
    \x02\x03\x01\x12\x04\x9b\x04\x19(\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\
    \x9b\x04+,\n\r\n\x05\x04\0\x02\x03\x08\x12\x04\x9c\x04\x06.\n\x10\n\x08\
    \x04\0\x02\x03\x08\x9c\x08\0\x12\x04\x9c\x04\x07-\n\x94\x02\n\x04\x04\0\
    \x02\x04\x12\x04\xa2\x04\x02)\x1a\x85\x02\x20This\x20flag\x20determines\
    \x20the\x20OS\x20policy\x20compliance\x20status\x20when\x20none\x20of\
    \x20the\n\x20resource\x20groups\x20within\x20the\x20policy\x20are\x20app\
    licable\x20for\x20a\x20VM.\x20Set\x20this\x20value\n\x20to\x20`true`\x20\
    if\x20the\x20policy\x20needs\x20to\x20be\x20reported\x20as\x20compliant\
    \x20even\x20if\x20the\n\x20policy\x20has\x20nothing\x20to\x20validate\
    \x20or\x20enforce.\n\n\r\n\x05\x04\0\x02\x04\x05\x12\x04\xa2\x04\x02\x06\
    \n\r\n\x05\x04\0\x02\x04\x01\x12\x04\xa2\x04\x07$\n\r\n\x05\x04\0\x02\
    \x04\x03\x12\x04\xa2\x04'(b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
