// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1alpha/instance_os_policies_compliance.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct InstanceOSPoliciesCompliance {
    // message fields
    pub name: ::std::string::String,
    pub instance: ::std::string::String,
    pub state: super::config_common::OSPolicyComplianceState,
    pub detailed_state: ::std::string::String,
    pub detailed_state_reason: ::std::string::String,
    pub os_policy_compliances: ::protobuf::RepeatedField<InstanceOSPoliciesCompliance_OSPolicyCompliance>,
    pub last_compliance_check_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub last_compliance_run_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstanceOSPoliciesCompliance {
    fn default() -> &'a InstanceOSPoliciesCompliance {
        <InstanceOSPoliciesCompliance as ::protobuf::Message>::default_instance()
    }
}

impl InstanceOSPoliciesCompliance {
    pub fn new() -> InstanceOSPoliciesCompliance {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string instance = 2;


    pub fn get_instance(&self) -> &str {
        &self.instance
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: ::std::string::String) {
        self.instance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut ::std::string::String {
        &mut self.instance
    }

    // Take field
    pub fn take_instance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.instance, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyComplianceState state = 3;


    pub fn get_state(&self) -> super::config_common::OSPolicyComplianceState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::config_common::OSPolicyComplianceState) {
        self.state = v;
    }

    // string detailed_state = 4;


    pub fn get_detailed_state(&self) -> &str {
        &self.detailed_state
    }
    pub fn clear_detailed_state(&mut self) {
        self.detailed_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_detailed_state(&mut self, v: ::std::string::String) {
        self.detailed_state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detailed_state(&mut self) -> &mut ::std::string::String {
        &mut self.detailed_state
    }

    // Take field
    pub fn take_detailed_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.detailed_state, ::std::string::String::new())
    }

    // string detailed_state_reason = 5;


    pub fn get_detailed_state_reason(&self) -> &str {
        &self.detailed_state_reason
    }
    pub fn clear_detailed_state_reason(&mut self) {
        self.detailed_state_reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_detailed_state_reason(&mut self, v: ::std::string::String) {
        self.detailed_state_reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detailed_state_reason(&mut self) -> &mut ::std::string::String {
        &mut self.detailed_state_reason
    }

    // Take field
    pub fn take_detailed_state_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.detailed_state_reason, ::std::string::String::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.InstanceOSPoliciesCompliance.OSPolicyCompliance os_policy_compliances = 6;


    pub fn get_os_policy_compliances(&self) -> &[InstanceOSPoliciesCompliance_OSPolicyCompliance] {
        &self.os_policy_compliances
    }
    pub fn clear_os_policy_compliances(&mut self) {
        self.os_policy_compliances.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_compliances(&mut self, v: ::protobuf::RepeatedField<InstanceOSPoliciesCompliance_OSPolicyCompliance>) {
        self.os_policy_compliances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policy_compliances(&mut self) -> &mut ::protobuf::RepeatedField<InstanceOSPoliciesCompliance_OSPolicyCompliance> {
        &mut self.os_policy_compliances
    }

    // Take field
    pub fn take_os_policy_compliances(&mut self) -> ::protobuf::RepeatedField<InstanceOSPoliciesCompliance_OSPolicyCompliance> {
        ::std::mem::replace(&mut self.os_policy_compliances, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp last_compliance_check_time = 7;


    pub fn get_last_compliance_check_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_compliance_check_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_compliance_check_time(&mut self) {
        self.last_compliance_check_time.clear();
    }

    pub fn has_last_compliance_check_time(&self) -> bool {
        self.last_compliance_check_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_compliance_check_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_compliance_check_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_compliance_check_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_compliance_check_time.is_none() {
            self.last_compliance_check_time.set_default();
        }
        self.last_compliance_check_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_compliance_check_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_compliance_check_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string last_compliance_run_id = 8;


    pub fn get_last_compliance_run_id(&self) -> &str {
        &self.last_compliance_run_id
    }
    pub fn clear_last_compliance_run_id(&mut self) {
        self.last_compliance_run_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_compliance_run_id(&mut self, v: ::std::string::String) {
        self.last_compliance_run_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_compliance_run_id(&mut self) -> &mut ::std::string::String {
        &mut self.last_compliance_run_id
    }

    // Take field
    pub fn take_last_compliance_run_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_compliance_run_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InstanceOSPoliciesCompliance {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_compliances {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_compliance_check_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.detailed_state)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.detailed_state_reason)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policy_compliances)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_compliance_check_time)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_compliance_run_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.instance.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.instance);
        }
        if self.state != super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if !self.detailed_state.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.detailed_state);
        }
        if !self.detailed_state_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.detailed_state_reason);
        }
        for value in &self.os_policy_compliances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.last_compliance_check_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.last_compliance_run_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.last_compliance_run_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.instance.is_empty() {
            os.write_string(2, &self.instance)?;
        }
        if self.state != super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if !self.detailed_state.is_empty() {
            os.write_string(4, &self.detailed_state)?;
        }
        if !self.detailed_state_reason.is_empty() {
            os.write_string(5, &self.detailed_state_reason)?;
        }
        for v in &self.os_policy_compliances {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.last_compliance_check_time.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.last_compliance_run_id.is_empty() {
            os.write_string(8, &self.last_compliance_run_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceOSPoliciesCompliance {
        InstanceOSPoliciesCompliance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &InstanceOSPoliciesCompliance| { &m.name },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instance",
                |m: &InstanceOSPoliciesCompliance| { &m.instance },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::config_common::OSPolicyComplianceState>>(
                "state",
                |m: &InstanceOSPoliciesCompliance| { &m.state },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailed_state",
                |m: &InstanceOSPoliciesCompliance| { &m.detailed_state },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.detailed_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailed_state_reason",
                |m: &InstanceOSPoliciesCompliance| { &m.detailed_state_reason },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.detailed_state_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstanceOSPoliciesCompliance_OSPolicyCompliance>>(
                "os_policy_compliances",
                |m: &InstanceOSPoliciesCompliance| { &m.os_policy_compliances },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.os_policy_compliances },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_compliance_check_time",
                |m: &InstanceOSPoliciesCompliance| { &m.last_compliance_check_time },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.last_compliance_check_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_compliance_run_id",
                |m: &InstanceOSPoliciesCompliance| { &m.last_compliance_run_id },
                |m: &mut InstanceOSPoliciesCompliance| { &mut m.last_compliance_run_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstanceOSPoliciesCompliance>(
                "InstanceOSPoliciesCompliance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstanceOSPoliciesCompliance {
        static instance: ::protobuf::rt::LazyV2<InstanceOSPoliciesCompliance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstanceOSPoliciesCompliance::new)
    }
}

impl ::protobuf::Clear for InstanceOSPoliciesCompliance {
    fn clear(&mut self) {
        self.name.clear();
        self.instance.clear();
        self.state = super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED;
        self.detailed_state.clear();
        self.detailed_state_reason.clear();
        self.os_policy_compliances.clear();
        self.last_compliance_check_time.clear();
        self.last_compliance_run_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceOSPoliciesCompliance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceOSPoliciesCompliance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstanceOSPoliciesCompliance_OSPolicyCompliance {
    // message fields
    pub os_policy_id: ::std::string::String,
    pub os_policy_assignment: ::std::string::String,
    pub state: super::config_common::OSPolicyComplianceState,
    pub os_policy_resource_compliances: ::protobuf::RepeatedField<super::config_common::OSPolicyResourceCompliance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstanceOSPoliciesCompliance_OSPolicyCompliance {
    fn default() -> &'a InstanceOSPoliciesCompliance_OSPolicyCompliance {
        <InstanceOSPoliciesCompliance_OSPolicyCompliance as ::protobuf::Message>::default_instance()
    }
}

impl InstanceOSPoliciesCompliance_OSPolicyCompliance {
    pub fn new() -> InstanceOSPoliciesCompliance_OSPolicyCompliance {
        ::std::default::Default::default()
    }

    // string os_policy_id = 1;


    pub fn get_os_policy_id(&self) -> &str {
        &self.os_policy_id
    }
    pub fn clear_os_policy_id(&mut self) {
        self.os_policy_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_id(&mut self, v: ::std::string::String) {
        self.os_policy_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_id(&mut self) -> &mut ::std::string::String {
        &mut self.os_policy_id
    }

    // Take field
    pub fn take_os_policy_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_policy_id, ::std::string::String::new())
    }

    // string os_policy_assignment = 2;


    pub fn get_os_policy_assignment(&self) -> &str {
        &self.os_policy_assignment
    }
    pub fn clear_os_policy_assignment(&mut self) {
        self.os_policy_assignment.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignment(&mut self, v: ::std::string::String) {
        self.os_policy_assignment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_assignment(&mut self) -> &mut ::std::string::String {
        &mut self.os_policy_assignment
    }

    // Take field
    pub fn take_os_policy_assignment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_policy_assignment, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyComplianceState state = 4;


    pub fn get_state(&self) -> super::config_common::OSPolicyComplianceState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::config_common::OSPolicyComplianceState) {
        self.state = v;
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyResourceCompliance os_policy_resource_compliances = 5;


    pub fn get_os_policy_resource_compliances(&self) -> &[super::config_common::OSPolicyResourceCompliance] {
        &self.os_policy_resource_compliances
    }
    pub fn clear_os_policy_resource_compliances(&mut self) {
        self.os_policy_resource_compliances.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_resource_compliances(&mut self, v: ::protobuf::RepeatedField<super::config_common::OSPolicyResourceCompliance>) {
        self.os_policy_resource_compliances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policy_resource_compliances(&mut self) -> &mut ::protobuf::RepeatedField<super::config_common::OSPolicyResourceCompliance> {
        &mut self.os_policy_resource_compliances
    }

    // Take field
    pub fn take_os_policy_resource_compliances(&mut self) -> ::protobuf::RepeatedField<super::config_common::OSPolicyResourceCompliance> {
        ::std::mem::replace(&mut self.os_policy_resource_compliances, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InstanceOSPoliciesCompliance_OSPolicyCompliance {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_resource_compliances {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_policy_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_policy_assignment)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policy_resource_compliances)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.os_policy_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os_policy_id);
        }
        if !self.os_policy_assignment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.os_policy_assignment);
        }
        if self.state != super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.state);
        }
        for value in &self.os_policy_resource_compliances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.os_policy_id.is_empty() {
            os.write_string(1, &self.os_policy_id)?;
        }
        if !self.os_policy_assignment.is_empty() {
            os.write_string(2, &self.os_policy_assignment)?;
        }
        if self.state != super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        for v in &self.os_policy_resource_compliances {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceOSPoliciesCompliance_OSPolicyCompliance {
        InstanceOSPoliciesCompliance_OSPolicyCompliance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_policy_id",
                |m: &InstanceOSPoliciesCompliance_OSPolicyCompliance| { &m.os_policy_id },
                |m: &mut InstanceOSPoliciesCompliance_OSPolicyCompliance| { &mut m.os_policy_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_policy_assignment",
                |m: &InstanceOSPoliciesCompliance_OSPolicyCompliance| { &m.os_policy_assignment },
                |m: &mut InstanceOSPoliciesCompliance_OSPolicyCompliance| { &mut m.os_policy_assignment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::config_common::OSPolicyComplianceState>>(
                "state",
                |m: &InstanceOSPoliciesCompliance_OSPolicyCompliance| { &m.state },
                |m: &mut InstanceOSPoliciesCompliance_OSPolicyCompliance| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_common::OSPolicyResourceCompliance>>(
                "os_policy_resource_compliances",
                |m: &InstanceOSPoliciesCompliance_OSPolicyCompliance| { &m.os_policy_resource_compliances },
                |m: &mut InstanceOSPoliciesCompliance_OSPolicyCompliance| { &mut m.os_policy_resource_compliances },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstanceOSPoliciesCompliance_OSPolicyCompliance>(
                "InstanceOSPoliciesCompliance.OSPolicyCompliance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstanceOSPoliciesCompliance_OSPolicyCompliance {
        static instance: ::protobuf::rt::LazyV2<InstanceOSPoliciesCompliance_OSPolicyCompliance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstanceOSPoliciesCompliance_OSPolicyCompliance::new)
    }
}

impl ::protobuf::Clear for InstanceOSPoliciesCompliance_OSPolicyCompliance {
    fn clear(&mut self) {
        self.os_policy_id.clear();
        self.os_policy_assignment.clear();
        self.state = super::config_common::OSPolicyComplianceState::OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED;
        self.os_policy_resource_compliances.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceOSPoliciesCompliance_OSPolicyCompliance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceOSPoliciesCompliance_OSPolicyCompliance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInstanceOSPoliciesComplianceRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInstanceOSPoliciesComplianceRequest {
    fn default() -> &'a GetInstanceOSPoliciesComplianceRequest {
        <GetInstanceOSPoliciesComplianceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInstanceOSPoliciesComplianceRequest {
    pub fn new() -> GetInstanceOSPoliciesComplianceRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetInstanceOSPoliciesComplianceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInstanceOSPoliciesComplianceRequest {
        GetInstanceOSPoliciesComplianceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetInstanceOSPoliciesComplianceRequest| { &m.name },
                |m: &mut GetInstanceOSPoliciesComplianceRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInstanceOSPoliciesComplianceRequest>(
                "GetInstanceOSPoliciesComplianceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInstanceOSPoliciesComplianceRequest {
        static instance: ::protobuf::rt::LazyV2<GetInstanceOSPoliciesComplianceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInstanceOSPoliciesComplianceRequest::new)
    }
}

impl ::protobuf::Clear for GetInstanceOSPoliciesComplianceRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInstanceOSPoliciesComplianceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInstanceOSPoliciesComplianceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInstanceOSPoliciesCompliancesRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub filter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInstanceOSPoliciesCompliancesRequest {
    fn default() -> &'a ListInstanceOSPoliciesCompliancesRequest {
        <ListInstanceOSPoliciesCompliancesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInstanceOSPoliciesCompliancesRequest {
    pub fn new() -> ListInstanceOSPoliciesCompliancesRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string filter = 4;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListInstanceOSPoliciesCompliancesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInstanceOSPoliciesCompliancesRequest {
        ListInstanceOSPoliciesCompliancesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListInstanceOSPoliciesCompliancesRequest| { &m.parent },
                |m: &mut ListInstanceOSPoliciesCompliancesRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListInstanceOSPoliciesCompliancesRequest| { &m.page_size },
                |m: &mut ListInstanceOSPoliciesCompliancesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListInstanceOSPoliciesCompliancesRequest| { &m.page_token },
                |m: &mut ListInstanceOSPoliciesCompliancesRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListInstanceOSPoliciesCompliancesRequest| { &m.filter },
                |m: &mut ListInstanceOSPoliciesCompliancesRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListInstanceOSPoliciesCompliancesRequest>(
                "ListInstanceOSPoliciesCompliancesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListInstanceOSPoliciesCompliancesRequest {
        static instance: ::protobuf::rt::LazyV2<ListInstanceOSPoliciesCompliancesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListInstanceOSPoliciesCompliancesRequest::new)
    }
}

impl ::protobuf::Clear for ListInstanceOSPoliciesCompliancesRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInstanceOSPoliciesCompliancesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInstanceOSPoliciesCompliancesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInstanceOSPoliciesCompliancesResponse {
    // message fields
    pub instance_os_policies_compliances: ::protobuf::RepeatedField<InstanceOSPoliciesCompliance>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInstanceOSPoliciesCompliancesResponse {
    fn default() -> &'a ListInstanceOSPoliciesCompliancesResponse {
        <ListInstanceOSPoliciesCompliancesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListInstanceOSPoliciesCompliancesResponse {
    pub fn new() -> ListInstanceOSPoliciesCompliancesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1alpha.InstanceOSPoliciesCompliance instance_os_policies_compliances = 1;


    pub fn get_instance_os_policies_compliances(&self) -> &[InstanceOSPoliciesCompliance] {
        &self.instance_os_policies_compliances
    }
    pub fn clear_instance_os_policies_compliances(&mut self) {
        self.instance_os_policies_compliances.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance_os_policies_compliances(&mut self, v: ::protobuf::RepeatedField<InstanceOSPoliciesCompliance>) {
        self.instance_os_policies_compliances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instance_os_policies_compliances(&mut self) -> &mut ::protobuf::RepeatedField<InstanceOSPoliciesCompliance> {
        &mut self.instance_os_policies_compliances
    }

    // Take field
    pub fn take_instance_os_policies_compliances(&mut self) -> ::protobuf::RepeatedField<InstanceOSPoliciesCompliance> {
        ::std::mem::replace(&mut self.instance_os_policies_compliances, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListInstanceOSPoliciesCompliancesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.instance_os_policies_compliances {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.instance_os_policies_compliances)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.instance_os_policies_compliances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.instance_os_policies_compliances {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInstanceOSPoliciesCompliancesResponse {
        ListInstanceOSPoliciesCompliancesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstanceOSPoliciesCompliance>>(
                "instance_os_policies_compliances",
                |m: &ListInstanceOSPoliciesCompliancesResponse| { &m.instance_os_policies_compliances },
                |m: &mut ListInstanceOSPoliciesCompliancesResponse| { &mut m.instance_os_policies_compliances },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListInstanceOSPoliciesCompliancesResponse| { &m.next_page_token },
                |m: &mut ListInstanceOSPoliciesCompliancesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListInstanceOSPoliciesCompliancesResponse>(
                "ListInstanceOSPoliciesCompliancesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListInstanceOSPoliciesCompliancesResponse {
        static instance: ::protobuf::rt::LazyV2<ListInstanceOSPoliciesCompliancesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListInstanceOSPoliciesCompliancesResponse::new)
    }
}

impl ::protobuf::Clear for ListInstanceOSPoliciesCompliancesResponse {
    fn clear(&mut self) {
        self.instance_os_policies_compliances.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInstanceOSPoliciesCompliancesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInstanceOSPoliciesCompliancesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nCgoogle/cloud/osconfig/v1alpha/instance_os_policies_compliance.proto\
    \x12\x1dgoogle.cloud.osconfig.v1alpha\x1a\x1fgoogle/api/field_behavior.p\
    roto\x1a\x19google/api/resource.proto\x1a1google/cloud/osconfig/v1alpha/\
    config_common.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xb1\x08\n\
    \x1cInstanceOSPoliciesCompliance\x12\x17\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\x03\xe0A\x03\x12\x1f\n\x08instance\x18\x02\x20\x01(\tR\x08inst\
    anceB\x03\xe0A\x03\x12Q\n\x05state\x18\x03\x20\x01(\x0e26.google.cloud.o\
    sconfig.v1alpha.OSPolicyComplianceStateR\x05stateB\x03\xe0A\x03\x12*\n\
    \x0edetailed_state\x18\x04\x20\x01(\tR\rdetailedStateB\x03\xe0A\x03\x127\
    \n\x15detailed_state_reason\x18\x05\x20\x01(\tR\x13detailedStateReasonB\
    \x03\xe0A\x03\x12\x87\x01\n\x15os_policy_compliances\x18\x06\x20\x03(\
    \x0b2N.google.cloud.osconfig.v1alpha.InstanceOSPoliciesCompliance.OSPoli\
    cyComplianceR\x13osPolicyCompliancesB\x03\xe0A\x03\x12\\\n\x1alast_compl\
    iance_check_time\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x17lastComplianceCheckTimeB\x03\xe0A\x03\x128\n\x16last_compliance_run_\
    id\x18\x08\x20\x01(\tR\x13lastComplianceRunIdB\x03\xe0A\x03\x1a\xeb\x02\
    \n\x12OSPolicyCompliance\x12\x20\n\x0cos_policy_id\x18\x01\x20\x01(\tR\n\
    osPolicyId\x12a\n\x14os_policy_assignment\x18\x02\x20\x01(\tR\x12osPolic\
    yAssignmentB/\xfaA,\n*osconfig.googleapis.com/OSPolicyAssignment\x12L\n\
    \x05state\x18\x04\x20\x01(\x0e26.google.cloud.osconfig.v1alpha.OSPolicyC\
    omplianceStateR\x05state\x12~\n\x1eos_policy_resource_compliances\x18\
    \x05\x20\x03(\x0b29.google.cloud.osconfig.v1alpha.OSPolicyResourceCompli\
    anceR\x1bosPolicyResourceCompliances:\x02\x18\x01:\x8e\x01\x18\x01\xeaA\
    \x88\x01\n4osconfig.googleapis.com/InstanceOSPoliciesCompliance\x12Pproj\
    ects/{project}/locations/{location}/instanceOSPoliciesCompliances/{insta\
    nce}\"~\n&GetInstanceOSPoliciesComplianceRequest\x12P\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB<\xfaA6\n4osconfig.googleapis.com/InstanceOSPolicie\
    sCompliance\xe0A\x02:\x02\x18\x01\"\xc5\x01\n(ListInstanceOSPoliciesComp\
    liancesRequest\x12A\n\x06parent\x18\x01\x20\x01(\tR\x06parentB)\xfaA#\n!\
    locations.googleapis.com/Location\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\
    \x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpa\
    geToken\x12\x16\n\x06filter\x18\x04\x20\x01(\tR\x06filter:\x02\x18\x01\"\
    \xde\x01\n)ListInstanceOSPoliciesCompliancesResponse\x12\x84\x01\n\x20in\
    stance_os_policies_compliances\x18\x01\x20\x03(\x0b2;.google.cloud.oscon\
    fig.v1alpha.InstanceOSPoliciesComplianceR\x1dinstanceOsPoliciesComplianc\
    es\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken:\x02\x18\
    \x01B\xea\x01\n!com.google.cloud.osconfig.v1alphaB!InstanceOSPoliciesCom\
    plianceProtoP\x01Z=cloud.google.com/go/osconfig/apiv1alpha/osconfigpb;os\
    configpb\xaa\x02\x1dGoogle.Cloud.OsConfig.V1Alpha\xca\x02\x1dGoogle\\Clo\
    ud\\OsConfig\\V1alpha\xea\x02\x20Google::Cloud::OsConfig::V1alphaJ\x9c1\
    \n\x07\x12\x05\x0e\0\xb5\x01\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\
    \xb1\x04\x20Copyright\x202021\x20Google\x20LLC\n\n\x20Licensed\x20under\
    \x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\
    \n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compli\
    ance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\
    \x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.\
    org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\
    \x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distrib\
    uted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\
    \x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\
    \x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\
    \x02\x12\x03\x10\0&\n\t\n\x02\x03\0\x12\x03\x12\0)\n\t\n\x02\x03\x01\x12\
    \x03\x13\0#\n\t\n\x02\x03\x02\x12\x03\x14\0;\n\t\n\x02\x03\x03\x12\x03\
    \x15\0)\n\x08\n\x01\x08\x12\x03\x17\0:\n\t\n\x02\x08%\x12\x03\x17\0:\n\
    \x08\n\x01\x08\x12\x03\x18\0T\n\t\n\x02\x08\x0b\x12\x03\x18\0T\n\x08\n\
    \x01\x08\x12\x03\x19\0\"\n\t\n\x02\x08\n\x12\x03\x19\0\"\n\x08\n\x01\x08\
    \x12\x03\x1a\0B\n\t\n\x02\x08\x08\x12\x03\x1a\0B\n\x08\n\x01\x08\x12\x03\
    \x1b\0:\n\t\n\x02\x08\x01\x12\x03\x1b\0:\n\x08\n\x01\x08\x12\x03\x1c\0:\
    \n\t\n\x02\x08)\x12\x03\x1c\0:\n\x08\n\x01\x08\x12\x03\x1d\09\n\t\n\x02\
    \x08-\x12\x03\x1d\09\n\xe2\x04\n\x02\x04\0\x12\x04+\0s\x01\x1a\xd5\x04\
    \x20This\x20API\x20resource\x20represents\x20the\x20OS\x20policies\x20co\
    mpliance\x20data\x20for\x20a\x20Compute\n\x20Engine\x20virtual\x20machin\
    e\x20(VM)\x20instance\x20at\x20a\x20given\x20point\x20in\x20time.\n\n\
    \x20A\x20Compute\x20Engine\x20VM\x20can\x20have\x20multiple\x20OS\x20pol\
    icy\x20assignments,\x20and\x20each\n\x20assignment\x20can\x20have\x20mul\
    tiple\x20OS\x20policies.\x20As\x20a\x20result,\x20multiple\x20OS\x20poli\
    cies\n\x20could\x20be\x20applied\x20to\x20a\x20single\x20VM.\n\n\x20You\
    \x20can\x20use\x20this\x20API\x20resource\x20to\x20determine\x20both\x20\
    the\x20compliance\x20state\x20of\x20your\n\x20VM\x20as\x20well\x20as\x20\
    the\x20compliance\x20state\x20of\x20an\x20individual\x20OS\x20policy.\n\
    \n\x20For\x20more\x20information,\x20see\x20[View\n\x20compliance](https\
    ://cloud.google.com/compute/docs/os-configuration-management/view-compli\
    ance).\n\n\n\n\x03\x04\0\x01\x12\x03+\x08$\n\n\n\x03\x04\0\x07\x12\x03,\
    \x02\x1b\n\x0b\n\x04\x04\0\x07\x03\x12\x03,\x02\x1b\n\x0b\n\x03\x04\0\
    \x07\x12\x04-\x020\x04\n\r\n\x05\x04\0\x07\x9d\x08\x12\x04-\x020\x04\n0\
    \n\x04\x04\0\x03\0\x12\x043\x02H\x03\x1a\"\x20Compliance\x20data\x20for\
    \x20an\x20OS\x20policy\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x033\n\x1c\n\
    \x0c\n\x05\x04\0\x03\0\x07\x12\x034\x04\x1d\n\r\n\x06\x04\0\x03\0\x07\
    \x03\x12\x034\x04\x1d\n!\n\x06\x04\0\x03\0\x02\0\x12\x037\x04\x1c\x1a\
    \x12\x20The\x20OS\x20policy\x20id\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\
    \x12\x037\x04\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x037\x0b\x17\n\x0e\
    \n\x07\x04\0\x03\0\x02\0\x03\x12\x037\x1a\x1b\n\xdc\x01\n\x06\x04\0\x03\
    \0\x02\x01\x12\x04>\x04@(\x1a\xcb\x01\x20Reference\x20to\x20the\x20`OSPo\
    licyAssignment`\x20API\x20resource\x20that\x20the\x20`OSPolicy`\n\x20bel\
    ongs\x20to.\n\n\x20Format:\n\x20`projects/{project_number}/locations/{lo\
    cation}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`\n\n\
    \x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03>\x04\n\n\x0e\n\x07\x04\0\x03\
    \0\x02\x01\x01\x12\x03>\x0b\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\
    \x03>\"#\n\x0f\n\x07\x04\0\x03\0\x02\x01\x08\x12\x04>$@'\n\x11\n\t\x04\0\
    \x03\0\x02\x01\x08\x9f\x08\x12\x04>%@&\n3\n\x06\x04\0\x03\0\x02\x02\x12\
    \x03C\x04&\x1a$\x20Compliance\x20state\x20of\x20the\x20OS\x20policy.\n\n\
    \x0e\n\x07\x04\0\x03\0\x02\x02\x06\x12\x03C\x04\x1b\n\x0e\n\x07\x04\0\
    \x03\0\x02\x02\x01\x12\x03C\x1c!\n\x0e\n\x07\x04\0\x03\0\x02\x02\x03\x12\
    \x03C$%\nX\n\x06\x04\0\x03\0\x02\x03\x12\x03G\x04K\x1aI\x20Compliance\
    \x20data\x20for\x20each\x20`OSPolicyResource`\x20that\x20is\x20applied\
    \x20to\x20the\n\x20VM.\n\n\x0e\n\x07\x04\0\x03\0\x02\x03\x04\x12\x03G\
    \x04\x0c\n\x0e\n\x07\x04\0\x03\0\x02\x03\x06\x12\x03G\r'\n\x0e\n\x07\x04\
    \0\x03\0\x02\x03\x01\x12\x03G(F\n\x0e\n\x07\x04\0\x03\0\x02\x03\x03\x12\
    \x03GIJ\n\xba\x01\n\x04\x04\0\x02\0\x12\x03N\x02>\x1a\xac\x01\x20Output\
    \x20only.\x20The\x20`InstanceOSPoliciesCompliance`\x20API\x20resource\
    \x20name.\n\n\x20Format:\n\x20`projects/{project_number}/locations/{loca\
    tion}/instanceOSPoliciesCompliances/{instance_id}`\n\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x03N\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03N\t\r\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03N\x10\x11\n\x0c\n\x05\x04\0\x02\0\x08\
    \x12\x03N\x12=\n\x0f\n\x08\x04\0\x02\0\x08\x9c\x08\0\x12\x03N\x13<\n@\n\
    \x04\x04\0\x02\x01\x12\x03Q\x02B\x1a3\x20Output\x20only.\x20The\x20Compu\
    te\x20Engine\x20VM\x20instance\x20name.\n\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03Q\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03Q\t\x11\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03Q\x14\x15\n\x0c\n\x05\x04\0\x02\x01\x08\
    \x12\x03Q\x16A\n\x0f\n\x08\x04\0\x02\x01\x08\x9c\x08\0\x12\x03Q\x17@\n7\
    \n\x04\x04\0\x02\x02\x12\x03T\x02P\x1a*\x20Output\x20only.\x20Compliance\
    \x20state\x20of\x20the\x20VM.\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03T\
    \x02\x19\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03T\x1a\x1f\n\x0c\n\x05\x04\
    \0\x02\x02\x03\x12\x03T\"#\n\x0c\n\x05\x04\0\x02\x02\x08\x12\x03T$O\n\
    \x0f\n\x08\x04\0\x02\x02\x08\x9c\x08\0\x12\x03T%N\n\xa3\x05\n\x04\x04\0\
    \x02\x03\x12\x03d\x02H\x1a\x95\x05\x20Output\x20only.\x20Detailed\x20com\
    pliance\x20state\x20of\x20the\x20VM.\n\x20This\x20field\x20is\x20populat\
    ed\x20only\x20when\x20compliance\x20state\x20is\x20`UNKNOWN`.\n\n\x20It\
    \x20may\x20contain\x20one\x20of\x20the\x20following\x20values:\n\n\x20*\
    \x20`no-compliance-data`:\x20Compliance\x20data\x20is\x20not\x20availabl\
    e\x20for\x20this\x20VM.\n\x20*\x20`no-agent-detected`:\x20OS\x20Config\
    \x20agent\x20is\x20not\x20detected\x20for\x20this\x20VM.\n\x20*\x20`conf\
    ig-not-supported-by-agent`:\x20The\x20version\x20of\x20the\x20OS\x20Conf\
    ig\x20agent\n\x20running\x20on\x20this\x20VM\x20does\x20not\x20support\
    \x20configuration\x20management.\n\x20*\x20`inactive`:\x20VM\x20is\x20no\
    t\x20running.\n\x20*\x20`internal-service-errors`:\x20There\x20were\x20i\
    nternal\x20service\x20errors\x20encountered\n\x20while\x20enforcing\x20c\
    ompliance.\n\x20*\x20`agent-errors`:\x20OS\x20config\x20agent\x20encount\
    ered\x20errors\x20while\x20enforcing\n\x20compliance.\n\n\x0c\n\x05\x04\
    \0\x02\x03\x05\x12\x03d\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03d\t\
    \x17\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03d\x1a\x1b\n\x0c\n\x05\x04\0\
    \x02\x03\x08\x12\x03d\x1cG\n\x0f\n\x08\x04\0\x02\x03\x08\x9c\x08\0\x12\
    \x03d\x1dF\nS\n\x04\x04\0\x02\x04\x12\x03g\x02O\x1aF\x20Output\x20only.\
    \x20The\x20reason\x20for\x20the\x20`detailed_state`\x20of\x20the\x20VM\
    \x20(if\x20any).\n\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03g\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x04\x01\x12\x03g\t\x1e\n\x0c\n\x05\x04\0\x02\x04\x03\
    \x12\x03g!\"\n\x0c\n\x05\x04\0\x02\x04\x08\x12\x03g#N\n\x0f\n\x08\x04\0\
    \x02\x04\x08\x9c\x08\0\x12\x03g$M\nZ\n\x04\x04\0\x02\x05\x12\x03j\x02d\
    \x1aM\x20Output\x20only.\x20Compliance\x20data\x20for\x20each\x20`OSPoli\
    cy`\x20that\x20is\x20applied\x20to\x20the\x20VM.\n\n\x0c\n\x05\x04\0\x02\
    \x05\x04\x12\x03j\x02\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03j\x0b\x1d\n\
    \x0c\n\x05\x04\0\x02\x05\x01\x12\x03j\x1e3\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03j67\n\x0c\n\x05\x04\0\x02\x05\x08\x12\x03j8c\n\x0f\n\x08\x04\0\
    \x02\x05\x08\x9c\x08\0\x12\x03j9b\nN\n\x04\x04\0\x02\x06\x12\x03m\x02g\
    \x1aA\x20Output\x20only.\x20Timestamp\x20of\x20the\x20last\x20compliance\
    \x20check\x20for\x20the\x20VM.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03m\
    \x02\x1b\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03m\x1c6\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03m9:\n\x0c\n\x05\x04\0\x02\x06\x08\x12\x03m;f\n\x0f\n\
    \x08\x04\0\x02\x06\x08\x9c\x08\0\x12\x03m<e\n\xc6\x01\n\x04\x04\0\x02\
    \x07\x12\x03r\x02P\x1a\xb8\x01\x20Output\x20only.\x20Unique\x20identifie\
    r\x20for\x20the\x20last\x20compliance\x20run.\n\x20This\x20id\x20will\
    \x20be\x20logged\x20by\x20the\x20OS\x20config\x20agent\x20during\x20a\
    \x20compliance\x20run\x20and\n\x20can\x20be\x20used\x20for\x20debugging\
    \x20and\x20tracing\x20purpose.\n\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03r\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03r\t\x1f\n\x0c\n\x05\x04\0\
    \x02\x07\x03\x12\x03r\"#\n\x0c\n\x05\x04\0\x02\x07\x08\x12\x03r$O\n\x0f\
    \n\x08\x04\0\x02\x07\x08\x9c\x08\0\x12\x03r%N\ns\n\x02\x04\x01\x12\x05w\
    \0\x89\x01\x01\x1af\x20A\x20request\x20message\x20for\x20getting\x20OS\
    \x20policies\x20compliance\x20data\x20for\x20the\x20given\n\x20Compute\
    \x20Engine\x20VM\x20instance.\n\n\n\n\x03\x04\x01\x01\x12\x03w\x08.\n\n\
    \n\x03\x04\x01\x07\x12\x03x\x02\x1b\n\x0b\n\x04\x04\x01\x07\x03\x12\x03x\
    \x02\x1b\n\xed\x02\n\x04\x04\x01\x02\0\x12\x06\x83\x01\x02\x88\x01\x04\
    \x1a\xdc\x02\x20Required.\x20API\x20resource\x20name\x20for\x20instance\
    \x20OS\x20policies\x20compliance\x20resource.\n\n\x20Format:\n\x20`proje\
    cts/{project}/locations/{location}/instanceOSPoliciesCompliances/{instan\
    ce}`\n\n\x20For\x20`{project}`,\x20either\x20Compute\x20Engine\x20projec\
    t-number\x20or\x20project-id\x20can\x20be\n\x20provided.\n\x20For\x20`{i\
    nstance}`,\x20either\x20Compute\x20Engine\x20VM\x20instance-id\x20or\x20\
    instance-name\x20can\n\x20be\x20provided.\n\n\r\n\x05\x04\x01\x02\0\x05\
    \x12\x04\x83\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x83\x01\t\r\
    \n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x83\x01\x10\x11\n\x0f\n\x05\x04\x01\
    \x02\0\x08\x12\x06\x83\x01\x12\x88\x01\x03\n\x10\n\x08\x04\x01\x02\0\x08\
    \x9c\x08\0\x12\x04\x84\x01\x04*\n\x11\n\x07\x04\x01\x02\0\x08\x9f\x08\
    \x12\x06\x85\x01\x04\x87\x01\x05\n|\n\x02\x04\x02\x12\x06\x8d\x01\0\xa8\
    \x01\x01\x1an\x20A\x20request\x20message\x20for\x20listing\x20OS\x20poli\
    cies\x20compliance\x20data\x20for\x20all\x20Compute\n\x20Engine\x20VMs\
    \x20in\x20the\x20given\x20location.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\
    \x8d\x01\x080\n\x0b\n\x03\x04\x02\x07\x12\x04\x8e\x01\x02\x1b\n\x0c\n\
    \x04\x04\x02\x07\x03\x12\x04\x8e\x01\x02\x1b\n\xc2\x01\n\x04\x04\x02\x02\
    \0\x12\x06\x96\x01\x02\x9b\x01\x04\x1a\xb1\x01\x20Required.\x20The\x20pa\
    rent\x20resource\x20name.\n\n\x20Format:\x20`projects/{project}/location\
    s/{location}`\n\n\x20For\x20`{project}`,\x20either\x20Compute\x20Engine\
    \x20project-number\x20or\x20project-id\x20can\x20be\n\x20provided.\n\n\r\
    \n\x05\x04\x02\x02\0\x05\x12\x04\x96\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\x96\x01\t\x0f\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x96\x01\
    \x12\x13\n\x0f\n\x05\x04\x02\x02\0\x08\x12\x06\x96\x01\x14\x9b\x01\x03\n\
    \x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\x97\x01\x04*\n\x11\n\x07\
    \x04\x02\x02\0\x08\x9f\x08\x12\x06\x98\x01\x04\x9a\x01\x05\n8\n\x04\x04\
    \x02\x02\x01\x12\x04\x9e\x01\x02\x16\x1a*\x20The\x20maximum\x20number\
    \x20of\x20results\x20to\x20return.\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\
    \x04\x9e\x01\x02\x07\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x9e\x01\x08\
    \x11\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x9e\x01\x14\x15\n\xa2\x01\n\
    \x04\x04\x02\x02\x02\x12\x04\xa3\x01\x02\x18\x1a\x93\x01\x20A\x20paginat\
    ion\x20token\x20returned\x20from\x20a\x20previous\x20call\x20to\n\x20`Li\
    stInstanceOSPoliciesCompliances`\x20that\x20indicates\x20where\x20this\
    \x20listing\n\x20should\x20continue\x20from.\n\n\r\n\x05\x04\x02\x02\x02\
    \x05\x12\x04\xa3\x01\x02\x08\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xa3\
    \x01\t\x13\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xa3\x01\x16\x17\n\xa2\
    \x01\n\x04\x04\x02\x02\x03\x12\x04\xa7\x01\x02\x14\x1a\x93\x01\x20If\x20\
    provided,\x20this\x20field\x20specifies\x20the\x20criteria\x20that\x20mu\
    st\x20be\x20met\x20by\x20a\n\x20`InstanceOSPoliciesCompliance`\x20API\
    \x20resource\x20to\x20be\x20included\x20in\x20the\x20response.\n\n\r\n\
    \x05\x04\x02\x02\x03\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x02\x02\
    \x03\x01\x12\x04\xa7\x01\t\x0f\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xa7\
    \x01\x12\x13\n}\n\x02\x04\x03\x12\x06\xac\x01\0\xb5\x01\x01\x1ao\x20A\
    \x20response\x20message\x20for\x20listing\x20OS\x20policies\x20complianc\
    e\x20data\x20for\x20all\x20Compute\n\x20Engine\x20VMs\x20in\x20the\x20gi\
    ven\x20location.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xac\x01\x081\n\x0b\n\
    \x03\x04\x03\x07\x12\x04\xad\x01\x02\x1b\n\x0c\n\x04\x04\x03\x07\x03\x12\
    \x04\xad\x01\x02\x1b\n@\n\x04\x04\x03\x02\0\x12\x04\xb0\x01\x02M\x1a2\
    \x20List\x20of\x20instance\x20OS\x20policies\x20compliance\x20objects.\n\
    \n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xb0\x01\x02\n\n\r\n\x05\x04\x03\x02\
    \0\x06\x12\x04\xb0\x01\x0b'\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xb0\x01(\
    H\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xb0\x01KL\nk\n\x04\x04\x03\x02\x01\
    \x12\x04\xb4\x01\x02\x1d\x1a]\x20The\x20pagination\x20token\x20to\x20ret\
    rieve\x20the\x20next\x20page\x20of\x20instance\x20OS\x20policies\n\x20co\
    mpliance\x20objects.\n\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xb4\x01\x02\
    \x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xb4\x01\t\x18\n\r\n\x05\x04\
    \x03\x02\x01\x03\x12\x04\xb4\x01\x1b\x1cb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
