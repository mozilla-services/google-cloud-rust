// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1alpha/os_policy_assignment_reports.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct GetOSPolicyAssignmentReportRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetOSPolicyAssignmentReportRequest {
    fn default() -> &'a GetOSPolicyAssignmentReportRequest {
        <GetOSPolicyAssignmentReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetOSPolicyAssignmentReportRequest {
    pub fn new() -> GetOSPolicyAssignmentReportRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetOSPolicyAssignmentReportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOSPolicyAssignmentReportRequest {
        GetOSPolicyAssignmentReportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetOSPolicyAssignmentReportRequest| { &m.name },
                |m: &mut GetOSPolicyAssignmentReportRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetOSPolicyAssignmentReportRequest>(
                "GetOSPolicyAssignmentReportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetOSPolicyAssignmentReportRequest {
        static instance: ::protobuf::rt::LazyV2<GetOSPolicyAssignmentReportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetOSPolicyAssignmentReportRequest::new)
    }
}

impl ::protobuf::Clear for GetOSPolicyAssignmentReportRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOSPolicyAssignmentReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOSPolicyAssignmentReportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOSPolicyAssignmentReportsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub filter: ::std::string::String,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOSPolicyAssignmentReportsRequest {
    fn default() -> &'a ListOSPolicyAssignmentReportsRequest {
        <ListOSPolicyAssignmentReportsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOSPolicyAssignmentReportsRequest {
    pub fn new() -> ListOSPolicyAssignmentReportsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string filter = 3;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOSPolicyAssignmentReportsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filter);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.filter.is_empty() {
            os.write_string(3, &self.filter)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOSPolicyAssignmentReportsRequest {
        ListOSPolicyAssignmentReportsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListOSPolicyAssignmentReportsRequest| { &m.parent },
                |m: &mut ListOSPolicyAssignmentReportsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListOSPolicyAssignmentReportsRequest| { &m.page_size },
                |m: &mut ListOSPolicyAssignmentReportsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListOSPolicyAssignmentReportsRequest| { &m.filter },
                |m: &mut ListOSPolicyAssignmentReportsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListOSPolicyAssignmentReportsRequest| { &m.page_token },
                |m: &mut ListOSPolicyAssignmentReportsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOSPolicyAssignmentReportsRequest>(
                "ListOSPolicyAssignmentReportsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOSPolicyAssignmentReportsRequest {
        static instance: ::protobuf::rt::LazyV2<ListOSPolicyAssignmentReportsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOSPolicyAssignmentReportsRequest::new)
    }
}

impl ::protobuf::Clear for ListOSPolicyAssignmentReportsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.filter.clear();
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOSPolicyAssignmentReportsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOSPolicyAssignmentReportsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOSPolicyAssignmentReportsResponse {
    // message fields
    pub os_policy_assignment_reports: ::protobuf::RepeatedField<OSPolicyAssignmentReport>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOSPolicyAssignmentReportsResponse {
    fn default() -> &'a ListOSPolicyAssignmentReportsResponse {
        <ListOSPolicyAssignmentReportsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOSPolicyAssignmentReportsResponse {
    pub fn new() -> ListOSPolicyAssignmentReportsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport os_policy_assignment_reports = 1;


    pub fn get_os_policy_assignment_reports(&self) -> &[OSPolicyAssignmentReport] {
        &self.os_policy_assignment_reports
    }
    pub fn clear_os_policy_assignment_reports(&mut self) {
        self.os_policy_assignment_reports.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignment_reports(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignmentReport>) {
        self.os_policy_assignment_reports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policy_assignment_reports(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignmentReport> {
        &mut self.os_policy_assignment_reports
    }

    // Take field
    pub fn take_os_policy_assignment_reports(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignmentReport> {
        ::std::mem::replace(&mut self.os_policy_assignment_reports, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOSPolicyAssignmentReportsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_assignment_reports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policy_assignment_reports)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.os_policy_assignment_reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.os_policy_assignment_reports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOSPolicyAssignmentReportsResponse {
        ListOSPolicyAssignmentReportsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignmentReport>>(
                "os_policy_assignment_reports",
                |m: &ListOSPolicyAssignmentReportsResponse| { &m.os_policy_assignment_reports },
                |m: &mut ListOSPolicyAssignmentReportsResponse| { &mut m.os_policy_assignment_reports },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListOSPolicyAssignmentReportsResponse| { &m.next_page_token },
                |m: &mut ListOSPolicyAssignmentReportsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOSPolicyAssignmentReportsResponse>(
                "ListOSPolicyAssignmentReportsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOSPolicyAssignmentReportsResponse {
        static instance: ::protobuf::rt::LazyV2<ListOSPolicyAssignmentReportsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOSPolicyAssignmentReportsResponse::new)
    }
}

impl ::protobuf::Clear for ListOSPolicyAssignmentReportsResponse {
    fn clear(&mut self) {
        self.os_policy_assignment_reports.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOSPolicyAssignmentReportsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOSPolicyAssignmentReportsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignmentReport {
    // message fields
    pub name: ::std::string::String,
    pub instance: ::std::string::String,
    pub os_policy_assignment: ::std::string::String,
    pub os_policy_compliances: ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub last_run_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignmentReport {
    fn default() -> &'a OSPolicyAssignmentReport {
        <OSPolicyAssignmentReport as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignmentReport {
    pub fn new() -> OSPolicyAssignmentReport {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string instance = 2;


    pub fn get_instance(&self) -> &str {
        &self.instance
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: ::std::string::String) {
        self.instance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut ::std::string::String {
        &mut self.instance
    }

    // Take field
    pub fn take_instance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.instance, ::std::string::String::new())
    }

    // string os_policy_assignment = 3;


    pub fn get_os_policy_assignment(&self) -> &str {
        &self.os_policy_assignment
    }
    pub fn clear_os_policy_assignment(&mut self) {
        self.os_policy_assignment.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignment(&mut self, v: ::std::string::String) {
        self.os_policy_assignment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_assignment(&mut self) -> &mut ::std::string::String {
        &mut self.os_policy_assignment
    }

    // Take field
    pub fn take_os_policy_assignment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_policy_assignment, ::std::string::String::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance os_policy_compliances = 4;


    pub fn get_os_policy_compliances(&self) -> &[OSPolicyAssignmentReport_OSPolicyCompliance] {
        &self.os_policy_compliances
    }
    pub fn clear_os_policy_compliances(&mut self) {
        self.os_policy_compliances.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_compliances(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance>) {
        self.os_policy_compliances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policy_compliances(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance> {
        &mut self.os_policy_compliances
    }

    // Take field
    pub fn take_os_policy_compliances(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance> {
        ::std::mem::replace(&mut self.os_policy_compliances, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp update_time = 5;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string last_run_id = 6;


    pub fn get_last_run_id(&self) -> &str {
        &self.last_run_id
    }
    pub fn clear_last_run_id(&mut self) {
        self.last_run_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_run_id(&mut self, v: ::std::string::String) {
        self.last_run_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_run_id(&mut self) -> &mut ::std::string::String {
        &mut self.last_run_id
    }

    // Take field
    pub fn take_last_run_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_run_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignmentReport {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_compliances {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_policy_assignment)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policy_compliances)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_run_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.instance.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.instance);
        }
        if !self.os_policy_assignment.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.os_policy_assignment);
        }
        for value in &self.os_policy_compliances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.last_run_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.last_run_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.instance.is_empty() {
            os.write_string(2, &self.instance)?;
        }
        if !self.os_policy_assignment.is_empty() {
            os.write_string(3, &self.os_policy_assignment)?;
        }
        for v in &self.os_policy_compliances {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.last_run_id.is_empty() {
            os.write_string(6, &self.last_run_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignmentReport {
        OSPolicyAssignmentReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OSPolicyAssignmentReport| { &m.name },
                |m: &mut OSPolicyAssignmentReport| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instance",
                |m: &OSPolicyAssignmentReport| { &m.instance },
                |m: &mut OSPolicyAssignmentReport| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_policy_assignment",
                |m: &OSPolicyAssignmentReport| { &m.os_policy_assignment },
                |m: &mut OSPolicyAssignmentReport| { &mut m.os_policy_assignment },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignmentReport_OSPolicyCompliance>>(
                "os_policy_compliances",
                |m: &OSPolicyAssignmentReport| { &m.os_policy_compliances },
                |m: &mut OSPolicyAssignmentReport| { &mut m.os_policy_compliances },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &OSPolicyAssignmentReport| { &m.update_time },
                |m: &mut OSPolicyAssignmentReport| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_run_id",
                |m: &OSPolicyAssignmentReport| { &m.last_run_id },
                |m: &mut OSPolicyAssignmentReport| { &mut m.last_run_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignmentReport>(
                "OSPolicyAssignmentReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignmentReport {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignmentReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignmentReport::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignmentReport {
    fn clear(&mut self) {
        self.name.clear();
        self.instance.clear();
        self.os_policy_assignment.clear();
        self.os_policy_compliances.clear();
        self.update_time.clear();
        self.last_run_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignmentReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignmentReport_OSPolicyCompliance {
    // message fields
    pub os_policy_id: ::std::string::String,
    pub compliance_state: OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState,
    pub compliance_state_reason: ::std::string::String,
    pub os_policy_resource_compliances: ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignmentReport_OSPolicyCompliance {
    fn default() -> &'a OSPolicyAssignmentReport_OSPolicyCompliance {
        <OSPolicyAssignmentReport_OSPolicyCompliance as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignmentReport_OSPolicyCompliance {
    pub fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance {
        ::std::default::Default::default()
    }

    // string os_policy_id = 1;


    pub fn get_os_policy_id(&self) -> &str {
        &self.os_policy_id
    }
    pub fn clear_os_policy_id(&mut self) {
        self.os_policy_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_id(&mut self, v: ::std::string::String) {
        self.os_policy_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_id(&mut self) -> &mut ::std::string::String {
        &mut self.os_policy_id
    }

    // Take field
    pub fn take_os_policy_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_policy_id, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.ComplianceState compliance_state = 2;


    pub fn get_compliance_state(&self) -> OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState {
        self.compliance_state
    }
    pub fn clear_compliance_state(&mut self) {
        self.compliance_state = OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_compliance_state(&mut self, v: OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState) {
        self.compliance_state = v;
    }

    // string compliance_state_reason = 3;


    pub fn get_compliance_state_reason(&self) -> &str {
        &self.compliance_state_reason
    }
    pub fn clear_compliance_state_reason(&mut self) {
        self.compliance_state_reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_compliance_state_reason(&mut self, v: ::std::string::String) {
        self.compliance_state_reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compliance_state_reason(&mut self) -> &mut ::std::string::String {
        &mut self.compliance_state_reason
    }

    // Take field
    pub fn take_compliance_state_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compliance_state_reason, ::std::string::String::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance os_policy_resource_compliances = 4;


    pub fn get_os_policy_resource_compliances(&self) -> &[OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance] {
        &self.os_policy_resource_compliances
    }
    pub fn clear_os_policy_resource_compliances(&mut self) {
        self.os_policy_resource_compliances.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_resource_compliances(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance>) {
        self.os_policy_resource_compliances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policy_resource_compliances(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance> {
        &mut self.os_policy_resource_compliances
    }

    // Take field
    pub fn take_os_policy_resource_compliances(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance> {
        ::std::mem::replace(&mut self.os_policy_resource_compliances, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignmentReport_OSPolicyCompliance {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_resource_compliances {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_policy_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.compliance_state, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compliance_state_reason)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policy_resource_compliances)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.os_policy_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os_policy_id);
        }
        if self.compliance_state != OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.compliance_state);
        }
        if !self.compliance_state_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.compliance_state_reason);
        }
        for value in &self.os_policy_resource_compliances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.os_policy_id.is_empty() {
            os.write_string(1, &self.os_policy_id)?;
        }
        if self.compliance_state != OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.compliance_state))?;
        }
        if !self.compliance_state_reason.is_empty() {
            os.write_string(3, &self.compliance_state_reason)?;
        }
        for v in &self.os_policy_resource_compliances {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance {
        OSPolicyAssignmentReport_OSPolicyCompliance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_policy_id",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance| { &m.os_policy_id },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance| { &mut m.os_policy_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState>>(
                "compliance_state",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance| { &m.compliance_state },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance| { &mut m.compliance_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "compliance_state_reason",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance| { &m.compliance_state_reason },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance| { &mut m.compliance_state_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance>>(
                "os_policy_resource_compliances",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance| { &m.os_policy_resource_compliances },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance| { &mut m.os_policy_resource_compliances },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignmentReport_OSPolicyCompliance>(
                "OSPolicyAssignmentReport.OSPolicyCompliance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignmentReport_OSPolicyCompliance {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignmentReport_OSPolicyCompliance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignmentReport_OSPolicyCompliance::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignmentReport_OSPolicyCompliance {
    fn clear(&mut self) {
        self.os_policy_id.clear();
        self.compliance_state = OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::UNKNOWN;
        self.compliance_state_reason.clear();
        self.os_policy_resource_compliances.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignmentReport_OSPolicyCompliance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport_OSPolicyCompliance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
    // message fields
    pub os_policy_resource_id: ::std::string::String,
    pub config_steps: ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep>,
    pub compliance_state: OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState,
    pub compliance_state_reason: ::std::string::String,
    // message oneof groups
    pub output: ::std::option::Option<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
    fn default() -> &'a OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
        <OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output {
    exec_resource_output(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput),
}

impl OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
    pub fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
        ::std::default::Default::default()
    }

    // string os_policy_resource_id = 1;


    pub fn get_os_policy_resource_id(&self) -> &str {
        &self.os_policy_resource_id
    }
    pub fn clear_os_policy_resource_id(&mut self) {
        self.os_policy_resource_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_resource_id(&mut self, v: ::std::string::String) {
        self.os_policy_resource_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_resource_id(&mut self) -> &mut ::std::string::String {
        &mut self.os_policy_resource_id
    }

    // Take field
    pub fn take_os_policy_resource_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_policy_resource_id, ::std::string::String::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep config_steps = 2;


    pub fn get_config_steps(&self) -> &[OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep] {
        &self.config_steps
    }
    pub fn clear_config_steps(&mut self) {
        self.config_steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_steps(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep>) {
        self.config_steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config_steps(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep> {
        &mut self.config_steps
    }

    // Take field
    pub fn take_config_steps(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep> {
        ::std::mem::replace(&mut self.config_steps, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ComplianceState compliance_state = 3;


    pub fn get_compliance_state(&self) -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState {
        self.compliance_state
    }
    pub fn clear_compliance_state(&mut self) {
        self.compliance_state = OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_compliance_state(&mut self, v: OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState) {
        self.compliance_state = v;
    }

    // string compliance_state_reason = 4;


    pub fn get_compliance_state_reason(&self) -> &str {
        &self.compliance_state_reason
    }
    pub fn clear_compliance_state_reason(&mut self) {
        self.compliance_state_reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_compliance_state_reason(&mut self, v: ::std::string::String) {
        self.compliance_state_reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compliance_state_reason(&mut self) -> &mut ::std::string::String {
        &mut self.compliance_state_reason
    }

    // Take field
    pub fn take_compliance_state_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compliance_state_reason, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ExecResourceOutput exec_resource_output = 5;


    pub fn get_exec_resource_output(&self) -> &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
        match self.output {
            ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(ref v)) => v,
            _ => <OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exec_resource_output(&mut self) {
        self.output = ::std::option::Option::None;
    }

    pub fn has_exec_resource_output(&self) -> bool {
        match self.output {
            ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exec_resource_output(&mut self, v: OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput) {
        self.output = ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exec_resource_output(&mut self) -> &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
        if let ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(_)) = self.output {
        } else {
            self.output = ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput::new()));
        }
        match self.output {
            ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exec_resource_output(&mut self) -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
        if self.has_exec_resource_output() {
            match self.output.take() {
                ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(v)) => v,
                _ => panic!(),
            }
        } else {
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput::new()
        }
    }
}

impl ::protobuf::Message for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
    fn is_initialized(&self) -> bool {
        for v in &self.config_steps {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(ref v)) = self.output {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_policy_resource_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.config_steps)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.compliance_state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compliance_state_reason)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.output = ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.os_policy_resource_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os_policy_resource_id);
        }
        for value in &self.config_steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.compliance_state != OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.compliance_state);
        }
        if !self.compliance_state_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.compliance_state_reason);
        }
        if let ::std::option::Option::Some(ref v) = self.output {
            match v {
                &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.os_policy_resource_id.is_empty() {
            os.write_string(1, &self.os_policy_resource_id)?;
        }
        for v in &self.config_steps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.compliance_state != OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::UNKNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.compliance_state))?;
        }
        if !self.compliance_state_reason.is_empty() {
            os.write_string(4, &self.compliance_state_reason)?;
        }
        if let ::std::option::Option::Some(ref v) = self.output {
            match v {
                &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_oneof_output::exec_resource_output(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
        OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_policy_resource_id",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &m.os_policy_resource_id },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &mut m.os_policy_resource_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep>>(
                "config_steps",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &m.config_steps },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &mut m.config_steps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState>>(
                "compliance_state",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &m.compliance_state },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &mut m.compliance_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "compliance_state_reason",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &m.compliance_state_reason },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance| { &mut m.compliance_state_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput>(
                "exec_resource_output",
                OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance::has_exec_resource_output,
                OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance::get_exec_resource_output,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance>(
                "OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
    fn clear(&mut self) {
        self.os_policy_resource_id.clear();
        self.config_steps.clear();
        self.compliance_state = OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::UNKNOWN;
        self.compliance_state_reason.clear();
        self.output = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
    // message fields
    pub field_type: OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type,
    pub error_message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
    fn default() -> &'a OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
        <OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
    pub fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep.Type type = 1;


    pub fn get_field_type(&self) -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type) {
        self.field_type = v;
    }

    // string error_message = 2;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.error_message.is_empty() {
            os.write_string(2, &self.error_message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
        OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type>>(
                "type",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep| { &m.field_type },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep| { &m.error_message },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep| { &mut m.error_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep>(
                "OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
    fn clear(&mut self) {
        self.field_type = OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::TYPE_UNSPECIFIED;
        self.error_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type {
    TYPE_UNSPECIFIED = 0,
    VALIDATION = 1,
    DESIRED_STATE_CHECK = 2,
    DESIRED_STATE_ENFORCEMENT = 3,
    DESIRED_STATE_CHECK_POST_ENFORCEMENT = 4,
}

impl ::protobuf::ProtobufEnum for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type> {
        match value {
            0 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::VALIDATION),
            2 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::DESIRED_STATE_CHECK),
            3 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::DESIRED_STATE_ENFORCEMENT),
            4 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::DESIRED_STATE_CHECK_POST_ENFORCEMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type] = &[
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::TYPE_UNSPECIFIED,
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::VALIDATION,
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::DESIRED_STATE_CHECK,
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::DESIRED_STATE_ENFORCEMENT,
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::DESIRED_STATE_CHECK_POST_ENFORCEMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type>("OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStep.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type {
}

impl ::std::default::Default for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type {
    fn default() -> Self {
        OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_OSPolicyResourceConfigStep_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
    // message fields
    pub enforcement_output: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
    fn default() -> &'a OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
        <OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
    pub fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
        ::std::default::Default::default()
    }

    // bytes enforcement_output = 2;


    pub fn get_enforcement_output(&self) -> &[u8] {
        &self.enforcement_output
    }
    pub fn clear_enforcement_output(&mut self) {
        self.enforcement_output.clear();
    }

    // Param is passed by value, moved
    pub fn set_enforcement_output(&mut self, v: ::std::vec::Vec<u8>) {
        self.enforcement_output = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enforcement_output(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.enforcement_output
    }

    // Take field
    pub fn take_enforcement_output(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.enforcement_output, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.enforcement_output)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.enforcement_output.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.enforcement_output);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.enforcement_output.is_empty() {
            os.write_bytes(2, &self.enforcement_output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
        OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "enforcement_output",
                |m: &OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput| { &m.enforcement_output },
                |m: &mut OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput| { &mut m.enforcement_output },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput>(
                "OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ExecResourceOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
    fn clear(&mut self) {
        self.enforcement_output.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ExecResourceOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState {
    UNKNOWN = 0,
    COMPLIANT = 1,
    NON_COMPLIANT = 2,
}

impl ::protobuf::ProtobufEnum for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState> {
        match value {
            0 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::UNKNOWN),
            1 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::COMPLIANT),
            2 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::NON_COMPLIANT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState] = &[
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::UNKNOWN,
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::COMPLIANT,
            OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::NON_COMPLIANT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState>("OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicyResourceCompliance.ComplianceState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState {
}

impl ::std::default::Default for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState {
    fn default() -> Self {
        OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport_OSPolicyCompliance_OSPolicyResourceCompliance_ComplianceState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState {
    UNKNOWN = 0,
    COMPLIANT = 1,
    NON_COMPLIANT = 2,
}

impl ::protobuf::ProtobufEnum for OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState> {
        match value {
            0 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::UNKNOWN),
            1 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::COMPLIANT),
            2 => ::std::option::Option::Some(OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::NON_COMPLIANT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState] = &[
            OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::UNKNOWN,
            OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::COMPLIANT,
            OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::NON_COMPLIANT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState>("OSPolicyAssignmentReport.OSPolicyCompliance.ComplianceState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState {
}

impl ::std::default::Default for OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState {
    fn default() -> Self {
        OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentReport_OSPolicyCompliance_ComplianceState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n@google/cloud/osconfig/v1alpha/os_policy_assignment_reports.proto\x12\
    \x1dgoogle.cloud.osconfig.v1alpha\x1a\x1fgoogle/api/field_behavior.proto\
    \x1a\x19google/api/resource.proto\x1a\x1fgoogle/protobuf/timestamp.proto\
    \"r\n\"GetOSPolicyAssignmentReportRequest\x12L\n\x04name\x18\x01\x20\x01\
    (\tR\x04nameB8\xfaA2\n0osconfig.googleapis.com/OSPolicyAssignmentReport\
    \xe0A\x02\"\xcd\x01\n$ListOSPolicyAssignmentReportsRequest\x12Q\n\x06par\
    ent\x18\x01\x20\x01(\tR\x06parentB9\xfaA3\n1compute.googleapis.com/Insta\
    nceOSPolicyAssignment\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05\
    R\x08pageSize\x12\x16\n\x06filter\x18\x03\x20\x01(\tR\x06filter\x12\x1d\
    \n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\xc9\x01\n%ListOSPolicyAs\
    signmentReportsResponse\x12x\n\x1cos_policy_assignment_reports\x18\x01\
    \x20\x03(\x0b27.google.cloud.osconfig.v1alpha.OSPolicyAssignmentReportR\
    \x19osPolicyAssignmentReports\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\
    \tR\rnextPageToken\"\x97\x11\n\x18OSPolicyAssignmentReport\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08instance\x18\x02\x20\x01(\
    \tR\x08instance\x12a\n\x14os_policy_assignment\x18\x03\x20\x01(\tR\x12os\
    PolicyAssignmentB/\xfaA,\n*osconfig.googleapis.com/OSPolicyAssignment\
    \x12~\n\x15os_policy_compliances\x18\x04\x20\x03(\x0b2J.google.cloud.osc\
    onfig.v1alpha.OSPolicyAssignmentReport.OSPolicyComplianceR\x13osPolicyCo\
    mpliances\x12;\n\x0bupdate_time\x18\x05\x20\x01(\x0b2\x1a.google.protobu\
    f.TimestampR\nupdateTime\x12\x1e\n\x0blast_run_id\x18\x06\x20\x01(\tR\tl\
    astRunId\x1a\xeb\x0c\n\x12OSPolicyCompliance\x12\x20\n\x0cos_policy_id\
    \x18\x01\x20\x01(\tR\nosPolicyId\x12\x85\x01\n\x10compliance_state\x18\
    \x02\x20\x01(\x0e2Z.google.cloud.osconfig.v1alpha.OSPolicyAssignmentRepo\
    rt.OSPolicyCompliance.ComplianceStateR\x0fcomplianceState\x126\n\x17comp\
    liance_state_reason\x18\x03\x20\x01(\tR\x15complianceStateReason\x12\xaa\
    \x01\n\x1eos_policy_resource_compliances\x18\x04\x20\x03(\x0b2e.google.c\
    loud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.OSPoli\
    cyResourceComplianceR\x1bosPolicyResourceCompliances\x1a\x83\t\n\x1aOSPo\
    licyResourceCompliance\x121\n\x15os_policy_resource_id\x18\x01\x20\x01(\
    \tR\x12osPolicyResourceId\x12\xa4\x01\n\x0cconfig_steps\x18\x02\x20\x03(\
    \x0b2\x80\x01.google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSP\
    olicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigStepR\
    \x0bconfigSteps\x12\xa0\x01\n\x10compliance_state\x18\x03\x20\x01(\x0e2u\
    .google.cloud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyComplian\
    ce.OSPolicyResourceCompliance.ComplianceStateR\x0fcomplianceState\x126\n\
    \x17compliance_state_reason\x18\x04\x20\x01(\tR\x15complianceStateReason\
    \x12\xac\x01\n\x14exec_resource_output\x18\x05\x20\x01(\x0b2x.google.clo\
    ud.osconfig.v1alpha.OSPolicyAssignmentReport.OSPolicyCompliance.OSPolicy\
    ResourceCompliance.ExecResourceOutputH\0R\x12execResourceOutput\x1a\xef\
    \x02\n\x1aOSPolicyResourceConfigStep\x12\x9a\x01\n\x04type\x18\x01\x20\
    \x01(\x0e2\x85\x01.google.cloud.osconfig.v1alpha.OSPolicyAssignmentRepor\
    t.OSPolicyCompliance.OSPolicyResourceCompliance.OSPolicyResourceConfigSt\
    ep.TypeR\x04type\x12#\n\rerror_message\x18\x02\x20\x01(\tR\x0cerrorMessa\
    ge\"\x8e\x01\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\x0e\n\nVA\
    LIDATION\x10\x01\x12\x17\n\x13DESIRED_STATE_CHECK\x10\x02\x12\x1d\n\x19D\
    ESIRED_STATE_ENFORCEMENT\x10\x03\x12(\n$DESIRED_STATE_CHECK_POST_ENFORCE\
    MENT\x10\x04\x1aC\n\x12ExecResourceOutput\x12-\n\x12enforcement_output\
    \x18\x02\x20\x01(\x0cR\x11enforcementOutput\"@\n\x0fComplianceState\x12\
    \x0b\n\x07UNKNOWN\x10\0\x12\r\n\tCOMPLIANT\x10\x01\x12\x11\n\rNON_COMPLI\
    ANT\x10\x02B\x08\n\x06output\"@\n\x0fComplianceState\x12\x0b\n\x07UNKNOW\
    N\x10\0\x12\r\n\tCOMPLIANT\x10\x01\x12\x11\n\rNON_COMPLIANT\x10\x02:\x9c\
    \x01\xeaA\x98\x01\n0osconfig.googleapis.com/OSPolicyAssignmentReport\x12\
    dprojects/{project}/locations/{location}/instances/{instance}/osPolicyAs\
    signments/{assignment}/reportB\xfd\x02\n!com.google.cloud.osconfig.v1alp\
    haB\x1eOSPolicyAssignmentReportsProtoP\x01Z=cloud.google.com/go/osconfig\
    /apiv1alpha/osconfigpb;osconfigpb\xaa\x02\x1dGoogle.Cloud.OsConfig.V1Alp\
    ha\xca\x02\x1dGoogle\\Cloud\\OsConfig\\V1alpha\xea\x02\x20Google::Cloud:\
    :OsConfig::V1alpha\xeaA\x92\x01\n1compute.googleapis.com/InstanceOSPolic\
    yAssignment\x12]projects/{project}/locations/{location}/instances/{insta\
    nce}/osPolicyAssignments/{assignment}J\xeeU\n\x07\x12\x05\x0e\0\xa7\x02\
    \x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202021\
    \x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\
    \x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20us\
    e\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20Licens\
    e.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\
    \n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\
    \x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\
    \x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\x20Licen\
    se\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHO\
    UT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20\
    express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20sp\
    ecific\x20language\x20governing\x20permissions\x20and\n\x20limitations\
    \x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0&\n\t\n\x02\
    \x03\0\x12\x03\x12\0)\n\t\n\x02\x03\x01\x12\x03\x13\0#\n\t\n\x02\x03\x02\
    \x12\x03\x14\0)\n\x08\n\x01\x08\x12\x03\x16\0:\n\t\n\x02\x08%\x12\x03\
    \x16\0:\n\x08\n\x01\x08\x12\x03\x17\0T\n\t\n\x02\x08\x0b\x12\x03\x17\0T\
    \n\x08\n\x01\x08\x12\x03\x18\0\"\n\t\n\x02\x08\n\x12\x03\x18\0\"\n\x08\n\
    \x01\x08\x12\x03\x19\0?\n\t\n\x02\x08\x08\x12\x03\x19\0?\n\x08\n\x01\x08\
    \x12\x03\x1a\0:\n\t\n\x02\x08\x01\x12\x03\x1a\0:\n\x08\n\x01\x08\x12\x03\
    \x1b\0:\n\t\n\x02\x08)\x12\x03\x1b\0:\n\x08\n\x01\x08\x12\x03\x1c\09\n\t\
    \n\x02\x08-\x12\x03\x1c\09\n\t\n\x01\x08\x12\x04\x1d\0\x20\x02\n\x0c\n\
    \x04\x08\x9d\x08\0\x12\x04\x1d\0\x20\x02\nI\n\x02\x04\0\x12\x04#\03\x01\
    \x1a=\x20Get\x20a\x20report\x20of\x20the\x20OS\x20policy\x20assignment\
    \x20for\x20a\x20VM\x20instance.\n\n\n\n\x03\x04\0\x01\x12\x03#\x08*\n\
    \xaf\x03\n\x04\x04\0\x02\0\x12\x04-\x022\x04\x1a\xa0\x03\x20Required.\
    \x20API\x20resource\x20name\x20for\x20OS\x20policy\x20assignment\x20repo\
    rt.\n\n\x20Format:\n\x20`/projects/{project}/locations/{location}/instan\
    ces/{instance}/osPolicyAssignments/{assignment}/report`\n\n\x20For\x20`{\
    project}`,\x20either\x20`project-number`\x20or\x20`project-id`\x20can\
    \x20be\x20provided.\n\x20For\x20`{instance_id}`,\x20either\x20Compute\
    \x20Engine\x20`instance-id`\x20or\x20`instance-name`\n\x20can\x20be\x20p\
    rovided.\n\x20For\x20`{assignment_id}`,\x20the\x20OSPolicyAssignment\x20\
    id\x20must\x20be\x20provided.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03-\x02\
    \x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03-\t\r\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03-\x10\x11\n\r\n\x05\x04\0\x02\0\x08\x12\x04-\x122\x03\n\x0f\
    \n\x08\x04\0\x02\0\x08\x9c\x08\0\x12\x03.\x04*\n\x0f\n\x07\x04\0\x02\0\
    \x08\x9f\x08\x12\x04/\x041\x05\nE\n\x02\x04\x01\x12\x046\0^\x01\x1a9\x20\
    List\x20the\x20OS\x20policy\x20assignment\x20reports\x20for\x20VM\x20ins\
    tances.\n\n\n\n\x03\x04\x01\x01\x12\x036\x08,\n\x86\t\n\x04\x04\x01\x02\
    \0\x12\x04L\x02Q\x04\x1a\xf7\x08\x20Required.\x20The\x20parent\x20resour\
    ce\x20name.\n\n\x20Format:\n\x20`projects/{project}/locations/{location}\
    /instances/{instance}/osPolicyAssignments/{assignment}/reports`\n\n\x20F\
    or\x20`{project}`,\x20either\x20`project-number`\x20or\x20`project-id`\
    \x20can\x20be\x20provided.\n\x20For\x20`{instance}`,\x20either\x20`insta\
    nce-name`,\x20`instance-id`,\x20or\x20`-`\x20can\x20be\n\x20provided.\
    \x20If\x20'-'\x20is\x20provided,\x20the\x20response\x20will\x20include\n\
    \x20OSPolicyAssignmentReports\x20for\x20all\x20instances\x20in\x20the\
    \x20project/location.\n\x20For\x20`{assignment}`,\x20either\x20`assignme\
    nt-id`\x20or\x20`-`\x20can\x20be\x20provided.\x20If\x20'-'\n\x20is\x20pr\
    ovided,\x20the\x20response\x20will\x20include\x20OSPolicyAssignmentRepor\
    ts\x20for\x20all\n\x20OSPolicyAssignments\x20in\x20the\x20project/locati\
    on.\n\x20Either\x20{instance}\x20or\x20{assignment}\x20must\x20be\x20`-`\
    .\n\n\x20For\x20example:\n\x20`projects/{project}/locations/{location}/i\
    nstances/{instance}/osPolicyAssignments/-/reports`\n\x20\x20returns\x20a\
    ll\x20reports\x20for\x20the\x20instance\n\x20`projects/{project}/locatio\
    ns/{location}/instances/-/osPolicyAssignments/{assignment-id}/reports`\n\
    \x20\x20returns\x20all\x20the\x20reports\x20for\x20the\x20given\x20assig\
    nment\x20across\x20all\x20instances.\n\x20`projects/{project}/locations/\
    {location}/instances/-/osPolicyAssignments/-/reports`\n\x20\x20returns\
    \x20all\x20the\x20reports\x20for\x20all\x20assignments\x20across\x20all\
    \x20instances.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03L\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03L\t\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03L\x12\x13\n\r\n\x05\x04\x01\x02\0\x08\x12\x04L\x14Q\x03\n\x0f\n\x08\
    \x04\x01\x02\0\x08\x9c\x08\0\x12\x03M\x04*\n\x0f\n\x07\x04\x01\x02\0\x08\
    \x9f\x08\x12\x04N\x04P\x05\n7\n\x04\x04\x01\x02\x01\x12\x03T\x02\x16\x1a\
    *\x20The\x20maximum\x20number\x20of\x20results\x20to\x20return.\n\n\x0c\
    \n\x05\x04\x01\x02\x01\x05\x12\x03T\x02\x07\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03T\x08\x11\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03T\x14\x15\n\
    \xa1\x01\n\x04\x04\x01\x02\x02\x12\x03X\x02\x14\x1a\x93\x01\x20If\x20pro\
    vided,\x20this\x20field\x20specifies\x20the\x20criteria\x20that\x20must\
    \x20be\x20met\x20by\x20the\n\x20`OSPolicyAssignmentReport`\x20API\x20res\
    ource\x20that\x20is\x20included\x20in\x20the\x20response.\n\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03X\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03X\t\x0f\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03X\x12\x13\n\xa8\
    \x01\n\x04\x04\x01\x02\x03\x12\x03]\x02\x18\x1a\x9a\x01\x20A\x20paginati\
    on\x20token\x20returned\x20from\x20a\x20previous\x20call\x20to\x20the\n\
    \x20`ListOSPolicyAssignmentReports`\x20method\x20that\x20indicates\x20wh\
    ere\x20this\x20listing\n\x20should\x20continue\x20from.\n\n\x0c\n\x05\
    \x04\x01\x02\x03\x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\
    \x12\x03]\t\x13\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03]\x16\x17\nx\n\
    \x02\x04\x02\x12\x04b\0i\x01\x1al\x20A\x20response\x20message\x20for\x20\
    listing\x20OS\x20Policy\x20assignment\x20reports\x20including\x20the\n\
    \x20page\x20of\x20results\x20and\x20page\x20token.\n\n\n\n\x03\x04\x02\
    \x01\x12\x03b\x08-\n4\n\x04\x04\x02\x02\0\x12\x03d\x02E\x1a'\x20List\x20\
    of\x20OS\x20policy\x20assignment\x20reports.\n\n\x0c\n\x05\x04\x02\x02\0\
    \x04\x12\x03d\x02\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03d\x0b#\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03d$@\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03d\
    CD\nf\n\x04\x04\x02\x02\x01\x12\x03h\x02\x1d\x1aY\x20The\x20pagination\
    \x20token\x20to\x20retrieve\x20the\x20next\x20page\x20of\x20OS\x20policy\
    \x20assignment\n\x20report\x20objects.\n\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03h\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03h\t\x18\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03h\x1b\x1c\nP\n\x02\x04\x03\x12\x05l\0\
    \xa7\x02\x01\x1aC\x20A\x20report\x20of\x20the\x20OS\x20policy\x20assignm\
    ent\x20status\x20for\x20a\x20given\x20instance.\n\n\n\n\x03\x04\x03\x01\
    \x12\x03l\x08\x20\n\x0b\n\x03\x04\x03\x07\x12\x04m\x02p\x04\n\r\n\x05\
    \x04\x03\x07\x9d\x08\x12\x04m\x02p\x04\n1\n\x04\x04\x03\x03\0\x12\x05s\
    \x02\x85\x02\x03\x1a\"\x20Compliance\x20data\x20for\x20an\x20OS\x20polic\
    y\n\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x03s\n\x1c\n?\n\x06\x04\x03\x03\0\
    \x04\0\x12\x05u\x04\x87\x01\x05\x1a.\x20Possible\x20compliance\x20states\
    \x20for\x20an\x20os\x20policy.\n\n\x0e\n\x07\x04\x03\x03\0\x04\0\x01\x12\
    \x03u\t\x18\n\xba\x01\n\x08\x04\x03\x03\0\x04\0\x02\0\x12\x03z\x06\x12\
    \x1a\xa8\x01\x20The\x20policy\x20is\x20in\x20an\x20unknown\x20compliance\
    \x20state.\n\n\x20Refer\x20to\x20the\x20field\x20`compliance_state_reaso\
    n`\x20to\x20learn\x20the\x20exact\x20reason\n\x20for\x20the\x20policy\
    \x20to\x20be\x20in\x20this\x20compliance\x20state.\n\n\x10\n\t\x04\x03\
    \x03\0\x04\0\x02\0\x01\x12\x03z\x06\r\n\x10\n\t\x04\x03\x03\0\x04\0\x02\
    \0\x02\x12\x03z\x10\x11\nw\n\x08\x04\x03\x03\0\x04\0\x02\x01\x12\x04\x80\
    \x01\x06\x14\x1ae\x20Policy\x20is\x20compliant.\n\n\x20The\x20policy\x20\
    is\x20compliant\x20if\x20all\x20the\x20underlying\x20resources\x20are\
    \x20also\n\x20compliant.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x01\x01\x12\
    \x04\x80\x01\x06\x0f\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x01\x02\x12\x04\
    \x80\x01\x12\x13\n\x82\x01\n\x08\x04\x03\x03\0\x04\0\x02\x02\x12\x04\x86\
    \x01\x06\x18\x1ap\x20Policy\x20is\x20non-compliant.\n\n\x20The\x20policy\
    \x20is\x20non-compliant\x20if\x20one\x20or\x20more\x20underlying\x20reso\
    urces\x20are\n\x20non-compliant.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x02\
    \x01\x12\x04\x86\x01\x06\x13\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x02\x02\
    \x12\x04\x86\x01\x16\x17\n>\n\x06\x04\x03\x03\0\x03\0\x12\x06\x8a\x01\
    \x04\xe4\x01\x05\x1a,\x20Compliance\x20data\x20for\x20an\x20OS\x20policy\
    \x20resource.\n\n\x0f\n\x07\x04\x03\x03\0\x03\0\x01\x12\x04\x8a\x01\x0c&\
    \ny\n\x08\x04\x03\x03\0\x03\0\x03\0\x12\x06\x8d\x01\x06\xad\x01\x07\x1ae\
    \x20Step\x20performed\x20by\x20the\x20OS\x20Config\x20agent\x20for\x20co\
    nfiguring\x20an\n\x20`OSPolicy`\x20resource\x20to\x20its\x20desired\x20s\
    tate.\n\n\x11\n\t\x04\x03\x03\0\x03\0\x03\0\x01\x12\x04\x8d\x01\x0e(\n:\
    \n\n\x04\x03\x03\0\x03\0\x03\0\x04\0\x12\x06\x8f\x01\x08\xa5\x01\t\x1a$\
    \x20Supported\x20configuration\x20step\x20types\n\n\x13\n\x0b\x04\x03\
    \x03\0\x03\0\x03\0\x04\0\x01\x12\x04\x8f\x01\r\x11\n<\n\x0c\x04\x03\x03\
    \0\x03\0\x03\0\x04\0\x02\0\x12\x04\x91\x01\n\x1f\x1a&\x20Default\x20valu\
    e.\x20This\x20value\x20is\x20unused.\n\n\x15\n\r\x04\x03\x03\0\x03\0\x03\
    \0\x04\0\x02\0\x01\x12\x04\x91\x01\n\x1a\n\x15\n\r\x04\x03\x03\0\x03\0\
    \x03\0\x04\0\x02\0\x02\x12\x04\x91\x01\x1d\x1e\nL\n\x0c\x04\x03\x03\0\
    \x03\0\x03\0\x04\0\x02\x01\x12\x04\x94\x01\n\x19\x1a6\x20Checks\x20for\
    \x20resource\x20conflicts\x20such\x20as\x20schema\x20errors.\n\n\x15\n\r\
    \x04\x03\x03\0\x03\0\x03\0\x04\0\x02\x01\x01\x12\x04\x94\x01\n\x14\n\x15\
    \n\r\x04\x03\x03\0\x03\0\x03\0\x04\0\x02\x01\x02\x12\x04\x94\x01\x17\x18\
    \nV\n\x0c\x04\x03\x03\0\x03\0\x03\0\x04\0\x02\x02\x12\x04\x97\x01\n\"\
    \x1a@\x20Checks\x20the\x20current\x20status\x20of\x20the\x20desired\x20s\
    tate\x20for\x20a\x20resource.\n\n\x15\n\r\x04\x03\x03\0\x03\0\x03\0\x04\
    \0\x02\x02\x01\x12\x04\x97\x01\n\x1d\n\x15\n\r\x04\x03\x03\0\x03\0\x03\0\
    \x04\0\x02\x02\x02\x12\x04\x97\x01\x20!\n`\n\x0c\x04\x03\x03\0\x03\0\x03\
    \0\x04\0\x02\x03\x12\x04\x9b\x01\n(\x1aJ\x20Enforces\x20the\x20desired\
    \x20state\x20for\x20a\x20resource\x20that\x20is\x20not\x20in\x20desired\
    \n\x20state.\n\n\x15\n\r\x04\x03\x03\0\x03\0\x03\0\x04\0\x02\x03\x01\x12\
    \x04\x9b\x01\n#\n\x15\n\r\x04\x03\x03\0\x03\0\x03\0\x04\0\x02\x03\x02\
    \x12\x04\x9b\x01&'\n\xe8\x02\n\x0c\x04\x03\x03\0\x03\0\x03\0\x04\0\x02\
    \x04\x12\x04\xa4\x01\n3\x1a\xd1\x02\x20Re-checks\x20the\x20status\x20of\
    \x20the\x20desired\x20state.\x20This\x20check\x20is\x20done\n\x20for\x20\
    a\x20resource\x20after\x20the\x20enforcement\x20of\x20all\x20OS\x20polic\
    ies.\n\n\x20This\x20step\x20is\x20used\x20to\x20determine\x20the\x20fina\
    l\x20desired\x20state\x20status\x20for\n\x20the\x20resource.\x20It\x20ac\
    counts\x20for\x20any\x20resources\x20that\x20might\x20have\x20drifted\n\
    \x20from\x20their\x20desired\x20state\x20due\x20to\x20side\x20effects\
    \x20from\x20executing\x20other\n\x20resources.\n\n\x15\n\r\x04\x03\x03\0\
    \x03\0\x03\0\x04\0\x02\x04\x01\x12\x04\xa4\x01\n.\n\x15\n\r\x04\x03\x03\
    \0\x03\0\x03\0\x04\0\x02\x04\x02\x12\x04\xa4\x0112\n.\n\n\x04\x03\x03\0\
    \x03\0\x03\0\x02\0\x12\x04\xa8\x01\x08\x16\x1a\x1a\x20Configuration\x20s\
    tep\x20type.\n\n\x13\n\x0b\x04\x03\x03\0\x03\0\x03\0\x02\0\x06\x12\x04\
    \xa8\x01\x08\x0c\n\x13\n\x0b\x04\x03\x03\0\x03\0\x03\0\x02\0\x01\x12\x04\
    \xa8\x01\r\x11\n\x13\n\x0b\x04\x03\x03\0\x03\0\x03\0\x02\0\x03\x12\x04\
    \xa8\x01\x14\x15\n\x9a\x01\n\n\x04\x03\x03\0\x03\0\x03\0\x02\x01\x12\x04\
    \xac\x01\x08!\x1a\x85\x01\x20An\x20error\x20message\x20recorded\x20durin\
    g\x20the\x20execution\x20of\x20this\x20step.\n\x20Only\x20populated\x20i\
    f\x20errors\x20were\x20encountered\x20during\x20this\x20step\x20executio\
    n.\n\n\x13\n\x0b\x04\x03\x03\0\x03\0\x03\0\x02\x01\x05\x12\x04\xac\x01\
    \x08\x0e\n\x13\n\x0b\x04\x03\x03\0\x03\0\x03\0\x02\x01\x01\x12\x04\xac\
    \x01\x0f\x1c\n\x13\n\x0b\x04\x03\x03\0\x03\0\x03\0\x02\x01\x03\x12\x04\
    \xac\x01\x1f\x20\n@\n\x08\x04\x03\x03\0\x03\0\x04\0\x12\x06\xb0\x01\x06\
    \xbc\x01\x07\x1a,\x20Possible\x20compliance\x20states\x20for\x20a\x20res\
    ource.\n\n\x11\n\t\x04\x03\x03\0\x03\0\x04\0\x01\x12\x04\xb0\x01\x0b\x1a\
    \n\xbe\x01\n\n\x04\x03\x03\0\x03\0\x04\0\x02\0\x12\x04\xb5\x01\x08\x14\
    \x1a\xa9\x01\x20The\x20resource\x20is\x20in\x20an\x20unknown\x20complian\
    ce\x20state.\n\n\x20To\x20get\x20more\x20details\x20about\x20why\x20the\
    \x20policy\x20is\x20in\x20this\x20state,\x20review\n\x20the\x20output\
    \x20of\x20the\x20`compliance_state_reason`\x20field.\n\n\x13\n\x0b\x04\
    \x03\x03\0\x03\0\x04\0\x02\0\x01\x12\x04\xb5\x01\x08\x0f\n\x13\n\x0b\x04\
    \x03\x03\0\x03\0\x04\0\x02\0\x02\x12\x04\xb5\x01\x12\x13\n,\n\n\x04\x03\
    \x03\0\x03\0\x04\0\x02\x01\x12\x04\xb8\x01\x08\x16\x1a\x18\x20Resource\
    \x20is\x20compliant.\n\n\x13\n\x0b\x04\x03\x03\0\x03\0\x04\0\x02\x01\x01\
    \x12\x04\xb8\x01\x08\x11\n\x13\n\x0b\x04\x03\x03\0\x03\0\x04\0\x02\x01\
    \x02\x12\x04\xb8\x01\x14\x15\n0\n\n\x04\x03\x03\0\x03\0\x04\0\x02\x02\
    \x12\x04\xbb\x01\x08\x1a\x1a\x1c\x20Resource\x20is\x20non-compliant.\n\n\
    \x13\n\x0b\x04\x03\x03\0\x03\0\x04\0\x02\x02\x01\x12\x04\xbb\x01\x08\x15\
    \n\x13\n\x0b\x04\x03\x03\0\x03\0\x04\0\x02\x02\x02\x12\x04\xbb\x01\x18\
    \x19\n3\n\x08\x04\x03\x03\0\x03\0\x03\x01\x12\x06\xbf\x01\x06\xc3\x01\
    \x07\x1a\x1f\x20ExecResource\x20specific\x20output.\n\n\x11\n\t\x04\x03\
    \x03\0\x03\0\x03\x01\x01\x12\x04\xbf\x01\x0e\x20\np\n\n\x04\x03\x03\0\
    \x03\0\x03\x01\x02\0\x12\x04\xc2\x01\x08%\x1a\\\x20Output\x20from\x20enf\
    orcement\x20phase\x20output\x20file\x20(if\x20run).\n\x20Output\x20size\
    \x20is\x20limited\x20to\x20100K\x20bytes.\n\n\x13\n\x0b\x04\x03\x03\0\
    \x03\0\x03\x01\x02\0\x05\x12\x04\xc2\x01\x08\r\n\x13\n\x0b\x04\x03\x03\0\
    \x03\0\x03\x01\x02\0\x01\x12\x04\xc2\x01\x0e\x20\n\x13\n\x0b\x04\x03\x03\
    \0\x03\0\x03\x01\x02\0\x03\x12\x04\xc2\x01#$\n5\n\x08\x04\x03\x03\0\x03\
    \0\x02\0\x12\x04\xc6\x01\x06'\x1a#\x20The\x20ID\x20of\x20the\x20OS\x20po\
    licy\x20resource.\n\n\x11\n\t\x04\x03\x03\0\x03\0\x02\0\x05\x12\x04\xc6\
    \x01\x06\x0c\n\x11\n\t\x04\x03\x03\0\x03\0\x02\0\x01\x12\x04\xc6\x01\r\"\
    \n\x11\n\t\x04\x03\x03\0\x03\0\x02\0\x03\x12\x04\xc6\x01%&\ne\n\x08\x04\
    \x03\x03\0\x03\0\x02\x01\x12\x04\xca\x01\x06;\x1aS\x20Ordered\x20list\
    \x20of\x20configuration\x20completed\x20by\x20the\x20agent\x20for\x20the\
    \x20OS\x20policy\n\x20resource.\n\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x01\
    \x04\x12\x04\xca\x01\x06\x0e\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x01\x06\
    \x12\x04\xca\x01\x0f)\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x01\x01\x12\x04\
    \xca\x01*6\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x01\x03\x12\x04\xca\x019:\n\
    9\n\x08\x04\x03\x03\0\x03\0\x02\x02\x12\x04\xcd\x01\x06+\x1a'\x20The\x20\
    compliance\x20state\x20of\x20the\x20resource.\n\n\x11\n\t\x04\x03\x03\0\
    \x03\0\x02\x02\x06\x12\x04\xcd\x01\x06\x15\n\x11\n\t\x04\x03\x03\0\x03\0\
    \x02\x02\x01\x12\x04\xcd\x01\x16&\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x02\
    \x03\x12\x04\xcd\x01)*\n\xaa\x05\n\x08\x04\x03\x03\0\x03\0\x02\x03\x12\
    \x04\xdd\x01\x06)\x1a\x97\x05\x20A\x20reason\x20for\x20the\x20resource\
    \x20to\x20be\x20in\x20the\x20given\x20compliance\x20state.\n\x20This\x20\
    field\x20is\x20always\x20populated\x20when\x20`compliance_state`\x20is\
    \x20`UNKNOWN`.\n\n\x20The\x20following\x20values\x20are\x20supported\x20\
    when\x20`compliance_state\x20==\x20UNKNOWN`\n\n\x20*\x20`execution-error\
    s`:\x20Errors\x20were\x20encountered\x20by\x20the\x20agent\x20while\n\
    \x20executing\x20the\x20resource\x20and\x20the\x20compliance\x20state\
    \x20couldn't\x20be\n\x20determined.\n\x20*\x20`execution-skipped-by-agen\
    t`:\x20Resource\x20execution\x20was\x20skipped\x20by\x20the\n\x20agent\
    \x20because\x20errors\x20were\x20encountered\x20while\x20executing\x20pr\
    ior\x20resources\n\x20in\x20the\x20OS\x20policy.\n\x20*\x20`os-policy-ex\
    ecution-attempt-failed`:\x20The\x20execution\x20of\x20the\x20OS\x20polic\
    y\n\x20containing\x20this\x20resource\x20failed\x20and\x20the\x20complia\
    nce\x20state\x20couldn't\x20be\n\x20determined.\n\n\x11\n\t\x04\x03\x03\
    \0\x03\0\x02\x03\x05\x12\x04\xdd\x01\x06\x0c\n\x11\n\t\x04\x03\x03\0\x03\
    \0\x02\x03\x01\x12\x04\xdd\x01\r$\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x03\
    \x03\x12\x04\xdd\x01'(\n/\n\x08\x04\x03\x03\0\x03\0\x08\0\x12\x06\xe0\
    \x01\x06\xe3\x01\x07\x1a\x1b\x20Resource\x20specific\x20output.\n\n\x11\
    \n\t\x04\x03\x03\0\x03\0\x08\0\x01\x12\x04\xe0\x01\x0c\x12\n1\n\x08\x04\
    \x03\x03\0\x03\0\x02\x04\x12\x04\xe2\x01\x084\x1a\x1f\x20ExecResource\
    \x20specific\x20output.\n\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x04\x06\x12\
    \x04\xe2\x01\x08\x1a\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x04\x01\x12\x04\
    \xe2\x01\x1b/\n\x11\n\t\x04\x03\x03\0\x03\0\x02\x04\x03\x12\x04\xe2\x012\
    3\n\"\n\x06\x04\x03\x03\0\x02\0\x12\x04\xe7\x01\x04\x1c\x1a\x12\x20The\
    \x20OS\x20policy\x20id\n\n\x0f\n\x07\x04\x03\x03\0\x02\0\x05\x12\x04\xe7\
    \x01\x04\n\n\x0f\n\x07\x04\x03\x03\0\x02\0\x01\x12\x04\xe7\x01\x0b\x17\n\
    \x0f\n\x07\x04\x03\x03\0\x02\0\x03\x12\x04\xe7\x01\x1a\x1b\n8\n\x06\x04\
    \x03\x03\0\x02\x01\x12\x04\xea\x01\x04)\x1a(\x20The\x20compliance\x20sta\
    te\x20of\x20the\x20OS\x20policy.\n\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x06\
    \x12\x04\xea\x01\x04\x13\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x01\x12\x04\
    \xea\x01\x14$\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x04\xea\x01'(\n\
    \xe9\x08\n\x06\x04\x03\x03\0\x02\x02\x12\x04\x80\x02\x04'\x1a\xd8\x08\
    \x20The\x20reason\x20for\x20the\x20OS\x20policy\x20to\x20be\x20in\x20an\
    \x20unknown\x20compliance\x20state.\n\x20This\x20field\x20is\x20always\
    \x20populated\x20when\x20`compliance_state`\x20is\x20`UNKNOWN`.\n\n\x20I\
    f\x20populated,\x20the\x20field\x20can\x20contain\x20one\x20of\x20the\
    \x20following\x20values:\n\n\x20*\x20`vm-not-running`:\x20The\x20VM\x20w\
    as\x20not\x20running.\n\x20*\x20`os-policies-not-supported-by-agent`:\
    \x20The\x20version\x20of\x20the\x20OS\x20Config\n\x20agent\x20running\
    \x20on\x20the\x20VM\x20does\x20not\x20support\x20running\x20OS\x20polici\
    es.\n\x20*\x20`no-agent-detected`:\x20The\x20OS\x20Config\x20agent\x20is\
    \x20not\x20detected\x20for\x20the\x20VM.\n\x20*\x20`resource-execution-e\
    rrors`:\x20The\x20OS\x20Config\x20agent\x20encountered\x20errors\n\x20wh\
    ile\x20executing\x20one\x20or\x20more\x20resources\x20in\x20the\x20polic\
    y.\x20See\n\x20`os_policy_resource_compliances`\x20for\x20details.\n\x20\
    *\x20`task-timeout`:\x20The\x20task\x20sent\x20to\x20the\x20agent\x20to\
    \x20apply\x20the\x20policy\x20timed\n\x20out.\n\x20*\x20`unexpected-agen\
    t-state`:\x20The\x20OS\x20Config\x20agent\x20did\x20not\x20report\x20the\
    \x20final\n\x20status\x20of\x20the\x20task\x20that\x20attempted\x20to\
    \x20apply\x20the\x20policy.\x20Instead,\x20the\x20agent\n\x20unexpectedl\
    y\x20started\x20working\x20on\x20a\x20different\x20task.\x20This\x20most\
    ly\x20happens\n\x20when\x20the\x20agent\x20or\x20VM\x20unexpectedly\x20r\
    estarts\x20while\x20applying\x20OS\x20policies.\n\x20*\x20`internal-serv\
    ice-errors`:\x20Internal\x20service\x20errors\x20were\x20encountered\n\
    \x20while\x20attempting\x20to\x20apply\x20the\x20policy.\n\n\x0f\n\x07\
    \x04\x03\x03\0\x02\x02\x05\x12\x04\x80\x02\x04\n\n\x0f\n\x07\x04\x03\x03\
    \0\x02\x02\x01\x12\x04\x80\x02\x0b\"\n\x0f\n\x07\x04\x03\x03\0\x02\x02\
    \x03\x12\x04\x80\x02%&\na\n\x06\x04\x03\x03\0\x02\x03\x12\x04\x84\x02\
    \x04K\x1aQ\x20Compliance\x20data\x20for\x20each\x20resource\x20within\
    \x20the\x20policy\x20that\x20is\x20applied\x20to\n\x20the\x20VM.\n\n\x0f\
    \n\x07\x04\x03\x03\0\x02\x03\x04\x12\x04\x84\x02\x04\x0c\n\x0f\n\x07\x04\
    \x03\x03\0\x02\x03\x06\x12\x04\x84\x02\r'\n\x0f\n\x07\x04\x03\x03\0\x02\
    \x03\x01\x12\x04\x84\x02(F\n\x0f\n\x07\x04\x03\x03\0\x02\x03\x03\x12\x04\
    \x84\x02IJ\n\xcb\x01\n\x04\x04\x03\x02\0\x12\x04\x8b\x02\x02\x12\x1a\xbc\
    \x01\x20The\x20`OSPolicyAssignmentReport`\x20API\x20resource\x20name.\n\
    \n\x20Format:\n\x20`projects/{project_number}/locations/{location}/insta\
    nces/{instance_id}/osPolicyAssignments/{os_policy_assignment_id}/report`\
    \n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x8b\x02\x02\x08\n\r\n\x05\x04\x03\
    \x02\0\x01\x12\x04\x8b\x02\t\r\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x8b\
    \x02\x10\x11\n4\n\x04\x04\x03\x02\x01\x12\x04\x8e\x02\x02\x16\x1a&\x20Th\
    e\x20Compute\x20Engine\x20VM\x20instance\x20name.\n\n\r\n\x05\x04\x03\
    \x02\x01\x05\x12\x04\x8e\x02\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\
    \x04\x8e\x02\t\x11\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\x8e\x02\x14\x15\
    \n\xdc\x01\n\x04\x04\x03\x02\x02\x12\x06\x95\x02\x02\x97\x02&\x1a\xcb\
    \x01\x20Reference\x20to\x20the\x20`OSPolicyAssignment`\x20API\x20resourc\
    e\x20that\x20the\x20`OSPolicy`\n\x20belongs\x20to.\n\n\x20Format:\n\x20`\
    projects/{project_number}/locations/{location}/osPolicyAssignments/{os_p\
    olicy_assignment_id@revision_id}`\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\
    \x04\x95\x02\x02\x08\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\x95\x02\t\x1d\
    \n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\x95\x02\x20!\n\x0f\n\x05\x04\x03\
    \x02\x02\x08\x12\x06\x95\x02\"\x97\x02%\n\x11\n\x07\x04\x03\x02\x02\x08\
    \x9f\x08\x12\x06\x95\x02#\x97\x02$\nN\n\x04\x04\x03\x02\x03\x12\x04\x9a\
    \x02\x028\x1a@\x20Compliance\x20data\x20for\x20each\x20`OSPolicy`\x20tha\
    t\x20is\x20applied\x20to\x20the\x20VM.\n\n\r\n\x05\x04\x03\x02\x03\x04\
    \x12\x04\x9a\x02\x02\n\n\r\n\x05\x04\x03\x02\x03\x06\x12\x04\x9a\x02\x0b\
    \x1d\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\x9a\x02\x1e3\n\r\n\x05\x04\
    \x03\x02\x03\x03\x12\x04\x9a\x0267\nA\n\x04\x04\x03\x02\x04\x12\x04\x9d\
    \x02\x02,\x1a3\x20Timestamp\x20for\x20when\x20the\x20report\x20was\x20la\
    st\x20generated.\n\n\r\n\x05\x04\x03\x02\x04\x06\x12\x04\x9d\x02\x02\x1b\
    \n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\x9d\x02\x1c'\n\r\n\x05\x04\x03\
    \x02\x04\x03\x12\x04\x9d\x02*+\n\x81\x03\n\x04\x04\x03\x02\x05\x12\x04\
    \xa6\x02\x02\x19\x1a\xf2\x02\x20Unique\x20identifier\x20of\x20the\x20las\
    t\x20attempted\x20run\x20to\x20apply\x20the\x20OS\x20policies\n\x20assoc\
    iated\x20with\x20this\x20assignment\x20on\x20the\x20VM.\n\n\x20This\x20I\
    D\x20is\x20logged\x20by\x20the\x20OS\x20Config\x20agent\x20while\x20appl\
    ying\x20the\x20OS\n\x20policies\x20associated\x20with\x20this\x20assignm\
    ent\x20on\x20the\x20VM.\n\x20NOTE:\x20If\x20the\x20service\x20is\x20unab\
    le\x20to\x20successfully\x20connect\x20to\x20the\x20agent\x20for\n\x20th\
    is\x20run,\x20then\x20this\x20id\x20will\x20not\x20be\x20available\x20in\
    \x20the\x20agent\x20logs.\n\n\r\n\x05\x04\x03\x02\x05\x05\x12\x04\xa6\
    \x02\x02\x08\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\xa6\x02\t\x14\n\r\n\
    \x05\x04\x03\x02\x05\x03\x12\x04\xa6\x02\x17\x18b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
