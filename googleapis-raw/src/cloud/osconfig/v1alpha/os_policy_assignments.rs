// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1alpha/os_policy_assignments.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignment {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub os_policies: ::protobuf::RepeatedField<super::os_policy::OSPolicy>,
    pub instance_filter: ::protobuf::SingularPtrField<OSPolicyAssignment_InstanceFilter>,
    pub rollout: ::protobuf::SingularPtrField<OSPolicyAssignment_Rollout>,
    pub revision_id: ::std::string::String,
    pub revision_create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub etag: ::std::string::String,
    pub rollout_state: OSPolicyAssignment_RolloutState,
    pub baseline: bool,
    pub deleted: bool,
    pub reconciling: bool,
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignment {
    fn default() -> &'a OSPolicyAssignment {
        <OSPolicyAssignment as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignment {
    pub fn new() -> OSPolicyAssignment {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicy os_policies = 3;


    pub fn get_os_policies(&self) -> &[super::os_policy::OSPolicy] {
        &self.os_policies
    }
    pub fn clear_os_policies(&mut self) {
        self.os_policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policies(&mut self, v: ::protobuf::RepeatedField<super::os_policy::OSPolicy>) {
        self.os_policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policies(&mut self) -> &mut ::protobuf::RepeatedField<super::os_policy::OSPolicy> {
        &mut self.os_policies
    }

    // Take field
    pub fn take_os_policies(&mut self) -> ::protobuf::RepeatedField<super::os_policy::OSPolicy> {
        ::std::mem::replace(&mut self.os_policies, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignment.InstanceFilter instance_filter = 4;


    pub fn get_instance_filter(&self) -> &OSPolicyAssignment_InstanceFilter {
        self.instance_filter.as_ref().unwrap_or_else(|| <OSPolicyAssignment_InstanceFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance_filter(&mut self) {
        self.instance_filter.clear();
    }

    pub fn has_instance_filter(&self) -> bool {
        self.instance_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_filter(&mut self, v: OSPolicyAssignment_InstanceFilter) {
        self.instance_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance_filter(&mut self) -> &mut OSPolicyAssignment_InstanceFilter {
        if self.instance_filter.is_none() {
            self.instance_filter.set_default();
        }
        self.instance_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance_filter(&mut self) -> OSPolicyAssignment_InstanceFilter {
        self.instance_filter.take().unwrap_or_else(|| OSPolicyAssignment_InstanceFilter::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignment.Rollout rollout = 5;


    pub fn get_rollout(&self) -> &OSPolicyAssignment_Rollout {
        self.rollout.as_ref().unwrap_or_else(|| <OSPolicyAssignment_Rollout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout(&mut self) {
        self.rollout.clear();
    }

    pub fn has_rollout(&self) -> bool {
        self.rollout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout(&mut self, v: OSPolicyAssignment_Rollout) {
        self.rollout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout(&mut self) -> &mut OSPolicyAssignment_Rollout {
        if self.rollout.is_none() {
            self.rollout.set_default();
        }
        self.rollout.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout(&mut self) -> OSPolicyAssignment_Rollout {
        self.rollout.take().unwrap_or_else(|| OSPolicyAssignment_Rollout::new())
    }

    // string revision_id = 6;


    pub fn get_revision_id(&self) -> &str {
        &self.revision_id
    }
    pub fn clear_revision_id(&mut self) {
        self.revision_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_revision_id(&mut self, v: ::std::string::String) {
        self.revision_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision_id(&mut self) -> &mut ::std::string::String {
        &mut self.revision_id
    }

    // Take field
    pub fn take_revision_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.revision_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp revision_create_time = 7;


    pub fn get_revision_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.revision_create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_revision_create_time(&mut self) {
        self.revision_create_time.clear();
    }

    pub fn has_revision_create_time(&self) -> bool {
        self.revision_create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.revision_create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.revision_create_time.is_none() {
            self.revision_create_time.set_default();
        }
        self.revision_create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.revision_create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string etag = 8;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignment.RolloutState rollout_state = 9;


    pub fn get_rollout_state(&self) -> OSPolicyAssignment_RolloutState {
        self.rollout_state
    }
    pub fn clear_rollout_state(&mut self) {
        self.rollout_state = OSPolicyAssignment_RolloutState::ROLLOUT_STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_rollout_state(&mut self, v: OSPolicyAssignment_RolloutState) {
        self.rollout_state = v;
    }

    // bool baseline = 10;


    pub fn get_baseline(&self) -> bool {
        self.baseline
    }
    pub fn clear_baseline(&mut self) {
        self.baseline = false;
    }

    // Param is passed by value, moved
    pub fn set_baseline(&mut self, v: bool) {
        self.baseline = v;
    }

    // bool deleted = 11;


    pub fn get_deleted(&self) -> bool {
        self.deleted
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = false;
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = v;
    }

    // bool reconciling = 12;


    pub fn get_reconciling(&self) -> bool {
        self.reconciling
    }
    pub fn clear_reconciling(&mut self) {
        self.reconciling = false;
    }

    // Param is passed by value, moved
    pub fn set_reconciling(&mut self, v: bool) {
        self.reconciling = v;
    }

    // string uid = 13;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignment {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instance_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revision_create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policies)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance_filter)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.revision_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.revision_create_time)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.rollout_state, 9, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.baseline = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reconciling = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.os_policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.instance_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.revision_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.revision_id);
        }
        if let Some(ref v) = self.revision_create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.etag);
        }
        if self.rollout_state != OSPolicyAssignment_RolloutState::ROLLOUT_STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(9, self.rollout_state);
        }
        if self.baseline != false {
            my_size += 2;
        }
        if self.deleted != false {
            my_size += 2;
        }
        if self.reconciling != false {
            my_size += 2;
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.os_policies {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.instance_filter.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.revision_id.is_empty() {
            os.write_string(6, &self.revision_id)?;
        }
        if let Some(ref v) = self.revision_create_time.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.etag.is_empty() {
            os.write_string(8, &self.etag)?;
        }
        if self.rollout_state != OSPolicyAssignment_RolloutState::ROLLOUT_STATE_UNSPECIFIED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.rollout_state))?;
        }
        if self.baseline != false {
            os.write_bool(10, self.baseline)?;
        }
        if self.deleted != false {
            os.write_bool(11, self.deleted)?;
        }
        if self.reconciling != false {
            os.write_bool(12, self.reconciling)?;
        }
        if !self.uid.is_empty() {
            os.write_string(13, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignment {
        OSPolicyAssignment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OSPolicyAssignment| { &m.name },
                |m: &mut OSPolicyAssignment| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &OSPolicyAssignment| { &m.description },
                |m: &mut OSPolicyAssignment| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::os_policy::OSPolicy>>(
                "os_policies",
                |m: &OSPolicyAssignment| { &m.os_policies },
                |m: &mut OSPolicyAssignment| { &mut m.os_policies },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment_InstanceFilter>>(
                "instance_filter",
                |m: &OSPolicyAssignment| { &m.instance_filter },
                |m: &mut OSPolicyAssignment| { &mut m.instance_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment_Rollout>>(
                "rollout",
                |m: &OSPolicyAssignment| { &m.rollout },
                |m: &mut OSPolicyAssignment| { &mut m.rollout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "revision_id",
                |m: &OSPolicyAssignment| { &m.revision_id },
                |m: &mut OSPolicyAssignment| { &mut m.revision_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "revision_create_time",
                |m: &OSPolicyAssignment| { &m.revision_create_time },
                |m: &mut OSPolicyAssignment| { &mut m.revision_create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &OSPolicyAssignment| { &m.etag },
                |m: &mut OSPolicyAssignment| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicyAssignment_RolloutState>>(
                "rollout_state",
                |m: &OSPolicyAssignment| { &m.rollout_state },
                |m: &mut OSPolicyAssignment| { &mut m.rollout_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "baseline",
                |m: &OSPolicyAssignment| { &m.baseline },
                |m: &mut OSPolicyAssignment| { &mut m.baseline },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &OSPolicyAssignment| { &m.deleted },
                |m: &mut OSPolicyAssignment| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reconciling",
                |m: &OSPolicyAssignment| { &m.reconciling },
                |m: &mut OSPolicyAssignment| { &mut m.reconciling },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &OSPolicyAssignment| { &m.uid },
                |m: &mut OSPolicyAssignment| { &mut m.uid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignment>(
                "OSPolicyAssignment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignment {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignment::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignment {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.os_policies.clear();
        self.instance_filter.clear();
        self.rollout.clear();
        self.revision_id.clear();
        self.revision_create_time.clear();
        self.etag.clear();
        self.rollout_state = OSPolicyAssignment_RolloutState::ROLLOUT_STATE_UNSPECIFIED;
        self.baseline = false;
        self.deleted = false;
        self.reconciling = false;
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignment_LabelSet {
    // message fields
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignment_LabelSet {
    fn default() -> &'a OSPolicyAssignment_LabelSet {
        <OSPolicyAssignment_LabelSet as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignment_LabelSet {
    pub fn new() -> OSPolicyAssignment_LabelSet {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignment.LabelSet.LabelsEntry labels = 1;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignment_LabelSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignment_LabelSet {
        OSPolicyAssignment_LabelSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &OSPolicyAssignment_LabelSet| { &m.labels },
                |m: &mut OSPolicyAssignment_LabelSet| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignment_LabelSet>(
                "OSPolicyAssignment.LabelSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignment_LabelSet {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignment_LabelSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignment_LabelSet::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignment_LabelSet {
    fn clear(&mut self) {
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignment_LabelSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignment_LabelSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignment_InstanceFilter {
    // message fields
    pub all: bool,
    pub os_short_names: ::protobuf::RepeatedField<::std::string::String>,
    pub inclusion_labels: ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet>,
    pub exclusion_labels: ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet>,
    pub inventories: ::protobuf::RepeatedField<OSPolicyAssignment_InstanceFilter_Inventory>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignment_InstanceFilter {
    fn default() -> &'a OSPolicyAssignment_InstanceFilter {
        <OSPolicyAssignment_InstanceFilter as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignment_InstanceFilter {
    pub fn new() -> OSPolicyAssignment_InstanceFilter {
        ::std::default::Default::default()
    }

    // bool all = 1;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }

    // repeated string os_short_names = 2;


    pub fn get_os_short_names(&self) -> &[::std::string::String] {
        &self.os_short_names
    }
    pub fn clear_os_short_names(&mut self) {
        self.os_short_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_short_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.os_short_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_short_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.os_short_names
    }

    // Take field
    pub fn take_os_short_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.os_short_names, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignment.LabelSet inclusion_labels = 3;


    pub fn get_inclusion_labels(&self) -> &[OSPolicyAssignment_LabelSet] {
        &self.inclusion_labels
    }
    pub fn clear_inclusion_labels(&mut self) {
        self.inclusion_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_inclusion_labels(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet>) {
        self.inclusion_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inclusion_labels(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet> {
        &mut self.inclusion_labels
    }

    // Take field
    pub fn take_inclusion_labels(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet> {
        ::std::mem::replace(&mut self.inclusion_labels, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignment.LabelSet exclusion_labels = 4;


    pub fn get_exclusion_labels(&self) -> &[OSPolicyAssignment_LabelSet] {
        &self.exclusion_labels
    }
    pub fn clear_exclusion_labels(&mut self) {
        self.exclusion_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusion_labels(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet>) {
        self.exclusion_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusion_labels(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet> {
        &mut self.exclusion_labels
    }

    // Take field
    pub fn take_exclusion_labels(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignment_LabelSet> {
        ::std::mem::replace(&mut self.exclusion_labels, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignment.InstanceFilter.Inventory inventories = 5;


    pub fn get_inventories(&self) -> &[OSPolicyAssignment_InstanceFilter_Inventory] {
        &self.inventories
    }
    pub fn clear_inventories(&mut self) {
        self.inventories.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventories(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignment_InstanceFilter_Inventory>) {
        self.inventories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventories(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignment_InstanceFilter_Inventory> {
        &mut self.inventories
    }

    // Take field
    pub fn take_inventories(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignment_InstanceFilter_Inventory> {
        ::std::mem::replace(&mut self.inventories, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignment_InstanceFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.inclusion_labels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exclusion_labels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.os_short_names)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inclusion_labels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exclusion_labels)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inventories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.all != false {
            my_size += 2;
        }
        for value in &self.os_short_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.inclusion_labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.exclusion_labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.inventories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.all != false {
            os.write_bool(1, self.all)?;
        }
        for v in &self.os_short_names {
            os.write_string(2, &v)?;
        };
        for v in &self.inclusion_labels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.exclusion_labels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.inventories {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignment_InstanceFilter {
        OSPolicyAssignment_InstanceFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "all",
                |m: &OSPolicyAssignment_InstanceFilter| { &m.all },
                |m: &mut OSPolicyAssignment_InstanceFilter| { &mut m.all },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_short_names",
                |m: &OSPolicyAssignment_InstanceFilter| { &m.os_short_names },
                |m: &mut OSPolicyAssignment_InstanceFilter| { &mut m.os_short_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment_LabelSet>>(
                "inclusion_labels",
                |m: &OSPolicyAssignment_InstanceFilter| { &m.inclusion_labels },
                |m: &mut OSPolicyAssignment_InstanceFilter| { &mut m.inclusion_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment_LabelSet>>(
                "exclusion_labels",
                |m: &OSPolicyAssignment_InstanceFilter| { &m.exclusion_labels },
                |m: &mut OSPolicyAssignment_InstanceFilter| { &mut m.exclusion_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment_InstanceFilter_Inventory>>(
                "inventories",
                |m: &OSPolicyAssignment_InstanceFilter| { &m.inventories },
                |m: &mut OSPolicyAssignment_InstanceFilter| { &mut m.inventories },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignment_InstanceFilter>(
                "OSPolicyAssignment.InstanceFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignment_InstanceFilter {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignment_InstanceFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignment_InstanceFilter::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignment_InstanceFilter {
    fn clear(&mut self) {
        self.all = false;
        self.os_short_names.clear();
        self.inclusion_labels.clear();
        self.exclusion_labels.clear();
        self.inventories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignment_InstanceFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignment_InstanceFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignment_InstanceFilter_Inventory {
    // message fields
    pub os_short_name: ::std::string::String,
    pub os_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignment_InstanceFilter_Inventory {
    fn default() -> &'a OSPolicyAssignment_InstanceFilter_Inventory {
        <OSPolicyAssignment_InstanceFilter_Inventory as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignment_InstanceFilter_Inventory {
    pub fn new() -> OSPolicyAssignment_InstanceFilter_Inventory {
        ::std::default::Default::default()
    }

    // string os_short_name = 1;


    pub fn get_os_short_name(&self) -> &str {
        &self.os_short_name
    }
    pub fn clear_os_short_name(&mut self) {
        self.os_short_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_short_name(&mut self, v: ::std::string::String) {
        self.os_short_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_short_name(&mut self) -> &mut ::std::string::String {
        &mut self.os_short_name
    }

    // Take field
    pub fn take_os_short_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_short_name, ::std::string::String::new())
    }

    // string os_version = 2;


    pub fn get_os_version(&self) -> &str {
        &self.os_version
    }
    pub fn clear_os_version(&mut self) {
        self.os_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_version(&mut self, v: ::std::string::String) {
        self.os_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version(&mut self) -> &mut ::std::string::String {
        &mut self.os_version
    }

    // Take field
    pub fn take_os_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignment_InstanceFilter_Inventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_short_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.os_short_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os_short_name);
        }
        if !self.os_version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.os_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.os_short_name.is_empty() {
            os.write_string(1, &self.os_short_name)?;
        }
        if !self.os_version.is_empty() {
            os.write_string(2, &self.os_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignment_InstanceFilter_Inventory {
        OSPolicyAssignment_InstanceFilter_Inventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_short_name",
                |m: &OSPolicyAssignment_InstanceFilter_Inventory| { &m.os_short_name },
                |m: &mut OSPolicyAssignment_InstanceFilter_Inventory| { &mut m.os_short_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_version",
                |m: &OSPolicyAssignment_InstanceFilter_Inventory| { &m.os_version },
                |m: &mut OSPolicyAssignment_InstanceFilter_Inventory| { &mut m.os_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignment_InstanceFilter_Inventory>(
                "OSPolicyAssignment.InstanceFilter.Inventory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignment_InstanceFilter_Inventory {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignment_InstanceFilter_Inventory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignment_InstanceFilter_Inventory::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignment_InstanceFilter_Inventory {
    fn clear(&mut self) {
        self.os_short_name.clear();
        self.os_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignment_InstanceFilter_Inventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignment_InstanceFilter_Inventory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignment_Rollout {
    // message fields
    pub disruption_budget: ::protobuf::SingularPtrField<super::osconfig_common::FixedOrPercent>,
    pub min_wait_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignment_Rollout {
    fn default() -> &'a OSPolicyAssignment_Rollout {
        <OSPolicyAssignment_Rollout as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignment_Rollout {
    pub fn new() -> OSPolicyAssignment_Rollout {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1alpha.FixedOrPercent disruption_budget = 1;


    pub fn get_disruption_budget(&self) -> &super::osconfig_common::FixedOrPercent {
        self.disruption_budget.as_ref().unwrap_or_else(|| <super::osconfig_common::FixedOrPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_disruption_budget(&mut self) {
        self.disruption_budget.clear();
    }

    pub fn has_disruption_budget(&self) -> bool {
        self.disruption_budget.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disruption_budget(&mut self, v: super::osconfig_common::FixedOrPercent) {
        self.disruption_budget = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disruption_budget(&mut self) -> &mut super::osconfig_common::FixedOrPercent {
        if self.disruption_budget.is_none() {
            self.disruption_budget.set_default();
        }
        self.disruption_budget.as_mut().unwrap()
    }

    // Take field
    pub fn take_disruption_budget(&mut self) -> super::osconfig_common::FixedOrPercent {
        self.disruption_budget.take().unwrap_or_else(|| super::osconfig_common::FixedOrPercent::new())
    }

    // .google.protobuf.Duration min_wait_duration = 2;


    pub fn get_min_wait_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.min_wait_duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_min_wait_duration(&mut self) {
        self.min_wait_duration.clear();
    }

    pub fn has_min_wait_duration(&self) -> bool {
        self.min_wait_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_wait_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.min_wait_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_wait_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.min_wait_duration.is_none() {
            self.min_wait_duration.set_default();
        }
        self.min_wait_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_min_wait_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.min_wait_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignment_Rollout {
    fn is_initialized(&self) -> bool {
        for v in &self.disruption_budget {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.min_wait_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.disruption_budget)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.min_wait_duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.disruption_budget.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.min_wait_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.disruption_budget.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.min_wait_duration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignment_Rollout {
        OSPolicyAssignment_Rollout::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::osconfig_common::FixedOrPercent>>(
                "disruption_budget",
                |m: &OSPolicyAssignment_Rollout| { &m.disruption_budget },
                |m: &mut OSPolicyAssignment_Rollout| { &mut m.disruption_budget },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "min_wait_duration",
                |m: &OSPolicyAssignment_Rollout| { &m.min_wait_duration },
                |m: &mut OSPolicyAssignment_Rollout| { &mut m.min_wait_duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignment_Rollout>(
                "OSPolicyAssignment.Rollout",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignment_Rollout {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignment_Rollout> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignment_Rollout::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignment_Rollout {
    fn clear(&mut self) {
        self.disruption_budget.clear();
        self.min_wait_duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignment_Rollout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignment_Rollout {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicyAssignment_RolloutState {
    ROLLOUT_STATE_UNSPECIFIED = 0,
    IN_PROGRESS = 1,
    CANCELLING = 2,
    CANCELLED = 3,
    SUCCEEDED = 4,
}

impl ::protobuf::ProtobufEnum for OSPolicyAssignment_RolloutState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicyAssignment_RolloutState> {
        match value {
            0 => ::std::option::Option::Some(OSPolicyAssignment_RolloutState::ROLLOUT_STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicyAssignment_RolloutState::IN_PROGRESS),
            2 => ::std::option::Option::Some(OSPolicyAssignment_RolloutState::CANCELLING),
            3 => ::std::option::Option::Some(OSPolicyAssignment_RolloutState::CANCELLED),
            4 => ::std::option::Option::Some(OSPolicyAssignment_RolloutState::SUCCEEDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicyAssignment_RolloutState] = &[
            OSPolicyAssignment_RolloutState::ROLLOUT_STATE_UNSPECIFIED,
            OSPolicyAssignment_RolloutState::IN_PROGRESS,
            OSPolicyAssignment_RolloutState::CANCELLING,
            OSPolicyAssignment_RolloutState::CANCELLED,
            OSPolicyAssignment_RolloutState::SUCCEEDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicyAssignment_RolloutState>("OSPolicyAssignment.RolloutState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicyAssignment_RolloutState {
}

impl ::std::default::Default for OSPolicyAssignment_RolloutState {
    fn default() -> Self {
        OSPolicyAssignment_RolloutState::ROLLOUT_STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignment_RolloutState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OSPolicyAssignmentOperationMetadata {
    // message fields
    pub os_policy_assignment: ::std::string::String,
    pub api_method: OSPolicyAssignmentOperationMetadata_APIMethod,
    pub rollout_state: OSPolicyAssignmentOperationMetadata_RolloutState,
    pub rollout_start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub rollout_update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OSPolicyAssignmentOperationMetadata {
    fn default() -> &'a OSPolicyAssignmentOperationMetadata {
        <OSPolicyAssignmentOperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl OSPolicyAssignmentOperationMetadata {
    pub fn new() -> OSPolicyAssignmentOperationMetadata {
        ::std::default::Default::default()
    }

    // string os_policy_assignment = 1;


    pub fn get_os_policy_assignment(&self) -> &str {
        &self.os_policy_assignment
    }
    pub fn clear_os_policy_assignment(&mut self) {
        self.os_policy_assignment.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignment(&mut self, v: ::std::string::String) {
        self.os_policy_assignment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_assignment(&mut self) -> &mut ::std::string::String {
        &mut self.os_policy_assignment
    }

    // Take field
    pub fn take_os_policy_assignment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_policy_assignment, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignmentOperationMetadata.APIMethod api_method = 2;


    pub fn get_api_method(&self) -> OSPolicyAssignmentOperationMetadata_APIMethod {
        self.api_method
    }
    pub fn clear_api_method(&mut self) {
        self.api_method = OSPolicyAssignmentOperationMetadata_APIMethod::API_METHOD_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_api_method(&mut self, v: OSPolicyAssignmentOperationMetadata_APIMethod) {
        self.api_method = v;
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignmentOperationMetadata.RolloutState rollout_state = 3;


    pub fn get_rollout_state(&self) -> OSPolicyAssignmentOperationMetadata_RolloutState {
        self.rollout_state
    }
    pub fn clear_rollout_state(&mut self) {
        self.rollout_state = OSPolicyAssignmentOperationMetadata_RolloutState::ROLLOUT_STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_rollout_state(&mut self, v: OSPolicyAssignmentOperationMetadata_RolloutState) {
        self.rollout_state = v;
    }

    // .google.protobuf.Timestamp rollout_start_time = 4;


    pub fn get_rollout_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.rollout_start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout_start_time(&mut self) {
        self.rollout_start_time.clear();
    }

    pub fn has_rollout_start_time(&self) -> bool {
        self.rollout_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.rollout_start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.rollout_start_time.is_none() {
            self.rollout_start_time.set_default();
        }
        self.rollout_start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.rollout_start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp rollout_update_time = 5;


    pub fn get_rollout_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.rollout_update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout_update_time(&mut self) {
        self.rollout_update_time.clear();
    }

    pub fn has_rollout_update_time(&self) -> bool {
        self.rollout_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.rollout_update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.rollout_update_time.is_none() {
            self.rollout_update_time.set_default();
        }
        self.rollout_update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.rollout_update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for OSPolicyAssignmentOperationMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.rollout_start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollout_update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_policy_assignment)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.api_method, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.rollout_state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout_start_time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout_update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.os_policy_assignment.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os_policy_assignment);
        }
        if self.api_method != OSPolicyAssignmentOperationMetadata_APIMethod::API_METHOD_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.api_method);
        }
        if self.rollout_state != OSPolicyAssignmentOperationMetadata_RolloutState::ROLLOUT_STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.rollout_state);
        }
        if let Some(ref v) = self.rollout_start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rollout_update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.os_policy_assignment.is_empty() {
            os.write_string(1, &self.os_policy_assignment)?;
        }
        if self.api_method != OSPolicyAssignmentOperationMetadata_APIMethod::API_METHOD_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.api_method))?;
        }
        if self.rollout_state != OSPolicyAssignmentOperationMetadata_RolloutState::ROLLOUT_STATE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.rollout_state))?;
        }
        if let Some(ref v) = self.rollout_start_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rollout_update_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OSPolicyAssignmentOperationMetadata {
        OSPolicyAssignmentOperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_policy_assignment",
                |m: &OSPolicyAssignmentOperationMetadata| { &m.os_policy_assignment },
                |m: &mut OSPolicyAssignmentOperationMetadata| { &mut m.os_policy_assignment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicyAssignmentOperationMetadata_APIMethod>>(
                "api_method",
                |m: &OSPolicyAssignmentOperationMetadata| { &m.api_method },
                |m: &mut OSPolicyAssignmentOperationMetadata| { &mut m.api_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OSPolicyAssignmentOperationMetadata_RolloutState>>(
                "rollout_state",
                |m: &OSPolicyAssignmentOperationMetadata| { &m.rollout_state },
                |m: &mut OSPolicyAssignmentOperationMetadata| { &mut m.rollout_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "rollout_start_time",
                |m: &OSPolicyAssignmentOperationMetadata| { &m.rollout_start_time },
                |m: &mut OSPolicyAssignmentOperationMetadata| { &mut m.rollout_start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "rollout_update_time",
                |m: &OSPolicyAssignmentOperationMetadata| { &m.rollout_update_time },
                |m: &mut OSPolicyAssignmentOperationMetadata| { &mut m.rollout_update_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OSPolicyAssignmentOperationMetadata>(
                "OSPolicyAssignmentOperationMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OSPolicyAssignmentOperationMetadata {
        static instance: ::protobuf::rt::LazyV2<OSPolicyAssignmentOperationMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OSPolicyAssignmentOperationMetadata::new)
    }
}

impl ::protobuf::Clear for OSPolicyAssignmentOperationMetadata {
    fn clear(&mut self) {
        self.os_policy_assignment.clear();
        self.api_method = OSPolicyAssignmentOperationMetadata_APIMethod::API_METHOD_UNSPECIFIED;
        self.rollout_state = OSPolicyAssignmentOperationMetadata_RolloutState::ROLLOUT_STATE_UNSPECIFIED;
        self.rollout_start_time.clear();
        self.rollout_update_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OSPolicyAssignmentOperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentOperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicyAssignmentOperationMetadata_APIMethod {
    API_METHOD_UNSPECIFIED = 0,
    CREATE = 1,
    UPDATE = 2,
    DELETE = 3,
}

impl ::protobuf::ProtobufEnum for OSPolicyAssignmentOperationMetadata_APIMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicyAssignmentOperationMetadata_APIMethod> {
        match value {
            0 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_APIMethod::API_METHOD_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_APIMethod::CREATE),
            2 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_APIMethod::UPDATE),
            3 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_APIMethod::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicyAssignmentOperationMetadata_APIMethod] = &[
            OSPolicyAssignmentOperationMetadata_APIMethod::API_METHOD_UNSPECIFIED,
            OSPolicyAssignmentOperationMetadata_APIMethod::CREATE,
            OSPolicyAssignmentOperationMetadata_APIMethod::UPDATE,
            OSPolicyAssignmentOperationMetadata_APIMethod::DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicyAssignmentOperationMetadata_APIMethod>("OSPolicyAssignmentOperationMetadata.APIMethod", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicyAssignmentOperationMetadata_APIMethod {
}

impl ::std::default::Default for OSPolicyAssignmentOperationMetadata_APIMethod {
    fn default() -> Self {
        OSPolicyAssignmentOperationMetadata_APIMethod::API_METHOD_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentOperationMetadata_APIMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OSPolicyAssignmentOperationMetadata_RolloutState {
    ROLLOUT_STATE_UNSPECIFIED = 0,
    IN_PROGRESS = 1,
    CANCELLING = 2,
    CANCELLED = 3,
    SUCCEEDED = 4,
}

impl ::protobuf::ProtobufEnum for OSPolicyAssignmentOperationMetadata_RolloutState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OSPolicyAssignmentOperationMetadata_RolloutState> {
        match value {
            0 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_RolloutState::ROLLOUT_STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_RolloutState::IN_PROGRESS),
            2 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_RolloutState::CANCELLING),
            3 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_RolloutState::CANCELLED),
            4 => ::std::option::Option::Some(OSPolicyAssignmentOperationMetadata_RolloutState::SUCCEEDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OSPolicyAssignmentOperationMetadata_RolloutState] = &[
            OSPolicyAssignmentOperationMetadata_RolloutState::ROLLOUT_STATE_UNSPECIFIED,
            OSPolicyAssignmentOperationMetadata_RolloutState::IN_PROGRESS,
            OSPolicyAssignmentOperationMetadata_RolloutState::CANCELLING,
            OSPolicyAssignmentOperationMetadata_RolloutState::CANCELLED,
            OSPolicyAssignmentOperationMetadata_RolloutState::SUCCEEDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OSPolicyAssignmentOperationMetadata_RolloutState>("OSPolicyAssignmentOperationMetadata.RolloutState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OSPolicyAssignmentOperationMetadata_RolloutState {
}

impl ::std::default::Default for OSPolicyAssignmentOperationMetadata_RolloutState {
    fn default() -> Self {
        OSPolicyAssignmentOperationMetadata_RolloutState::ROLLOUT_STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OSPolicyAssignmentOperationMetadata_RolloutState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateOSPolicyAssignmentRequest {
    // message fields
    pub parent: ::std::string::String,
    pub os_policy_assignment: ::protobuf::SingularPtrField<OSPolicyAssignment>,
    pub os_policy_assignment_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateOSPolicyAssignmentRequest {
    fn default() -> &'a CreateOSPolicyAssignmentRequest {
        <CreateOSPolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateOSPolicyAssignmentRequest {
    pub fn new() -> CreateOSPolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignment os_policy_assignment = 2;


    pub fn get_os_policy_assignment(&self) -> &OSPolicyAssignment {
        self.os_policy_assignment.as_ref().unwrap_or_else(|| <OSPolicyAssignment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_os_policy_assignment(&mut self) {
        self.os_policy_assignment.clear();
    }

    pub fn has_os_policy_assignment(&self) -> bool {
        self.os_policy_assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignment(&mut self, v: OSPolicyAssignment) {
        self.os_policy_assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_assignment(&mut self) -> &mut OSPolicyAssignment {
        if self.os_policy_assignment.is_none() {
            self.os_policy_assignment.set_default();
        }
        self.os_policy_assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_policy_assignment(&mut self) -> OSPolicyAssignment {
        self.os_policy_assignment.take().unwrap_or_else(|| OSPolicyAssignment::new())
    }

    // string os_policy_assignment_id = 3;


    pub fn get_os_policy_assignment_id(&self) -> &str {
        &self.os_policy_assignment_id
    }
    pub fn clear_os_policy_assignment_id(&mut self) {
        self.os_policy_assignment_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignment_id(&mut self, v: ::std::string::String) {
        self.os_policy_assignment_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_assignment_id(&mut self) -> &mut ::std::string::String {
        &mut self.os_policy_assignment_id
    }

    // Take field
    pub fn take_os_policy_assignment_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.os_policy_assignment_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateOSPolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.os_policy_assignment)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.os_policy_assignment_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.os_policy_assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.os_policy_assignment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.os_policy_assignment_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.os_policy_assignment.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.os_policy_assignment_id.is_empty() {
            os.write_string(3, &self.os_policy_assignment_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateOSPolicyAssignmentRequest {
        CreateOSPolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateOSPolicyAssignmentRequest| { &m.parent },
                |m: &mut CreateOSPolicyAssignmentRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment>>(
                "os_policy_assignment",
                |m: &CreateOSPolicyAssignmentRequest| { &m.os_policy_assignment },
                |m: &mut CreateOSPolicyAssignmentRequest| { &mut m.os_policy_assignment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_policy_assignment_id",
                |m: &CreateOSPolicyAssignmentRequest| { &m.os_policy_assignment_id },
                |m: &mut CreateOSPolicyAssignmentRequest| { &mut m.os_policy_assignment_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateOSPolicyAssignmentRequest>(
                "CreateOSPolicyAssignmentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateOSPolicyAssignmentRequest {
        static instance: ::protobuf::rt::LazyV2<CreateOSPolicyAssignmentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateOSPolicyAssignmentRequest::new)
    }
}

impl ::protobuf::Clear for CreateOSPolicyAssignmentRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.os_policy_assignment.clear();
        self.os_policy_assignment_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOSPolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateOSPolicyAssignmentRequest {
    // message fields
    pub os_policy_assignment: ::protobuf::SingularPtrField<OSPolicyAssignment>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateOSPolicyAssignmentRequest {
    fn default() -> &'a UpdateOSPolicyAssignmentRequest {
        <UpdateOSPolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOSPolicyAssignmentRequest {
    pub fn new() -> UpdateOSPolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1alpha.OSPolicyAssignment os_policy_assignment = 1;


    pub fn get_os_policy_assignment(&self) -> &OSPolicyAssignment {
        self.os_policy_assignment.as_ref().unwrap_or_else(|| <OSPolicyAssignment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_os_policy_assignment(&mut self) {
        self.os_policy_assignment.clear();
    }

    pub fn has_os_policy_assignment(&self) -> bool {
        self.os_policy_assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignment(&mut self, v: OSPolicyAssignment) {
        self.os_policy_assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_policy_assignment(&mut self) -> &mut OSPolicyAssignment {
        if self.os_policy_assignment.is_none() {
            self.os_policy_assignment.set_default();
        }
        self.os_policy_assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_policy_assignment(&mut self) -> OSPolicyAssignment {
        self.os_policy_assignment.take().unwrap_or_else(|| OSPolicyAssignment::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateOSPolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.os_policy_assignment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.os_policy_assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.os_policy_assignment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateOSPolicyAssignmentRequest {
        UpdateOSPolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment>>(
                "os_policy_assignment",
                |m: &UpdateOSPolicyAssignmentRequest| { &m.os_policy_assignment },
                |m: &mut UpdateOSPolicyAssignmentRequest| { &mut m.os_policy_assignment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateOSPolicyAssignmentRequest| { &m.update_mask },
                |m: &mut UpdateOSPolicyAssignmentRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateOSPolicyAssignmentRequest>(
                "UpdateOSPolicyAssignmentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateOSPolicyAssignmentRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateOSPolicyAssignmentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateOSPolicyAssignmentRequest::new)
    }
}

impl ::protobuf::Clear for UpdateOSPolicyAssignmentRequest {
    fn clear(&mut self) {
        self.os_policy_assignment.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOSPolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOSPolicyAssignmentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetOSPolicyAssignmentRequest {
    fn default() -> &'a GetOSPolicyAssignmentRequest {
        <GetOSPolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetOSPolicyAssignmentRequest {
    pub fn new() -> GetOSPolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetOSPolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOSPolicyAssignmentRequest {
        GetOSPolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetOSPolicyAssignmentRequest| { &m.name },
                |m: &mut GetOSPolicyAssignmentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetOSPolicyAssignmentRequest>(
                "GetOSPolicyAssignmentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetOSPolicyAssignmentRequest {
        static instance: ::protobuf::rt::LazyV2<GetOSPolicyAssignmentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetOSPolicyAssignmentRequest::new)
    }
}

impl ::protobuf::Clear for GetOSPolicyAssignmentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOSPolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOSPolicyAssignmentsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOSPolicyAssignmentsRequest {
    fn default() -> &'a ListOSPolicyAssignmentsRequest {
        <ListOSPolicyAssignmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOSPolicyAssignmentsRequest {
    pub fn new() -> ListOSPolicyAssignmentsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOSPolicyAssignmentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOSPolicyAssignmentsRequest {
        ListOSPolicyAssignmentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListOSPolicyAssignmentsRequest| { &m.parent },
                |m: &mut ListOSPolicyAssignmentsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListOSPolicyAssignmentsRequest| { &m.page_size },
                |m: &mut ListOSPolicyAssignmentsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListOSPolicyAssignmentsRequest| { &m.page_token },
                |m: &mut ListOSPolicyAssignmentsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOSPolicyAssignmentsRequest>(
                "ListOSPolicyAssignmentsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOSPolicyAssignmentsRequest {
        static instance: ::protobuf::rt::LazyV2<ListOSPolicyAssignmentsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOSPolicyAssignmentsRequest::new)
    }
}

impl ::protobuf::Clear for ListOSPolicyAssignmentsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOSPolicyAssignmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOSPolicyAssignmentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOSPolicyAssignmentsResponse {
    // message fields
    pub os_policy_assignments: ::protobuf::RepeatedField<OSPolicyAssignment>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOSPolicyAssignmentsResponse {
    fn default() -> &'a ListOSPolicyAssignmentsResponse {
        <ListOSPolicyAssignmentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOSPolicyAssignmentsResponse {
    pub fn new() -> ListOSPolicyAssignmentsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignment os_policy_assignments = 1;


    pub fn get_os_policy_assignments(&self) -> &[OSPolicyAssignment] {
        &self.os_policy_assignments
    }
    pub fn clear_os_policy_assignments(&mut self) {
        self.os_policy_assignments.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignments(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignment>) {
        self.os_policy_assignments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policy_assignments(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignment> {
        &mut self.os_policy_assignments
    }

    // Take field
    pub fn take_os_policy_assignments(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignment> {
        ::std::mem::replace(&mut self.os_policy_assignments, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOSPolicyAssignmentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_assignments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policy_assignments)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.os_policy_assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.os_policy_assignments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOSPolicyAssignmentsResponse {
        ListOSPolicyAssignmentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment>>(
                "os_policy_assignments",
                |m: &ListOSPolicyAssignmentsResponse| { &m.os_policy_assignments },
                |m: &mut ListOSPolicyAssignmentsResponse| { &mut m.os_policy_assignments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListOSPolicyAssignmentsResponse| { &m.next_page_token },
                |m: &mut ListOSPolicyAssignmentsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOSPolicyAssignmentsResponse>(
                "ListOSPolicyAssignmentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOSPolicyAssignmentsResponse {
        static instance: ::protobuf::rt::LazyV2<ListOSPolicyAssignmentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOSPolicyAssignmentsResponse::new)
    }
}

impl ::protobuf::Clear for ListOSPolicyAssignmentsResponse {
    fn clear(&mut self) {
        self.os_policy_assignments.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOSPolicyAssignmentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOSPolicyAssignmentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOSPolicyAssignmentRevisionsRequest {
    // message fields
    pub name: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOSPolicyAssignmentRevisionsRequest {
    fn default() -> &'a ListOSPolicyAssignmentRevisionsRequest {
        <ListOSPolicyAssignmentRevisionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOSPolicyAssignmentRevisionsRequest {
    pub fn new() -> ListOSPolicyAssignmentRevisionsRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOSPolicyAssignmentRevisionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOSPolicyAssignmentRevisionsRequest {
        ListOSPolicyAssignmentRevisionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListOSPolicyAssignmentRevisionsRequest| { &m.name },
                |m: &mut ListOSPolicyAssignmentRevisionsRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListOSPolicyAssignmentRevisionsRequest| { &m.page_size },
                |m: &mut ListOSPolicyAssignmentRevisionsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListOSPolicyAssignmentRevisionsRequest| { &m.page_token },
                |m: &mut ListOSPolicyAssignmentRevisionsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOSPolicyAssignmentRevisionsRequest>(
                "ListOSPolicyAssignmentRevisionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOSPolicyAssignmentRevisionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListOSPolicyAssignmentRevisionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOSPolicyAssignmentRevisionsRequest::new)
    }
}

impl ::protobuf::Clear for ListOSPolicyAssignmentRevisionsRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOSPolicyAssignmentRevisionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOSPolicyAssignmentRevisionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOSPolicyAssignmentRevisionsResponse {
    // message fields
    pub os_policy_assignments: ::protobuf::RepeatedField<OSPolicyAssignment>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOSPolicyAssignmentRevisionsResponse {
    fn default() -> &'a ListOSPolicyAssignmentRevisionsResponse {
        <ListOSPolicyAssignmentRevisionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOSPolicyAssignmentRevisionsResponse {
    pub fn new() -> ListOSPolicyAssignmentRevisionsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1alpha.OSPolicyAssignment os_policy_assignments = 1;


    pub fn get_os_policy_assignments(&self) -> &[OSPolicyAssignment] {
        &self.os_policy_assignments
    }
    pub fn clear_os_policy_assignments(&mut self) {
        self.os_policy_assignments.clear();
    }

    // Param is passed by value, moved
    pub fn set_os_policy_assignments(&mut self, v: ::protobuf::RepeatedField<OSPolicyAssignment>) {
        self.os_policy_assignments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_os_policy_assignments(&mut self) -> &mut ::protobuf::RepeatedField<OSPolicyAssignment> {
        &mut self.os_policy_assignments
    }

    // Take field
    pub fn take_os_policy_assignments(&mut self) -> ::protobuf::RepeatedField<OSPolicyAssignment> {
        ::std::mem::replace(&mut self.os_policy_assignments, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOSPolicyAssignmentRevisionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.os_policy_assignments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.os_policy_assignments)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.os_policy_assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.os_policy_assignments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOSPolicyAssignmentRevisionsResponse {
        ListOSPolicyAssignmentRevisionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OSPolicyAssignment>>(
                "os_policy_assignments",
                |m: &ListOSPolicyAssignmentRevisionsResponse| { &m.os_policy_assignments },
                |m: &mut ListOSPolicyAssignmentRevisionsResponse| { &mut m.os_policy_assignments },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListOSPolicyAssignmentRevisionsResponse| { &m.next_page_token },
                |m: &mut ListOSPolicyAssignmentRevisionsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOSPolicyAssignmentRevisionsResponse>(
                "ListOSPolicyAssignmentRevisionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOSPolicyAssignmentRevisionsResponse {
        static instance: ::protobuf::rt::LazyV2<ListOSPolicyAssignmentRevisionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOSPolicyAssignmentRevisionsResponse::new)
    }
}

impl ::protobuf::Clear for ListOSPolicyAssignmentRevisionsResponse {
    fn clear(&mut self) {
        self.os_policy_assignments.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOSPolicyAssignmentRevisionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOSPolicyAssignmentRevisionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOSPolicyAssignmentRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteOSPolicyAssignmentRequest {
    fn default() -> &'a DeleteOSPolicyAssignmentRequest {
        <DeleteOSPolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOSPolicyAssignmentRequest {
    pub fn new() -> DeleteOSPolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteOSPolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteOSPolicyAssignmentRequest {
        DeleteOSPolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteOSPolicyAssignmentRequest| { &m.name },
                |m: &mut DeleteOSPolicyAssignmentRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteOSPolicyAssignmentRequest>(
                "DeleteOSPolicyAssignmentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteOSPolicyAssignmentRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteOSPolicyAssignmentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteOSPolicyAssignmentRequest::new)
    }
}

impl ::protobuf::Clear for DeleteOSPolicyAssignmentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOSPolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOSPolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n9google/cloud/osconfig/v1alpha/os_policy_assignments.proto\x12\x1dgoog\
    le.cloud.osconfig.v1alpha\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19\
    google/api/resource.proto\x1a-google/cloud/osconfig/v1alpha/os_policy.pr\
    oto\x1a3google/cloud/osconfig/v1alpha/osconfig_common.proto\x1a\x1egoogl\
    e/protobuf/duration.proto\x1a\x20google/protobuf/field_mask.proto\x1a\
    \x1fgoogle/protobuf/timestamp.proto\"\x8e\x0e\n\x12OSPolicyAssignment\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\
    \x18\x02\x20\x01(\tR\x0bdescription\x12M\n\x0bos_policies\x18\x03\x20\
    \x03(\x0b2'.google.cloud.osconfig.v1alpha.OSPolicyR\nosPoliciesB\x03\xe0\
    A\x02\x12n\n\x0finstance_filter\x18\x04\x20\x01(\x0b2@.google.cloud.osco\
    nfig.v1alpha.OSPolicyAssignment.InstanceFilterR\x0einstanceFilterB\x03\
    \xe0A\x02\x12X\n\x07rollout\x18\x05\x20\x01(\x0b29.google.cloud.osconfig\
    .v1alpha.OSPolicyAssignment.RolloutR\x07rolloutB\x03\xe0A\x02\x12$\n\x0b\
    revision_id\x18\x06\x20\x01(\tR\nrevisionIdB\x03\xe0A\x03\x12Q\n\x14revi\
    sion_create_time\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x12revisionCreateTimeB\x03\xe0A\x03\x12\x12\n\x04etag\x18\x08\x20\x01(\
    \tR\x04etag\x12h\n\rrollout_state\x18\t\x20\x01(\x0e2>.google.cloud.osco\
    nfig.v1alpha.OSPolicyAssignment.RolloutStateR\x0crolloutStateB\x03\xe0A\
    \x03\x12\x1f\n\x08baseline\x18\n\x20\x01(\x08R\x08baselineB\x03\xe0A\x03\
    \x12\x1d\n\x07deleted\x18\x0b\x20\x01(\x08R\x07deletedB\x03\xe0A\x03\x12\
    %\n\x0breconciling\x18\x0c\x20\x01(\x08R\x0breconcilingB\x03\xe0A\x03\
    \x12\x15\n\x03uid\x18\r\x20\x01(\tR\x03uidB\x03\xe0A\x03\x1a\xa5\x01\n\
    \x08LabelSet\x12^\n\x06labels\x18\x01\x20\x03(\x0b2F.google.cloud.osconf\
    ig.v1alpha.OSPolicyAssignment.LabelSet.LabelsEntryR\x06labels\x1a9\n\x0b\
    LabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xdd\x03\n\x0eInstanceFilte\
    r\x12\x10\n\x03all\x18\x01\x20\x01(\x08R\x03all\x12(\n\x0eos_short_names\
    \x18\x02\x20\x03(\tR\x0cosShortNamesB\x02\x18\x01\x12e\n\x10inclusion_la\
    bels\x18\x03\x20\x03(\x0b2:.google.cloud.osconfig.v1alpha.OSPolicyAssign\
    ment.LabelSetR\x0finclusionLabels\x12e\n\x10exclusion_labels\x18\x04\x20\
    \x03(\x0b2:.google.cloud.osconfig.v1alpha.OSPolicyAssignment.LabelSetR\
    \x0fexclusionLabels\x12l\n\x0binventories\x18\x05\x20\x03(\x0b2J.google.\
    cloud.osconfig.v1alpha.OSPolicyAssignment.InstanceFilter.InventoryR\x0bi\
    nventories\x1aS\n\tInventory\x12'\n\ros_short_name\x18\x01\x20\x01(\tR\
    \x0bosShortNameB\x03\xe0A\x02\x12\x1d\n\nos_version\x18\x02\x20\x01(\tR\
    \tosVersion\x1a\xb6\x01\n\x07Rollout\x12_\n\x11disruption_budget\x18\x01\
    \x20\x01(\x0b2-.google.cloud.osconfig.v1alpha.FixedOrPercentR\x10disrupt\
    ionBudgetB\x03\xe0A\x02\x12J\n\x11min_wait_duration\x18\x02\x20\x01(\x0b\
    2\x19.google.protobuf.DurationR\x0fminWaitDurationB\x03\xe0A\x02\"l\n\
    \x0cRolloutState\x12\x1d\n\x19ROLLOUT_STATE_UNSPECIFIED\x10\0\x12\x0f\n\
    \x0bIN_PROGRESS\x10\x01\x12\x0e\n\nCANCELLING\x10\x02\x12\r\n\tCANCELLED\
    \x10\x03\x12\r\n\tSUCCEEDED\x10\x04:\x84\x01\xeaA\x80\x01\n*osconfig.goo\
    gleapis.com/OSPolicyAssignment\x12Rprojects/{project}/locations/{locatio\
    n}/osPolicyAssignments/{os_policy_assignment}\"\xbc\x05\n#OSPolicyAssign\
    mentOperationMetadata\x12a\n\x14os_policy_assignment\x18\x01\x20\x01(\tR\
    \x12osPolicyAssignmentB/\xfaA,\n*osconfig.googleapis.com/OSPolicyAssignm\
    ent\x12k\n\napi_method\x18\x02\x20\x01(\x0e2L.google.cloud.osconfig.v1al\
    pha.OSPolicyAssignmentOperationMetadata.APIMethodR\tapiMethod\x12t\n\rro\
    llout_state\x18\x03\x20\x01(\x0e2O.google.cloud.osconfig.v1alpha.OSPolic\
    yAssignmentOperationMetadata.RolloutStateR\x0crolloutState\x12H\n\x12rol\
    lout_start_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x10\
    rolloutStartTime\x12J\n\x13rollout_update_time\x18\x05\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\x11rolloutUpdateTime\"K\n\tAPIMethod\x12\x1a\
    \n\x16API_METHOD_UNSPECIFIED\x10\0\x12\n\n\x06CREATE\x10\x01\x12\n\n\x06\
    UPDATE\x10\x02\x12\n\n\x06DELETE\x10\x03\"l\n\x0cRolloutState\x12\x1d\n\
    \x19ROLLOUT_STATE_UNSPECIFIED\x10\0\x12\x0f\n\x0bIN_PROGRESS\x10\x01\x12\
    \x0e\n\nCANCELLING\x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\r\n\tSUCCEEDED\
    \x10\x04\"\x8a\x02\n\x1fCreateOSPolicyAssignmentRequest\x12A\n\x06parent\
    \x18\x01\x20\x01(\tR\x06parentB)\xfaA#\n!locations.googleapis.com/Locati\
    on\xe0A\x02\x12h\n\x14os_policy_assignment\x18\x02\x20\x01(\x0b21.google\
    .cloud.osconfig.v1alpha.OSPolicyAssignmentR\x12osPolicyAssignmentB\x03\
    \xe0A\x02\x12:\n\x17os_policy_assignment_id\x18\x03\x20\x01(\tR\x14osPol\
    icyAssignmentIdB\x03\xe0A\x02\"\xcd\x01\n\x1fUpdateOSPolicyAssignmentReq\
    uest\x12h\n\x14os_policy_assignment\x18\x01\x20\x01(\x0b21.google.cloud.\
    osconfig.v1alpha.OSPolicyAssignmentR\x12osPolicyAssignmentB\x03\xe0A\x02\
    \x12@\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMa\
    skR\nupdateMaskB\x03\xe0A\x01\"f\n\x1cGetOSPolicyAssignmentRequest\x12F\
    \n\x04name\x18\x01\x20\x01(\tR\x04nameB2\xfaA,\n*osconfig.googleapis.com\
    /OSPolicyAssignment\xe0A\x02\"\x9f\x01\n\x1eListOSPolicyAssignmentsReque\
    st\x12A\n\x06parent\x18\x01\x20\x01(\tR\x06parentB)\xfaA#\n!locations.go\
    ogleapis.com/Location\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05\
    R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"\xb0\
    \x01\n\x1fListOSPolicyAssignmentsResponse\x12e\n\x15os_policy_assignment\
    s\x18\x01\x20\x03(\x0b21.google.cloud.osconfig.v1alpha.OSPolicyAssignmen\
    tR\x13osPolicyAssignments\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\
    \rnextPageToken\"\xac\x01\n&ListOSPolicyAssignmentRevisionsRequest\x12F\
    \n\x04name\x18\x01\x20\x01(\tR\x04nameB2\xfaA,\n*osconfig.googleapis.com\
    /OSPolicyAssignment\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\
    \x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"\xb8\
    \x01\n'ListOSPolicyAssignmentRevisionsResponse\x12e\n\x15os_policy_assig\
    nments\x18\x01\x20\x03(\x0b21.google.cloud.osconfig.v1alpha.OSPolicyAssi\
    gnmentR\x13osPolicyAssignments\x12&\n\x0fnext_page_token\x18\x02\x20\x01\
    (\tR\rnextPageToken\"i\n\x1fDeleteOSPolicyAssignmentRequest\x12F\n\x04na\
    me\x18\x01\x20\x01(\tR\x04nameB2\xfaA,\n*osconfig.googleapis.com/OSPolic\
    yAssignment\xe0A\x02B\xe1\x01\n!com.google.cloud.osconfig.v1alphaB\x18Os\
    PolicyAssignmentsProtoP\x01Z=cloud.google.com/go/osconfig/apiv1alpha/osc\
    onfigpb;osconfigpb\xaa\x02\x1dGoogle.Cloud.OsConfig.V1Alpha\xca\x02\x1dG\
    oogle\\Cloud\\OsConfig\\V1alpha\xea\x02\x20Google::Cloud::OsConfig::V1al\
    phaJ\x83g\n\x07\x12\x05\x0e\0\xfe\x02\x01\n\xbc\x04\n\x01\x0c\x12\x03\
    \x0e\0\x122\xb1\x04\x20Copyright\x202021\x20Google\x20LLC\n\n\x20License\
    d\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"L\
    icense\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\
    \x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\
    \x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www\
    .apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20appl\
    icable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20d\
    istributed\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\
    \x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITION\
    S\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\
    \x20the\x20License\x20for\x20the\x20specific\x20language\x20governing\
    \x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\
    \x08\n\x01\x02\x12\x03\x10\0&\n\t\n\x02\x03\0\x12\x03\x12\0)\n\t\n\x02\
    \x03\x01\x12\x03\x13\0#\n\t\n\x02\x03\x02\x12\x03\x14\07\n\t\n\x02\x03\
    \x03\x12\x03\x15\0=\n\t\n\x02\x03\x04\x12\x03\x16\0(\n\t\n\x02\x03\x05\
    \x12\x03\x17\0*\n\t\n\x02\x03\x06\x12\x03\x18\0)\n\x08\n\x01\x08\x12\x03\
    \x1a\0:\n\t\n\x02\x08%\x12\x03\x1a\0:\n\x08\n\x01\x08\x12\x03\x1b\0T\n\t\
    \n\x02\x08\x0b\x12\x03\x1b\0T\n\x08\n\x01\x08\x12\x03\x1c\0\"\n\t\n\x02\
    \x08\n\x12\x03\x1c\0\"\n\x08\n\x01\x08\x12\x03\x1d\09\n\t\n\x02\x08\x08\
    \x12\x03\x1d\09\n\x08\n\x01\x08\x12\x03\x1e\0:\n\t\n\x02\x08\x01\x12\x03\
    \x1e\0:\n\x08\n\x01\x08\x12\x03\x1f\0:\n\t\n\x02\x08)\x12\x03\x1f\0:\n\
    \x08\n\x01\x08\x12\x03\x20\09\n\t\n\x02\x08-\x12\x03\x20\09\n\xb4\x04\n\
    \x02\x04\0\x12\x05-\0\xd1\x01\x01\x1a\xa6\x04\x20OS\x20policy\x20assignm\
    ent\x20is\x20an\x20API\x20resource\x20that\x20is\x20used\x20to\n\x20appl\
    y\x20a\x20set\x20of\x20OS\x20policies\x20to\x20a\x20dynamically\x20targe\
    ted\x20group\x20of\x20Compute\x20Engine\n\x20VM\x20instances.\n\n\x20An\
    \x20OS\x20policy\x20is\x20used\x20to\x20define\x20the\x20desired\x20stat\
    e\x20configuration\x20for\x20a\n\x20Compute\x20Engine\x20VM\x20instance\
    \x20through\x20a\x20set\x20of\x20configuration\x20resources\x20that\n\
    \x20provide\x20capabilities\x20such\x20as\x20installing\x20or\x20removin\
    g\x20software\x20packages,\x20or\n\x20executing\x20a\x20script.\n\n\x20F\
    or\x20more\x20information,\x20see\x20[OS\x20policy\x20and\x20OS\x20polic\
    y\n\x20assignment](https://cloud.google.com/compute/docs/os-configuratio\
    n-management/working-with-os-policies).\n\n\n\n\x03\x04\0\x01\x12\x03-\
    \x08\x1a\n\x0b\n\x03\x04\0\x07\x12\x04.\x021\x04\n\r\n\x05\x04\0\x07\x9d\
    \x08\x12\x04.\x021\x04\n\xaf\x03\n\x04\x04\0\x03\0\x12\x04<\x02A\x03\x1a\
    \xa0\x03\x20Message\x20representing\x20label\x20set.\n\x20*\x20A\x20labe\
    l\x20is\x20a\x20key\x20value\x20pair\x20set\x20for\x20a\x20VM.\n\x20*\
    \x20A\x20LabelSet\x20is\x20a\x20set\x20of\x20labels.\n\x20*\x20Labels\
    \x20within\x20a\x20LabelSet\x20are\x20ANDed.\x20In\x20other\x20words,\
    \x20a\x20LabelSet\x20is\n\x20\x20\x20applicable\x20for\x20a\x20VM\x20onl\
    y\x20if\x20it\x20matches\x20all\x20the\x20labels\x20in\x20the\n\x20\x20\
    \x20LabelSet.\n\x20*\x20Example:\x20A\x20LabelSet\x20with\x202\x20labels\
    :\x20`env=prod`\x20and\x20`type=webserver`\x20will\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20only\x20be\x20applicable\x20for\x20those\x20\
    VMs\x20with\x20both\x20labels\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20present.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03<\n\x12\n\x9b\x01\
    \n\x06\x04\0\x03\0\x02\0\x12\x03@\x04#\x1a\x8b\x01\x20Labels\x20are\x20i\
    dentified\x20by\x20key/value\x20pairs\x20in\x20this\x20map.\n\x20A\x20VM\
    \x20should\x20contain\x20all\x20the\x20key/value\x20pairs\x20specified\
    \x20in\x20this\n\x20map\x20to\x20be\x20selected.\n\n\x0e\n\x07\x04\0\x03\
    \0\x02\0\x06\x12\x03@\x04\x17\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03@\
    \x18\x1e\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03@!\"\n\xb7\x01\n\x04\
    \x04\0\x03\x01\x12\x04G\x02q\x03\x1a\xa8\x01\x20Filters\x20to\x20select\
    \x20target\x20VMs\x20for\x20an\x20assignment.\n\n\x20If\x20more\x20than\
    \x20one\x20filter\x20criteria\x20is\x20specified\x20below,\x20a\x20VM\
    \x20will\x20be\x20selected\n\x20if\x20and\x20only\x20if\x20it\x20satisfi\
    es\x20all\x20of\x20them.\n\n\x0c\n\x05\x04\0\x03\x01\x01\x12\x03G\n\x18\
    \n'\n\x06\x04\0\x03\x01\x03\0\x12\x04I\x04U\x05\x1a\x17\x20VM\x20invento\
    ry\x20details.\n\n\x0e\n\x07\x04\0\x03\x01\x03\0\x01\x12\x03I\x0c\x15\n.\
    \n\x08\x04\0\x03\x01\x03\0\x02\0\x12\x03K\x06H\x1a\x1d\x20Required.\x20T\
    he\x20OS\x20short\x20name\n\n\x10\n\t\x04\0\x03\x01\x03\0\x02\0\x05\x12\
    \x03K\x06\x0c\n\x10\n\t\x04\0\x03\x01\x03\0\x02\0\x01\x12\x03K\r\x1a\n\
    \x10\n\t\x04\0\x03\x01\x03\0\x02\0\x03\x12\x03K\x1d\x1e\n\x10\n\t\x04\0\
    \x03\x01\x03\0\x02\0\x08\x12\x03K\x1fG\n\x13\n\x0c\x04\0\x03\x01\x03\0\
    \x02\0\x08\x9c\x08\0\x12\x03K\x20F\n\x91\x02\n\x08\x04\0\x03\x01\x03\0\
    \x02\x01\x12\x03T\x06\x1c\x1a\xff\x01\x20The\x20OS\x20version\n\n\x20Pre\
    fix\x20matches\x20are\x20supported\x20if\x20asterisk(*)\x20is\x20provide\
    d\x20as\x20the\n\x20last\x20character.\x20For\x20example,\x20to\x20match\
    \x20all\x20versions\x20with\x20a\x20major\n\x20version\x20of\x20`7`,\x20\
    specify\x20the\x20following\x20value\x20for\x20this\x20field\x20`7.*`\n\
    \n\x20An\x20empty\x20string\x20matches\x20all\x20OS\x20versions.\n\n\x10\
    \n\t\x04\0\x03\x01\x03\0\x02\x01\x05\x12\x03T\x06\x0c\n\x10\n\t\x04\0\
    \x03\x01\x03\0\x02\x01\x01\x12\x03T\r\x17\n\x10\n\t\x04\0\x03\x01\x03\0\
    \x02\x01\x03\x12\x03T\x1a\x1b\nY\n\x06\x04\0\x03\x01\x02\0\x12\x03Y\x04\
    \x11\x1aJ\x20Target\x20all\x20VMs\x20in\x20the\x20project.\x20If\x20true\
    ,\x20no\x20other\x20criteria\x20is\n\x20permitted.\n\n\x0e\n\x07\x04\0\
    \x03\x01\x02\0\x05\x12\x03Y\x04\x08\n\x0e\n\x07\x04\0\x03\x01\x02\0\x01\
    \x12\x03Y\t\x0c\n\x0e\n\x07\x04\0\x03\x01\x02\0\x03\x12\x03Y\x0f\x10\n\
    \xa1\x01\n\x06\x04\0\x03\x01\x02\x01\x12\x03^\x04;\x1a\x91\x01\x20Deprec\
    ated.\x20Use\x20the\x20`inventories`\x20field\x20instead.\n\x20A\x20VM\
    \x20is\x20selected\x20if\x20it's\x20OS\x20short\x20name\x20matches\x20wi\
    th\x20any\x20of\x20the\n\x20values\x20provided\x20in\x20this\x20list.\n\
    \n\x0e\n\x07\x04\0\x03\x01\x02\x01\x04\x12\x03^\x04\x0c\n\x0e\n\x07\x04\
    \0\x03\x01\x02\x01\x05\x12\x03^\r\x13\n\x0e\n\x07\x04\0\x03\x01\x02\x01\
    \x01\x12\x03^\x14\"\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x03\x12\x03^%&\n\
    \x0e\n\x07\x04\0\x03\x01\x02\x01\x08\x12\x03^':\n\x0f\n\x08\x04\0\x03\
    \x01\x02\x01\x08\x03\x12\x03^(9\n\xaf\x01\n\x06\x04\0\x03\x01\x02\x02\
    \x12\x03d\x04+\x1a\x9f\x01\x20List\x20of\x20label\x20sets\x20used\x20for\
    \x20VM\x20inclusion.\n\n\x20If\x20the\x20list\x20has\x20more\x20than\x20\
    one\x20`LabelSet`,\x20the\x20VM\x20is\x20included\x20if\x20any\n\x20of\
    \x20the\x20label\x20sets\x20are\x20applicable\x20for\x20the\x20VM.\n\n\
    \x0e\n\x07\x04\0\x03\x01\x02\x02\x04\x12\x03d\x04\x0c\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x02\x06\x12\x03d\r\x15\n\x0e\n\x07\x04\0\x03\x01\x02\x02\
    \x01\x12\x03d\x16&\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x03\x12\x03d)*\n\
    \xae\x01\n\x06\x04\0\x03\x01\x02\x03\x12\x03j\x04+\x1a\x9e\x01\x20List\
    \x20of\x20label\x20sets\x20used\x20for\x20VM\x20exclusion.\n\n\x20If\x20\
    the\x20list\x20has\x20more\x20than\x20one\x20label\x20set,\x20the\x20VM\
    \x20is\x20excluded\x20if\x20any\n\x20of\x20the\x20label\x20sets\x20are\
    \x20applicable\x20for\x20the\x20VM.\n\n\x0e\n\x07\x04\0\x03\x01\x02\x03\
    \x04\x12\x03j\x04\x0c\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x06\x12\x03j\r\
    \x15\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x01\x12\x03j\x16&\n\x0e\n\x07\x04\
    \0\x03\x01\x02\x03\x03\x12\x03j)*\n\x91\x01\n\x06\x04\0\x03\x01\x02\x04\
    \x12\x03p\x04'\x1a\x81\x01\x20List\x20of\x20inventories\x20to\x20select\
    \x20VMs.\n\n\x20A\x20VM\x20is\x20selected\x20if\x20its\x20inventory\x20d\
    ata\x20matches\x20at\x20least\x20one\x20of\x20the\n\x20following\x20inve\
    ntories.\n\n\x0e\n\x07\x04\0\x03\x01\x02\x04\x04\x12\x03p\x04\x0c\n\x0e\
    \n\x07\x04\0\x03\x01\x02\x04\x06\x12\x03p\r\x16\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x04\x01\x12\x03p\x17\"\n\x0e\n\x07\x04\0\x03\x01\x02\x04\x03\
    \x12\x03p%&\nc\n\x04\x04\0\x03\x02\x12\x05u\x02\x80\x01\x03\x1aT\x20Mess\
    age\x20to\x20configure\x20the\x20rollout\x20at\x20the\x20zonal\x20level\
    \x20for\x20the\x20OS\x20policy\n\x20assignment.\n\n\x0c\n\x05\x04\0\x03\
    \x02\x01\x12\x03u\n\x11\nn\n\x06\x04\0\x03\x02\x02\0\x12\x03x\x04R\x1a_\
    \x20Required.\x20The\x20maximum\x20number\x20(or\x20percentage)\x20of\
    \x20VMs\x20per\x20zone\x20to\x20disrupt\x20at\n\x20any\x20given\x20momen\
    t.\n\n\x0e\n\x07\x04\0\x03\x02\x02\0\x06\x12\x03x\x04\x12\n\x0e\n\x07\
    \x04\0\x03\x02\x02\0\x01\x12\x03x\x13$\n\x0e\n\x07\x04\0\x03\x02\x02\0\
    \x03\x12\x03x'(\n\x0e\n\x07\x04\0\x03\x02\x02\0\x08\x12\x03x)Q\n\x11\n\n\
    \x04\0\x03\x02\x02\0\x08\x9c\x08\0\x12\x03x*P\n\xae\x02\n\x06\x04\0\x03\
    \x02\x02\x01\x12\x03\x7f\x04\\\x1a\x9e\x02\x20Required.\x20This\x20deter\
    mines\x20the\x20minimum\x20duration\x20of\x20time\x20to\x20wait\x20after\
    \x20the\n\x20configuration\x20changes\x20are\x20applied\x20through\x20th\
    e\x20current\x20rollout.\x20A\n\x20VM\x20continues\x20to\x20count\x20tow\
    ards\x20the\x20`disruption_budget`\x20at\x20least\n\x20until\x20this\x20\
    duration\x20of\x20time\x20has\x20passed\x20after\x20configuration\x20cha\
    nges\x20are\n\x20applied.\n\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x06\x12\
    \x03\x7f\x04\x1c\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x01\x12\x03\x7f\x1d.\
    \n\x0e\n\x07\x04\0\x03\x02\x02\x01\x03\x12\x03\x7f12\n\x0e\n\x07\x04\0\
    \x03\x02\x02\x01\x08\x12\x03\x7f3[\n\x11\n\n\x04\0\x03\x02\x02\x01\x08\
    \x9c\x08\0\x12\x03\x7f4Z\n4\n\x04\x04\0\x04\0\x12\x06\x83\x01\x02\x92\
    \x01\x03\x1a$\x20OS\x20policy\x20assignment\x20rollout\x20state\n\n\r\n\
    \x05\x04\0\x04\0\x01\x12\x04\x83\x01\x07\x13\n\x1f\n\x06\x04\0\x04\0\x02\
    \0\x12\x04\x85\x01\x04\"\x1a\x0f\x20Invalid\x20value\n\n\x0f\n\x07\x04\0\
    \x04\0\x02\0\x01\x12\x04\x85\x01\x04\x1d\n\x0f\n\x07\x04\0\x04\0\x02\0\
    \x02\x12\x04\x85\x01\x20!\n-\n\x06\x04\0\x04\0\x02\x01\x12\x04\x88\x01\
    \x04\x14\x1a\x1d\x20The\x20rollout\x20is\x20in\x20progress.\n\n\x0f\n\
    \x07\x04\0\x04\0\x02\x01\x01\x12\x04\x88\x01\x04\x0f\n\x0f\n\x07\x04\0\
    \x04\0\x02\x01\x02\x12\x04\x88\x01\x12\x13\n1\n\x06\x04\0\x04\0\x02\x02\
    \x12\x04\x8b\x01\x04\x13\x1a!\x20The\x20rollout\x20is\x20being\x20cancel\
    led.\n\n\x0f\n\x07\x04\0\x04\0\x02\x02\x01\x12\x04\x8b\x01\x04\x0e\n\x0f\
    \n\x07\x04\0\x04\0\x02\x02\x02\x12\x04\x8b\x01\x11\x12\n+\n\x06\x04\0\
    \x04\0\x02\x03\x12\x04\x8e\x01\x04\x12\x1a\x1b\x20The\x20rollout\x20is\
    \x20cancelled.\n\n\x0f\n\x07\x04\0\x04\0\x02\x03\x01\x12\x04\x8e\x01\x04\
    \r\n\x0f\n\x07\x04\0\x04\0\x02\x03\x02\x12\x04\x8e\x01\x10\x11\n9\n\x06\
    \x04\0\x04\0\x02\x04\x12\x04\x91\x01\x04\x12\x1a)\x20The\x20rollout\x20h\
    as\x20completed\x20successfully.\n\n\x0f\n\x07\x04\0\x04\0\x02\x04\x01\
    \x12\x04\x91\x01\x04\r\n\x0f\n\x07\x04\0\x04\0\x02\x04\x02\x12\x04\x91\
    \x01\x10\x11\n\xca\x01\n\x04\x04\0\x02\0\x12\x04\x9a\x01\x02\x12\x1a\xbb\
    \x01\x20Resource\x20name.\n\n\x20Format:\n\x20`projects/{project_number}\
    /locations/{location}/osPolicyAssignments/{os_policy_assignment_id}`\n\n\
    \x20This\x20field\x20is\x20ignored\x20when\x20you\x20create\x20an\x20OS\
    \x20policy\x20assignment.\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\x9a\x01\
    \x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x9a\x01\t\r\n\r\n\x05\x04\0\
    \x02\0\x03\x12\x04\x9a\x01\x10\x11\nk\n\x04\x04\0\x02\x01\x12\x04\x9e\
    \x01\x02\x19\x1a]\x20OS\x20policy\x20assignment\x20description.\n\x20Len\
    gth\x20of\x20the\x20description\x20is\x20limited\x20to\x201024\x20charac\
    ters.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\x9e\x01\x02\x08\n\r\n\x05\
    \x04\0\x02\x01\x01\x12\x04\x9e\x01\t\x14\n\r\n\x05\x04\0\x02\x01\x03\x12\
    \x04\x9e\x01\x17\x18\nG\n\x04\x04\0\x02\x02\x12\x04\xa1\x01\x02M\x1a9\
    \x20Required.\x20List\x20of\x20OS\x20policies\x20to\x20be\x20applied\x20\
    to\x20the\x20VMs.\n\n\r\n\x05\x04\0\x02\x02\x04\x12\x04\xa1\x01\x02\n\n\
    \r\n\x05\x04\0\x02\x02\x06\x12\x04\xa1\x01\x0b\x13\n\r\n\x05\x04\0\x02\
    \x02\x01\x12\x04\xa1\x01\x14\x1f\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xa1\
    \x01\"#\n\r\n\x05\x04\0\x02\x02\x08\x12\x04\xa1\x01$L\n\x10\n\x08\x04\0\
    \x02\x02\x08\x9c\x08\0\x12\x04\xa1\x01%K\n/\n\x04\x04\0\x02\x03\x12\x04\
    \xa4\x01\x02N\x1a!\x20Required.\x20Filter\x20to\x20select\x20VMs.\n\n\r\
    \n\x05\x04\0\x02\x03\x06\x12\x04\xa4\x01\x02\x10\n\r\n\x05\x04\0\x02\x03\
    \x01\x12\x04\xa4\x01\x11\x20\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\xa4\x01\
    #$\n\r\n\x05\x04\0\x02\x03\x08\x12\x04\xa4\x01%M\n\x10\n\x08\x04\0\x02\
    \x03\x08\x9c\x08\0\x12\x04\xa4\x01&L\n\xcc\x02\n\x04\x04\0\x02\x04\x12\
    \x04\xae\x01\x02?\x1a\xbd\x02\x20Required.\x20Rollout\x20to\x20deploy\
    \x20the\x20OS\x20policy\x20assignment.\n\x20A\x20rollout\x20is\x20trigge\
    red\x20in\x20the\x20following\x20situations:\n\x201)\x20OSPolicyAssignme\
    nt\x20is\x20created.\n\x202)\x20OSPolicyAssignment\x20is\x20updated\x20a\
    nd\x20the\x20update\x20contains\x20changes\x20to\x20one\x20of\n\x20the\
    \x20following\x20fields:\n\x20\x20\x20\x20-\x20instance_filter\n\x20\x20\
    \x20\x20-\x20os_policies\n\x203)\x20OSPolicyAssignment\x20is\x20deleted.\
    \n\n\r\n\x05\x04\0\x02\x04\x06\x12\x04\xae\x01\x02\t\n\r\n\x05\x04\0\x02\
    \x04\x01\x12\x04\xae\x01\n\x11\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xae\
    \x01\x14\x15\n\r\n\x05\x04\0\x02\x04\x08\x12\x04\xae\x01\x16>\n\x10\n\
    \x08\x04\0\x02\x04\x08\x9c\x08\0\x12\x04\xae\x01\x17=\n\x91\x01\n\x04\
    \x04\0\x02\x05\x12\x04\xb3\x01\x02E\x1a\x82\x01\x20Output\x20only.\x20Th\
    e\x20assignment\x20revision\x20ID\n\x20A\x20new\x20revision\x20is\x20com\
    mitted\x20whenever\x20a\x20rollout\x20is\x20triggered\x20for\x20a\x20OS\
    \x20policy\n\x20assignment\n\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\xb3\x01\
    \x02\x08\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xb3\x01\t\x14\n\r\n\x05\x04\
    \0\x02\x05\x03\x12\x04\xb3\x01\x17\x18\n\r\n\x05\x04\0\x02\x05\x08\x12\
    \x04\xb3\x01\x19D\n\x10\n\x08\x04\0\x02\x05\x08\x9c\x08\0\x12\x04\xb3\
    \x01\x1aC\nI\n\x04\x04\0\x02\x06\x12\x04\xb6\x01\x02a\x1a;\x20Output\x20\
    only.\x20The\x20timestamp\x20that\x20the\x20revision\x20was\x20created.\
    \n\n\r\n\x05\x04\0\x02\x06\x06\x12\x04\xb6\x01\x02\x1b\n\r\n\x05\x04\0\
    \x02\x06\x01\x12\x04\xb6\x01\x1c0\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\
    \xb6\x0134\n\r\n\x05\x04\0\x02\x06\x08\x12\x04\xb6\x015`\n\x10\n\x08\x04\
    \0\x02\x06\x08\x9c\x08\0\x12\x04\xb6\x016_\nx\n\x04\x04\0\x02\x07\x12\
    \x04\xba\x01\x02\x12\x1aj\x20The\x20etag\x20for\x20this\x20OS\x20policy\
    \x20assignment.\n\x20If\x20this\x20is\x20provided\x20on\x20update,\x20it\
    \x20must\x20match\x20the\x20server's\x20etag.\n\n\r\n\x05\x04\0\x02\x07\
    \x05\x12\x04\xba\x01\x02\x08\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\xba\x01\
    \t\r\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\xba\x01\x10\x11\n?\n\x04\x04\0\
    \x02\x08\x12\x04\xbd\x01\x02M\x1a1\x20Output\x20only.\x20OS\x20policy\
    \x20assignment\x20rollout\x20state\n\n\r\n\x05\x04\0\x02\x08\x06\x12\x04\
    \xbd\x01\x02\x0e\n\r\n\x05\x04\0\x02\x08\x01\x12\x04\xbd\x01\x0f\x1c\n\r\
    \n\x05\x04\0\x02\x08\x03\x12\x04\xbd\x01\x1f\x20\n\r\n\x05\x04\0\x02\x08\
    \x08\x12\x04\xbd\x01!L\n\x10\n\x08\x04\0\x02\x08\x08\x9c\x08\0\x12\x04\
    \xbd\x01\"K\n\x8d\x02\n\x04\x04\0\x02\t\x12\x04\xc4\x01\x02A\x1a\xfe\x01\
    \x20Output\x20only.\x20Indicates\x20that\x20this\x20revision\x20has\x20b\
    een\x20successfully\x20rolled\x20out\x20in\x20this\x20zone\n\x20and\x20n\
    ew\x20VMs\x20will\x20be\x20assigned\x20OS\x20policies\x20from\x20this\
    \x20revision.\n\n\x20For\x20a\x20given\x20OS\x20policy\x20assignment,\
    \x20there\x20is\x20only\x20one\x20revision\x20with\x20a\x20value\n\x20of\
    \x20`true`\x20for\x20this\x20field.\n\n\r\n\x05\x04\0\x02\t\x05\x12\x04\
    \xc4\x01\x02\x06\n\r\n\x05\x04\0\x02\t\x01\x12\x04\xc4\x01\x07\x0f\n\r\n\
    \x05\x04\0\x02\t\x03\x12\x04\xc4\x01\x12\x14\n\r\n\x05\x04\0\x02\t\x08\
    \x12\x04\xc4\x01\x15@\n\x10\n\x08\x04\0\x02\t\x08\x9c\x08\0\x12\x04\xc4\
    \x01\x16?\n[\n\x04\x04\0\x02\n\x12\x04\xc7\x01\x02@\x1aM\x20Output\x20on\
    ly.\x20Indicates\x20that\x20this\x20revision\x20deletes\x20the\x20OS\x20\
    policy\x20assignment.\n\n\r\n\x05\x04\0\x02\n\x05\x12\x04\xc7\x01\x02\
    \x06\n\r\n\x05\x04\0\x02\n\x01\x12\x04\xc7\x01\x07\x0e\n\r\n\x05\x04\0\
    \x02\n\x03\x12\x04\xc7\x01\x11\x13\n\r\n\x05\x04\0\x02\n\x08\x12\x04\xc7\
    \x01\x14?\n\x10\n\x08\x04\0\x02\n\x08\x9c\x08\0\x12\x04\xc7\x01\x15>\n\
    \xb3\x01\n\x04\x04\0\x02\x0b\x12\x04\xcd\x01\x02D\x1a\xa4\x01\x20Output\
    \x20only.\x20Indicates\x20that\x20reconciliation\x20is\x20in\x20progress\
    \x20for\x20the\x20revision.\n\x20This\x20value\x20is\x20`true`\x20when\
    \x20the\x20`rollout_state`\x20is\x20one\x20of:\n\x20*\x20IN_PROGRESS\n\
    \x20*\x20CANCELLING\n\n\r\n\x05\x04\0\x02\x0b\x05\x12\x04\xcd\x01\x02\
    \x06\n\r\n\x05\x04\0\x02\x0b\x01\x12\x04\xcd\x01\x07\x12\n\r\n\x05\x04\0\
    \x02\x0b\x03\x12\x04\xcd\x01\x15\x17\n\r\n\x05\x04\0\x02\x0b\x08\x12\x04\
    \xcd\x01\x18C\n\x10\n\x08\x04\0\x02\x0b\x08\x9c\x08\0\x12\x04\xcd\x01\
    \x19B\n^\n\x04\x04\0\x02\x0c\x12\x04\xd0\x01\x02>\x1aP\x20Output\x20only\
    .\x20Server\x20generated\x20unique\x20id\x20for\x20the\x20OS\x20policy\
    \x20assignment\x20resource.\n\n\r\n\x05\x04\0\x02\x0c\x05\x12\x04\xd0\
    \x01\x02\x08\n\r\n\x05\x04\0\x02\x0c\x01\x12\x04\xd0\x01\t\x0c\n\r\n\x05\
    \x04\0\x02\x0c\x03\x12\x04\xd0\x01\x0f\x11\n\r\n\x05\x04\0\x02\x0c\x08\
    \x12\x04\xd0\x01\x12=\n\x10\n\x08\x04\0\x02\x0c\x08\x9c\x08\0\x12\x04\
    \xd0\x01\x13<\n\x8a\x01\n\x02\x04\x01\x12\x06\xd5\x01\0\x8a\x02\x01\x1a|\
    \x20OS\x20policy\x20assignment\x20operation\x20metadata\x20provided\x20b\
    y\x20OS\x20policy\x20assignment\x20API\n\x20methods\x20that\x20return\
    \x20long\x20running\x20operations.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xd5\
    \x01\x08+\n6\n\x04\x04\x01\x04\0\x12\x06\xd7\x01\x02\xe3\x01\x03\x1a&\
    \x20The\x20OS\x20policy\x20assignment\x20API\x20method.\n\n\r\n\x05\x04\
    \x01\x04\0\x01\x12\x04\xd7\x01\x07\x10\n\x1f\n\x06\x04\x01\x04\0\x02\0\
    \x12\x04\xd9\x01\x04\x1f\x1a\x0f\x20Invalid\x20value\n\n\x0f\n\x07\x04\
    \x01\x04\0\x02\0\x01\x12\x04\xd9\x01\x04\x1a\n\x0f\n\x07\x04\x01\x04\0\
    \x02\0\x02\x12\x04\xd9\x01\x1d\x1e\n8\n\x06\x04\x01\x04\0\x02\x01\x12\
    \x04\xdc\x01\x04\x0f\x1a(\x20Create\x20OS\x20policy\x20assignment\x20API\
    \x20method\n\n\x0f\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x04\xdc\x01\x04\n\
    \n\x0f\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x04\xdc\x01\r\x0e\n8\n\x06\
    \x04\x01\x04\0\x02\x02\x12\x04\xdf\x01\x04\x0f\x1a(\x20Update\x20OS\x20p\
    olicy\x20assignment\x20API\x20method\n\n\x0f\n\x07\x04\x01\x04\0\x02\x02\
    \x01\x12\x04\xdf\x01\x04\n\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x04\
    \xdf\x01\r\x0e\n8\n\x06\x04\x01\x04\0\x02\x03\x12\x04\xe2\x01\x04\x0f\
    \x1a(\x20Delete\x20OS\x20policy\x20assignment\x20API\x20method\n\n\x0f\n\
    \x07\x04\x01\x04\0\x02\x03\x01\x12\x04\xe2\x01\x04\n\n\x0f\n\x07\x04\x01\
    \x04\0\x02\x03\x02\x12\x04\xe2\x01\r\x0e\n&\n\x04\x04\x01\x04\x01\x12\
    \x06\xe6\x01\x02\xf5\x01\x03\x1a\x16\x20State\x20of\x20the\x20rollout\n\
    \n\r\n\x05\x04\x01\x04\x01\x01\x12\x04\xe6\x01\x07\x13\n\x1f\n\x06\x04\
    \x01\x04\x01\x02\0\x12\x04\xe8\x01\x04\"\x1a\x0f\x20Invalid\x20value\n\n\
    \x0f\n\x07\x04\x01\x04\x01\x02\0\x01\x12\x04\xe8\x01\x04\x1d\n\x0f\n\x07\
    \x04\x01\x04\x01\x02\0\x02\x12\x04\xe8\x01\x20!\n-\n\x06\x04\x01\x04\x01\
    \x02\x01\x12\x04\xeb\x01\x04\x14\x1a\x1d\x20The\x20rollout\x20is\x20in\
    \x20progress.\n\n\x0f\n\x07\x04\x01\x04\x01\x02\x01\x01\x12\x04\xeb\x01\
    \x04\x0f\n\x0f\n\x07\x04\x01\x04\x01\x02\x01\x02\x12\x04\xeb\x01\x12\x13\
    \n1\n\x06\x04\x01\x04\x01\x02\x02\x12\x04\xee\x01\x04\x13\x1a!\x20The\
    \x20rollout\x20is\x20being\x20cancelled.\n\n\x0f\n\x07\x04\x01\x04\x01\
    \x02\x02\x01\x12\x04\xee\x01\x04\x0e\n\x0f\n\x07\x04\x01\x04\x01\x02\x02\
    \x02\x12\x04\xee\x01\x11\x12\n+\n\x06\x04\x01\x04\x01\x02\x03\x12\x04\
    \xf1\x01\x04\x12\x1a\x1b\x20The\x20rollout\x20is\x20cancelled.\n\n\x0f\n\
    \x07\x04\x01\x04\x01\x02\x03\x01\x12\x04\xf1\x01\x04\r\n\x0f\n\x07\x04\
    \x01\x04\x01\x02\x03\x02\x12\x04\xf1\x01\x10\x11\n9\n\x06\x04\x01\x04\
    \x01\x02\x04\x12\x04\xf4\x01\x04\x12\x1a)\x20The\x20rollout\x20has\x20co\
    mpleted\x20successfully.\n\n\x0f\n\x07\x04\x01\x04\x01\x02\x04\x01\x12\
    \x04\xf4\x01\x04\r\n\x0f\n\x07\x04\x01\x04\x01\x02\x04\x02\x12\x04\xf4\
    \x01\x10\x11\n\xbc\x01\n\x04\x04\x01\x02\0\x12\x06\xfb\x01\x02\xfd\x01&\
    \x1a\xab\x01\x20Reference\x20to\x20the\x20`OSPolicyAssignment`\x20API\
    \x20resource.\n\n\x20Format:\n\x20`projects/{project_number}/locations/{\
    location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`\n\n\
    \r\n\x05\x04\x01\x02\0\x05\x12\x04\xfb\x01\x02\x08\n\r\n\x05\x04\x01\x02\
    \0\x01\x12\x04\xfb\x01\t\x1d\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xfb\x01\
    \x20!\n\x0f\n\x05\x04\x01\x02\0\x08\x12\x06\xfb\x01\"\xfd\x01%\n\x11\n\
    \x07\x04\x01\x02\0\x08\x9f\x08\x12\x06\xfb\x01#\xfd\x01$\n4\n\x04\x04\
    \x01\x02\x01\x12\x04\x80\x02\x02\x1b\x1a&\x20The\x20OS\x20policy\x20assi\
    gnment\x20API\x20method.\n\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\x80\x02\
    \x02\x0b\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\x80\x02\x0c\x16\n\r\n\x05\
    \x04\x01\x02\x01\x03\x12\x04\x80\x02\x19\x1a\n$\n\x04\x04\x01\x02\x02\
    \x12\x04\x83\x02\x02!\x1a\x16\x20State\x20of\x20the\x20rollout\n\n\r\n\
    \x05\x04\x01\x02\x02\x06\x12\x04\x83\x02\x02\x0e\n\r\n\x05\x04\x01\x02\
    \x02\x01\x12\x04\x83\x02\x0f\x1c\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\
    \x83\x02\x1f\x20\n\"\n\x04\x04\x01\x02\x03\x12\x04\x86\x02\x023\x1a\x14\
    \x20Rollout\x20start\x20time\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\x86\
    \x02\x02\x1b\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\x86\x02\x1c.\n\r\n\
    \x05\x04\x01\x02\x03\x03\x12\x04\x86\x0212\n#\n\x04\x04\x01\x02\x04\x12\
    \x04\x89\x02\x024\x1a\x15\x20Rollout\x20update\x20time\n\n\r\n\x05\x04\
    \x01\x02\x04\x06\x12\x04\x89\x02\x02\x1b\n\r\n\x05\x04\x01\x02\x04\x01\
    \x12\x04\x89\x02\x1c/\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\x89\x0223\nC\
    \n\x02\x04\x02\x12\x06\x8d\x02\0\xa3\x02\x01\x1a5\x20A\x20request\x20mes\
    sage\x20to\x20create\x20an\x20OS\x20policy\x20assignment\n\n\x0b\n\x03\
    \x04\x02\x01\x12\x04\x8d\x02\x08'\nj\n\x04\x04\x02\x02\0\x12\x06\x90\x02\
    \x02\x95\x02\x04\x1aZ\x20Required.\x20The\x20parent\x20resource\x20name\
    \x20in\x20the\x20form:\n\x20projects/{project}/locations/{location}\n\n\
    \r\n\x05\x04\x02\x02\0\x05\x12\x04\x90\x02\x02\x08\n\r\n\x05\x04\x02\x02\
    \0\x01\x12\x04\x90\x02\t\x0f\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x90\x02\
    \x12\x13\n\x0f\n\x05\x04\x02\x02\0\x08\x12\x06\x90\x02\x14\x95\x02\x03\n\
    \x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\x91\x02\x04*\n\x11\n\x07\
    \x04\x02\x02\0\x08\x9f\x08\x12\x06\x92\x02\x04\x94\x02\x05\nA\n\x04\x04\
    \x02\x02\x01\x12\x04\x98\x02\x02W\x1a3\x20Required.\x20The\x20OS\x20poli\
    cy\x20assignment\x20to\x20be\x20created.\n\n\r\n\x05\x04\x02\x02\x01\x06\
    \x12\x04\x98\x02\x02\x14\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x98\x02\
    \x15)\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x98\x02,-\n\r\n\x05\x04\x02\
    \x02\x01\x08\x12\x04\x98\x02.V\n\x10\n\x08\x04\x02\x02\x01\x08\x9c\x08\0\
    \x12\x04\x98\x02/U\n\xc5\x02\n\x04\x04\x02\x02\x02\x12\x04\xa2\x02\x02N\
    \x1a\xb6\x02\x20Required.\x20The\x20logical\x20name\x20of\x20the\x20OS\
    \x20policy\x20assignment\x20in\x20the\x20project\n\x20with\x20the\x20fol\
    lowing\x20restrictions:\n\n\x20*\x20Must\x20contain\x20only\x20lowercase\
    \x20letters,\x20numbers,\x20and\x20hyphens.\n\x20*\x20Must\x20start\x20w\
    ith\x20a\x20letter.\n\x20*\x20Must\x20be\x20between\x201-63\x20character\
    s.\n\x20*\x20Must\x20end\x20with\x20a\x20number\x20or\x20a\x20letter.\n\
    \x20*\x20Must\x20be\x20unique\x20within\x20the\x20project.\n\n\r\n\x05\
    \x04\x02\x02\x02\x05\x12\x04\xa2\x02\x02\x08\n\r\n\x05\x04\x02\x02\x02\
    \x01\x12\x04\xa2\x02\t\x20\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xa2\x02\
    #$\n\r\n\x05\x04\x02\x02\x02\x08\x12\x04\xa2\x02%M\n\x10\n\x08\x04\x02\
    \x02\x02\x08\x9c\x08\0\x12\x04\xa2\x02&L\nC\n\x02\x04\x03\x12\x06\xa6\
    \x02\0\xac\x02\x01\x1a5\x20A\x20request\x20message\x20to\x20update\x20an\
    \x20OS\x20policy\x20assignment\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xa6\x02\
    \x08'\n;\n\x04\x04\x03\x02\0\x12\x04\xa8\x02\x02W\x1a-\x20Required.\x20T\
    he\x20updated\x20OS\x20policy\x20assignment.\n\n\r\n\x05\x04\x03\x02\0\
    \x06\x12\x04\xa8\x02\x02\x14\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xa8\x02\
    \x15)\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xa8\x02,-\n\r\n\x05\x04\x03\
    \x02\0\x08\x12\x04\xa8\x02.V\n\x10\n\x08\x04\x03\x02\0\x08\x9c\x08\0\x12\
    \x04\xa8\x02/U\nd\n\x04\x04\x03\x02\x01\x12\x04\xab\x02\x02U\x1aV\x20Opt\
    ional.\x20Field\x20mask\x20that\x20controls\x20which\x20fields\x20of\x20\
    the\x20assignment\x20should\x20be\x20updated.\n\n\r\n\x05\x04\x03\x02\
    \x01\x06\x12\x04\xab\x02\x02\x1b\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\
    \xab\x02\x1c'\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xab\x02*+\n\r\n\x05\
    \x04\x03\x02\x01\x08\x12\x04\xab\x02,T\n\x10\n\x08\x04\x03\x02\x01\x08\
    \x9c\x08\0\x12\x04\xab\x02-S\n@\n\x02\x04\x04\x12\x06\xaf\x02\0\xba\x02\
    \x01\x1a2\x20A\x20request\x20message\x20to\x20get\x20an\x20OS\x20policy\
    \x20assignment\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xaf\x02\x08$\n\xb4\x01\
    \n\x04\x04\x04\x02\0\x12\x06\xb4\x02\x02\xb9\x02\x04\x1a\xa3\x01\x20Requ\
    ired.\x20The\x20resource\x20name\x20of\x20OS\x20policy\x20assignment.\n\
    \n\x20Format:\n\x20`projects/{project}/locations/{location}/osPolicyAssi\
    gnments/{os_policy_assignment}@{revisionId}`\n\n\r\n\x05\x04\x04\x02\0\
    \x05\x12\x04\xb4\x02\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xb4\x02\
    \t\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xb4\x02\x10\x11\n\x0f\n\x05\x04\
    \x04\x02\0\x08\x12\x06\xb4\x02\x12\xb9\x02\x03\n\x10\n\x08\x04\x04\x02\0\
    \x08\x9c\x08\0\x12\x04\xb5\x02\x04*\n\x11\n\x07\x04\x04\x02\0\x08\x9f\
    \x08\x12\x06\xb6\x02\x04\xb8\x02\x05\nU\n\x02\x04\x05\x12\x06\xbd\x02\0\
    \xcd\x02\x01\x1aG\x20A\x20request\x20message\x20to\x20list\x20OS\x20poli\
    cy\x20assignments\x20for\x20a\x20parent\x20resource\n\n\x0b\n\x03\x04\
    \x05\x01\x12\x04\xbd\x02\x08&\n5\n\x04\x04\x05\x02\0\x12\x06\xbf\x02\x02\
    \xc4\x02\x04\x1a%\x20Required.\x20The\x20parent\x20resource\x20name.\n\n\
    \r\n\x05\x04\x05\x02\0\x05\x12\x04\xbf\x02\x02\x08\n\r\n\x05\x04\x05\x02\
    \0\x01\x12\x04\xbf\x02\t\x0f\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xbf\x02\
    \x12\x13\n\x0f\n\x05\x04\x05\x02\0\x08\x12\x06\xbf\x02\x14\xc4\x02\x03\n\
    \x10\n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\xc0\x02\x04*\n\x11\n\x07\
    \x04\x05\x02\0\x08\x9f\x08\x12\x06\xc1\x02\x04\xc3\x02\x05\n<\n\x04\x04\
    \x05\x02\x01\x12\x04\xc7\x02\x02\x16\x1a.\x20The\x20maximum\x20number\
    \x20of\x20assignments\x20to\x20return.\n\n\r\n\x05\x04\x05\x02\x01\x05\
    \x12\x04\xc7\x02\x02\x07\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xc7\x02\
    \x08\x11\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xc7\x02\x14\x15\n\x98\x01\
    \n\x04\x04\x05\x02\x02\x12\x04\xcc\x02\x02\x18\x1a\x89\x01\x20A\x20pagin\
    ation\x20token\x20returned\x20from\x20a\x20previous\x20call\x20to\n\x20`\
    ListOSPolicyAssignments`\x20that\x20indicates\x20where\x20this\x20listin\
    g\x20should\x20continue\n\x20from.\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\
    \x04\xcc\x02\x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xcc\x02\t\x13\
    \n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xcc\x02\x16\x17\nR\n\x02\x04\x06\
    \x12\x06\xd0\x02\0\xd6\x02\x01\x1aD\x20A\x20response\x20message\x20for\
    \x20listing\x20all\x20assignments\x20under\x20given\x20parent.\n\n\x0b\n\
    \x03\x04\x06\x01\x12\x04\xd0\x02\x08'\n'\n\x04\x04\x06\x02\0\x12\x04\xd2\
    \x02\x028\x1a\x19\x20The\x20list\x20of\x20assignments\n\n\r\n\x05\x04\
    \x06\x02\0\x04\x12\x04\xd2\x02\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\
    \xd2\x02\x0b\x1d\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xd2\x02\x1e3\n\r\n\
    \x05\x04\x06\x02\0\x03\x12\x04\xd2\x0267\nX\n\x04\x04\x06\x02\x01\x12\
    \x04\xd5\x02\x02\x1d\x1aJ\x20The\x20pagination\x20token\x20to\x20retriev\
    e\x20the\x20next\x20page\x20of\x20OS\x20policy\x20assignments.\n\n\r\n\
    \x05\x04\x06\x02\x01\x05\x12\x04\xd5\x02\x02\x08\n\r\n\x05\x04\x06\x02\
    \x01\x01\x12\x04\xd5\x02\t\x18\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xd5\
    \x02\x1b\x1c\nN\n\x02\x04\x07\x12\x06\xd9\x02\0\xe9\x02\x01\x1a@\x20A\
    \x20request\x20message\x20to\x20list\x20revisions\x20for\x20a\x20OS\x20p\
    olicy\x20assignment\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xd9\x02\x08.\nW\n\
    \x04\x04\x07\x02\0\x12\x06\xdb\x02\x02\xe0\x02\x04\x1aG\x20Required.\x20\
    The\x20name\x20of\x20the\x20OS\x20policy\x20assignment\x20to\x20list\x20\
    revisions\x20for.\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xdb\x02\x02\x08\
    \n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xdb\x02\t\r\n\r\n\x05\x04\x07\x02\0\
    \x03\x12\x04\xdb\x02\x10\x11\n\x0f\n\x05\x04\x07\x02\0\x08\x12\x06\xdb\
    \x02\x12\xe0\x02\x03\n\x10\n\x08\x04\x07\x02\0\x08\x9c\x08\0\x12\x04\xdc\
    \x02\x04*\n\x11\n\x07\x04\x07\x02\0\x08\x9f\x08\x12\x06\xdd\x02\x04\xdf\
    \x02\x05\n:\n\x04\x04\x07\x02\x01\x12\x04\xe3\x02\x02\x16\x1a,\x20The\
    \x20maximum\x20number\x20of\x20revisions\x20to\x20return.\n\n\r\n\x05\
    \x04\x07\x02\x01\x05\x12\x04\xe3\x02\x02\x07\n\r\n\x05\x04\x07\x02\x01\
    \x01\x12\x04\xe3\x02\x08\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xe3\
    \x02\x14\x15\n\xa0\x01\n\x04\x04\x07\x02\x02\x12\x04\xe8\x02\x02\x18\x1a\
    \x91\x01\x20A\x20pagination\x20token\x20returned\x20from\x20a\x20previou\
    s\x20call\x20to\n\x20`ListOSPolicyAssignmentRevisions`\x20that\x20indica\
    tes\x20where\x20this\x20listing\x20should\n\x20continue\x20from.\n\n\r\n\
    \x05\x04\x07\x02\x02\x05\x12\x04\xe8\x02\x02\x08\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\xe8\x02\t\x13\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xe8\
    \x02\x16\x17\nX\n\x02\x04\x08\x12\x06\xec\x02\0\xf3\x02\x01\x1aJ\x20A\
    \x20response\x20message\x20for\x20listing\x20all\x20revisions\x20for\x20\
    a\x20OS\x20policy\x20assignment.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xec\
    \x02\x08/\n2\n\x04\x04\x08\x02\0\x12\x04\xee\x02\x028\x1a$\x20The\x20OS\
    \x20policy\x20assignment\x20revisions\n\n\r\n\x05\x04\x08\x02\0\x04\x12\
    \x04\xee\x02\x02\n\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xee\x02\x0b\x1d\n\
    \r\n\x05\x04\x08\x02\0\x01\x12\x04\xee\x02\x1e3\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xee\x0267\nb\n\x04\x04\x08\x02\x01\x12\x04\xf2\x02\x02\x1d\
    \x1aT\x20The\x20pagination\x20token\x20to\x20retrieve\x20the\x20next\x20\
    page\x20of\x20OS\x20policy\x20assignment\n\x20revisions.\n\n\r\n\x05\x04\
    \x08\x02\x01\x05\x12\x04\xf2\x02\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\
    \x12\x04\xf2\x02\t\x18\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xf2\x02\x1b\
    \x1c\nF\n\x02\x04\t\x12\x06\xf6\x02\0\xfe\x02\x01\x1a8\x20A\x20request\
    \x20message\x20for\x20deleting\x20a\x20OS\x20policy\x20assignment.\n\n\
    \x0b\n\x03\x04\t\x01\x12\x04\xf6\x02\x08'\nN\n\x04\x04\t\x02\0\x12\x06\
    \xf8\x02\x02\xfd\x02\x04\x1a>\x20Required.\x20The\x20name\x20of\x20the\
    \x20OS\x20policy\x20assignment\x20to\x20be\x20deleted\n\n\r\n\x05\x04\t\
    \x02\0\x05\x12\x04\xf8\x02\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xf8\
    \x02\t\r\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xf8\x02\x10\x11\n\x0f\n\x05\
    \x04\t\x02\0\x08\x12\x06\xf8\x02\x12\xfd\x02\x03\n\x10\n\x08\x04\t\x02\0\
    \x08\x9c\x08\0\x12\x04\xf9\x02\x04*\n\x11\n\x07\x04\t\x02\0\x08\x9f\x08\
    \x12\x06\xfa\x02\x04\xfc\x02\x05b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
