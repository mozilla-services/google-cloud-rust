// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/v1alpha/vulnerability.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct VulnerabilityReport {
    // message fields
    pub name: ::std::string::String,
    pub vulnerabilities: ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VulnerabilityReport {
    fn default() -> &'a VulnerabilityReport {
        <VulnerabilityReport as ::protobuf::Message>::default_instance()
    }
}

impl VulnerabilityReport {
    pub fn new() -> VulnerabilityReport {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.VulnerabilityReport.Vulnerability vulnerabilities = 2;


    pub fn get_vulnerabilities(&self) -> &[VulnerabilityReport_Vulnerability] {
        &self.vulnerabilities
    }
    pub fn clear_vulnerabilities(&mut self) {
        self.vulnerabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_vulnerabilities(&mut self, v: ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability>) {
        self.vulnerabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vulnerabilities(&mut self) -> &mut ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability> {
        &mut self.vulnerabilities
    }

    // Take field
    pub fn take_vulnerabilities(&mut self) -> ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability> {
        ::std::mem::replace(&mut self.vulnerabilities, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp update_time = 3;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for VulnerabilityReport {
    fn is_initialized(&self) -> bool {
        for v in &self.vulnerabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vulnerabilities)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.vulnerabilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.vulnerabilities {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VulnerabilityReport {
        VulnerabilityReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VulnerabilityReport| { &m.name },
                |m: &mut VulnerabilityReport| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityReport_Vulnerability>>(
                "vulnerabilities",
                |m: &VulnerabilityReport| { &m.vulnerabilities },
                |m: &mut VulnerabilityReport| { &mut m.vulnerabilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &VulnerabilityReport| { &m.update_time },
                |m: &mut VulnerabilityReport| { &mut m.update_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VulnerabilityReport>(
                "VulnerabilityReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VulnerabilityReport {
        static instance: ::protobuf::rt::LazyV2<VulnerabilityReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VulnerabilityReport::new)
    }
}

impl ::protobuf::Clear for VulnerabilityReport {
    fn clear(&mut self) {
        self.name.clear();
        self.vulnerabilities.clear();
        self.update_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VulnerabilityReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VulnerabilityReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VulnerabilityReport_Vulnerability {
    // message fields
    pub details: ::protobuf::SingularPtrField<VulnerabilityReport_Vulnerability_Details>,
    pub installed_inventory_item_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub available_inventory_item_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub items: ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VulnerabilityReport_Vulnerability {
    fn default() -> &'a VulnerabilityReport_Vulnerability {
        <VulnerabilityReport_Vulnerability as ::protobuf::Message>::default_instance()
    }
}

impl VulnerabilityReport_Vulnerability {
    pub fn new() -> VulnerabilityReport_Vulnerability {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.v1alpha.VulnerabilityReport.Vulnerability.Details details = 1;


    pub fn get_details(&self) -> &VulnerabilityReport_Vulnerability_Details {
        self.details.as_ref().unwrap_or_else(|| <VulnerabilityReport_Vulnerability_Details as ::protobuf::Message>::default_instance())
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: VulnerabilityReport_Vulnerability_Details) {
        self.details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut VulnerabilityReport_Vulnerability_Details {
        if self.details.is_none() {
            self.details.set_default();
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> VulnerabilityReport_Vulnerability_Details {
        self.details.take().unwrap_or_else(|| VulnerabilityReport_Vulnerability_Details::new())
    }

    // repeated string installed_inventory_item_ids = 2;


    pub fn get_installed_inventory_item_ids(&self) -> &[::std::string::String] {
        &self.installed_inventory_item_ids
    }
    pub fn clear_installed_inventory_item_ids(&mut self) {
        self.installed_inventory_item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_installed_inventory_item_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.installed_inventory_item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_installed_inventory_item_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.installed_inventory_item_ids
    }

    // Take field
    pub fn take_installed_inventory_item_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.installed_inventory_item_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string available_inventory_item_ids = 3;


    pub fn get_available_inventory_item_ids(&self) -> &[::std::string::String] {
        &self.available_inventory_item_ids
    }
    pub fn clear_available_inventory_item_ids(&mut self) {
        self.available_inventory_item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_inventory_item_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.available_inventory_item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_available_inventory_item_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.available_inventory_item_ids
    }

    // Take field
    pub fn take_available_inventory_item_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.available_inventory_item_ids, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp create_time = 4;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 5;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.VulnerabilityReport.Vulnerability.Item items = 6;


    pub fn get_items(&self) -> &[VulnerabilityReport_Vulnerability_Item] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VulnerabilityReport_Vulnerability {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.installed_inventory_item_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.available_inventory_item_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.installed_inventory_item_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.available_inventory_item_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.installed_inventory_item_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.available_inventory_item_ids {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VulnerabilityReport_Vulnerability {
        VulnerabilityReport_Vulnerability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityReport_Vulnerability_Details>>(
                "details",
                |m: &VulnerabilityReport_Vulnerability| { &m.details },
                |m: &mut VulnerabilityReport_Vulnerability| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "installed_inventory_item_ids",
                |m: &VulnerabilityReport_Vulnerability| { &m.installed_inventory_item_ids },
                |m: &mut VulnerabilityReport_Vulnerability| { &mut m.installed_inventory_item_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "available_inventory_item_ids",
                |m: &VulnerabilityReport_Vulnerability| { &m.available_inventory_item_ids },
                |m: &mut VulnerabilityReport_Vulnerability| { &mut m.available_inventory_item_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &VulnerabilityReport_Vulnerability| { &m.create_time },
                |m: &mut VulnerabilityReport_Vulnerability| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &VulnerabilityReport_Vulnerability| { &m.update_time },
                |m: &mut VulnerabilityReport_Vulnerability| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityReport_Vulnerability_Item>>(
                "items",
                |m: &VulnerabilityReport_Vulnerability| { &m.items },
                |m: &mut VulnerabilityReport_Vulnerability| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VulnerabilityReport_Vulnerability>(
                "VulnerabilityReport.Vulnerability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VulnerabilityReport_Vulnerability {
        static instance: ::protobuf::rt::LazyV2<VulnerabilityReport_Vulnerability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VulnerabilityReport_Vulnerability::new)
    }
}

impl ::protobuf::Clear for VulnerabilityReport_Vulnerability {
    fn clear(&mut self) {
        self.details.clear();
        self.installed_inventory_item_ids.clear();
        self.available_inventory_item_ids.clear();
        self.create_time.clear();
        self.update_time.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VulnerabilityReport_Vulnerability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VulnerabilityReport_Vulnerability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VulnerabilityReport_Vulnerability_Details {
    // message fields
    pub cve: ::std::string::String,
    pub cvss_v2_score: f32,
    pub cvss_v3: ::protobuf::SingularPtrField<CVSSv3>,
    pub severity: ::std::string::String,
    pub description: ::std::string::String,
    pub references: ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Details_Reference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VulnerabilityReport_Vulnerability_Details {
    fn default() -> &'a VulnerabilityReport_Vulnerability_Details {
        <VulnerabilityReport_Vulnerability_Details as ::protobuf::Message>::default_instance()
    }
}

impl VulnerabilityReport_Vulnerability_Details {
    pub fn new() -> VulnerabilityReport_Vulnerability_Details {
        ::std::default::Default::default()
    }

    // string cve = 1;


    pub fn get_cve(&self) -> &str {
        &self.cve
    }
    pub fn clear_cve(&mut self) {
        self.cve.clear();
    }

    // Param is passed by value, moved
    pub fn set_cve(&mut self, v: ::std::string::String) {
        self.cve = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cve(&mut self) -> &mut ::std::string::String {
        &mut self.cve
    }

    // Take field
    pub fn take_cve(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cve, ::std::string::String::new())
    }

    // float cvss_v2_score = 2;


    pub fn get_cvss_v2_score(&self) -> f32 {
        self.cvss_v2_score
    }
    pub fn clear_cvss_v2_score(&mut self) {
        self.cvss_v2_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cvss_v2_score(&mut self, v: f32) {
        self.cvss_v2_score = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3 cvss_v3 = 3;


    pub fn get_cvss_v3(&self) -> &CVSSv3 {
        self.cvss_v3.as_ref().unwrap_or_else(|| <CVSSv3 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cvss_v3(&mut self) {
        self.cvss_v3.clear();
    }

    pub fn has_cvss_v3(&self) -> bool {
        self.cvss_v3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cvss_v3(&mut self, v: CVSSv3) {
        self.cvss_v3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cvss_v3(&mut self) -> &mut CVSSv3 {
        if self.cvss_v3.is_none() {
            self.cvss_v3.set_default();
        }
        self.cvss_v3.as_mut().unwrap()
    }

    // Take field
    pub fn take_cvss_v3(&mut self) -> CVSSv3 {
        self.cvss_v3.take().unwrap_or_else(|| CVSSv3::new())
    }

    // string severity = 4;


    pub fn get_severity(&self) -> &str {
        &self.severity
    }
    pub fn clear_severity(&mut self) {
        self.severity.clear();
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: ::std::string::String) {
        self.severity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_severity(&mut self) -> &mut ::std::string::String {
        &mut self.severity
    }

    // Take field
    pub fn take_severity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.severity, ::std::string::String::new())
    }

    // string description = 5;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .google.cloud.osconfig.v1alpha.VulnerabilityReport.Vulnerability.Details.Reference references = 6;


    pub fn get_references(&self) -> &[VulnerabilityReport_Vulnerability_Details_Reference] {
        &self.references
    }
    pub fn clear_references(&mut self) {
        self.references.clear();
    }

    // Param is passed by value, moved
    pub fn set_references(&mut self, v: ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Details_Reference>) {
        self.references = v;
    }

    // Mutable pointer to the field.
    pub fn mut_references(&mut self) -> &mut ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Details_Reference> {
        &mut self.references
    }

    // Take field
    pub fn take_references(&mut self) -> ::protobuf::RepeatedField<VulnerabilityReport_Vulnerability_Details_Reference> {
        ::std::mem::replace(&mut self.references, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VulnerabilityReport_Vulnerability_Details {
    fn is_initialized(&self) -> bool {
        for v in &self.cvss_v3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.references {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cve)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cvss_v2_score = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cvss_v3)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.severity)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.references)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cve.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cve);
        }
        if self.cvss_v2_score != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.cvss_v3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.severity.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.severity);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.description);
        }
        for value in &self.references {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cve.is_empty() {
            os.write_string(1, &self.cve)?;
        }
        if self.cvss_v2_score != 0. {
            os.write_float(2, self.cvss_v2_score)?;
        }
        if let Some(ref v) = self.cvss_v3.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.severity.is_empty() {
            os.write_string(4, &self.severity)?;
        }
        if !self.description.is_empty() {
            os.write_string(5, &self.description)?;
        }
        for v in &self.references {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VulnerabilityReport_Vulnerability_Details {
        VulnerabilityReport_Vulnerability_Details::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cve",
                |m: &VulnerabilityReport_Vulnerability_Details| { &m.cve },
                |m: &mut VulnerabilityReport_Vulnerability_Details| { &mut m.cve },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cvss_v2_score",
                |m: &VulnerabilityReport_Vulnerability_Details| { &m.cvss_v2_score },
                |m: &mut VulnerabilityReport_Vulnerability_Details| { &mut m.cvss_v2_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CVSSv3>>(
                "cvss_v3",
                |m: &VulnerabilityReport_Vulnerability_Details| { &m.cvss_v3 },
                |m: &mut VulnerabilityReport_Vulnerability_Details| { &mut m.cvss_v3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "severity",
                |m: &VulnerabilityReport_Vulnerability_Details| { &m.severity },
                |m: &mut VulnerabilityReport_Vulnerability_Details| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &VulnerabilityReport_Vulnerability_Details| { &m.description },
                |m: &mut VulnerabilityReport_Vulnerability_Details| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityReport_Vulnerability_Details_Reference>>(
                "references",
                |m: &VulnerabilityReport_Vulnerability_Details| { &m.references },
                |m: &mut VulnerabilityReport_Vulnerability_Details| { &mut m.references },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VulnerabilityReport_Vulnerability_Details>(
                "VulnerabilityReport.Vulnerability.Details",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VulnerabilityReport_Vulnerability_Details {
        static instance: ::protobuf::rt::LazyV2<VulnerabilityReport_Vulnerability_Details> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VulnerabilityReport_Vulnerability_Details::new)
    }
}

impl ::protobuf::Clear for VulnerabilityReport_Vulnerability_Details {
    fn clear(&mut self) {
        self.cve.clear();
        self.cvss_v2_score = 0.;
        self.cvss_v3.clear();
        self.severity.clear();
        self.description.clear();
        self.references.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VulnerabilityReport_Vulnerability_Details {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VulnerabilityReport_Vulnerability_Details {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VulnerabilityReport_Vulnerability_Details_Reference {
    // message fields
    pub url: ::std::string::String,
    pub source: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VulnerabilityReport_Vulnerability_Details_Reference {
    fn default() -> &'a VulnerabilityReport_Vulnerability_Details_Reference {
        <VulnerabilityReport_Vulnerability_Details_Reference as ::protobuf::Message>::default_instance()
    }
}

impl VulnerabilityReport_Vulnerability_Details_Reference {
    pub fn new() -> VulnerabilityReport_Vulnerability_Details_Reference {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string source = 2;


    pub fn get_source(&self) -> &str {
        &self.source
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VulnerabilityReport_Vulnerability_Details_Reference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.source.is_empty() {
            os.write_string(2, &self.source)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VulnerabilityReport_Vulnerability_Details_Reference {
        VulnerabilityReport_Vulnerability_Details_Reference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &VulnerabilityReport_Vulnerability_Details_Reference| { &m.url },
                |m: &mut VulnerabilityReport_Vulnerability_Details_Reference| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source",
                |m: &VulnerabilityReport_Vulnerability_Details_Reference| { &m.source },
                |m: &mut VulnerabilityReport_Vulnerability_Details_Reference| { &mut m.source },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VulnerabilityReport_Vulnerability_Details_Reference>(
                "VulnerabilityReport.Vulnerability.Details.Reference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VulnerabilityReport_Vulnerability_Details_Reference {
        static instance: ::protobuf::rt::LazyV2<VulnerabilityReport_Vulnerability_Details_Reference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VulnerabilityReport_Vulnerability_Details_Reference::new)
    }
}

impl ::protobuf::Clear for VulnerabilityReport_Vulnerability_Details_Reference {
    fn clear(&mut self) {
        self.url.clear();
        self.source.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VulnerabilityReport_Vulnerability_Details_Reference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VulnerabilityReport_Vulnerability_Details_Reference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VulnerabilityReport_Vulnerability_Item {
    // message fields
    pub installed_inventory_item_id: ::std::string::String,
    pub available_inventory_item_id: ::std::string::String,
    pub fixed_cpe_uri: ::std::string::String,
    pub upstream_fix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VulnerabilityReport_Vulnerability_Item {
    fn default() -> &'a VulnerabilityReport_Vulnerability_Item {
        <VulnerabilityReport_Vulnerability_Item as ::protobuf::Message>::default_instance()
    }
}

impl VulnerabilityReport_Vulnerability_Item {
    pub fn new() -> VulnerabilityReport_Vulnerability_Item {
        ::std::default::Default::default()
    }

    // string installed_inventory_item_id = 1;


    pub fn get_installed_inventory_item_id(&self) -> &str {
        &self.installed_inventory_item_id
    }
    pub fn clear_installed_inventory_item_id(&mut self) {
        self.installed_inventory_item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_installed_inventory_item_id(&mut self, v: ::std::string::String) {
        self.installed_inventory_item_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_installed_inventory_item_id(&mut self) -> &mut ::std::string::String {
        &mut self.installed_inventory_item_id
    }

    // Take field
    pub fn take_installed_inventory_item_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.installed_inventory_item_id, ::std::string::String::new())
    }

    // string available_inventory_item_id = 2;


    pub fn get_available_inventory_item_id(&self) -> &str {
        &self.available_inventory_item_id
    }
    pub fn clear_available_inventory_item_id(&mut self) {
        self.available_inventory_item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_inventory_item_id(&mut self, v: ::std::string::String) {
        self.available_inventory_item_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_available_inventory_item_id(&mut self) -> &mut ::std::string::String {
        &mut self.available_inventory_item_id
    }

    // Take field
    pub fn take_available_inventory_item_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.available_inventory_item_id, ::std::string::String::new())
    }

    // string fixed_cpe_uri = 3;


    pub fn get_fixed_cpe_uri(&self) -> &str {
        &self.fixed_cpe_uri
    }
    pub fn clear_fixed_cpe_uri(&mut self) {
        self.fixed_cpe_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_fixed_cpe_uri(&mut self, v: ::std::string::String) {
        self.fixed_cpe_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fixed_cpe_uri(&mut self) -> &mut ::std::string::String {
        &mut self.fixed_cpe_uri
    }

    // Take field
    pub fn take_fixed_cpe_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fixed_cpe_uri, ::std::string::String::new())
    }

    // string upstream_fix = 4;


    pub fn get_upstream_fix(&self) -> &str {
        &self.upstream_fix
    }
    pub fn clear_upstream_fix(&mut self) {
        self.upstream_fix.clear();
    }

    // Param is passed by value, moved
    pub fn set_upstream_fix(&mut self, v: ::std::string::String) {
        self.upstream_fix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upstream_fix(&mut self) -> &mut ::std::string::String {
        &mut self.upstream_fix
    }

    // Take field
    pub fn take_upstream_fix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.upstream_fix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VulnerabilityReport_Vulnerability_Item {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.installed_inventory_item_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.available_inventory_item_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fixed_cpe_uri)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.upstream_fix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.installed_inventory_item_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.installed_inventory_item_id);
        }
        if !self.available_inventory_item_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.available_inventory_item_id);
        }
        if !self.fixed_cpe_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.fixed_cpe_uri);
        }
        if !self.upstream_fix.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.upstream_fix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.installed_inventory_item_id.is_empty() {
            os.write_string(1, &self.installed_inventory_item_id)?;
        }
        if !self.available_inventory_item_id.is_empty() {
            os.write_string(2, &self.available_inventory_item_id)?;
        }
        if !self.fixed_cpe_uri.is_empty() {
            os.write_string(3, &self.fixed_cpe_uri)?;
        }
        if !self.upstream_fix.is_empty() {
            os.write_string(4, &self.upstream_fix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VulnerabilityReport_Vulnerability_Item {
        VulnerabilityReport_Vulnerability_Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "installed_inventory_item_id",
                |m: &VulnerabilityReport_Vulnerability_Item| { &m.installed_inventory_item_id },
                |m: &mut VulnerabilityReport_Vulnerability_Item| { &mut m.installed_inventory_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "available_inventory_item_id",
                |m: &VulnerabilityReport_Vulnerability_Item| { &m.available_inventory_item_id },
                |m: &mut VulnerabilityReport_Vulnerability_Item| { &mut m.available_inventory_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fixed_cpe_uri",
                |m: &VulnerabilityReport_Vulnerability_Item| { &m.fixed_cpe_uri },
                |m: &mut VulnerabilityReport_Vulnerability_Item| { &mut m.fixed_cpe_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upstream_fix",
                |m: &VulnerabilityReport_Vulnerability_Item| { &m.upstream_fix },
                |m: &mut VulnerabilityReport_Vulnerability_Item| { &mut m.upstream_fix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VulnerabilityReport_Vulnerability_Item>(
                "VulnerabilityReport.Vulnerability.Item",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VulnerabilityReport_Vulnerability_Item {
        static instance: ::protobuf::rt::LazyV2<VulnerabilityReport_Vulnerability_Item> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VulnerabilityReport_Vulnerability_Item::new)
    }
}

impl ::protobuf::Clear for VulnerabilityReport_Vulnerability_Item {
    fn clear(&mut self) {
        self.installed_inventory_item_id.clear();
        self.available_inventory_item_id.clear();
        self.fixed_cpe_uri.clear();
        self.upstream_fix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VulnerabilityReport_Vulnerability_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VulnerabilityReport_Vulnerability_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetVulnerabilityReportRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetVulnerabilityReportRequest {
    fn default() -> &'a GetVulnerabilityReportRequest {
        <GetVulnerabilityReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVulnerabilityReportRequest {
    pub fn new() -> GetVulnerabilityReportRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetVulnerabilityReportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetVulnerabilityReportRequest {
        GetVulnerabilityReportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetVulnerabilityReportRequest| { &m.name },
                |m: &mut GetVulnerabilityReportRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetVulnerabilityReportRequest>(
                "GetVulnerabilityReportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetVulnerabilityReportRequest {
        static instance: ::protobuf::rt::LazyV2<GetVulnerabilityReportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetVulnerabilityReportRequest::new)
    }
}

impl ::protobuf::Clear for GetVulnerabilityReportRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetVulnerabilityReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVulnerabilityReportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVulnerabilityReportsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub filter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListVulnerabilityReportsRequest {
    fn default() -> &'a ListVulnerabilityReportsRequest {
        <ListVulnerabilityReportsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListVulnerabilityReportsRequest {
    pub fn new() -> ListVulnerabilityReportsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string filter = 4;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListVulnerabilityReportsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVulnerabilityReportsRequest {
        ListVulnerabilityReportsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListVulnerabilityReportsRequest| { &m.parent },
                |m: &mut ListVulnerabilityReportsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListVulnerabilityReportsRequest| { &m.page_size },
                |m: &mut ListVulnerabilityReportsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListVulnerabilityReportsRequest| { &m.page_token },
                |m: &mut ListVulnerabilityReportsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListVulnerabilityReportsRequest| { &m.filter },
                |m: &mut ListVulnerabilityReportsRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListVulnerabilityReportsRequest>(
                "ListVulnerabilityReportsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListVulnerabilityReportsRequest {
        static instance: ::protobuf::rt::LazyV2<ListVulnerabilityReportsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListVulnerabilityReportsRequest::new)
    }
}

impl ::protobuf::Clear for ListVulnerabilityReportsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVulnerabilityReportsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVulnerabilityReportsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVulnerabilityReportsResponse {
    // message fields
    pub vulnerability_reports: ::protobuf::RepeatedField<VulnerabilityReport>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListVulnerabilityReportsResponse {
    fn default() -> &'a ListVulnerabilityReportsResponse {
        <ListVulnerabilityReportsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListVulnerabilityReportsResponse {
    pub fn new() -> ListVulnerabilityReportsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.v1alpha.VulnerabilityReport vulnerability_reports = 1;


    pub fn get_vulnerability_reports(&self) -> &[VulnerabilityReport] {
        &self.vulnerability_reports
    }
    pub fn clear_vulnerability_reports(&mut self) {
        self.vulnerability_reports.clear();
    }

    // Param is passed by value, moved
    pub fn set_vulnerability_reports(&mut self, v: ::protobuf::RepeatedField<VulnerabilityReport>) {
        self.vulnerability_reports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vulnerability_reports(&mut self) -> &mut ::protobuf::RepeatedField<VulnerabilityReport> {
        &mut self.vulnerability_reports
    }

    // Take field
    pub fn take_vulnerability_reports(&mut self) -> ::protobuf::RepeatedField<VulnerabilityReport> {
        ::std::mem::replace(&mut self.vulnerability_reports, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListVulnerabilityReportsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.vulnerability_reports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vulnerability_reports)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vulnerability_reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vulnerability_reports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVulnerabilityReportsResponse {
        ListVulnerabilityReportsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityReport>>(
                "vulnerability_reports",
                |m: &ListVulnerabilityReportsResponse| { &m.vulnerability_reports },
                |m: &mut ListVulnerabilityReportsResponse| { &mut m.vulnerability_reports },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListVulnerabilityReportsResponse| { &m.next_page_token },
                |m: &mut ListVulnerabilityReportsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListVulnerabilityReportsResponse>(
                "ListVulnerabilityReportsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListVulnerabilityReportsResponse {
        static instance: ::protobuf::rt::LazyV2<ListVulnerabilityReportsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListVulnerabilityReportsResponse::new)
    }
}

impl ::protobuf::Clear for ListVulnerabilityReportsResponse {
    fn clear(&mut self) {
        self.vulnerability_reports.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVulnerabilityReportsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVulnerabilityReportsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVSSv3 {
    // message fields
    pub base_score: f32,
    pub exploitability_score: f32,
    pub impact_score: f32,
    pub attack_vector: CVSSv3_AttackVector,
    pub attack_complexity: CVSSv3_AttackComplexity,
    pub privileges_required: CVSSv3_PrivilegesRequired,
    pub user_interaction: CVSSv3_UserInteraction,
    pub scope: CVSSv3_Scope,
    pub confidentiality_impact: CVSSv3_Impact,
    pub integrity_impact: CVSSv3_Impact,
    pub availability_impact: CVSSv3_Impact,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVSSv3 {
    fn default() -> &'a CVSSv3 {
        <CVSSv3 as ::protobuf::Message>::default_instance()
    }
}

impl CVSSv3 {
    pub fn new() -> CVSSv3 {
        ::std::default::Default::default()
    }

    // float base_score = 1;


    pub fn get_base_score(&self) -> f32 {
        self.base_score
    }
    pub fn clear_base_score(&mut self) {
        self.base_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_base_score(&mut self, v: f32) {
        self.base_score = v;
    }

    // float exploitability_score = 2;


    pub fn get_exploitability_score(&self) -> f32 {
        self.exploitability_score
    }
    pub fn clear_exploitability_score(&mut self) {
        self.exploitability_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_exploitability_score(&mut self, v: f32) {
        self.exploitability_score = v;
    }

    // float impact_score = 3;


    pub fn get_impact_score(&self) -> f32 {
        self.impact_score
    }
    pub fn clear_impact_score(&mut self) {
        self.impact_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_impact_score(&mut self, v: f32) {
        self.impact_score = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.AttackVector attack_vector = 5;


    pub fn get_attack_vector(&self) -> CVSSv3_AttackVector {
        self.attack_vector
    }
    pub fn clear_attack_vector(&mut self) {
        self.attack_vector = CVSSv3_AttackVector::ATTACK_VECTOR_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_attack_vector(&mut self, v: CVSSv3_AttackVector) {
        self.attack_vector = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.AttackComplexity attack_complexity = 6;


    pub fn get_attack_complexity(&self) -> CVSSv3_AttackComplexity {
        self.attack_complexity
    }
    pub fn clear_attack_complexity(&mut self) {
        self.attack_complexity = CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_attack_complexity(&mut self, v: CVSSv3_AttackComplexity) {
        self.attack_complexity = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.PrivilegesRequired privileges_required = 7;


    pub fn get_privileges_required(&self) -> CVSSv3_PrivilegesRequired {
        self.privileges_required
    }
    pub fn clear_privileges_required(&mut self) {
        self.privileges_required = CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_privileges_required(&mut self, v: CVSSv3_PrivilegesRequired) {
        self.privileges_required = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.UserInteraction user_interaction = 8;


    pub fn get_user_interaction(&self) -> CVSSv3_UserInteraction {
        self.user_interaction
    }
    pub fn clear_user_interaction(&mut self) {
        self.user_interaction = CVSSv3_UserInteraction::USER_INTERACTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_user_interaction(&mut self, v: CVSSv3_UserInteraction) {
        self.user_interaction = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.Scope scope = 9;


    pub fn get_scope(&self) -> CVSSv3_Scope {
        self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope = CVSSv3_Scope::SCOPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: CVSSv3_Scope) {
        self.scope = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.Impact confidentiality_impact = 10;


    pub fn get_confidentiality_impact(&self) -> CVSSv3_Impact {
        self.confidentiality_impact
    }
    pub fn clear_confidentiality_impact(&mut self) {
        self.confidentiality_impact = CVSSv3_Impact::IMPACT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_confidentiality_impact(&mut self, v: CVSSv3_Impact) {
        self.confidentiality_impact = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.Impact integrity_impact = 11;


    pub fn get_integrity_impact(&self) -> CVSSv3_Impact {
        self.integrity_impact
    }
    pub fn clear_integrity_impact(&mut self) {
        self.integrity_impact = CVSSv3_Impact::IMPACT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_integrity_impact(&mut self, v: CVSSv3_Impact) {
        self.integrity_impact = v;
    }

    // .google.cloud.osconfig.v1alpha.CVSSv3.Impact availability_impact = 12;


    pub fn get_availability_impact(&self) -> CVSSv3_Impact {
        self.availability_impact
    }
    pub fn clear_availability_impact(&mut self) {
        self.availability_impact = CVSSv3_Impact::IMPACT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_availability_impact(&mut self, v: CVSSv3_Impact) {
        self.availability_impact = v;
    }
}

impl ::protobuf::Message for CVSSv3 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.base_score = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.exploitability_score = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.impact_score = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.attack_vector, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.attack_complexity, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.privileges_required, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.user_interaction, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.scope, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.confidentiality_impact, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.integrity_impact, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.availability_impact, 12, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.base_score != 0. {
            my_size += 5;
        }
        if self.exploitability_score != 0. {
            my_size += 5;
        }
        if self.impact_score != 0. {
            my_size += 5;
        }
        if self.attack_vector != CVSSv3_AttackVector::ATTACK_VECTOR_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.attack_vector);
        }
        if self.attack_complexity != CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.attack_complexity);
        }
        if self.privileges_required != CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(7, self.privileges_required);
        }
        if self.user_interaction != CVSSv3_UserInteraction::USER_INTERACTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(8, self.user_interaction);
        }
        if self.scope != CVSSv3_Scope::SCOPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(9, self.scope);
        }
        if self.confidentiality_impact != CVSSv3_Impact::IMPACT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(10, self.confidentiality_impact);
        }
        if self.integrity_impact != CVSSv3_Impact::IMPACT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(11, self.integrity_impact);
        }
        if self.availability_impact != CVSSv3_Impact::IMPACT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(12, self.availability_impact);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.base_score != 0. {
            os.write_float(1, self.base_score)?;
        }
        if self.exploitability_score != 0. {
            os.write_float(2, self.exploitability_score)?;
        }
        if self.impact_score != 0. {
            os.write_float(3, self.impact_score)?;
        }
        if self.attack_vector != CVSSv3_AttackVector::ATTACK_VECTOR_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.attack_vector))?;
        }
        if self.attack_complexity != CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.attack_complexity))?;
        }
        if self.privileges_required != CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_UNSPECIFIED {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.privileges_required))?;
        }
        if self.user_interaction != CVSSv3_UserInteraction::USER_INTERACTION_UNSPECIFIED {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.user_interaction))?;
        }
        if self.scope != CVSSv3_Scope::SCOPE_UNSPECIFIED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.scope))?;
        }
        if self.confidentiality_impact != CVSSv3_Impact::IMPACT_UNSPECIFIED {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.confidentiality_impact))?;
        }
        if self.integrity_impact != CVSSv3_Impact::IMPACT_UNSPECIFIED {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.integrity_impact))?;
        }
        if self.availability_impact != CVSSv3_Impact::IMPACT_UNSPECIFIED {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.availability_impact))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVSSv3 {
        CVSSv3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "base_score",
                |m: &CVSSv3| { &m.base_score },
                |m: &mut CVSSv3| { &mut m.base_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "exploitability_score",
                |m: &CVSSv3| { &m.exploitability_score },
                |m: &mut CVSSv3| { &mut m.exploitability_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "impact_score",
                |m: &CVSSv3| { &m.impact_score },
                |m: &mut CVSSv3| { &mut m.impact_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_AttackVector>>(
                "attack_vector",
                |m: &CVSSv3| { &m.attack_vector },
                |m: &mut CVSSv3| { &mut m.attack_vector },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_AttackComplexity>>(
                "attack_complexity",
                |m: &CVSSv3| { &m.attack_complexity },
                |m: &mut CVSSv3| { &mut m.attack_complexity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_PrivilegesRequired>>(
                "privileges_required",
                |m: &CVSSv3| { &m.privileges_required },
                |m: &mut CVSSv3| { &mut m.privileges_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_UserInteraction>>(
                "user_interaction",
                |m: &CVSSv3| { &m.user_interaction },
                |m: &mut CVSSv3| { &mut m.user_interaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_Scope>>(
                "scope",
                |m: &CVSSv3| { &m.scope },
                |m: &mut CVSSv3| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_Impact>>(
                "confidentiality_impact",
                |m: &CVSSv3| { &m.confidentiality_impact },
                |m: &mut CVSSv3| { &mut m.confidentiality_impact },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_Impact>>(
                "integrity_impact",
                |m: &CVSSv3| { &m.integrity_impact },
                |m: &mut CVSSv3| { &mut m.integrity_impact },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CVSSv3_Impact>>(
                "availability_impact",
                |m: &CVSSv3| { &m.availability_impact },
                |m: &mut CVSSv3| { &mut m.availability_impact },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CVSSv3>(
                "CVSSv3",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVSSv3 {
        static instance: ::protobuf::rt::LazyV2<CVSSv3> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CVSSv3::new)
    }
}

impl ::protobuf::Clear for CVSSv3 {
    fn clear(&mut self) {
        self.base_score = 0.;
        self.exploitability_score = 0.;
        self.impact_score = 0.;
        self.attack_vector = CVSSv3_AttackVector::ATTACK_VECTOR_UNSPECIFIED;
        self.attack_complexity = CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_UNSPECIFIED;
        self.privileges_required = CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_UNSPECIFIED;
        self.user_interaction = CVSSv3_UserInteraction::USER_INTERACTION_UNSPECIFIED;
        self.scope = CVSSv3_Scope::SCOPE_UNSPECIFIED;
        self.confidentiality_impact = CVSSv3_Impact::IMPACT_UNSPECIFIED;
        self.integrity_impact = CVSSv3_Impact::IMPACT_UNSPECIFIED;
        self.availability_impact = CVSSv3_Impact::IMPACT_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVSSv3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVSSv3 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CVSSv3_AttackVector {
    ATTACK_VECTOR_UNSPECIFIED = 0,
    ATTACK_VECTOR_NETWORK = 1,
    ATTACK_VECTOR_ADJACENT = 2,
    ATTACK_VECTOR_LOCAL = 3,
    ATTACK_VECTOR_PHYSICAL = 4,
}

impl ::protobuf::ProtobufEnum for CVSSv3_AttackVector {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CVSSv3_AttackVector> {
        match value {
            0 => ::std::option::Option::Some(CVSSv3_AttackVector::ATTACK_VECTOR_UNSPECIFIED),
            1 => ::std::option::Option::Some(CVSSv3_AttackVector::ATTACK_VECTOR_NETWORK),
            2 => ::std::option::Option::Some(CVSSv3_AttackVector::ATTACK_VECTOR_ADJACENT),
            3 => ::std::option::Option::Some(CVSSv3_AttackVector::ATTACK_VECTOR_LOCAL),
            4 => ::std::option::Option::Some(CVSSv3_AttackVector::ATTACK_VECTOR_PHYSICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CVSSv3_AttackVector] = &[
            CVSSv3_AttackVector::ATTACK_VECTOR_UNSPECIFIED,
            CVSSv3_AttackVector::ATTACK_VECTOR_NETWORK,
            CVSSv3_AttackVector::ATTACK_VECTOR_ADJACENT,
            CVSSv3_AttackVector::ATTACK_VECTOR_LOCAL,
            CVSSv3_AttackVector::ATTACK_VECTOR_PHYSICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CVSSv3_AttackVector>("CVSSv3.AttackVector", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CVSSv3_AttackVector {
}

impl ::std::default::Default for CVSSv3_AttackVector {
    fn default() -> Self {
        CVSSv3_AttackVector::ATTACK_VECTOR_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CVSSv3_AttackVector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CVSSv3_AttackComplexity {
    ATTACK_COMPLEXITY_UNSPECIFIED = 0,
    ATTACK_COMPLEXITY_LOW = 1,
    ATTACK_COMPLEXITY_HIGH = 2,
}

impl ::protobuf::ProtobufEnum for CVSSv3_AttackComplexity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CVSSv3_AttackComplexity> {
        match value {
            0 => ::std::option::Option::Some(CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_UNSPECIFIED),
            1 => ::std::option::Option::Some(CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_LOW),
            2 => ::std::option::Option::Some(CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CVSSv3_AttackComplexity] = &[
            CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_UNSPECIFIED,
            CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_LOW,
            CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_HIGH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CVSSv3_AttackComplexity>("CVSSv3.AttackComplexity", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CVSSv3_AttackComplexity {
}

impl ::std::default::Default for CVSSv3_AttackComplexity {
    fn default() -> Self {
        CVSSv3_AttackComplexity::ATTACK_COMPLEXITY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CVSSv3_AttackComplexity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CVSSv3_PrivilegesRequired {
    PRIVILEGES_REQUIRED_UNSPECIFIED = 0,
    PRIVILEGES_REQUIRED_NONE = 1,
    PRIVILEGES_REQUIRED_LOW = 2,
    PRIVILEGES_REQUIRED_HIGH = 3,
}

impl ::protobuf::ProtobufEnum for CVSSv3_PrivilegesRequired {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CVSSv3_PrivilegesRequired> {
        match value {
            0 => ::std::option::Option::Some(CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_UNSPECIFIED),
            1 => ::std::option::Option::Some(CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_NONE),
            2 => ::std::option::Option::Some(CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_LOW),
            3 => ::std::option::Option::Some(CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CVSSv3_PrivilegesRequired] = &[
            CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_UNSPECIFIED,
            CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_NONE,
            CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_LOW,
            CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_HIGH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CVSSv3_PrivilegesRequired>("CVSSv3.PrivilegesRequired", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CVSSv3_PrivilegesRequired {
}

impl ::std::default::Default for CVSSv3_PrivilegesRequired {
    fn default() -> Self {
        CVSSv3_PrivilegesRequired::PRIVILEGES_REQUIRED_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CVSSv3_PrivilegesRequired {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CVSSv3_UserInteraction {
    USER_INTERACTION_UNSPECIFIED = 0,
    USER_INTERACTION_NONE = 1,
    USER_INTERACTION_REQUIRED = 2,
}

impl ::protobuf::ProtobufEnum for CVSSv3_UserInteraction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CVSSv3_UserInteraction> {
        match value {
            0 => ::std::option::Option::Some(CVSSv3_UserInteraction::USER_INTERACTION_UNSPECIFIED),
            1 => ::std::option::Option::Some(CVSSv3_UserInteraction::USER_INTERACTION_NONE),
            2 => ::std::option::Option::Some(CVSSv3_UserInteraction::USER_INTERACTION_REQUIRED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CVSSv3_UserInteraction] = &[
            CVSSv3_UserInteraction::USER_INTERACTION_UNSPECIFIED,
            CVSSv3_UserInteraction::USER_INTERACTION_NONE,
            CVSSv3_UserInteraction::USER_INTERACTION_REQUIRED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CVSSv3_UserInteraction>("CVSSv3.UserInteraction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CVSSv3_UserInteraction {
}

impl ::std::default::Default for CVSSv3_UserInteraction {
    fn default() -> Self {
        CVSSv3_UserInteraction::USER_INTERACTION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CVSSv3_UserInteraction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CVSSv3_Scope {
    SCOPE_UNSPECIFIED = 0,
    SCOPE_UNCHANGED = 1,
    SCOPE_CHANGED = 2,
}

impl ::protobuf::ProtobufEnum for CVSSv3_Scope {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CVSSv3_Scope> {
        match value {
            0 => ::std::option::Option::Some(CVSSv3_Scope::SCOPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(CVSSv3_Scope::SCOPE_UNCHANGED),
            2 => ::std::option::Option::Some(CVSSv3_Scope::SCOPE_CHANGED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CVSSv3_Scope] = &[
            CVSSv3_Scope::SCOPE_UNSPECIFIED,
            CVSSv3_Scope::SCOPE_UNCHANGED,
            CVSSv3_Scope::SCOPE_CHANGED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CVSSv3_Scope>("CVSSv3.Scope", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CVSSv3_Scope {
}

impl ::std::default::Default for CVSSv3_Scope {
    fn default() -> Self {
        CVSSv3_Scope::SCOPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CVSSv3_Scope {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CVSSv3_Impact {
    IMPACT_UNSPECIFIED = 0,
    IMPACT_HIGH = 1,
    IMPACT_LOW = 2,
    IMPACT_NONE = 3,
}

impl ::protobuf::ProtobufEnum for CVSSv3_Impact {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CVSSv3_Impact> {
        match value {
            0 => ::std::option::Option::Some(CVSSv3_Impact::IMPACT_UNSPECIFIED),
            1 => ::std::option::Option::Some(CVSSv3_Impact::IMPACT_HIGH),
            2 => ::std::option::Option::Some(CVSSv3_Impact::IMPACT_LOW),
            3 => ::std::option::Option::Some(CVSSv3_Impact::IMPACT_NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CVSSv3_Impact] = &[
            CVSSv3_Impact::IMPACT_UNSPECIFIED,
            CVSSv3_Impact::IMPACT_HIGH,
            CVSSv3_Impact::IMPACT_LOW,
            CVSSv3_Impact::IMPACT_NONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CVSSv3_Impact>("CVSSv3.Impact", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CVSSv3_Impact {
}

impl ::std::default::Default for CVSSv3_Impact {
    fn default() -> Self {
        CVSSv3_Impact::IMPACT_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CVSSv3_Impact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1google/cloud/osconfig/v1alpha/vulnerability.proto\x12\x1dgoogle.cloud\
    .osconfig.v1alpha\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/a\
    pi/resource.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xf6\n\n\x13Vu\
    lnerabilityReport\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x03\xe0\
    A\x03\x12o\n\x0fvulnerabilities\x18\x02\x20\x03(\x0b2@.google.cloud.osco\
    nfig.v1alpha.VulnerabilityReport.VulnerabilityR\x0fvulnerabilitiesB\x03\
    \xe0A\x03\x12@\n\x0bupdate_time\x18\x03\x20\x01(\x0b2\x1a.google.protobu\
    f.TimestampR\nupdateTimeB\x03\xe0A\x03\x1a\x8d\x08\n\rVulnerability\x12b\
    \n\x07details\x18\x01\x20\x01(\x0b2H.google.cloud.osconfig.v1alpha.Vulne\
    rabilityReport.Vulnerability.DetailsR\x07details\x12C\n\x1cinstalled_inv\
    entory_item_ids\x18\x02\x20\x03(\tR\x19installedInventoryItemIdsB\x02\
    \x18\x01\x12C\n\x1cavailable_inventory_item_ids\x18\x03\x20\x03(\tR\x19a\
    vailableInventoryItemIdsB\x02\x18\x01\x12;\n\x0bcreate_time\x18\x04\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\x0bupdate_t\
    ime\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nupdateTime\x12\
    [\n\x05items\x18\x06\x20\x03(\x0b2E.google.cloud.osconfig.v1alpha.Vulner\
    abilityReport.Vulnerability.ItemR\x05items\x1a\xe8\x02\n\x07Details\x12\
    \x10\n\x03cve\x18\x01\x20\x01(\tR\x03cve\x12\"\n\rcvss_v2_score\x18\x02\
    \x20\x01(\x02R\x0bcvssV2Score\x12>\n\x07cvss_v3\x18\x03\x20\x01(\x0b2%.g\
    oogle.cloud.osconfig.v1alpha.CVSSv3R\x06cvssV3\x12\x1a\n\x08severity\x18\
    \x04\x20\x01(\tR\x08severity\x12\x20\n\x0bdescription\x18\x05\x20\x01(\t\
    R\x0bdescription\x12r\n\nreferences\x18\x06\x20\x03(\x0b2R.google.cloud.\
    osconfig.v1alpha.VulnerabilityReport.Vulnerability.Details.ReferenceR\nr\
    eferences\x1a5\n\tReference\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\
    \x12\x16\n\x06source\x18\x02\x20\x01(\tR\x06source\x1a\xcb\x01\n\x04Item\
    \x12=\n\x1binstalled_inventory_item_id\x18\x01\x20\x01(\tR\x18installedI\
    nventoryItemId\x12=\n\x1bavailable_inventory_item_id\x18\x02\x20\x01(\tR\
    \x18availableInventoryItemId\x12\"\n\rfixed_cpe_uri\x18\x03\x20\x01(\tR\
    \x0bfixedCpeUri\x12!\n\x0cupstream_fix\x18\x04\x20\x01(\tR\x0bupstreamFi\
    x:\x82\x01\xeaA\x7f\n+osconfig.googleapis.com/VulnerabilityReport\x12Ppr\
    ojects/{project}/locations/{location}/instances/{instance}/vulnerability\
    Report\"h\n\x1dGetVulnerabilityReportRequest\x12G\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB3\xfaA-\n+osconfig.googleapis.com/VulnerabilityReport\
    \xe0A\x02\"\xb6\x01\n\x1fListVulnerabilityReportsRequest\x12?\n\x06paren\
    t\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\n\x1fcompute.googleapis.com/Inst\
    ance\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\x12\x16\n\x06filter\
    \x18\x04\x20\x01(\tR\x06filter\"\xb3\x01\n\x20ListVulnerabilityReportsRe\
    sponse\x12g\n\x15vulnerability_reports\x18\x01\x20\x03(\x0b22.google.clo\
    ud.osconfig.v1alpha.VulnerabilityReportR\x14vulnerabilityReports\x12&\n\
    \x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\x92\x0c\n\x06CV\
    SSv3\x12\x1d\n\nbase_score\x18\x01\x20\x01(\x02R\tbaseScore\x121\n\x14ex\
    ploitability_score\x18\x02\x20\x01(\x02R\x13exploitabilityScore\x12!\n\
    \x0cimpact_score\x18\x03\x20\x01(\x02R\x0bimpactScore\x12W\n\rattack_vec\
    tor\x18\x05\x20\x01(\x0e22.google.cloud.osconfig.v1alpha.CVSSv3.AttackVe\
    ctorR\x0cattackVector\x12c\n\x11attack_complexity\x18\x06\x20\x01(\x0e26\
    .google.cloud.osconfig.v1alpha.CVSSv3.AttackComplexityR\x10attackComplex\
    ity\x12i\n\x13privileges_required\x18\x07\x20\x01(\x0e28.google.cloud.os\
    config.v1alpha.CVSSv3.PrivilegesRequiredR\x12privilegesRequired\x12`\n\
    \x10user_interaction\x18\x08\x20\x01(\x0e25.google.cloud.osconfig.v1alph\
    a.CVSSv3.UserInteractionR\x0fuserInteraction\x12A\n\x05scope\x18\t\x20\
    \x01(\x0e2+.google.cloud.osconfig.v1alpha.CVSSv3.ScopeR\x05scope\x12c\n\
    \x16confidentiality_impact\x18\n\x20\x01(\x0e2,.google.cloud.osconfig.v1\
    alpha.CVSSv3.ImpactR\x15confidentialityImpact\x12W\n\x10integrity_impact\
    \x18\x0b\x20\x01(\x0e2,.google.cloud.osconfig.v1alpha.CVSSv3.ImpactR\x0f\
    integrityImpact\x12]\n\x13availability_impact\x18\x0c\x20\x01(\x0e2,.goo\
    gle.cloud.osconfig.v1alpha.CVSSv3.ImpactR\x12availabilityImpact\"\x99\
    \x01\n\x0cAttackVector\x12\x1d\n\x19ATTACK_VECTOR_UNSPECIFIED\x10\0\x12\
    \x19\n\x15ATTACK_VECTOR_NETWORK\x10\x01\x12\x1a\n\x16ATTACK_VECTOR_ADJAC\
    ENT\x10\x02\x12\x17\n\x13ATTACK_VECTOR_LOCAL\x10\x03\x12\x1a\n\x16ATTACK\
    _VECTOR_PHYSICAL\x10\x04\"l\n\x10AttackComplexity\x12!\n\x1dATTACK_COMPL\
    EXITY_UNSPECIFIED\x10\0\x12\x19\n\x15ATTACK_COMPLEXITY_LOW\x10\x01\x12\
    \x1a\n\x16ATTACK_COMPLEXITY_HIGH\x10\x02\"\x92\x01\n\x12PrivilegesRequir\
    ed\x12#\n\x1fPRIVILEGES_REQUIRED_UNSPECIFIED\x10\0\x12\x1c\n\x18PRIVILEG\
    ES_REQUIRED_NONE\x10\x01\x12\x1b\n\x17PRIVILEGES_REQUIRED_LOW\x10\x02\
    \x12\x1c\n\x18PRIVILEGES_REQUIRED_HIGH\x10\x03\"m\n\x0fUserInteraction\
    \x12\x20\n\x1cUSER_INTERACTION_UNSPECIFIED\x10\0\x12\x19\n\x15USER_INTER\
    ACTION_NONE\x10\x01\x12\x1d\n\x19USER_INTERACTION_REQUIRED\x10\x02\"F\n\
    \x05Scope\x12\x15\n\x11SCOPE_UNSPECIFIED\x10\0\x12\x13\n\x0fSCOPE_UNCHAN\
    GED\x10\x01\x12\x11\n\rSCOPE_CHANGED\x10\x02\"R\n\x06Impact\x12\x16\n\
    \x12IMPACT_UNSPECIFIED\x10\0\x12\x0f\n\x0bIMPACT_HIGH\x10\x01\x12\x0e\n\
    \nIMPACT_LOW\x10\x02\x12\x0f\n\x0bIMPACT_NONE\x10\x03B\xdb\x01\n!com.goo\
    gle.cloud.osconfig.v1alphaB\x12VulnerabilityProtoP\x01Z=cloud.google.com\
    /go/osconfig/apiv1alpha/osconfigpb;osconfigpb\xaa\x02\x1dGoogle.Cloud.Os\
    Config.V1Alpha\xca\x02\x1dGoogle\\Cloud\\OsConfig\\V1alpha\xea\x02\x20Go\
    ogle::Cloud::OsConfig::V1alphaJ\xf2p\n\x07\x12\x05\x0e\0\xec\x02\x01\n\
    \xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202021\x20Go\
    ogle\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ver\
    sion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20th\
    is\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0&\n\t\n\x02\x03\0\
    \x12\x03\x12\0)\n\t\n\x02\x03\x01\x12\x03\x13\0#\n\t\n\x02\x03\x02\x12\
    \x03\x14\0)\n\x08\n\x01\x08\x12\x03\x16\0:\n\t\n\x02\x08%\x12\x03\x16\0:\
    \n\x08\n\x01\x08\x12\x03\x17\0T\n\t\n\x02\x08\x0b\x12\x03\x17\0T\n\x08\n\
    \x01\x08\x12\x03\x18\0\"\n\t\n\x02\x08\n\x12\x03\x18\0\"\n\x08\n\x01\x08\
    \x12\x03\x19\03\n\t\n\x02\x08\x08\x12\x03\x19\03\n\x08\n\x01\x08\x12\x03\
    \x1a\0:\n\t\n\x02\x08\x01\x12\x03\x1a\0:\n\x08\n\x01\x08\x12\x03\x1b\0:\
    \n\t\n\x02\x08)\x12\x03\x1b\0:\n\x08\n\x01\x08\x12\x03\x1c\09\n\t\n\x02\
    \x08-\x12\x03\x1c\09\n\xb2\x02\n\x02\x04\0\x12\x05#\0\x90\x01\x01\x1a\
    \xa4\x02\x20This\x20API\x20resource\x20represents\x20the\x20vulnerabilit\
    y\x20report\x20for\x20a\x20specified\n\x20Compute\x20Engine\x20virtual\
    \x20machine\x20(VM)\x20instance\x20at\x20a\x20given\x20point\x20in\x20ti\
    me.\n\n\x20For\x20more\x20information,\x20see\x20[Vulnerability\n\x20rep\
    orts](https://cloud.google.com/compute/docs/instances/os-inventory-manag\
    ement#vulnerability-reports).\n\n\n\n\x03\x04\0\x01\x12\x03#\x08\x1b\n\
    \x0b\n\x03\x04\0\x07\x12\x04$\x02'\x04\n\r\n\x05\x04\0\x07\x9d\x08\x12\
    \x04$\x02'\x04\n;\n\x04\x04\0\x03\0\x12\x05*\x02\x82\x01\x03\x1a,\x20A\
    \x20vulnerability\x20affecting\x20the\x20VM\x20instance.\n\n\x0c\n\x05\
    \x04\0\x03\0\x01\x12\x03*\n\x17\n\x96\x01\n\x06\x04\0\x03\0\x03\0\x12\
    \x04-\x04K\x05\x1a\x85\x01\x20Contains\x20metadata\x20information\x20for\
    \x20the\x20vulnerability.\x20This\x20information\x20is\n\x20collected\
    \x20from\x20the\x20upstream\x20feed\x20of\x20the\x20operating\x20system.\
    \n\n\x0e\n\x07\x04\0\x03\0\x03\0\x01\x12\x03-\x0c\x13\n7\n\x08\x04\0\x03\
    \0\x03\0\x03\0\x12\x04/\x065\x07\x1a%\x20A\x20reference\x20for\x20this\
    \x20vulnerability.\n\n\x10\n\t\x04\0\x03\0\x03\0\x03\0\x01\x12\x03/\x0e\
    \x17\n.\n\n\x04\0\x03\0\x03\0\x03\0\x02\0\x12\x031\x08\x17\x1a\x1b\x20Th\
    e\x20url\x20of\x20the\x20reference.\n\n\x12\n\x0b\x04\0\x03\0\x03\0\x03\
    \0\x02\0\x05\x12\x031\x08\x0e\n\x12\n\x0b\x04\0\x03\0\x03\0\x03\0\x02\0\
    \x01\x12\x031\x0f\x12\n\x12\n\x0b\x04\0\x03\0\x03\0\x03\0\x02\0\x03\x12\
    \x031\x15\x16\n:\n\n\x04\0\x03\0\x03\0\x03\0\x02\x01\x12\x034\x08\x1a\
    \x1a'\x20The\x20source\x20of\x20the\x20reference\x20e.g.\x20NVD.\n\n\x12\
    \n\x0b\x04\0\x03\0\x03\0\x03\0\x02\x01\x05\x12\x034\x08\x0e\n\x12\n\x0b\
    \x04\0\x03\0\x03\0\x03\0\x02\x01\x01\x12\x034\x0f\x15\n\x12\n\x0b\x04\0\
    \x03\0\x03\0\x03\0\x02\x01\x03\x12\x034\x18\x19\n\xa6\x01\n\x08\x04\0\
    \x03\0\x03\0\x02\0\x12\x03:\x06\x15\x1a\x94\x01\x20The\x20CVE\x20of\x20t\
    he\x20vulnerability.\x20CVE\x20cannot\x20be\n\x20empty\x20and\x20the\x20\
    combination\x20of\x20<cve,\x20classification>\x20should\x20be\x20unique\
    \n\x20across\x20vulnerabilities\x20for\x20a\x20VM.\n\n\x10\n\t\x04\0\x03\
    \0\x03\0\x02\0\x05\x12\x03:\x06\x0c\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\
    \x01\x12\x03:\r\x10\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\x03\x12\x03:\x13\
    \x14\n\xa2\x01\n\x08\x04\0\x03\0\x03\0\x02\x01\x12\x03>\x06\x1e\x1a\x90\
    \x01\x20The\x20CVSS\x20V2\x20score\x20of\x20this\x20vulnerability.\x20CV\
    SS\x20V2\x20score\x20is\x20on\x20a\x20scale\x20of\n\x200\x20-\x2010\x20w\
    here\x200\x20indicates\x20low\x20severity\x20and\x2010\x20indicates\x20h\
    igh\x20severity.\n\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x05\x12\x03>\x06\
    \x0b\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x01\x12\x03>\x0c\x19\n\x10\n\t\
    \x04\0\x03\0\x03\0\x02\x01\x03\x12\x03>\x1c\x1d\nV\n\x08\x04\0\x03\0\x03\
    \0\x02\x02\x12\x03A\x06\x19\x1aE\x20The\x20full\x20description\x20of\x20\
    the\x20CVSSv3\x20for\x20this\x20vulnerability\x20from\x20NVD.\n\n\x10\n\
    \t\x04\0\x03\0\x03\0\x02\x02\x06\x12\x03A\x06\x0c\n\x10\n\t\x04\0\x03\0\
    \x03\0\x02\x02\x01\x12\x03A\r\x14\n\x10\n\t\x04\0\x03\0\x03\0\x02\x02\
    \x03\x12\x03A\x17\x18\nD\n\x08\x04\0\x03\0\x03\0\x02\x03\x12\x03D\x06\
    \x1a\x1a3\x20Assigned\x20severity/impact\x20ranking\x20from\x20the\x20di\
    stro.\n\n\x10\n\t\x04\0\x03\0\x03\0\x02\x03\x05\x12\x03D\x06\x0c\n\x10\n\
    \t\x04\0\x03\0\x03\0\x02\x03\x01\x12\x03D\r\x15\n\x10\n\t\x04\0\x03\0\
    \x03\0\x02\x03\x03\x12\x03D\x18\x19\nX\n\x08\x04\0\x03\0\x03\0\x02\x04\
    \x12\x03G\x06\x1d\x1aG\x20The\x20note\x20or\x20description\x20describing\
    \x20the\x20vulnerability\x20from\x20the\x20distro.\n\n\x10\n\t\x04\0\x03\
    \0\x03\0\x02\x04\x05\x12\x03G\x06\x0c\n\x10\n\t\x04\0\x03\0\x03\0\x02\
    \x04\x01\x12\x03G\r\x18\n\x10\n\t\x04\0\x03\0\x03\0\x02\x04\x03\x12\x03G\
    \x1b\x1c\nX\n\x08\x04\0\x03\0\x03\0\x02\x05\x12\x03J\x06(\x1aG\x20Corres\
    ponds\x20to\x20the\x20references\x20attached\x20to\x20the\x20`Vulnerabil\
    ityDetails`.\n\n\x10\n\t\x04\0\x03\0\x03\0\x02\x05\x04\x12\x03J\x06\x0e\
    \n\x10\n\t\x04\0\x03\0\x03\0\x02\x05\x06\x12\x03J\x0f\x18\n\x10\n\t\x04\
    \0\x03\0\x03\0\x02\x05\x01\x12\x03J\x19#\n\x10\n\t\x04\0\x03\0\x03\0\x02\
    \x05\x03\x12\x03J&'\nq\n\x06\x04\0\x03\0\x03\x01\x12\x04O\x04e\x05\x1aa\
    \x20OS\x20inventory\x20item\x20that\x20is\x20affected\x20by\x20a\x20vuln\
    erability\x20or\x20fixed\x20as\x20a\n\x20result\x20of\x20a\x20vulnerabil\
    ity.\n\n\x0e\n\x07\x04\0\x03\0\x03\x01\x01\x12\x03O\x0c\x10\n\xd2\x02\n\
    \x08\x04\0\x03\0\x03\x01\x02\0\x12\x03U\x06-\x1a\xc0\x02\x20Corresponds\
    \x20to\x20the\x20`INSTALLED_PACKAGE`\x20inventory\x20item\x20on\x20the\
    \x20VM.\n\x20This\x20field\x20displays\x20the\x20inventory\x20items\x20a\
    ffected\x20by\x20this\x20vulnerability.\n\x20If\x20the\x20vulnerability\
    \x20report\x20was\x20not\x20updated\x20after\x20the\x20VM\x20inventory\n\
    \x20update,\x20these\x20values\x20might\x20not\x20display\x20in\x20VM\
    \x20inventory.\x20For\x20some\n\x20operating\x20systems,\x20this\x20fiel\
    d\x20might\x20be\x20empty.\n\n\x10\n\t\x04\0\x03\0\x03\x01\x02\0\x05\x12\
    \x03U\x06\x0c\n\x10\n\t\x04\0\x03\0\x03\x01\x02\0\x01\x12\x03U\r(\n\x10\
    \n\t\x04\0\x03\0\x03\x01\x02\0\x03\x12\x03U+,\n\xfa\x02\n\x08\x04\0\x03\
    \0\x03\x01\x02\x01\x12\x03]\x06-\x1a\xe8\x02\x20Corresponds\x20to\x20the\
    \x20`AVAILABLE_PACKAGE`\x20inventory\x20item\x20on\x20the\x20VM.\n\x20If\
    \x20the\x20vulnerability\x20report\x20was\x20not\x20updated\x20after\x20\
    the\x20VM\x20inventory\n\x20update,\x20these\x20values\x20might\x20not\
    \x20display\x20in\x20VM\x20inventory.\x20If\x20there\x20is\x20no\n\x20av\
    ailable\x20fix,\x20the\x20field\x20is\x20empty.\x20The\x20`inventory_ite\
    m`\x20value\x20specifies\n\x20the\x20latest\x20`SoftwarePackage`\x20avai\
    lable\x20to\x20the\x20VM\x20that\x20fixes\x20the\n\x20vulnerability.\n\n\
    \x10\n\t\x04\0\x03\0\x03\x01\x02\x01\x05\x12\x03]\x06\x0c\n\x10\n\t\x04\
    \0\x03\0\x03\x01\x02\x01\x01\x12\x03]\r(\n\x10\n\t\x04\0\x03\0\x03\x01\
    \x02\x01\x03\x12\x03]+,\n\x86\x01\n\x08\x04\0\x03\0\x03\x01\x02\x02\x12\
    \x03a\x06\x1f\x1au\x20The\x20recommended\x20[CPE\x20URI](https://cpe.mit\
    re.org/specification/)\x20update\n\x20that\x20contains\x20a\x20fix\x20fo\
    r\x20this\x20vulnerability.\n\n\x10\n\t\x04\0\x03\0\x03\x01\x02\x02\x05\
    \x12\x03a\x06\x0c\n\x10\n\t\x04\0\x03\0\x03\x01\x02\x02\x01\x12\x03a\r\
    \x1a\n\x10\n\t\x04\0\x03\0\x03\x01\x02\x02\x03\x12\x03a\x1d\x1e\nV\n\x08\
    \x04\0\x03\0\x03\x01\x02\x03\x12\x03d\x06\x1e\x1aE\x20The\x20upstream\
    \x20OS\x20patch,\x20packages\x20or\x20KB\x20that\x20fixes\x20the\x20vuln\
    erability.\n\n\x10\n\t\x04\0\x03\0\x03\x01\x02\x03\x05\x12\x03d\x06\x0c\
    \n\x10\n\t\x04\0\x03\0\x03\x01\x02\x03\x01\x12\x03d\r\x19\n\x10\n\t\x04\
    \0\x03\0\x03\x01\x02\x03\x03\x12\x03d\x1c\x1d\n]\n\x06\x04\0\x03\0\x02\0\
    \x12\x03i\x04\x18\x1aN\x20Contains\x20metadata\x20as\x20per\x20the\x20up\
    stream\x20feed\x20of\x20the\x20operating\x20system\x20and\n\x20NVD.\n\n\
    \x0e\n\x07\x04\0\x03\0\x02\0\x06\x12\x03i\x04\x0b\n\x0e\n\x07\x04\0\x03\
    \0\x02\0\x01\x12\x03i\x0c\x13\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03i\
    \x16\x17\n\xc4\x02\n\x06\x04\0\x03\0\x02\x01\x12\x03p\x04I\x1a\xb4\x02\
    \x20Corresponds\x20to\x20the\x20`INSTALLED_PACKAGE`\x20inventory\x20item\
    \x20on\x20the\x20VM.\n\x20This\x20field\x20displays\x20the\x20inventory\
    \x20items\x20affected\x20by\x20this\x20vulnerability.\n\x20If\x20the\x20\
    vulnerability\x20report\x20was\x20not\x20updated\x20after\x20the\x20VM\
    \x20inventory\n\x20update,\x20these\x20values\x20might\x20not\x20display\
    \x20in\x20VM\x20inventory.\x20For\x20some\x20distros,\n\x20this\x20field\
    \x20may\x20be\x20empty.\n\n\x0e\n\x07\x04\0\x03\0\x02\x01\x04\x12\x03p\
    \x04\x0c\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03p\r\x13\n\x0e\n\x07\
    \x04\0\x03\0\x02\x01\x01\x12\x03p\x140\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x03\x12\x03p34\n\x0e\n\x07\x04\0\x03\0\x02\x01\x08\x12\x03p5H\n\x0f\n\
    \x08\x04\0\x03\0\x02\x01\x08\x03\x12\x03p6G\n\xf8\x02\n\x06\x04\0\x03\0\
    \x02\x02\x12\x03x\x04I\x1a\xe8\x02\x20Corresponds\x20to\x20the\x20`AVAIL\
    ABLE_PACKAGE`\x20inventory\x20item\x20on\x20the\x20VM.\n\x20If\x20the\
    \x20vulnerability\x20report\x20was\x20not\x20updated\x20after\x20the\x20\
    VM\x20inventory\n\x20update,\x20these\x20values\x20might\x20not\x20displ\
    ay\x20in\x20VM\x20inventory.\x20If\x20there\x20is\x20no\n\x20available\
    \x20fix,\x20the\x20field\x20is\x20empty.\x20The\x20`inventory_item`\x20v\
    alue\x20specifies\n\x20the\x20latest\x20`SoftwarePackage`\x20available\
    \x20to\x20the\x20VM\x20that\x20fixes\x20the\n\x20vulnerability.\n\n\x0e\
    \n\x07\x04\0\x03\0\x02\x02\x04\x12\x03x\x04\x0c\n\x0e\n\x07\x04\0\x03\0\
    \x02\x02\x05\x12\x03x\r\x13\n\x0e\n\x07\x04\0\x03\0\x02\x02\x01\x12\x03x\
    \x140\n\x0e\n\x07\x04\0\x03\0\x02\x02\x03\x12\x03x34\n\x0e\n\x07\x04\0\
    \x03\0\x02\x02\x08\x12\x03x5H\n\x0f\n\x08\x04\0\x03\0\x02\x02\x08\x03\
    \x12\x03x6G\nM\n\x06\x04\0\x03\0\x02\x03\x12\x03{\x04.\x1a>\x20The\x20ti\
    mestamp\x20for\x20when\x20the\x20vulnerability\x20was\x20first\x20detect\
    ed.\n\n\x0e\n\x07\x04\0\x03\0\x02\x03\x06\x12\x03{\x04\x1d\n\x0e\n\x07\
    \x04\0\x03\0\x02\x03\x01\x12\x03{\x1e)\n\x0e\n\x07\x04\0\x03\0\x02\x03\
    \x03\x12\x03{,-\nL\n\x06\x04\0\x03\0\x02\x04\x12\x03~\x04.\x1a=\x20The\
    \x20timestamp\x20for\x20when\x20the\x20vulnerability\x20was\x20last\x20m\
    odified.\n\n\x0e\n\x07\x04\0\x03\0\x02\x04\x06\x12\x03~\x04\x1d\n\x0e\n\
    \x07\x04\0\x03\0\x02\x04\x01\x12\x03~\x1e)\n\x0e\n\x07\x04\0\x03\0\x02\
    \x04\x03\x12\x03~,-\n>\n\x06\x04\0\x03\0\x02\x05\x12\x04\x81\x01\x04\x1c\
    \x1a.\x20List\x20of\x20items\x20affected\x20by\x20the\x20vulnerability.\
    \n\n\x0f\n\x07\x04\0\x03\0\x02\x05\x04\x12\x04\x81\x01\x04\x0c\n\x0f\n\
    \x07\x04\0\x03\0\x02\x05\x06\x12\x04\x81\x01\r\x11\n\x0f\n\x07\x04\0\x03\
    \0\x02\x05\x01\x12\x04\x81\x01\x12\x17\n\x0f\n\x07\x04\0\x03\0\x02\x05\
    \x03\x12\x04\x81\x01\x1a\x1b\n\xb2\x01\n\x04\x04\0\x02\0\x12\x04\x88\x01\
    \x02>\x1a\xa3\x01\x20Output\x20only.\x20The\x20`vulnerabilityReport`\x20\
    API\x20resource\x20name.\n\n\x20Format:\n\x20`projects/{project_number}/\
    locations/{location}/instances/{instance_id}/vulnerabilityReport`\n\n\r\
    \n\x05\x04\0\x02\0\x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\0\x02\0\x01\
    \x12\x04\x88\x01\t\r\n\r\n\x05\x04\0\x02\0\x03\x12\x04\x88\x01\x10\x11\n\
    \r\n\x05\x04\0\x02\0\x08\x12\x04\x88\x01\x12=\n\x10\n\x08\x04\0\x02\0\
    \x08\x9c\x08\0\x12\x04\x88\x01\x13<\nF\n\x04\x04\0\x02\x01\x12\x04\x8b\
    \x01\x02Y\x1a8\x20Output\x20only.\x20List\x20of\x20vulnerabilities\x20af\
    fecting\x20the\x20VM.\n\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x8b\x01\x02\
    \n\n\r\n\x05\x04\0\x02\x01\x06\x12\x04\x8b\x01\x0b\x18\n\r\n\x05\x04\0\
    \x02\x01\x01\x12\x04\x8b\x01\x19(\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\
    \x8b\x01+,\n\r\n\x05\x04\0\x02\x01\x08\x12\x04\x8b\x01-X\n\x10\n\x08\x04\
    \0\x02\x01\x08\x9c\x08\0\x12\x04\x8b\x01.W\nl\n\x04\x04\0\x02\x02\x12\
    \x04\x8f\x01\x02X\x1a^\x20Output\x20only.\x20The\x20timestamp\x20for\x20\
    when\x20the\x20last\x20vulnerability\x20report\x20was\x20generated\x20fo\
    r\x20the\n\x20VM.\n\n\r\n\x05\x04\0\x02\x02\x06\x12\x04\x8f\x01\x02\x1b\
    \n\r\n\x05\x04\0\x02\x02\x01\x12\x04\x8f\x01\x1c'\n\r\n\x05\x04\0\x02\
    \x02\x03\x12\x04\x8f\x01*+\n\r\n\x05\x04\0\x02\x02\x08\x12\x04\x8f\x01,W\
    \n\x10\n\x08\x04\0\x02\x02\x08\x9c\x08\0\x12\x04\x8f\x01-V\n\\\n\x02\x04\
    \x01\x12\x06\x93\x01\0\xa2\x01\x01\x1aN\x20A\x20request\x20message\x20fo\
    r\x20getting\x20the\x20vulnerability\x20report\x20for\x20the\x20specifie\
    d\x20VM.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x93\x01\x08%\n\xd0\x02\n\x04\
    \x04\x01\x02\0\x12\x06\x9c\x01\x02\xa1\x01\x04\x1a\xbf\x02\x20Required.\
    \x20API\x20resource\x20name\x20for\x20vulnerability\x20resource.\n\n\x20\
    Format:\n\x20`projects/{project}/locations/{location}/instances/{instanc\
    e}/vulnerabilityReport`\n\n\x20For\x20`{project}`,\x20either\x20`project\
    -number`\x20or\x20`project-id`\x20can\x20be\x20provided.\n\x20For\x20`{i\
    nstance}`,\x20either\x20Compute\x20Engine\x20`instance-id`\x20or\x20`ins\
    tance-name`\n\x20can\x20be\x20provided.\n\n\r\n\x05\x04\x01\x02\0\x05\
    \x12\x04\x9c\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x9c\x01\t\r\
    \n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x9c\x01\x10\x11\n\x0f\n\x05\x04\x01\
    \x02\0\x08\x12\x06\x9c\x01\x12\xa1\x01\x03\n\x10\n\x08\x04\x01\x02\0\x08\
    \x9c\x08\0\x12\x04\x9d\x01\x04*\n\x11\n\x07\x04\x01\x02\0\x08\x9f\x08\
    \x12\x06\x9e\x01\x04\xa0\x01\x05\nt\n\x02\x04\x02\x12\x06\xa6\x01\0\xbe\
    \x01\x01\x1af\x20A\x20request\x20message\x20for\x20listing\x20vulnerabil\
    ity\x20reports\x20for\x20all\x20VM\x20instances\x20in\n\x20the\x20specif\
    ied\x20location.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xa6\x01\x08'\n\xc2\
    \x01\n\x04\x04\x02\x02\0\x12\x06\xac\x01\x02\xb1\x01\x04\x1a\xb1\x01\x20\
    Required.\x20The\x20parent\x20resource\x20name.\n\n\x20Format:\x20`proje\
    cts/{project}/locations/{location}/instances/-`\n\n\x20For\x20`{project}\
    `,\x20either\x20`project-number`\x20or\x20`project-id`\x20can\x20be\x20p\
    rovided.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xac\x01\x02\x08\n\r\n\x05\
    \x04\x02\x02\0\x01\x12\x04\xac\x01\t\x0f\n\r\n\x05\x04\x02\x02\0\x03\x12\
    \x04\xac\x01\x12\x13\n\x0f\n\x05\x04\x02\x02\0\x08\x12\x06\xac\x01\x14\
    \xb1\x01\x03\n\x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\xad\x01\x04\
    *\n\x11\n\x07\x04\x02\x02\0\x08\x9f\x08\x12\x06\xae\x01\x04\xb0\x01\x05\
    \n8\n\x04\x04\x02\x02\x01\x12\x04\xb4\x01\x02\x16\x1a*\x20The\x20maximum\
    \x20number\x20of\x20results\x20to\x20return.\n\n\r\n\x05\x04\x02\x02\x01\
    \x05\x12\x04\xb4\x01\x02\x07\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xb4\
    \x01\x08\x11\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xb4\x01\x14\x15\n\x99\
    \x01\n\x04\x04\x02\x02\x02\x12\x04\xb9\x01\x02\x18\x1a\x8a\x01\x20A\x20p\
    agination\x20token\x20returned\x20from\x20a\x20previous\x20call\x20to\n\
    \x20`ListVulnerabilityReports`\x20that\x20indicates\x20where\x20this\x20\
    listing\n\x20should\x20continue\x20from.\n\n\r\n\x05\x04\x02\x02\x02\x05\
    \x12\x04\xb9\x01\x02\x08\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb9\x01\t\
    \x13\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xb9\x01\x16\x17\n\x99\x01\n\
    \x04\x04\x02\x02\x03\x12\x04\xbd\x01\x02\x14\x1a\x8a\x01\x20If\x20provid\
    ed,\x20this\x20field\x20specifies\x20the\x20criteria\x20that\x20must\x20\
    be\x20met\x20by\x20a\n\x20`vulnerabilityReport`\x20API\x20resource\x20to\
    \x20be\x20included\x20in\x20the\x20response.\n\n\r\n\x05\x04\x02\x02\x03\
    \x05\x12\x04\xbd\x01\x02\x08\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xbd\
    \x01\t\x0f\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xbd\x01\x12\x13\nu\n\
    \x02\x04\x03\x12\x06\xc2\x01\0\xc9\x01\x01\x1ag\x20A\x20response\x20mess\
    age\x20for\x20listing\x20vulnerability\x20reports\x20for\x20all\x20VM\
    \x20instances\x20in\n\x20the\x20specified\x20location.\n\n\x0b\n\x03\x04\
    \x03\x01\x12\x04\xc2\x01\x08(\n4\n\x04\x04\x03\x02\0\x12\x04\xc4\x01\x02\
    9\x1a&\x20List\x20of\x20vulnerabilityReport\x20objects.\n\n\r\n\x05\x04\
    \x03\x02\0\x04\x12\x04\xc4\x01\x02\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\
    \xc4\x01\x0b\x1e\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xc4\x01\x1f4\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\xc4\x0178\n_\n\x04\x04\x03\x02\x01\x12\
    \x04\xc8\x01\x02\x1d\x1aQ\x20The\x20pagination\x20token\x20to\x20retriev\
    e\x20the\x20next\x20page\x20of\x20vulnerabilityReports\n\x20object.\n\n\
    \r\n\x05\x04\x03\x02\x01\x05\x12\x04\xc8\x01\x02\x08\n\r\n\x05\x04\x03\
    \x02\x01\x01\x12\x04\xc8\x01\t\x18\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\
    \xc8\x01\x1b\x1c\n\x82\x01\n\x02\x04\x04\x12\x06\xcd\x01\0\xec\x02\x01\
    \x1at\x20Common\x20Vulnerability\x20Scoring\x20System\x20version\x203.\n\
    \x20For\x20details,\x20see\x20https://www.first.org/cvss/specification-d\
    ocument\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xcd\x01\x08\x0e\nd\n\x04\x04\
    \x04\x04\0\x12\x06\xd0\x01\x02\xe4\x01\x03\x1aT\x20This\x20metric\x20ref\
    lects\x20the\x20context\x20by\x20which\x20vulnerability\x20exploitation\
    \x20is\n\x20possible.\n\n\r\n\x05\x04\x04\x04\0\x01\x12\x04\xd0\x01\x07\
    \x13\n\x20\n\x06\x04\x04\x04\0\x02\0\x12\x04\xd2\x01\x04\"\x1a\x10\x20In\
    valid\x20value.\n\n\x0f\n\x07\x04\x04\x04\0\x02\0\x01\x12\x04\xd2\x01\
    \x04\x1d\n\x0f\n\x07\x04\x04\x04\0\x02\0\x02\x12\x04\xd2\x01\x20!\n\xc5\
    \x01\n\x06\x04\x04\x04\0\x02\x01\x12\x04\xd7\x01\x04\x1e\x1a\xb4\x01\x20\
    The\x20vulnerable\x20component\x20is\x20bound\x20to\x20the\x20network\
    \x20stack\x20and\x20the\x20set\x20of\n\x20possible\x20attackers\x20exten\
    ds\x20beyond\x20the\x20other\x20options\x20listed\x20below,\x20up\x20to\
    \n\x20and\x20including\x20the\x20entire\x20Internet.\n\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x01\x01\x12\x04\xd7\x01\x04\x19\n\x0f\n\x07\x04\x04\x04\0\
    \x02\x01\x02\x12\x04\xd7\x01\x1c\x1d\n\x9d\x01\n\x06\x04\x04\x04\0\x02\
    \x02\x12\x04\xdb\x01\x04\x1f\x1a\x8c\x01\x20The\x20vulnerable\x20compone\
    nt\x20is\x20bound\x20to\x20the\x20network\x20stack,\x20but\x20the\x20att\
    ack\x20is\n\x20limited\x20at\x20the\x20protocol\x20level\x20to\x20a\x20l\
    ogically\x20adjacent\x20topology.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x02\
    \x01\x12\x04\xdb\x01\x04\x1a\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x02\x12\
    \x04\xdb\x01\x1d\x1e\n\x8d\x01\n\x06\x04\x04\x04\0\x02\x03\x12\x04\xdf\
    \x01\x04\x1c\x1a}\x20The\x20vulnerable\x20component\x20is\x20not\x20boun\
    d\x20to\x20the\x20network\x20stack\x20and\x20the\n\x20attacker's\x20path\
    \x20is\x20via\x20read/write/execute\x20capabilities.\n\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x03\x01\x12\x04\xdf\x01\x04\x17\n\x0f\n\x07\x04\x04\x04\0\
    \x02\x03\x02\x12\x04\xdf\x01\x1a\x1b\no\n\x06\x04\x04\x04\0\x02\x04\x12\
    \x04\xe3\x01\x04\x1f\x1a_\x20The\x20attack\x20requires\x20the\x20attacke\
    r\x20to\x20physically\x20touch\x20or\x20manipulate\x20the\n\x20vulnerabl\
    e\x20component.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x01\x12\x04\xe3\x01\
    \x04\x1a\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x02\x12\x04\xe3\x01\x1d\x1e\n\
    \x8c\x01\n\x04\x04\x04\x04\x01\x12\x06\xe8\x01\x02\xf7\x01\x03\x1a|\x20T\
    his\x20metric\x20describes\x20the\x20conditions\x20beyond\x20the\x20atta\
    cker's\x20control\x20that\n\x20must\x20exist\x20in\x20order\x20to\x20exp\
    loit\x20the\x20vulnerability.\n\n\r\n\x05\x04\x04\x04\x01\x01\x12\x04\
    \xe8\x01\x07\x17\n\x20\n\x06\x04\x04\x04\x01\x02\0\x12\x04\xea\x01\x04&\
    \x1a\x10\x20Invalid\x20value.\n\n\x0f\n\x07\x04\x04\x04\x01\x02\0\x01\
    \x12\x04\xea\x01\x04!\n\x0f\n\x07\x04\x04\x04\x01\x02\0\x02\x12\x04\xea\
    \x01$%\n\xb0\x01\n\x06\x04\x04\x04\x01\x02\x01\x12\x04\xef\x01\x04\x1e\
    \x1a\x9f\x01\x20Specialized\x20access\x20conditions\x20or\x20extenuating\
    \x20circumstances\x20do\x20not\x20exist.\n\x20An\x20attacker\x20can\x20e\
    xpect\x20repeatable\x20success\x20when\x20attacking\x20the\x20vulnerable\
    \n\x20component.\n\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\x01\x12\x04\xef\
    \x01\x04\x19\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\x02\x12\x04\xef\x01\x1c\
    \x1d\n\xcd\x02\n\x06\x04\x04\x04\x01\x02\x02\x12\x04\xf6\x01\x04\x1f\x1a\
    \xbc\x02\x20A\x20successful\x20attack\x20depends\x20on\x20conditions\x20\
    beyond\x20the\x20attacker's\x20control.\n\x20That\x20is,\x20a\x20success\
    ful\x20attack\x20cannot\x20be\x20accomplished\x20at\x20will,\x20but\x20r\
    equires\n\x20the\x20attacker\x20to\x20invest\x20in\x20some\x20measurable\
    \x20amount\x20of\x20effort\x20in\x20preparation\n\x20or\x20execution\x20\
    against\x20the\x20vulnerable\x20component\x20before\x20a\x20successful\
    \x20attack\n\x20can\x20be\x20expected.\n\n\x0f\n\x07\x04\x04\x04\x01\x02\
    \x02\x01\x12\x04\xf6\x01\x04\x1a\n\x0f\n\x07\x04\x04\x04\x01\x02\x02\x02\
    \x12\x04\xf6\x01\x1d\x1e\n\x8b\x01\n\x04\x04\x04\x04\x02\x12\x06\xfb\x01\
    \x02\x8e\x02\x03\x1a{\x20This\x20metric\x20describes\x20the\x20level\x20\
    of\x20privileges\x20an\x20attacker\x20must\x20possess\n\x20before\x20suc\
    cessfully\x20exploiting\x20the\x20vulnerability.\n\n\r\n\x05\x04\x04\x04\
    \x02\x01\x12\x04\xfb\x01\x07\x19\n\x20\n\x06\x04\x04\x04\x02\x02\0\x12\
    \x04\xfd\x01\x04(\x1a\x10\x20Invalid\x20value.\n\n\x0f\n\x07\x04\x04\x04\
    \x02\x02\0\x01\x12\x04\xfd\x01\x04#\n\x0f\n\x07\x04\x04\x04\x02\x02\0\
    \x02\x12\x04\xfd\x01&'\n\xb2\x01\n\x06\x04\x04\x04\x02\x02\x01\x12\x04\
    \x82\x02\x04!\x1a\xa1\x01\x20The\x20attacker\x20is\x20unauthorized\x20pr\
    ior\x20to\x20attack,\x20and\x20therefore\x20does\x20not\n\x20require\x20\
    any\x20access\x20to\x20settings\x20or\x20files\x20of\x20the\x20vulnerabl\
    e\x20system\x20to\n\x20carry\x20out\x20an\x20attack.\n\n\x0f\n\x07\x04\
    \x04\x04\x02\x02\x01\x01\x12\x04\x82\x02\x04\x1c\n\x0f\n\x07\x04\x04\x04\
    \x02\x02\x01\x02\x12\x04\x82\x02\x1f\x20\n\x86\x02\n\x06\x04\x04\x04\x02\
    \x02\x02\x12\x04\x88\x02\x04\x20\x1a\xf5\x01\x20The\x20attacker\x20requi\
    res\x20privileges\x20that\x20provide\x20basic\x20user\x20capabilities\n\
    \x20that\x20could\x20normally\x20affect\x20only\x20settings\x20and\x20fi\
    les\x20owned\x20by\x20a\x20user.\n\x20Alternatively,\x20an\x20attacker\
    \x20with\x20Low\x20privileges\x20has\x20the\x20ability\x20to\x20access\n\
    \x20only\x20non-sensitive\x20resources.\n\n\x0f\n\x07\x04\x04\x04\x02\
    \x02\x02\x01\x12\x04\x88\x02\x04\x1b\n\x0f\n\x07\x04\x04\x04\x02\x02\x02\
    \x02\x12\x04\x88\x02\x1e\x1f\n\xc1\x01\n\x06\x04\x04\x04\x02\x02\x03\x12\
    \x04\x8d\x02\x04!\x1a\xb0\x01\x20The\x20attacker\x20requires\x20privileg\
    es\x20that\x20provide\x20significant\x20(e.g.,\n\x20administrative)\x20c\
    ontrol\x20over\x20the\x20vulnerable\x20component\x20allowing\x20access\
    \x20to\n\x20component-wide\x20settings\x20and\x20files.\n\n\x0f\n\x07\
    \x04\x04\x04\x02\x02\x03\x01\x12\x04\x8d\x02\x04\x1c\n\x0f\n\x07\x04\x04\
    \x04\x02\x02\x03\x02\x12\x04\x8d\x02\x1f\x20\n\xad\x01\n\x04\x04\x04\x04\
    \x03\x12\x06\x93\x02\x02\x9d\x02\x03\x1a\x9c\x01\x20This\x20metric\x20ca\
    ptures\x20the\x20requirement\x20for\x20a\x20human\x20user,\x20other\x20t\
    han\x20the\n\x20attacker,\x20to\x20participate\x20in\x20the\x20successfu\
    l\x20compromise\x20of\x20the\x20vulnerable\n\x20component.\n\n\r\n\x05\
    \x04\x04\x04\x03\x01\x12\x04\x93\x02\x07\x16\n\x20\n\x06\x04\x04\x04\x03\
    \x02\0\x12\x04\x95\x02\x04%\x1a\x10\x20Invalid\x20value.\n\n\x0f\n\x07\
    \x04\x04\x04\x03\x02\0\x01\x12\x04\x95\x02\x04\x20\n\x0f\n\x07\x04\x04\
    \x04\x03\x02\0\x02\x12\x04\x95\x02#$\n[\n\x06\x04\x04\x04\x03\x02\x01\
    \x12\x04\x98\x02\x04\x1e\x1aK\x20The\x20vulnerable\x20system\x20can\x20b\
    e\x20exploited\x20without\x20interaction\x20from\x20any\x20user.\n\n\x0f\
    \n\x07\x04\x04\x04\x03\x02\x01\x01\x12\x04\x98\x02\x04\x19\n\x0f\n\x07\
    \x04\x04\x04\x03\x02\x01\x02\x12\x04\x98\x02\x1c\x1d\n\x8f\x01\n\x06\x04\
    \x04\x04\x03\x02\x02\x12\x04\x9c\x02\x04\"\x1a\x7f\x20Successful\x20expl\
    oitation\x20of\x20this\x20vulnerability\x20requires\x20a\x20user\x20to\
    \x20take\n\x20some\x20action\x20before\x20the\x20vulnerability\x20can\
    \x20be\x20exploited.\n\n\x0f\n\x07\x04\x04\x04\x03\x02\x02\x01\x12\x04\
    \x9c\x02\x04\x1d\n\x0f\n\x07\x04\x04\x04\x03\x02\x02\x02\x12\x04\x9c\x02\
    \x20!\n\x9c\x01\n\x04\x04\x04\x04\x04\x12\x06\xa1\x02\x02\xac\x02\x03\
    \x1a\x8b\x01\x20The\x20Scope\x20metric\x20captures\x20whether\x20a\x20vu\
    lnerability\x20in\x20one\x20vulnerable\n\x20component\x20impacts\x20reso\
    urces\x20in\x20components\x20beyond\x20its\x20security\x20scope.\n\n\r\n\
    \x05\x04\x04\x04\x04\x01\x12\x04\xa1\x02\x07\x0c\n\x20\n\x06\x04\x04\x04\
    \x04\x02\0\x12\x04\xa3\x02\x04\x1a\x1a\x10\x20Invalid\x20value.\n\n\x0f\
    \n\x07\x04\x04\x04\x04\x02\0\x01\x12\x04\xa3\x02\x04\x15\n\x0f\n\x07\x04\
    \x04\x04\x04\x02\0\x02\x12\x04\xa3\x02\x18\x19\no\n\x06\x04\x04\x04\x04\
    \x02\x01\x12\x04\xa7\x02\x04\x18\x1a_\x20An\x20exploited\x20vulnerabilit\
    y\x20can\x20only\x20affect\x20resources\x20managed\x20by\x20the\x20same\
    \n\x20security\x20authority.\n\n\x0f\n\x07\x04\x04\x04\x04\x02\x01\x01\
    \x12\x04\xa7\x02\x04\x13\n\x0f\n\x07\x04\x04\x04\x04\x02\x01\x02\x12\x04\
    \xa7\x02\x16\x17\n\x9c\x01\n\x06\x04\x04\x04\x04\x02\x02\x12\x04\xab\x02\
    \x04\x16\x1a\x8b\x01\x20An\x20exploited\x20vulnerability\x20can\x20affec\
    t\x20resources\x20beyond\x20the\x20security\x20scope\n\x20managed\x20by\
    \x20the\x20security\x20authority\x20of\x20the\x20vulnerable\x20component\
    .\n\n\x0f\n\x07\x04\x04\x04\x04\x02\x02\x01\x12\x04\xab\x02\x04\x11\n\
    \x0f\n\x07\x04\x04\x04\x04\x02\x02\x02\x12\x04\xab\x02\x14\x15\n\xd7\x01\
    \n\x04\x04\x04\x04\x05\x12\x06\xb1\x02\x02\xbd\x02\x03\x1a\xc6\x01\x20Th\
    e\x20Impact\x20metrics\x20capture\x20the\x20effects\x20of\x20a\x20succes\
    sfully\x20exploited\n\x20vulnerability\x20on\x20the\x20component\x20that\
    \x20suffers\x20the\x20worst\x20outcome\x20that\x20is\x20most\n\x20direct\
    ly\x20and\x20predictably\x20associated\x20with\x20the\x20attack.\n\n\r\n\
    \x05\x04\x04\x04\x05\x01\x12\x04\xb1\x02\x07\r\n\x20\n\x06\x04\x04\x04\
    \x05\x02\0\x12\x04\xb3\x02\x04\x1b\x1a\x10\x20Invalid\x20value.\n\n\x0f\
    \n\x07\x04\x04\x04\x05\x02\0\x01\x12\x04\xb3\x02\x04\x16\n\x0f\n\x07\x04\
    \x04\x04\x05\x02\0\x02\x12\x04\xb3\x02\x19\x1a\n\x1e\n\x06\x04\x04\x04\
    \x05\x02\x01\x12\x04\xb6\x02\x04\x14\x1a\x0e\x20High\x20impact.\n\n\x0f\
    \n\x07\x04\x04\x04\x05\x02\x01\x01\x12\x04\xb6\x02\x04\x0f\n\x0f\n\x07\
    \x04\x04\x04\x05\x02\x01\x02\x12\x04\xb6\x02\x12\x13\n\x1d\n\x06\x04\x04\
    \x04\x05\x02\x02\x12\x04\xb9\x02\x04\x13\x1a\r\x20Low\x20impact.\n\n\x0f\
    \n\x07\x04\x04\x04\x05\x02\x02\x01\x12\x04\xb9\x02\x04\x0e\n\x0f\n\x07\
    \x04\x04\x04\x05\x02\x02\x02\x12\x04\xb9\x02\x11\x12\n\x1c\n\x06\x04\x04\
    \x04\x05\x02\x03\x12\x04\xbc\x02\x04\x14\x1a\x0c\x20No\x20impact.\n\n\
    \x0f\n\x07\x04\x04\x04\x05\x02\x03\x01\x12\x04\xbc\x02\x04\x0f\n\x0f\n\
    \x07\x04\x04\x04\x05\x02\x03\x02\x12\x04\xbc\x02\x12\x13\n\x87\x01\n\x04\
    \x04\x04\x02\0\x12\x04\xc1\x02\x02\x17\x1ay\x20The\x20base\x20score\x20i\
    s\x20a\x20function\x20of\x20the\x20base\x20metric\x20scores.\n\x20https:\
    //www.first.org/cvss/specification-document#Base-Metrics\n\n\r\n\x05\x04\
    \x04\x02\0\x05\x12\x04\xc1\x02\x02\x07\n\r\n\x05\x04\x04\x02\0\x01\x12\
    \x04\xc1\x02\x08\x12\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xc1\x02\x15\x16\
    \n\xb6\x01\n\x04\x04\x04\x02\x01\x12\x04\xc6\x02\x02!\x1a\xa7\x01\x20The\
    \x20Exploitability\x20sub-score\x20equation\x20is\x20derived\x20from\x20\
    the\x20Base\n\x20Exploitability\x20metrics.\n\x20https://www.first.org/c\
    vss/specification-document#2-1-Exploitability-Metrics\n\n\r\n\x05\x04\
    \x04\x02\x01\x05\x12\x04\xc6\x02\x02\x07\n\r\n\x05\x04\x04\x02\x01\x01\
    \x12\x04\xc6\x02\x08\x1c\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xc6\x02\
    \x1f\x20\nV\n\x04\x04\x04\x02\x02\x12\x04\xc9\x02\x02\x19\x1aH\x20The\
    \x20Impact\x20sub-score\x20equation\x20is\x20derived\x20from\x20the\x20B\
    ase\x20Impact\x20metrics.\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xc9\
    \x02\x02\x07\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\xc9\x02\x08\x14\n\r\n\
    \x05\x04\x04\x02\x02\x03\x12\x04\xc9\x02\x17\x18\nb\n\x04\x04\x04\x02\
    \x03\x12\x04\xcd\x02\x02!\x1aT\x20This\x20metric\x20reflects\x20the\x20c\
    ontext\x20by\x20which\x20vulnerability\x20exploitation\x20is\n\x20possib\
    le.\n\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\xcd\x02\x02\x0e\n\r\n\x05\
    \x04\x04\x02\x03\x01\x12\x04\xcd\x02\x0f\x1c\n\r\n\x05\x04\x04\x02\x03\
    \x03\x12\x04\xcd\x02\x1f\x20\n\x8a\x01\n\x04\x04\x04\x02\x04\x12\x04\xd1\
    \x02\x02)\x1a|\x20This\x20metric\x20describes\x20the\x20conditions\x20be\
    yond\x20the\x20attacker's\x20control\x20that\n\x20must\x20exist\x20in\
    \x20order\x20to\x20exploit\x20the\x20vulnerability.\n\n\r\n\x05\x04\x04\
    \x02\x04\x06\x12\x04\xd1\x02\x02\x12\n\r\n\x05\x04\x04\x02\x04\x01\x12\
    \x04\xd1\x02\x13$\n\r\n\x05\x04\x04\x02\x04\x03\x12\x04\xd1\x02'(\n\x89\
    \x01\n\x04\x04\x04\x02\x05\x12\x04\xd5\x02\x02-\x1a{\x20This\x20metric\
    \x20describes\x20the\x20level\x20of\x20privileges\x20an\x20attacker\x20m\
    ust\x20possess\n\x20before\x20successfully\x20exploiting\x20the\x20vulne\
    rability.\n\n\r\n\x05\x04\x04\x02\x05\x06\x12\x04\xd5\x02\x02\x14\n\r\n\
    \x05\x04\x04\x02\x05\x01\x12\x04\xd5\x02\x15(\n\r\n\x05\x04\x04\x02\x05\
    \x03\x12\x04\xd5\x02+,\n\xab\x01\n\x04\x04\x04\x02\x06\x12\x04\xda\x02\
    \x02'\x1a\x9c\x01\x20This\x20metric\x20captures\x20the\x20requirement\
    \x20for\x20a\x20human\x20user,\x20other\x20than\x20the\n\x20attacker,\
    \x20to\x20participate\x20in\x20the\x20successful\x20compromise\x20of\x20\
    the\x20vulnerable\n\x20component.\n\n\r\n\x05\x04\x04\x02\x06\x06\x12\
    \x04\xda\x02\x02\x11\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\xda\x02\x12\"\
    \n\r\n\x05\x04\x04\x02\x06\x03\x12\x04\xda\x02%&\n\x9a\x01\n\x04\x04\x04\
    \x02\x07\x12\x04\xde\x02\x02\x12\x1a\x8b\x01\x20The\x20Scope\x20metric\
    \x20captures\x20whether\x20a\x20vulnerability\x20in\x20one\x20vulnerable\
    \n\x20component\x20impacts\x20resources\x20in\x20components\x20beyond\
    \x20its\x20security\x20scope.\n\n\r\n\x05\x04\x04\x02\x07\x06\x12\x04\
    \xde\x02\x02\x07\n\r\n\x05\x04\x04\x02\x07\x01\x12\x04\xde\x02\x08\r\n\r\
    \n\x05\x04\x04\x02\x07\x03\x12\x04\xde\x02\x10\x11\n\xb5\x01\n\x04\x04\
    \x04\x02\x08\x12\x04\xe3\x02\x02%\x1a\xa6\x01\x20This\x20metric\x20measu\
    res\x20the\x20impact\x20to\x20the\x20confidentiality\x20of\x20the\x20inf\
    ormation\n\x20resources\x20managed\x20by\x20a\x20software\x20component\
    \x20due\x20to\x20a\x20successfully\x20exploited\n\x20vulnerability.\n\n\
    \r\n\x05\x04\x04\x02\x08\x06\x12\x04\xe3\x02\x02\x08\n\r\n\x05\x04\x04\
    \x02\x08\x01\x12\x04\xe3\x02\t\x1f\n\r\n\x05\x04\x04\x02\x08\x03\x12\x04\
    \xe3\x02\"$\nh\n\x04\x04\x04\x02\t\x12\x04\xe7\x02\x02\x1f\x1aZ\x20This\
    \x20metric\x20measures\x20the\x20impact\x20to\x20integrity\x20of\x20a\
    \x20successfully\x20exploited\n\x20vulnerability.\n\n\r\n\x05\x04\x04\
    \x02\t\x06\x12\x04\xe7\x02\x02\x08\n\r\n\x05\x04\x04\x02\t\x01\x12\x04\
    \xe7\x02\t\x19\n\r\n\x05\x04\x04\x02\t\x03\x12\x04\xe7\x02\x1c\x1e\n\x96\
    \x01\n\x04\x04\x04\x02\n\x12\x04\xeb\x02\x02\"\x1a\x87\x01\x20This\x20me\
    tric\x20measures\x20the\x20impact\x20to\x20the\x20availability\x20of\x20\
    the\x20impacted\n\x20component\x20resulting\x20from\x20a\x20successfully\
    \x20exploited\x20vulnerability.\n\n\r\n\x05\x04\x04\x02\n\x06\x12\x04\
    \xeb\x02\x02\x08\n\r\n\x05\x04\x04\x02\n\x01\x12\x04\xeb\x02\t\x1c\n\r\n\
    \x05\x04\x04\x02\n\x03\x12\x04\xeb\x02\x1f!b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
