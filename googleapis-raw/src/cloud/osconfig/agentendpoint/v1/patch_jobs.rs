// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/osconfig/agentendpoint/v1/patch_jobs.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct PatchConfig {
    // message fields
    pub reboot_config: PatchConfig_RebootConfig,
    pub retry_strategy: ::protobuf::SingularPtrField<RetryStrategy>,
    pub apt: ::protobuf::SingularPtrField<AptSettings>,
    pub yum: ::protobuf::SingularPtrField<YumSettings>,
    pub goo: ::protobuf::SingularPtrField<GooSettings>,
    pub zypper: ::protobuf::SingularPtrField<ZypperSettings>,
    pub windows_update: ::protobuf::SingularPtrField<WindowsUpdateSettings>,
    pub pre_step: ::protobuf::SingularPtrField<ExecStep>,
    pub post_step: ::protobuf::SingularPtrField<ExecStep>,
    pub mig_instances_allowed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchConfig {
    fn default() -> &'a PatchConfig {
        <PatchConfig as ::protobuf::Message>::default_instance()
    }
}

impl PatchConfig {
    pub fn new() -> PatchConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.agentendpoint.v1.PatchConfig.RebootConfig reboot_config = 1;


    pub fn get_reboot_config(&self) -> PatchConfig_RebootConfig {
        self.reboot_config
    }
    pub fn clear_reboot_config(&mut self) {
        self.reboot_config = PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_reboot_config(&mut self, v: PatchConfig_RebootConfig) {
        self.reboot_config = v;
    }

    // .google.cloud.osconfig.agentendpoint.v1.RetryStrategy retry_strategy = 2;


    pub fn get_retry_strategy(&self) -> &RetryStrategy {
        self.retry_strategy.as_ref().unwrap_or_else(|| <RetryStrategy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_strategy(&mut self) {
        self.retry_strategy.clear();
    }

    pub fn has_retry_strategy(&self) -> bool {
        self.retry_strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_strategy(&mut self, v: RetryStrategy) {
        self.retry_strategy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_strategy(&mut self) -> &mut RetryStrategy {
        if self.retry_strategy.is_none() {
            self.retry_strategy.set_default();
        }
        self.retry_strategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_strategy(&mut self) -> RetryStrategy {
        self.retry_strategy.take().unwrap_or_else(|| RetryStrategy::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.AptSettings apt = 3;


    pub fn get_apt(&self) -> &AptSettings {
        self.apt.as_ref().unwrap_or_else(|| <AptSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_apt(&mut self) {
        self.apt.clear();
    }

    pub fn has_apt(&self) -> bool {
        self.apt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apt(&mut self, v: AptSettings) {
        self.apt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apt(&mut self) -> &mut AptSettings {
        if self.apt.is_none() {
            self.apt.set_default();
        }
        self.apt.as_mut().unwrap()
    }

    // Take field
    pub fn take_apt(&mut self) -> AptSettings {
        self.apt.take().unwrap_or_else(|| AptSettings::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.YumSettings yum = 4;


    pub fn get_yum(&self) -> &YumSettings {
        self.yum.as_ref().unwrap_or_else(|| <YumSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_yum(&mut self) {
        self.yum.clear();
    }

    pub fn has_yum(&self) -> bool {
        self.yum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yum(&mut self, v: YumSettings) {
        self.yum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_yum(&mut self) -> &mut YumSettings {
        if self.yum.is_none() {
            self.yum.set_default();
        }
        self.yum.as_mut().unwrap()
    }

    // Take field
    pub fn take_yum(&mut self) -> YumSettings {
        self.yum.take().unwrap_or_else(|| YumSettings::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.GooSettings goo = 5;


    pub fn get_goo(&self) -> &GooSettings {
        self.goo.as_ref().unwrap_or_else(|| <GooSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_goo(&mut self) {
        self.goo.clear();
    }

    pub fn has_goo(&self) -> bool {
        self.goo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goo(&mut self, v: GooSettings) {
        self.goo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_goo(&mut self) -> &mut GooSettings {
        if self.goo.is_none() {
            self.goo.set_default();
        }
        self.goo.as_mut().unwrap()
    }

    // Take field
    pub fn take_goo(&mut self) -> GooSettings {
        self.goo.take().unwrap_or_else(|| GooSettings::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.ZypperSettings zypper = 6;


    pub fn get_zypper(&self) -> &ZypperSettings {
        self.zypper.as_ref().unwrap_or_else(|| <ZypperSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zypper(&mut self) {
        self.zypper.clear();
    }

    pub fn has_zypper(&self) -> bool {
        self.zypper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zypper(&mut self, v: ZypperSettings) {
        self.zypper = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zypper(&mut self) -> &mut ZypperSettings {
        if self.zypper.is_none() {
            self.zypper.set_default();
        }
        self.zypper.as_mut().unwrap()
    }

    // Take field
    pub fn take_zypper(&mut self) -> ZypperSettings {
        self.zypper.take().unwrap_or_else(|| ZypperSettings::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.WindowsUpdateSettings windows_update = 7;


    pub fn get_windows_update(&self) -> &WindowsUpdateSettings {
        self.windows_update.as_ref().unwrap_or_else(|| <WindowsUpdateSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windows_update(&mut self) {
        self.windows_update.clear();
    }

    pub fn has_windows_update(&self) -> bool {
        self.windows_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windows_update(&mut self, v: WindowsUpdateSettings) {
        self.windows_update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windows_update(&mut self) -> &mut WindowsUpdateSettings {
        if self.windows_update.is_none() {
            self.windows_update.set_default();
        }
        self.windows_update.as_mut().unwrap()
    }

    // Take field
    pub fn take_windows_update(&mut self) -> WindowsUpdateSettings {
        self.windows_update.take().unwrap_or_else(|| WindowsUpdateSettings::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.ExecStep pre_step = 8;


    pub fn get_pre_step(&self) -> &ExecStep {
        self.pre_step.as_ref().unwrap_or_else(|| <ExecStep as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pre_step(&mut self) {
        self.pre_step.clear();
    }

    pub fn has_pre_step(&self) -> bool {
        self.pre_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_step(&mut self, v: ExecStep) {
        self.pre_step = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_step(&mut self) -> &mut ExecStep {
        if self.pre_step.is_none() {
            self.pre_step.set_default();
        }
        self.pre_step.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_step(&mut self) -> ExecStep {
        self.pre_step.take().unwrap_or_else(|| ExecStep::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.ExecStep post_step = 9;


    pub fn get_post_step(&self) -> &ExecStep {
        self.post_step.as_ref().unwrap_or_else(|| <ExecStep as ::protobuf::Message>::default_instance())
    }
    pub fn clear_post_step(&mut self) {
        self.post_step.clear();
    }

    pub fn has_post_step(&self) -> bool {
        self.post_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post_step(&mut self, v: ExecStep) {
        self.post_step = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post_step(&mut self) -> &mut ExecStep {
        if self.post_step.is_none() {
            self.post_step.set_default();
        }
        self.post_step.as_mut().unwrap()
    }

    // Take field
    pub fn take_post_step(&mut self) -> ExecStep {
        self.post_step.take().unwrap_or_else(|| ExecStep::new())
    }

    // bool mig_instances_allowed = 10;


    pub fn get_mig_instances_allowed(&self) -> bool {
        self.mig_instances_allowed
    }
    pub fn clear_mig_instances_allowed(&mut self) {
        self.mig_instances_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_mig_instances_allowed(&mut self, v: bool) {
        self.mig_instances_allowed = v;
    }
}

impl ::protobuf::Message for PatchConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.retry_strategy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.yum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.goo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.zypper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windows_update {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pre_step {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.post_step {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reboot_config, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_strategy)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.yum)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.goo)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zypper)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windows_update)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_step)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.post_step)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mig_instances_allowed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reboot_config != PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.reboot_config);
        }
        if let Some(ref v) = self.retry_strategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.apt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.yum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.goo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.zypper.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windows_update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pre_step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.post_step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mig_instances_allowed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reboot_config != PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.reboot_config))?;
        }
        if let Some(ref v) = self.retry_strategy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.apt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.yum.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.goo.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.zypper.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windows_update.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pre_step.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.post_step.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mig_instances_allowed != false {
            os.write_bool(10, self.mig_instances_allowed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchConfig {
        PatchConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PatchConfig_RebootConfig>>(
                "reboot_config",
                |m: &PatchConfig| { &m.reboot_config },
                |m: &mut PatchConfig| { &mut m.reboot_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryStrategy>>(
                "retry_strategy",
                |m: &PatchConfig| { &m.retry_strategy },
                |m: &mut PatchConfig| { &mut m.retry_strategy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AptSettings>>(
                "apt",
                |m: &PatchConfig| { &m.apt },
                |m: &mut PatchConfig| { &mut m.apt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<YumSettings>>(
                "yum",
                |m: &PatchConfig| { &m.yum },
                |m: &mut PatchConfig| { &mut m.yum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GooSettings>>(
                "goo",
                |m: &PatchConfig| { &m.goo },
                |m: &mut PatchConfig| { &mut m.goo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZypperSettings>>(
                "zypper",
                |m: &PatchConfig| { &m.zypper },
                |m: &mut PatchConfig| { &mut m.zypper },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsUpdateSettings>>(
                "windows_update",
                |m: &PatchConfig| { &m.windows_update },
                |m: &mut PatchConfig| { &mut m.windows_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStep>>(
                "pre_step",
                |m: &PatchConfig| { &m.pre_step },
                |m: &mut PatchConfig| { &mut m.pre_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStep>>(
                "post_step",
                |m: &PatchConfig| { &m.post_step },
                |m: &mut PatchConfig| { &mut m.post_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mig_instances_allowed",
                |m: &PatchConfig| { &m.mig_instances_allowed },
                |m: &mut PatchConfig| { &mut m.mig_instances_allowed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchConfig>(
                "PatchConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchConfig {
        static instance: ::protobuf::rt::LazyV2<PatchConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchConfig::new)
    }
}

impl ::protobuf::Clear for PatchConfig {
    fn clear(&mut self) {
        self.reboot_config = PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED;
        self.retry_strategy.clear();
        self.apt.clear();
        self.yum.clear();
        self.goo.clear();
        self.zypper.clear();
        self.windows_update.clear();
        self.pre_step.clear();
        self.post_step.clear();
        self.mig_instances_allowed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PatchConfig_RebootConfig {
    REBOOT_CONFIG_UNSPECIFIED = 0,
    DEFAULT = 1,
    ALWAYS = 2,
    NEVER = 3,
}

impl ::protobuf::ProtobufEnum for PatchConfig_RebootConfig {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PatchConfig_RebootConfig> {
        match value {
            0 => ::std::option::Option::Some(PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED),
            1 => ::std::option::Option::Some(PatchConfig_RebootConfig::DEFAULT),
            2 => ::std::option::Option::Some(PatchConfig_RebootConfig::ALWAYS),
            3 => ::std::option::Option::Some(PatchConfig_RebootConfig::NEVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PatchConfig_RebootConfig] = &[
            PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED,
            PatchConfig_RebootConfig::DEFAULT,
            PatchConfig_RebootConfig::ALWAYS,
            PatchConfig_RebootConfig::NEVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PatchConfig_RebootConfig>("PatchConfig.RebootConfig", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PatchConfig_RebootConfig {
}

impl ::std::default::Default for PatchConfig_RebootConfig {
    fn default() -> Self {
        PatchConfig_RebootConfig::REBOOT_CONFIG_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConfig_RebootConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AptSettings {
    // message fields
    pub field_type: AptSettings_Type,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_packages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AptSettings {
    fn default() -> &'a AptSettings {
        <AptSettings as ::protobuf::Message>::default_instance()
    }
}

impl AptSettings {
    pub fn new() -> AptSettings {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.agentendpoint.v1.AptSettings.Type type = 1;


    pub fn get_field_type(&self) -> AptSettings_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AptSettings_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AptSettings_Type) {
        self.field_type = v;
    }

    // repeated string excludes = 2;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_packages = 3;


    pub fn get_exclusive_packages(&self) -> &[::std::string::String] {
        &self.exclusive_packages
    }
    pub fn clear_exclusive_packages(&mut self) {
        self.exclusive_packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_packages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_packages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_packages
    }

    // Take field
    pub fn take_exclusive_packages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_packages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AptSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_packages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != AptSettings_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.exclusive_packages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != AptSettings_Type::TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        for v in &self.excludes {
            os.write_string(2, &v)?;
        };
        for v in &self.exclusive_packages {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AptSettings {
        AptSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AptSettings_Type>>(
                "type",
                |m: &AptSettings| { &m.field_type },
                |m: &mut AptSettings| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &AptSettings| { &m.excludes },
                |m: &mut AptSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_packages",
                |m: &AptSettings| { &m.exclusive_packages },
                |m: &mut AptSettings| { &mut m.exclusive_packages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AptSettings>(
                "AptSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AptSettings {
        static instance: ::protobuf::rt::LazyV2<AptSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AptSettings::new)
    }
}

impl ::protobuf::Clear for AptSettings {
    fn clear(&mut self) {
        self.field_type = AptSettings_Type::TYPE_UNSPECIFIED;
        self.excludes.clear();
        self.exclusive_packages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AptSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AptSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AptSettings_Type {
    TYPE_UNSPECIFIED = 0,
    DIST = 1,
    UPGRADE = 2,
}

impl ::protobuf::ProtobufEnum for AptSettings_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AptSettings_Type> {
        match value {
            0 => ::std::option::Option::Some(AptSettings_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AptSettings_Type::DIST),
            2 => ::std::option::Option::Some(AptSettings_Type::UPGRADE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AptSettings_Type] = &[
            AptSettings_Type::TYPE_UNSPECIFIED,
            AptSettings_Type::DIST,
            AptSettings_Type::UPGRADE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AptSettings_Type>("AptSettings.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AptSettings_Type {
}

impl ::std::default::Default for AptSettings_Type {
    fn default() -> Self {
        AptSettings_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AptSettings_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct YumSettings {
    // message fields
    pub security: bool,
    pub minimal: bool,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_packages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a YumSettings {
    fn default() -> &'a YumSettings {
        <YumSettings as ::protobuf::Message>::default_instance()
    }
}

impl YumSettings {
    pub fn new() -> YumSettings {
        ::std::default::Default::default()
    }

    // bool security = 1;


    pub fn get_security(&self) -> bool {
        self.security
    }
    pub fn clear_security(&mut self) {
        self.security = false;
    }

    // Param is passed by value, moved
    pub fn set_security(&mut self, v: bool) {
        self.security = v;
    }

    // bool minimal = 2;


    pub fn get_minimal(&self) -> bool {
        self.minimal
    }
    pub fn clear_minimal(&mut self) {
        self.minimal = false;
    }

    // Param is passed by value, moved
    pub fn set_minimal(&mut self, v: bool) {
        self.minimal = v;
    }

    // repeated string excludes = 3;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_packages = 4;


    pub fn get_exclusive_packages(&self) -> &[::std::string::String] {
        &self.exclusive_packages
    }
    pub fn clear_exclusive_packages(&mut self) {
        self.exclusive_packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_packages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_packages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_packages
    }

    // Take field
    pub fn take_exclusive_packages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_packages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for YumSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.security = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.minimal = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_packages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.security != false {
            my_size += 2;
        }
        if self.minimal != false {
            my_size += 2;
        }
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.exclusive_packages {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.security != false {
            os.write_bool(1, self.security)?;
        }
        if self.minimal != false {
            os.write_bool(2, self.minimal)?;
        }
        for v in &self.excludes {
            os.write_string(3, &v)?;
        };
        for v in &self.exclusive_packages {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> YumSettings {
        YumSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "security",
                |m: &YumSettings| { &m.security },
                |m: &mut YumSettings| { &mut m.security },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "minimal",
                |m: &YumSettings| { &m.minimal },
                |m: &mut YumSettings| { &mut m.minimal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &YumSettings| { &m.excludes },
                |m: &mut YumSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_packages",
                |m: &YumSettings| { &m.exclusive_packages },
                |m: &mut YumSettings| { &mut m.exclusive_packages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<YumSettings>(
                "YumSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static YumSettings {
        static instance: ::protobuf::rt::LazyV2<YumSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(YumSettings::new)
    }
}

impl ::protobuf::Clear for YumSettings {
    fn clear(&mut self) {
        self.security = false;
        self.minimal = false;
        self.excludes.clear();
        self.exclusive_packages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for YumSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for YumSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GooSettings {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GooSettings {
    fn default() -> &'a GooSettings {
        <GooSettings as ::protobuf::Message>::default_instance()
    }
}

impl GooSettings {
    pub fn new() -> GooSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GooSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GooSettings {
        GooSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GooSettings>(
                "GooSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GooSettings {
        static instance: ::protobuf::rt::LazyV2<GooSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GooSettings::new)
    }
}

impl ::protobuf::Clear for GooSettings {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GooSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GooSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZypperSettings {
    // message fields
    pub with_optional: bool,
    pub with_update: bool,
    pub categories: ::protobuf::RepeatedField<::std::string::String>,
    pub severities: ::protobuf::RepeatedField<::std::string::String>,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_patches: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZypperSettings {
    fn default() -> &'a ZypperSettings {
        <ZypperSettings as ::protobuf::Message>::default_instance()
    }
}

impl ZypperSettings {
    pub fn new() -> ZypperSettings {
        ::std::default::Default::default()
    }

    // bool with_optional = 1;


    pub fn get_with_optional(&self) -> bool {
        self.with_optional
    }
    pub fn clear_with_optional(&mut self) {
        self.with_optional = false;
    }

    // Param is passed by value, moved
    pub fn set_with_optional(&mut self, v: bool) {
        self.with_optional = v;
    }

    // bool with_update = 2;


    pub fn get_with_update(&self) -> bool {
        self.with_update
    }
    pub fn clear_with_update(&mut self) {
        self.with_update = false;
    }

    // Param is passed by value, moved
    pub fn set_with_update(&mut self, v: bool) {
        self.with_update = v;
    }

    // repeated string categories = 3;


    pub fn get_categories(&self) -> &[::std::string::String] {
        &self.categories
    }
    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.categories, ::protobuf::RepeatedField::new())
    }

    // repeated string severities = 4;


    pub fn get_severities(&self) -> &[::std::string::String] {
        &self.severities
    }
    pub fn clear_severities(&mut self) {
        self.severities.clear();
    }

    // Param is passed by value, moved
    pub fn set_severities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.severities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_severities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.severities
    }

    // Take field
    pub fn take_severities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.severities, ::protobuf::RepeatedField::new())
    }

    // repeated string excludes = 5;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_patches = 6;


    pub fn get_exclusive_patches(&self) -> &[::std::string::String] {
        &self.exclusive_patches
    }
    pub fn clear_exclusive_patches(&mut self) {
        self.exclusive_patches.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_patches(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_patches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_patches(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_patches
    }

    // Take field
    pub fn take_exclusive_patches(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_patches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ZypperSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_optional = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_update = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categories)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.severities)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_patches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.with_optional != false {
            my_size += 2;
        }
        if self.with_update != false {
            my_size += 2;
        }
        for value in &self.categories {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.severities {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.exclusive_patches {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.with_optional != false {
            os.write_bool(1, self.with_optional)?;
        }
        if self.with_update != false {
            os.write_bool(2, self.with_update)?;
        }
        for v in &self.categories {
            os.write_string(3, &v)?;
        };
        for v in &self.severities {
            os.write_string(4, &v)?;
        };
        for v in &self.excludes {
            os.write_string(5, &v)?;
        };
        for v in &self.exclusive_patches {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZypperSettings {
        ZypperSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "with_optional",
                |m: &ZypperSettings| { &m.with_optional },
                |m: &mut ZypperSettings| { &mut m.with_optional },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "with_update",
                |m: &ZypperSettings| { &m.with_update },
                |m: &mut ZypperSettings| { &mut m.with_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categories",
                |m: &ZypperSettings| { &m.categories },
                |m: &mut ZypperSettings| { &mut m.categories },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "severities",
                |m: &ZypperSettings| { &m.severities },
                |m: &mut ZypperSettings| { &mut m.severities },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &ZypperSettings| { &m.excludes },
                |m: &mut ZypperSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_patches",
                |m: &ZypperSettings| { &m.exclusive_patches },
                |m: &mut ZypperSettings| { &mut m.exclusive_patches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZypperSettings>(
                "ZypperSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZypperSettings {
        static instance: ::protobuf::rt::LazyV2<ZypperSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZypperSettings::new)
    }
}

impl ::protobuf::Clear for ZypperSettings {
    fn clear(&mut self) {
        self.with_optional = false;
        self.with_update = false;
        self.categories.clear();
        self.severities.clear();
        self.excludes.clear();
        self.exclusive_patches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZypperSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZypperSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsUpdateSettings {
    // message fields
    pub classifications: ::std::vec::Vec<WindowsUpdateSettings_Classification>,
    pub excludes: ::protobuf::RepeatedField<::std::string::String>,
    pub exclusive_patches: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsUpdateSettings {
    fn default() -> &'a WindowsUpdateSettings {
        <WindowsUpdateSettings as ::protobuf::Message>::default_instance()
    }
}

impl WindowsUpdateSettings {
    pub fn new() -> WindowsUpdateSettings {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.osconfig.agentendpoint.v1.WindowsUpdateSettings.Classification classifications = 1;


    pub fn get_classifications(&self) -> &[WindowsUpdateSettings_Classification] {
        &self.classifications
    }
    pub fn clear_classifications(&mut self) {
        self.classifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_classifications(&mut self, v: ::std::vec::Vec<WindowsUpdateSettings_Classification>) {
        self.classifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_classifications(&mut self) -> &mut ::std::vec::Vec<WindowsUpdateSettings_Classification> {
        &mut self.classifications
    }

    // Take field
    pub fn take_classifications(&mut self) -> ::std::vec::Vec<WindowsUpdateSettings_Classification> {
        ::std::mem::replace(&mut self.classifications, ::std::vec::Vec::new())
    }

    // repeated string excludes = 2;


    pub fn get_excludes(&self) -> &[::std::string::String] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // repeated string exclusive_patches = 3;


    pub fn get_exclusive_patches(&self) -> &[::std::string::String] {
        &self.exclusive_patches
    }
    pub fn clear_exclusive_patches(&mut self) {
        self.exclusive_patches.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusive_patches(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exclusive_patches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusive_patches(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exclusive_patches
    }

    // Take field
    pub fn take_exclusive_patches(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exclusive_patches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WindowsUpdateSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.classifications, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exclusive_patches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.classifications {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in &self.excludes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.exclusive_patches {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.classifications {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.excludes {
            os.write_string(2, &v)?;
        };
        for v in &self.exclusive_patches {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsUpdateSettings {
        WindowsUpdateSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WindowsUpdateSettings_Classification>>(
                "classifications",
                |m: &WindowsUpdateSettings| { &m.classifications },
                |m: &mut WindowsUpdateSettings| { &mut m.classifications },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excludes",
                |m: &WindowsUpdateSettings| { &m.excludes },
                |m: &mut WindowsUpdateSettings| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exclusive_patches",
                |m: &WindowsUpdateSettings| { &m.exclusive_patches },
                |m: &mut WindowsUpdateSettings| { &mut m.exclusive_patches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsUpdateSettings>(
                "WindowsUpdateSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsUpdateSettings {
        static instance: ::protobuf::rt::LazyV2<WindowsUpdateSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsUpdateSettings::new)
    }
}

impl ::protobuf::Clear for WindowsUpdateSettings {
    fn clear(&mut self) {
        self.classifications.clear();
        self.excludes.clear();
        self.exclusive_patches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsUpdateSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsUpdateSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WindowsUpdateSettings_Classification {
    CLASSIFICATION_UNSPECIFIED = 0,
    CRITICAL = 1,
    SECURITY = 2,
    DEFINITION = 3,
    DRIVER = 4,
    FEATURE_PACK = 5,
    SERVICE_PACK = 6,
    TOOL = 7,
    UPDATE_ROLLUP = 8,
    UPDATE = 9,
}

impl ::protobuf::ProtobufEnum for WindowsUpdateSettings_Classification {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WindowsUpdateSettings_Classification> {
        match value {
            0 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::CLASSIFICATION_UNSPECIFIED),
            1 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::CRITICAL),
            2 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::SECURITY),
            3 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::DEFINITION),
            4 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::DRIVER),
            5 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::FEATURE_PACK),
            6 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::SERVICE_PACK),
            7 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::TOOL),
            8 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::UPDATE_ROLLUP),
            9 => ::std::option::Option::Some(WindowsUpdateSettings_Classification::UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WindowsUpdateSettings_Classification] = &[
            WindowsUpdateSettings_Classification::CLASSIFICATION_UNSPECIFIED,
            WindowsUpdateSettings_Classification::CRITICAL,
            WindowsUpdateSettings_Classification::SECURITY,
            WindowsUpdateSettings_Classification::DEFINITION,
            WindowsUpdateSettings_Classification::DRIVER,
            WindowsUpdateSettings_Classification::FEATURE_PACK,
            WindowsUpdateSettings_Classification::SERVICE_PACK,
            WindowsUpdateSettings_Classification::TOOL,
            WindowsUpdateSettings_Classification::UPDATE_ROLLUP,
            WindowsUpdateSettings_Classification::UPDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WindowsUpdateSettings_Classification>("WindowsUpdateSettings.Classification", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WindowsUpdateSettings_Classification {
}

impl ::std::default::Default for WindowsUpdateSettings_Classification {
    fn default() -> Self {
        WindowsUpdateSettings_Classification::CLASSIFICATION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsUpdateSettings_Classification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RetryStrategy {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryStrategy {
    fn default() -> &'a RetryStrategy {
        <RetryStrategy as ::protobuf::Message>::default_instance()
    }
}

impl RetryStrategy {
    pub fn new() -> RetryStrategy {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for RetryStrategy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryStrategy {
        RetryStrategy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &RetryStrategy| { &m.enabled },
                |m: &mut RetryStrategy| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryStrategy>(
                "RetryStrategy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryStrategy {
        static instance: ::protobuf::rt::LazyV2<RetryStrategy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryStrategy::new)
    }
}

impl ::protobuf::Clear for RetryStrategy {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecStep {
    // message fields
    pub linux_exec_step_config: ::protobuf::SingularPtrField<ExecStepConfig>,
    pub windows_exec_step_config: ::protobuf::SingularPtrField<ExecStepConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecStep {
    fn default() -> &'a ExecStep {
        <ExecStep as ::protobuf::Message>::default_instance()
    }
}

impl ExecStep {
    pub fn new() -> ExecStep {
        ::std::default::Default::default()
    }

    // .google.cloud.osconfig.agentendpoint.v1.ExecStepConfig linux_exec_step_config = 1;


    pub fn get_linux_exec_step_config(&self) -> &ExecStepConfig {
        self.linux_exec_step_config.as_ref().unwrap_or_else(|| <ExecStepConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_linux_exec_step_config(&mut self) {
        self.linux_exec_step_config.clear();
    }

    pub fn has_linux_exec_step_config(&self) -> bool {
        self.linux_exec_step_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linux_exec_step_config(&mut self, v: ExecStepConfig) {
        self.linux_exec_step_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linux_exec_step_config(&mut self) -> &mut ExecStepConfig {
        if self.linux_exec_step_config.is_none() {
            self.linux_exec_step_config.set_default();
        }
        self.linux_exec_step_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_linux_exec_step_config(&mut self) -> ExecStepConfig {
        self.linux_exec_step_config.take().unwrap_or_else(|| ExecStepConfig::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.ExecStepConfig windows_exec_step_config = 2;


    pub fn get_windows_exec_step_config(&self) -> &ExecStepConfig {
        self.windows_exec_step_config.as_ref().unwrap_or_else(|| <ExecStepConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windows_exec_step_config(&mut self) {
        self.windows_exec_step_config.clear();
    }

    pub fn has_windows_exec_step_config(&self) -> bool {
        self.windows_exec_step_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windows_exec_step_config(&mut self, v: ExecStepConfig) {
        self.windows_exec_step_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windows_exec_step_config(&mut self) -> &mut ExecStepConfig {
        if self.windows_exec_step_config.is_none() {
            self.windows_exec_step_config.set_default();
        }
        self.windows_exec_step_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_windows_exec_step_config(&mut self) -> ExecStepConfig {
        self.windows_exec_step_config.take().unwrap_or_else(|| ExecStepConfig::new())
    }
}

impl ::protobuf::Message for ExecStep {
    fn is_initialized(&self) -> bool {
        for v in &self.linux_exec_step_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windows_exec_step_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linux_exec_step_config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windows_exec_step_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.linux_exec_step_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windows_exec_step_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.linux_exec_step_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windows_exec_step_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecStep {
        ExecStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStepConfig>>(
                "linux_exec_step_config",
                |m: &ExecStep| { &m.linux_exec_step_config },
                |m: &mut ExecStep| { &mut m.linux_exec_step_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecStepConfig>>(
                "windows_exec_step_config",
                |m: &ExecStep| { &m.windows_exec_step_config },
                |m: &mut ExecStep| { &mut m.windows_exec_step_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecStep>(
                "ExecStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecStep {
        static instance: ::protobuf::rt::LazyV2<ExecStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecStep::new)
    }
}

impl ::protobuf::Clear for ExecStep {
    fn clear(&mut self) {
        self.linux_exec_step_config.clear();
        self.windows_exec_step_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecStepConfig {
    // message fields
    pub allowed_success_codes: ::std::vec::Vec<i32>,
    pub interpreter: ExecStepConfig_Interpreter,
    // message oneof groups
    pub executable: ::std::option::Option<ExecStepConfig_oneof_executable>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecStepConfig {
    fn default() -> &'a ExecStepConfig {
        <ExecStepConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExecStepConfig_oneof_executable {
    local_path(::std::string::String),
    gcs_object(GcsObject),
}

impl ExecStepConfig {
    pub fn new() -> ExecStepConfig {
        ::std::default::Default::default()
    }

    // string local_path = 1;


    pub fn get_local_path(&self) -> &str {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_local_path(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_local_path(&self) -> bool {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local_path(&mut self, v: ::std::string::String) {
        self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(_)) = self.executable {
        } else {
            self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(::std::string::String::new()));
        }
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local_path(&mut self) -> ::std::string::String {
        if self.has_local_path() {
            match self.executable.take() {
                ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.cloud.osconfig.agentendpoint.v1.GcsObject gcs_object = 2;


    pub fn get_gcs_object(&self) -> &GcsObject {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(ref v)) => v,
            _ => <GcsObject as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_object(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_gcs_object(&self) -> bool {
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_object(&mut self, v: GcsObject) {
        self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_object(&mut self) -> &mut GcsObject {
        if let ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(_)) = self.executable {
        } else {
            self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(GcsObject::new()));
        }
        match self.executable {
            ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_object(&mut self) -> GcsObject {
        if self.has_gcs_object() {
            match self.executable.take() {
                ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(v)) => v,
                _ => panic!(),
            }
        } else {
            GcsObject::new()
        }
    }

    // repeated int32 allowed_success_codes = 3;


    pub fn get_allowed_success_codes(&self) -> &[i32] {
        &self.allowed_success_codes
    }
    pub fn clear_allowed_success_codes(&mut self) {
        self.allowed_success_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_success_codes(&mut self, v: ::std::vec::Vec<i32>) {
        self.allowed_success_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_success_codes(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.allowed_success_codes
    }

    // Take field
    pub fn take_allowed_success_codes(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.allowed_success_codes, ::std::vec::Vec::new())
    }

    // .google.cloud.osconfig.agentendpoint.v1.ExecStepConfig.Interpreter interpreter = 4;


    pub fn get_interpreter(&self) -> ExecStepConfig_Interpreter {
        self.interpreter
    }
    pub fn clear_interpreter(&mut self) {
        self.interpreter = ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_interpreter(&mut self, v: ExecStepConfig_Interpreter) {
        self.interpreter = v;
    }
}

impl ::protobuf::Message for ExecStepConfig {
    fn is_initialized(&self) -> bool {
        if let Some(ExecStepConfig_oneof_executable::gcs_object(ref v)) = self.executable {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::local_path(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executable = ::std::option::Option::Some(ExecStepConfig_oneof_executable::gcs_object(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.allowed_success_codes)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.interpreter, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_success_codes {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.interpreter != ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.interpreter);
        }
        if let ::std::option::Option::Some(ref v) = self.executable {
            match v {
                &ExecStepConfig_oneof_executable::local_path(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &ExecStepConfig_oneof_executable::gcs_object(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_success_codes {
            os.write_int32(3, *v)?;
        };
        if self.interpreter != ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.interpreter))?;
        }
        if let ::std::option::Option::Some(ref v) = self.executable {
            match v {
                &ExecStepConfig_oneof_executable::local_path(ref v) => {
                    os.write_string(1, v)?;
                },
                &ExecStepConfig_oneof_executable::gcs_object(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecStepConfig {
        ExecStepConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "local_path",
                ExecStepConfig::has_local_path,
                ExecStepConfig::get_local_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GcsObject>(
                "gcs_object",
                ExecStepConfig::has_gcs_object,
                ExecStepConfig::get_gcs_object,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "allowed_success_codes",
                |m: &ExecStepConfig| { &m.allowed_success_codes },
                |m: &mut ExecStepConfig| { &mut m.allowed_success_codes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExecStepConfig_Interpreter>>(
                "interpreter",
                |m: &ExecStepConfig| { &m.interpreter },
                |m: &mut ExecStepConfig| { &mut m.interpreter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecStepConfig>(
                "ExecStepConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecStepConfig {
        static instance: ::protobuf::rt::LazyV2<ExecStepConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecStepConfig::new)
    }
}

impl ::protobuf::Clear for ExecStepConfig {
    fn clear(&mut self) {
        self.executable = ::std::option::Option::None;
        self.executable = ::std::option::Option::None;
        self.allowed_success_codes.clear();
        self.interpreter = ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecStepConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecStepConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExecStepConfig_Interpreter {
    INTERPRETER_UNSPECIFIED = 0,
    NONE = 3,
    SHELL = 1,
    POWERSHELL = 2,
}

impl ::protobuf::ProtobufEnum for ExecStepConfig_Interpreter {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExecStepConfig_Interpreter> {
        match value {
            0 => ::std::option::Option::Some(ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED),
            3 => ::std::option::Option::Some(ExecStepConfig_Interpreter::NONE),
            1 => ::std::option::Option::Some(ExecStepConfig_Interpreter::SHELL),
            2 => ::std::option::Option::Some(ExecStepConfig_Interpreter::POWERSHELL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExecStepConfig_Interpreter] = &[
            ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED,
            ExecStepConfig_Interpreter::NONE,
            ExecStepConfig_Interpreter::SHELL,
            ExecStepConfig_Interpreter::POWERSHELL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExecStepConfig_Interpreter>("ExecStepConfig.Interpreter", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExecStepConfig_Interpreter {
}

impl ::std::default::Default for ExecStepConfig_Interpreter {
    fn default() -> Self {
        ExecStepConfig_Interpreter::INTERPRETER_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecStepConfig_Interpreter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsObject {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation_number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsObject {
    fn default() -> &'a GcsObject {
        <GcsObject as ::protobuf::Message>::default_instance()
    }
}

impl GcsObject {
    pub fn new() -> GcsObject {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation_number = 3;


    pub fn get_generation_number(&self) -> i64 {
        self.generation_number
    }
    pub fn clear_generation_number(&mut self) {
        self.generation_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation_number(&mut self, v: i64) {
        self.generation_number = v;
    }
}

impl ::protobuf::Message for GcsObject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation_number != 0 {
            os.write_int64(3, self.generation_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsObject {
        GcsObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GcsObject| { &m.bucket },
                |m: &mut GcsObject| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &GcsObject| { &m.object },
                |m: &mut GcsObject| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation_number",
                |m: &GcsObject| { &m.generation_number },
                |m: &mut GcsObject| { &mut m.generation_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsObject>(
                "GcsObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsObject {
        static instance: ::protobuf::rt::LazyV2<GcsObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsObject::new)
    }
}

impl ::protobuf::Clear for GcsObject {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n7google/cloud/osconfig/agentendpoint/v1/patch_jobs.proto\x12&google.cl\
    oud.osconfig.agentendpoint.v1\"\x80\x07\n\x0bPatchConfig\x12e\n\rreboot_\
    config\x18\x01\x20\x01(\x0e2@.google.cloud.osconfig.agentendpoint.v1.Pat\
    chConfig.RebootConfigR\x0crebootConfig\x12\\\n\x0eretry_strategy\x18\x02\
    \x20\x01(\x0b25.google.cloud.osconfig.agentendpoint.v1.RetryStrategyR\rr\
    etryStrategy\x12E\n\x03apt\x18\x03\x20\x01(\x0b23.google.cloud.osconfig.\
    agentendpoint.v1.AptSettingsR\x03apt\x12E\n\x03yum\x18\x04\x20\x01(\x0b2\
    3.google.cloud.osconfig.agentendpoint.v1.YumSettingsR\x03yum\x12E\n\x03g\
    oo\x18\x05\x20\x01(\x0b23.google.cloud.osconfig.agentendpoint.v1.GooSett\
    ingsR\x03goo\x12N\n\x06zypper\x18\x06\x20\x01(\x0b26.google.cloud.osconf\
    ig.agentendpoint.v1.ZypperSettingsR\x06zypper\x12d\n\x0ewindows_update\
    \x18\x07\x20\x01(\x0b2=.google.cloud.osconfig.agentendpoint.v1.WindowsUp\
    dateSettingsR\rwindowsUpdate\x12K\n\x08pre_step\x18\x08\x20\x01(\x0b20.g\
    oogle.cloud.osconfig.agentendpoint.v1.ExecStepR\x07preStep\x12M\n\tpost_\
    step\x18\t\x20\x01(\x0b20.google.cloud.osconfig.agentendpoint.v1.ExecSte\
    pR\x08postStep\x122\n\x15mig_instances_allowed\x18\n\x20\x01(\x08R\x13mi\
    gInstancesAllowed\"Q\n\x0cRebootConfig\x12\x1d\n\x19REBOOT_CONFIG_UNSPEC\
    IFIED\x10\0\x12\x0b\n\x07DEFAULT\x10\x01\x12\n\n\x06ALWAYS\x10\x02\x12\t\
    \n\x05NEVER\x10\x03\"\xdb\x01\n\x0bAptSettings\x12L\n\x04type\x18\x01\
    \x20\x01(\x0e28.google.cloud.osconfig.agentendpoint.v1.AptSettings.TypeR\
    \x04type\x12\x1a\n\x08excludes\x18\x02\x20\x03(\tR\x08excludes\x12-\n\
    \x12exclusive_packages\x18\x03\x20\x03(\tR\x11exclusivePackages\"3\n\x04\
    Type\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\x08\n\x04DIST\x10\x01\x12\
    \x0b\n\x07UPGRADE\x10\x02\"\x8e\x01\n\x0bYumSettings\x12\x1a\n\x08securi\
    ty\x18\x01\x20\x01(\x08R\x08security\x12\x18\n\x07minimal\x18\x02\x20\
    \x01(\x08R\x07minimal\x12\x1a\n\x08excludes\x18\x03\x20\x03(\tR\x08exclu\
    des\x12-\n\x12exclusive_packages\x18\x04\x20\x03(\tR\x11exclusivePackage\
    s\"\r\n\x0bGooSettings\"\xdf\x01\n\x0eZypperSettings\x12#\n\rwith_option\
    al\x18\x01\x20\x01(\x08R\x0cwithOptional\x12\x1f\n\x0bwith_update\x18\
    \x02\x20\x01(\x08R\nwithUpdate\x12\x1e\n\ncategories\x18\x03\x20\x03(\tR\
    \ncategories\x12\x1e\n\nseverities\x18\x04\x20\x03(\tR\nseverities\x12\
    \x1a\n\x08excludes\x18\x05\x20\x03(\tR\x08excludes\x12+\n\x11exclusive_p\
    atches\x18\x06\x20\x03(\tR\x10exclusivePatches\"\x90\x03\n\x15WindowsUpd\
    ateSettings\x12v\n\x0fclassifications\x18\x01\x20\x03(\x0e2L.google.clou\
    d.osconfig.agentendpoint.v1.WindowsUpdateSettings.ClassificationR\x0fcla\
    ssifications\x12\x1a\n\x08excludes\x18\x02\x20\x03(\tR\x08excludes\x12+\
    \n\x11exclusive_patches\x18\x03\x20\x03(\tR\x10exclusivePatches\"\xb5\
    \x01\n\x0eClassification\x12\x1e\n\x1aCLASSIFICATION_UNSPECIFIED\x10\0\
    \x12\x0c\n\x08CRITICAL\x10\x01\x12\x0c\n\x08SECURITY\x10\x02\x12\x0e\n\n\
    DEFINITION\x10\x03\x12\n\n\x06DRIVER\x10\x04\x12\x10\n\x0cFEATURE_PACK\
    \x10\x05\x12\x10\n\x0cSERVICE_PACK\x10\x06\x12\x08\n\x04TOOL\x10\x07\x12\
    \x11\n\rUPDATE_ROLLUP\x10\x08\x12\n\n\x06UPDATE\x10\t\")\n\rRetryStrateg\
    y\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\"\xe8\x01\n\x08E\
    xecStep\x12k\n\x16linux_exec_step_config\x18\x01\x20\x01(\x0b26.google.c\
    loud.osconfig.agentendpoint.v1.ExecStepConfigR\x13linuxExecStepConfig\
    \x12o\n\x18windows_exec_step_config\x18\x02\x20\x01(\x0b26.google.cloud.\
    osconfig.agentendpoint.v1.ExecStepConfigR\x15windowsExecStepConfig\"\xfe\
    \x02\n\x0eExecStepConfig\x12\x1f\n\nlocal_path\x18\x01\x20\x01(\tH\0R\tl\
    ocalPath\x12R\n\ngcs_object\x18\x02\x20\x01(\x0b21.google.cloud.osconfig\
    .agentendpoint.v1.GcsObjectH\0R\tgcsObject\x122\n\x15allowed_success_cod\
    es\x18\x03\x20\x03(\x05R\x13allowedSuccessCodes\x12d\n\x0binterpreter\
    \x18\x04\x20\x01(\x0e2B.google.cloud.osconfig.agentendpoint.v1.ExecStepC\
    onfig.InterpreterR\x0binterpreter\"O\n\x0bInterpreter\x12\x1b\n\x17INTER\
    PRETER_UNSPECIFIED\x10\0\x12\x08\n\x04NONE\x10\x03\x12\t\n\x05SHELL\x10\
    \x01\x12\x0e\n\nPOWERSHELL\x10\x02B\x0c\n\nexecutable\"h\n\tGcsObject\
    \x12\x16\n\x06bucket\x18\x01\x20\x01(\tR\x06bucket\x12\x16\n\x06object\
    \x18\x02\x20\x01(\tR\x06object\x12+\n\x11generation_number\x18\x03\x20\
    \x01(\x03R\x10generationNumberB\x89\x01\n*com.google.cloud.osconfig.agen\
    tendpoint.v1B\tPatchJobsZPcloud.google.com/go/osconfig/agentendpoint/api\
    v1/agentendpointpb;agentendpointpbJ\xc1Y\n\x07\x12\x05\x0e\0\xa5\x02\x01\
    \n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202020\x20\
    Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20V\
    ersion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20\
    this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0/\n\x08\n\x01\x08\
    \x12\x03\x12\0g\n\t\n\x02\x08\x0b\x12\x03\x12\0g\n\x08\n\x01\x08\x12\x03\
    \x13\0*\n\t\n\x02\x08\x08\x12\x03\x13\0*\n\x08\n\x01\x08\x12\x03\x14\0C\
    \n\t\n\x02\x08\x01\x12\x03\x14\0C\nm\n\x02\x04\0\x12\x04\x18\0J\x01\x1aa\
    \x20Patch\x20configuration\x20specifications.\x20Contains\x20details\x20\
    on\x20how\x20to\n\x20apply\x20patches\x20to\x20a\x20VM\x20instance.\n\n\
    \n\n\x03\x04\0\x01\x12\x03\x18\x08\x13\n+\n\x04\x04\0\x04\0\x12\x04\x1a\
    \x02)\x03\x1a\x1d\x20Post-patch\x20reboot\x20settings.\n\n\x0c\n\x05\x04\
    \0\x04\0\x01\x12\x03\x1a\x07\x13\n1\n\x06\x04\0\x04\0\x02\0\x12\x03\x1c\
    \x04\"\x1a\"\x20The\x20default\x20behavior\x20is\x20DEFAULT.\n\n\x0e\n\
    \x07\x04\0\x04\0\x02\0\x01\x12\x03\x1c\x04\x1d\n\x0e\n\x07\x04\0\x04\0\
    \x02\0\x02\x12\x03\x1c\x20!\n\x8d\x02\n\x06\x04\0\x04\0\x02\x01\x12\x03\
    \"\x04\x10\x1a\xfd\x01\x20The\x20agent\x20decides\x20if\x20a\x20reboot\
    \x20is\x20necessary\x20by\x20checking\n\x20signals\x20such\x20as\x20regi\
    stry\x20keys\x20on\x20Windows\x20or\x20`/var/run/reboot-required`\x20on\
    \n\x20APT\x20based\x20systems.\x20On\x20RPM\x20based\x20systems,\x20a\
    \x20set\x20of\x20core\x20system\x20package\n\x20install\x20times\x20are\
    \x20compared\x20with\x20system\x20boot\x20time.\n\n\x0e\n\x07\x04\0\x04\
    \0\x02\x01\x01\x12\x03\"\x04\x0b\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\
    \x03\"\x0e\x0f\nF\n\x06\x04\0\x04\0\x02\x02\x12\x03%\x04\x0f\x1a7\x20Alw\
    ays\x20reboot\x20the\x20machine\x20after\x20the\x20update\x20completes.\
    \n\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03%\x04\n\n\x0e\n\x07\x04\0\
    \x04\0\x02\x02\x02\x12\x03%\r\x0e\nE\n\x06\x04\0\x04\0\x02\x03\x12\x03(\
    \x04\x0e\x1a6\x20Never\x20reboot\x20the\x20machine\x20after\x20the\x20up\
    date\x20completes.\n\n\x0e\n\x07\x04\0\x04\0\x02\x03\x01\x12\x03(\x04\t\
    \n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03(\x0c\r\n*\n\x04\x04\0\x02\0\
    \x12\x03,\x02!\x1a\x1d\x20Post-patch\x20reboot\x20settings.\n\n\x0c\n\
    \x05\x04\0\x02\0\x06\x12\x03,\x02\x0e\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03,\x0f\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03,\x1f\x20\n\xb0\x01\n\
    \x04\x04\0\x02\x01\x12\x031\x02#\x1a\xa2\x01\x20Retry\x20strategy\x20can\
    \x20be\x20defined\x20to\x20have\x20the\x20agent\x20retry\x20patching\n\
    \x20during\x20the\x20window\x20if\x20patching\x20fails.\x20If\x20omitted\
    ,\x20the\x20agent\x20will\x20use\x20its\n\x20default\x20retry\x20strateg\
    y.\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x031\x02\x0f\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x031\x10\x1e\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x031!\"\
    \nR\n\x04\x04\0\x02\x02\x12\x034\x02\x16\x1aE\x20Apt\x20update\x20settin\
    gs.\x20Use\x20this\x20override\x20the\x20default\x20apt\x20patch\x20rule\
    s.\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x034\x02\r\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x034\x0e\x11\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x034\x14\x15\
    \nR\n\x04\x04\0\x02\x03\x12\x037\x02\x16\x1aE\x20Yum\x20update\x20settin\
    gs.\x20Use\x20this\x20override\x20the\x20default\x20yum\x20patch\x20rule\
    s.\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x037\x02\r\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x037\x0e\x11\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x037\x14\x15\
    \nR\n\x04\x04\0\x02\x04\x12\x03:\x02\x16\x1aE\x20Goo\x20update\x20settin\
    gs.\x20Use\x20this\x20override\x20the\x20default\x20goo\x20patch\x20rule\
    s.\n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03:\x02\r\n\x0c\n\x05\x04\0\x02\
    \x04\x01\x12\x03:\x0e\x11\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03:\x14\x15\
    \nX\n\x04\x04\0\x02\x05\x12\x03=\x02\x1c\x1aK\x20Zypper\x20update\x20set\
    tings.\x20Use\x20this\x20override\x20the\x20default\x20zypper\x20patch\
    \x20rules.\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03=\x02\x10\n\x0c\n\x05\
    \x04\0\x02\x05\x01\x12\x03=\x11\x17\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x03=\x1a\x1b\nZ\n\x04\x04\0\x02\x06\x12\x03@\x02+\x1aM\x20Windows\x20up\
    date\x20settings.\x20Use\x20this\x20override\x20the\x20default\x20window\
    s\x20patch\x20rules.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03@\x02\x17\n\
    \x0c\n\x05\x04\0\x02\x06\x01\x12\x03@\x18&\n\x0c\n\x05\x04\0\x02\x06\x03\
    \x12\x03@)*\n;\n\x04\x04\0\x02\x07\x12\x03C\x02\x18\x1a.\x20The\x20ExecS\
    tep\x20to\x20run\x20before\x20the\x20patch\x20update.\n\n\x0c\n\x05\x04\
    \0\x02\x07\x06\x12\x03C\x02\n\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03C\x0b\
    \x13\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03C\x16\x17\n:\n\x04\x04\0\x02\
    \x08\x12\x03F\x02\x19\x1a-\x20The\x20ExecStep\x20to\x20run\x20after\x20t\
    he\x20patch\x20update.\n\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03F\x02\n\n\
    \x0c\n\x05\x04\0\x02\x08\x01\x12\x03F\x0b\x14\n\x0c\n\x05\x04\0\x02\x08\
    \x03\x12\x03F\x17\x18\nM\n\x04\x04\0\x02\t\x12\x03I\x02\"\x1a@\x20Allows\
    \x20the\x20patch\x20job\x20to\x20run\x20on\x20Managed\x20instance\x20gro\
    ups\x20(MIGs).\n\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03I\x02\x06\n\x0c\n\
    \x05\x04\0\x02\t\x01\x12\x03I\x07\x1c\n\x0c\n\x05\x04\0\x02\t\x03\x12\
    \x03I\x1f!\n\x9f\x01\n\x02\x04\x01\x12\x04N\0g\x01\x1a\x92\x01\x20Apt\
    \x20patching\x20will\x20be\x20performed\x20by\x20executing\x20`apt-get\
    \x20update\x20&&\x20apt-get\n\x20upgrade`.\x20Additional\x20options\x20c\
    an\x20be\x20set\x20to\x20control\x20how\x20this\x20is\x20executed.\n\n\n\
    \n\x03\x04\x01\x01\x12\x03N\x08\x13\n\x1f\n\x04\x04\x01\x04\0\x12\x04P\
    \x02Y\x03\x1a\x11\x20Apt\x20patch\x20type.\n\n\x0c\n\x05\x04\x01\x04\0\
    \x01\x12\x03P\x07\x0b\n7\n\x06\x04\x01\x04\0\x02\0\x12\x03R\x04\x19\x1a(\
    \x20By\x20default,\x20upgrade\x20will\x20be\x20performed.\n\n\x0e\n\x07\
    \x04\x01\x04\0\x02\0\x01\x12\x03R\x04\x14\n\x0e\n\x07\x04\x01\x04\0\x02\
    \0\x02\x12\x03R\x17\x18\n-\n\x06\x04\x01\x04\0\x02\x01\x12\x03U\x04\r\
    \x1a\x1e\x20Runs\x20`apt-get\x20dist-upgrade`.\n\n\x0e\n\x07\x04\x01\x04\
    \0\x02\x01\x01\x12\x03U\x04\x08\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\
    \x12\x03U\x0b\x0c\n(\n\x06\x04\x01\x04\0\x02\x02\x12\x03X\x04\x10\x1a\
    \x19\x20Runs\x20`apt-get\x20upgrade`.\n\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x02\x01\x12\x03X\x04\x0b\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x03X\
    \x0e\x0f\nr\n\x04\x04\x01\x02\0\x12\x03]\x02\x10\x1ae\x20By\x20changing\
    \x20the\x20type\x20to\x20DIST,\x20the\x20patching\x20will\x20be\x20perfo\
    rmed\n\x20using\x20`apt-get\x20dist-upgrade`\x20instead.\n\n\x0c\n\x05\
    \x04\x01\x02\0\x06\x12\x03]\x02\x06\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03]\x07\x0b\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03]\x0e\x0f\n7\n\x04\
    \x04\x01\x02\x01\x12\x03`\x02\x1f\x1a*\x20List\x20of\x20packages\x20to\
    \x20exclude\x20from\x20update.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\
    `\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03`\x0b\x11\n\x0c\n\x05\x04\
    \x01\x02\x01\x01\x12\x03`\x12\x1a\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\
    \x03`\x1d\x1e\n\xf6\x01\n\x04\x04\x01\x02\x02\x12\x03f\x02)\x1a\xe8\x01\
    \x20An\x20exclusive\x20list\x20of\x20packages\x20to\x20be\x20updated.\
    \x20These\x20are\x20the\x20only\x20packages\n\x20that\x20will\x20be\x20u\
    pdated.\x20If\x20these\x20packages\x20are\x20not\x20installed,\x20they\
    \x20will\x20be\n\x20ignored.\x20This\x20field\x20cannot\x20be\x20specifi\
    ed\x20with\x20any\x20other\x20patch\x20configuration\n\x20fields.\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x04\x12\x03f\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x02\x05\x12\x03f\x0b\x11\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03f\x12$\
    \n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03f'(\n\xc5\x01\n\x02\x04\x02\x12\
    \x04m\0~\x01\x1a\xb8\x01\x20Yum\x20patching\x20will\x20be\x20performed\
    \x20by\x20executing\x20`yum\x20update`.\x20Additional\x20options\n\x20ca\
    n\x20be\x20set\x20to\x20control\x20how\x20this\x20is\x20executed.\n\n\
    \x20Note\x20that\x20not\x20all\x20settings\x20are\x20supported\x20on\x20\
    all\x20platforms.\n\n\n\n\x03\x04\x02\x01\x12\x03m\x08\x13\n[\n\x04\x04\
    \x02\x02\0\x12\x03p\x02\x14\x1aN\x20Adds\x20the\x20`--security`\x20flag\
    \x20to\x20`yum\x20update`.\x20Not\x20supported\x20on\n\x20all\x20platfor\
    ms.\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03p\x02\x06\n\x0c\n\x05\x04\x02\
    \x02\0\x01\x12\x03p\x07\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03p\x12\
    \x13\nD\n\x04\x04\x02\x02\x01\x12\x03s\x02\x13\x1a7\x20Will\x20cause\x20\
    patch\x20to\x20run\x20`yum\x20update-minimal`\x20instead.\n\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03s\x02\x06\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03s\x07\x0e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03s\x11\x12\n{\n\
    \x04\x04\x02\x02\x02\x12\x03w\x02\x1f\x1an\x20List\x20of\x20packages\x20\
    to\x20exclude\x20from\x20update.\x20These\x20packages\x20will\x20be\x20e\
    xcluded\x20by\n\x20using\x20the\x20yum\x20`--exclude`\x20flag.\n\n\x0c\n\
    \x05\x04\x02\x02\x02\x04\x12\x03w\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03w\x0b\x11\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03w\x12\x1a\n\x0c\
    \n\x05\x04\x02\x02\x02\x03\x12\x03w\x1d\x1e\n\xf8\x01\n\x04\x04\x02\x02\
    \x03\x12\x03}\x02)\x1a\xea\x01\x20An\x20exclusive\x20list\x20of\x20packa\
    ges\x20to\x20be\x20updated.\x20These\x20are\x20the\x20only\x20packages\n\
    \x20that\x20will\x20be\x20updated.\x20If\x20these\x20packages\x20are\x20\
    not\x20installed,\x20they\x20will\x20be\n\x20ignored.\x20This\x20field\
    \x20must\x20not\x20be\x20specified\x20with\x20any\x20other\x20patch\n\
    \x20configuration\x20fields.\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03}\
    \x02\n\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03}\x0b\x11\n\x0c\n\x05\x04\
    \x02\x02\x03\x01\x12\x03}\x12$\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03}'\
    (\nH\n\x02\x04\x03\x12\x06\x81\x01\0\x83\x01\x01\x1a:\x20Googet\x20patch\
    ing\x20is\x20performed\x20by\x20running\x20`googet\x20update`.\n\n\x0b\n\
    \x03\x04\x03\x01\x12\x04\x81\x01\x08\x13\n|\n\x02\x04\x04\x12\x06\x87\
    \x01\0\x9d\x01\x01\x1an\x20Zypper\x20patching\x20is\x20performed\x20by\
    \x20running\x20`zypper\x20patch`.\n\x20See\x20also\x20https://en.opensus\
    e.org/SDB:Zypper_manual.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x87\x01\x08\
    \x16\nB\n\x04\x04\x04\x02\0\x12\x04\x89\x01\x02\x19\x1a4\x20Adds\x20the\
    \x20`--with-optional`\x20flag\x20to\x20`zypper\x20patch`.\n\n\r\n\x05\
    \x04\x04\x02\0\x05\x12\x04\x89\x01\x02\x06\n\r\n\x05\x04\x04\x02\0\x01\
    \x12\x04\x89\x01\x07\x14\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x89\x01\x17\
    \x18\nA\n\x04\x04\x04\x02\x01\x12\x04\x8c\x01\x02\x17\x1a3\x20Adds\x20th\
    e\x20`--with-update`\x20flag,\x20to\x20`zypper\x20patch`.\n\n\r\n\x05\
    \x04\x04\x02\x01\x05\x12\x04\x8c\x01\x02\x06\n\r\n\x05\x04\x04\x02\x01\
    \x01\x12\x04\x8c\x01\x07\x12\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x8c\
    \x01\x15\x16\nz\n\x04\x04\x04\x02\x02\x12\x04\x90\x01\x02!\x1al\x20Insta\
    ll\x20only\x20patches\x20with\x20these\x20categories.\n\x20Common\x20cat\
    egories\x20include\x20security,\x20recommended,\x20and\x20feature.\n\n\r\
    \n\x05\x04\x04\x02\x02\x04\x12\x04\x90\x01\x02\n\n\r\n\x05\x04\x04\x02\
    \x02\x05\x12\x04\x90\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\
    \x90\x01\x12\x1c\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x90\x01\x1f\x20\n\
    ~\n\x04\x04\x04\x02\x03\x12\x04\x94\x01\x02!\x1ap\x20Install\x20only\x20\
    patches\x20with\x20these\x20severities.\n\x20Common\x20severities\x20inc\
    lude\x20critical,\x20important,\x20moderate,\x20and\x20low.\n\n\r\n\x05\
    \x04\x04\x02\x03\x04\x12\x04\x94\x01\x02\n\n\r\n\x05\x04\x04\x02\x03\x05\
    \x12\x04\x94\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\x94\x01\
    \x12\x1c\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\x94\x01\x1f\x20\n7\n\x04\
    \x04\x04\x02\x04\x12\x04\x97\x01\x02\x1f\x1a)\x20List\x20of\x20patches\
    \x20to\x20exclude\x20from\x20update.\n\n\r\n\x05\x04\x04\x02\x04\x04\x12\
    \x04\x97\x01\x02\n\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\x97\x01\x0b\x11\
    \n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\x97\x01\x12\x1a\n\r\n\x05\x04\x04\
    \x02\x04\x03\x12\x04\x97\x01\x1d\x1e\n\xe8\x01\n\x04\x04\x04\x02\x05\x12\
    \x04\x9c\x01\x02(\x1a\xd9\x01\x20An\x20exclusive\x20list\x20of\x20patche\
    s\x20to\x20be\x20updated.\x20These\x20are\x20the\x20only\x20patches\n\
    \x20that\x20will\x20be\x20installed\x20using\x20'zypper\x20patch\x20patc\
    h:<patch_name>'\x20command.\n\x20This\x20field\x20must\x20not\x20be\x20u\
    sed\x20with\x20any\x20other\x20patch\x20configuration\x20fields.\n\n\r\n\
    \x05\x04\x04\x02\x05\x04\x12\x04\x9c\x01\x02\n\n\r\n\x05\x04\x04\x02\x05\
    \x05\x12\x04\x9c\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\x9c\
    \x01\x12#\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\x9c\x01&'\nM\n\x02\x04\
    \x05\x12\x06\xa0\x01\0\xe0\x01\x01\x1a?\x20Windows\x20patching\x20is\x20\
    performed\x20using\x20the\x20Windows\x20Update\x20Agent.\n\n\x0b\n\x03\
    \x04\x05\x01\x12\x04\xa0\x01\x08\x1d\n\xc6\x01\n\x04\x04\x05\x04\0\x12\
    \x06\xa4\x01\x02\xd3\x01\x03\x1a\xb5\x01\x20Microsoft\x20Windows\x20upda\
    te\x20classifications\x20as\x20defined\x20in\n\x20[1]\n\x20https://suppo\
    rt.microsoft.com/en-us/help/824684/description-of-the-standard-terminolo\
    gy-that-is-used-to-describe-micro\n\n\r\n\x05\x04\x05\x04\0\x01\x12\x04\
    \xa4\x01\x07\x15\nS\n\x06\x04\x05\x04\0\x02\0\x12\x04\xa6\x01\x04#\x1aC\
    \x20Invalid.\x20If\x20classifications\x20are\x20included,\x20they\x20mus\
    t\x20be\x20specified.\n\n\x0f\n\x07\x04\x05\x04\0\x02\0\x01\x12\x04\xa6\
    \x01\x04\x1e\n\x0f\n\x07\x04\x05\x04\0\x02\0\x02\x12\x04\xa6\x01!\"\nz\n\
    \x06\x04\x05\x04\0\x02\x01\x12\x04\xaa\x01\x04\x11\x1aj\x20\"A\x20widely\
    \x20released\x20fix\x20for\x20a\x20specific\x20problem\x20that\x20addres\
    ses\x20a\x20critical,\n\x20non-security-related\x20bug.\"\x20[1]\n\n\x0f\
    \n\x07\x04\x05\x04\0\x02\x01\x01\x12\x04\xaa\x01\x04\x0c\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x01\x02\x12\x04\xaa\x01\x0f\x10\n\x8d\x02\n\x06\x04\x05\
    \x04\0\x02\x02\x12\x04\xb0\x01\x04\x11\x1a\xfc\x01\x20\"A\x20widely\x20r\
    eleased\x20fix\x20for\x20a\x20product-specific,\x20security-related\n\
    \x20vulnerability.\x20Security\x20vulnerabilities\x20are\x20rated\x20by\
    \x20their\x20severity.\x20The\n\x20severity\x20rating\x20is\x20indicated\
    \x20in\x20the\x20Microsoft\x20security\x20bulletin\x20as\n\x20critical,\
    \x20important,\x20moderate,\x20or\x20low.\"\x20[1]\n\n\x0f\n\x07\x04\x05\
    \x04\0\x02\x02\x01\x12\x04\xb0\x01\x04\x0c\n\x0f\n\x07\x04\x05\x04\0\x02\
    \x02\x02\x12\x04\xb0\x01\x0f\x10\n\x96\x02\n\x06\x04\x05\x04\0\x02\x03\
    \x12\x04\xb6\x01\x04\x13\x1a\x85\x02\x20\"A\x20widely\x20released\x20and\
    \x20frequent\x20software\x20update\x20that\x20contains\x20additions\n\
    \x20to\x20a\x20product\xe2\x80\x99s\x20definition\x20database.\x20Defini\
    tion\x20databases\x20are\x20often\x20used\n\x20to\x20detect\x20objects\
    \x20that\x20have\x20specific\x20attributes,\x20such\x20as\x20malicious\
    \x20code,\n\x20phishing\x20websites,\x20or\x20junk\x20mail.\"\x20[1]\n\n\
    \x0f\n\x07\x04\x05\x04\0\x02\x03\x01\x12\x04\xb6\x01\x04\x0e\n\x0f\n\x07\
    \x04\x05\x04\0\x02\x03\x02\x12\x04\xb6\x01\x11\x12\nP\n\x06\x04\x05\x04\
    \0\x02\x04\x12\x04\xb9\x01\x04\x0f\x1a@\x20\"Software\x20that\x20control\
    s\x20the\x20input\x20and\x20output\x20of\x20a\x20device.\"\x20[1]\n\n\
    \x0f\n\x07\x04\x05\x04\0\x02\x04\x01\x12\x04\xb9\x01\x04\n\n\x0f\n\x07\
    \x04\x05\x04\0\x02\x04\x02\x12\x04\xb9\x01\r\x0e\n\xb8\x01\n\x06\x04\x05\
    \x04\0\x02\x05\x12\x04\xbe\x01\x04\x15\x1a\xa7\x01\x20\"New\x20product\
    \x20functionality\x20that\x20is\x20first\x20distributed\x20outside\x20th\
    e\x20context\n\x20of\x20a\x20product\x20release\x20and\x20that\x20is\x20\
    typically\x20included\x20in\x20the\x20next\x20full\n\x20product\x20relea\
    se.\"\x20[1]\n\n\x0f\n\x07\x04\x05\x04\0\x02\x05\x01\x12\x04\xbe\x01\x04\
    \x10\n\x0f\n\x07\x04\x05\x04\0\x02\x05\x02\x12\x04\xbe\x01\x13\x14\n\xda\
    \x02\n\x06\x04\x05\x04\0\x02\x06\x12\x04\xc5\x01\x04\x15\x1a\xc9\x02\x20\
    \"A\x20tested,\x20cumulative\x20set\x20of\x20all\x20hotfixes,\x20securit\
    y\x20updates,\x20critical\n\x20updates,\x20and\x20updates.\x20Additional\
    ly,\x20service\x20packs\x20may\x20contain\x20additional\n\x20fixes\x20fo\
    r\x20problems\x20that\x20are\x20found\x20internally\x20since\x20the\x20r\
    elease\x20of\x20the\n\x20product.\x20Service\x20packs\x20my\x20also\x20c\
    ontain\x20a\x20limited\x20number\x20of\n\x20customer-requested\x20design\
    \x20changes\x20or\x20features.\"\x20[1]\n\n\x0f\n\x07\x04\x05\x04\0\x02\
    \x06\x01\x12\x04\xc5\x01\x04\x10\n\x0f\n\x07\x04\x05\x04\0\x02\x06\x02\
    \x12\x04\xc5\x01\x13\x14\nX\n\x06\x04\x05\x04\0\x02\x07\x12\x04\xc8\x01\
    \x04\r\x1aH\x20\"A\x20utility\x20or\x20feature\x20that\x20helps\x20compl\
    ete\x20a\x20task\x20or\x20set\x20of\x20tasks.\"\x20[1]\n\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x07\x01\x12\x04\xc8\x01\x04\x08\n\x0f\n\x07\x04\x05\x04\0\
    \x02\x07\x02\x12\x04\xc8\x01\x0b\x0c\n\xa9\x02\n\x06\x04\x05\x04\0\x02\
    \x08\x12\x04\xce\x01\x04\x16\x1a\x98\x02\x20\"A\x20tested,\x20cumulative\
    \x20set\x20of\x20hotfixes,\x20security\x20updates,\x20critical\n\x20upda\
    tes,\x20and\x20updates\x20that\x20are\x20packaged\x20together\x20for\x20\
    easy\x20deployment.\x20A\n\x20rollup\x20generally\x20targets\x20a\x20spe\
    cific\x20area,\x20such\x20as\x20security,\x20or\x20a\n\x20component\x20o\
    f\x20a\x20product,\x20such\x20as\x20Internet\x20Information\x20Services\
    \x20(IIS).\"\x20[1]\n\n\x0f\n\x07\x04\x05\x04\0\x02\x08\x01\x12\x04\xce\
    \x01\x04\x11\n\x0f\n\x07\x04\x05\x04\0\x02\x08\x02\x12\x04\xce\x01\x14\
    \x15\n\x83\x01\n\x06\x04\x05\x04\0\x02\t\x12\x04\xd2\x01\x04\x0f\x1as\
    \x20\"A\x20widely\x20released\x20fix\x20for\x20a\x20specific\x20problem.\
    \x20An\x20update\x20addresses\x20a\n\x20noncritical,\x20non-security-rel\
    ated\x20bug.\"\x20[1]\n\n\x0f\n\x07\x04\x05\x04\0\x02\t\x01\x12\x04\xd2\
    \x01\x04\n\n\x0f\n\x07\x04\x05\x04\0\x02\t\x02\x12\x04\xd2\x01\r\x0e\ns\
    \n\x04\x04\x05\x02\0\x12\x04\xd7\x01\x02.\x1ae\x20Only\x20apply\x20updat\
    es\x20of\x20these\x20windows\x20update\x20classifications.\x20If\x20empt\
    y,\x20all\n\x20updates\x20will\x20be\x20applied.\n\n\r\n\x05\x04\x05\x02\
    \0\x04\x12\x04\xd7\x01\x02\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xd7\x01\
    \x0b\x19\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xd7\x01\x1a)\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\xd7\x01,-\n3\n\x04\x04\x05\x02\x01\x12\x04\xda\
    \x01\x02\x1f\x1a%\x20List\x20of\x20KBs\x20to\x20exclude\x20from\x20updat\
    e.\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xda\x01\x02\n\n\r\n\x05\x04\
    \x05\x02\x01\x05\x12\x04\xda\x01\x0b\x11\n\r\n\x05\x04\x05\x02\x01\x01\
    \x12\x04\xda\x01\x12\x1a\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xda\x01\
    \x1d\x1e\n\xa8\x01\n\x04\x04\x05\x02\x02\x12\x04\xdf\x01\x02(\x1a\x99\
    \x01\x20An\x20exclusive\x20list\x20of\x20kbs\x20to\x20be\x20updated.\x20\
    These\x20are\x20the\x20only\x20patches\n\x20that\x20will\x20be\x20update\
    d.\x20This\x20field\x20must\x20not\x20be\x20used\x20with\x20other\n\x20p\
    atch\x20configurations.\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xdf\x01\
    \x02\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xdf\x01\x0b\x11\n\r\n\x05\
    \x04\x05\x02\x02\x01\x12\x04\xdf\x01\x12#\n\r\n\x05\x04\x05\x02\x02\x03\
    \x12\x04\xdf\x01&'\nQ\n\x02\x04\x06\x12\x06\xe3\x01\0\xe7\x01\x01\x1aC\
    \x20The\x20strategy\x20for\x20retrying\x20failed\x20patches\x20during\
    \x20the\x20patch\x20window.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xe3\x01\
    \x08\x15\n^\n\x04\x04\x06\x02\0\x12\x04\xe6\x01\x02\x13\x1aP\x20If\x20tr\
    ue,\x20the\x20agent\x20will\x20continue\x20to\x20try\x20and\x20patch\x20\
    until\x20the\x20window\x20has\n\x20ended.\n\n\r\n\x05\x04\x06\x02\0\x05\
    \x12\x04\xe6\x01\x02\x06\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xe6\x01\x07\
    \x0e\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xe6\x01\x11\x12\n>\n\x02\x04\
    \x07\x12\x06\xea\x01\0\xf0\x01\x01\x1a0\x20A\x20step\x20that\x20runs\x20\
    an\x20executable\x20for\x20a\x20PatchJob.\n\n\x0b\n\x03\x04\x07\x01\x12\
    \x04\xea\x01\x08\x10\nN\n\x04\x04\x07\x02\0\x12\x04\xec\x01\x02,\x1a@\
    \x20The\x20ExecStepConfig\x20for\x20all\x20Linux\x20VMs\x20targeted\x20b\
    y\x20the\x20PatchJob.\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xec\x01\x02\
    \x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xec\x01\x11'\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\xec\x01*+\nP\n\x04\x04\x07\x02\x01\x12\x04\xef\x01\
    \x02.\x1aB\x20The\x20ExecStepConfig\x20for\x20all\x20Windows\x20VMs\x20t\
    argeted\x20by\x20the\x20PatchJob.\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\
    \x04\xef\x01\x02\x10\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xef\x01\x11)\
    \n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xef\x01,-\n6\n\x02\x04\x08\x12\
    \x06\xf3\x01\0\x98\x02\x01\x1a(\x20Common\x20configurations\x20for\x20an\
    \x20ExecStep.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xf3\x01\x08\x16\n=\n\x04\
    \x04\x08\x04\0\x12\x06\xf5\x01\x02\x84\x02\x03\x1a-\x20The\x20interprete\
    r\x20used\x20to\x20execute\x20the\x20a\x20file.\n\n\r\n\x05\x04\x08\x04\
    \0\x01\x12\x04\xf5\x01\x07\x12\nI\n\x06\x04\x08\x04\0\x02\0\x12\x04\xf7\
    \x01\x04\x20\x1a9\x20Deprecated,\x20defaults\x20to\x20NONE\x20for\x20com\
    patibility\x20reasons.\n\n\x0f\n\x07\x04\x08\x04\0\x02\0\x01\x12\x04\xf7\
    \x01\x04\x1b\n\x0f\n\x07\x04\x08\x04\0\x02\0\x02\x12\x04\xf7\x01\x1e\x1f\
    \n\xa9\x01\n\x06\x04\x08\x04\0\x02\x01\x12\x04\xfc\x01\x04\r\x1a\x98\x01\
    \x20Invalid\x20for\x20a\x20Windows\x20ExecStepConfig.\x20For\x20a\x20Lin\
    ux\x20ExecStepConfig,\x20the\n\x20interpreter\x20will\x20be\x20parsed\
    \x20from\x20the\x20shebang\x20line\x20of\x20the\x20script\x20if\n\x20uns\
    pecified.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x04\xfc\x01\x04\
    \x08\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x02\x12\x04\xfc\x01\x0b\x0c\nb\n\
    \x06\x04\x08\x04\0\x02\x02\x12\x04\x80\x02\x04\x0e\x1aR\x20Indicates\x20\
    that\x20the\x20script\x20will\x20be\x20run\x20with\x20/bin/sh\x20on\x20L\
    inux\x20and\x20cmd\n\x20on\x20windows.\n\n\x0f\n\x07\x04\x08\x04\0\x02\
    \x02\x01\x12\x04\x80\x02\x04\t\n\x0f\n\x07\x04\x08\x04\0\x02\x02\x02\x12\
    \x04\x80\x02\x0c\r\nF\n\x06\x04\x08\x04\0\x02\x03\x12\x04\x83\x02\x04\
    \x13\x1a6\x20Indicates\x20that\x20the\x20file\x20will\x20be\x20run\x20wi\
    th\x20PowerShell.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x01\x12\x04\x83\
    \x02\x04\x0e\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x02\x12\x04\x83\x02\x11\
    \x12\n-\n\x04\x04\x08\x08\0\x12\x06\x87\x02\x02\x8d\x02\x03\x1a\x1d\x20L\
    ocation\x20of\x20the\x20executable.\n\n\r\n\x05\x04\x08\x08\0\x01\x12\
    \x04\x87\x02\x08\x12\n=\n\x04\x04\x08\x02\0\x12\x04\x89\x02\x04\x1a\x1a/\
    \x20An\x20absolute\x20path\x20to\x20the\x20executable\x20on\x20the\x20VM\
    .\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x89\x02\x04\n\n\r\n\x05\x04\x08\
    \x02\0\x01\x12\x04\x89\x02\x0b\x15\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\
    \x89\x02\x18\x19\n7\n\x04\x04\x08\x02\x01\x12\x04\x8c\x02\x04\x1d\x1a)\
    \x20A\x20GCS\x20object\x20containing\x20the\x20executable.\n\n\r\n\x05\
    \x04\x08\x02\x01\x06\x12\x04\x8c\x02\x04\r\n\r\n\x05\x04\x08\x02\x01\x01\
    \x12\x04\x8c\x02\x0e\x18\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x8c\x02\
    \x1b\x1c\nw\n\x04\x04\x08\x02\x02\x12\x04\x91\x02\x02+\x1ai\x20Defaults\
    \x20to\x20[0].\x20A\x20list\x20of\x20possible\x20return\x20values\x20tha\
    t\x20the\n\x20execution\x20can\x20return\x20to\x20indicate\x20a\x20succe\
    ss.\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x91\x02\x02\n\n\r\n\x05\x04\
    \x08\x02\x02\x05\x12\x04\x91\x02\x0b\x10\n\r\n\x05\x04\x08\x02\x02\x01\
    \x12\x04\x91\x02\x11&\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x91\x02)*\n\
    \x8b\x02\n\x04\x04\x08\x02\x03\x12\x04\x97\x02\x02\x1e\x1a\xfc\x01\x20Th\
    e\x20script\x20interpreter\x20to\x20use\x20to\x20run\x20the\x20script.\
    \x20If\x20no\x20interpreter\x20is\n\x20specified\x20the\x20script\x20wil\
    l\x20be\x20executed\x20directly,\x20which\x20will\x20likely\n\x20only\
    \x20succeed\x20for\x20scripts\x20with\x20shebang\x20lines.\n\x20[Wikiped\
    ia\x20shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).\n\n\r\n\
    \x05\x04\x08\x02\x03\x06\x12\x04\x97\x02\x02\r\n\r\n\x05\x04\x08\x02\x03\
    \x01\x12\x04\x97\x02\x0e\x19\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\x97\
    \x02\x1c\x1d\n*\n\x02\x04\t\x12\x06\x9b\x02\0\xa5\x02\x01\x1a\x1c\x20GCS\
    \x20object\x20representation.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x9b\x02\
    \x08\x11\n)\n\x04\x04\t\x02\0\x12\x04\x9d\x02\x02\x14\x1a\x1b\x20Bucket\
    \x20of\x20the\x20GCS\x20object.\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x9d\
    \x02\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x9d\x02\t\x0f\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\x9d\x02\x12\x13\n'\n\x04\x04\t\x02\x01\x12\x04\
    \xa0\x02\x02\x14\x1a\x19\x20Name\x20of\x20the\x20GCS\x20object.\n\n\r\n\
    \x05\x04\t\x02\x01\x05\x12\x04\xa0\x02\x02\x08\n\r\n\x05\x04\t\x02\x01\
    \x01\x12\x04\xa0\x02\t\x0f\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xa0\x02\
    \x12\x13\n\x8a\x01\n\x04\x04\t\x02\x02\x12\x04\xa4\x02\x02\x1e\x1a|\x20G\
    eneration\x20number\x20of\x20the\x20GCS\x20object.\x20This\x20is\x20used\
    \x20to\x20ensure\x20that\x20the\n\x20ExecStep\x20specified\x20by\x20this\
    \x20PatchJob\x20does\x20not\x20change.\n\n\r\n\x05\x04\t\x02\x02\x05\x12\
    \x04\xa4\x02\x02\x07\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xa4\x02\x08\x19\
    \n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xa4\x02\x1c\x1db\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
