// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/spanner/v1/spanner.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

///  The request for [CreateSession][google.spanner.v1.Spanner.CreateSession].
// @@protoc_insertion_point(message:google.spanner.v1.CreateSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateSessionRequest {
    // message fields
    ///  Required. The database in which the new session is created.
    // @@protoc_insertion_point(field:google.spanner.v1.CreateSessionRequest.database)
    pub database: ::std::string::String,
    ///  The session to create.
    // @@protoc_insertion_point(field:google.spanner.v1.CreateSessionRequest.session)
    pub session: ::protobuf::MessageField<Session>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.CreateSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSessionRequest {
    fn default() -> &'a CreateSessionRequest {
        <CreateSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSessionRequest {
    pub fn new() -> CreateSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "database",
            |m: &CreateSessionRequest| { &m.database },
            |m: &mut CreateSessionRequest| { &mut m.database },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Session>(
            "session",
            |m: &CreateSessionRequest| { &m.session },
            |m: &mut CreateSessionRequest| { &mut m.session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSessionRequest>(
            "CreateSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSessionRequest {
    const NAME: &'static str = "CreateSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.database = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.session)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        if let Some(v) = self.session.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        if let Some(v) = self.session.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSessionRequest {
        CreateSessionRequest::new()
    }

    fn clear(&mut self) {
        self.database.clear();
        self.session.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSessionRequest {
        static instance: CreateSessionRequest = CreateSessionRequest {
            database: ::std::string::String::new(),
            session: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for
///  [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].
// @@protoc_insertion_point(message:google.spanner.v1.BatchCreateSessionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BatchCreateSessionsRequest {
    // message fields
    ///  Required. The database in which the new sessions are created.
    // @@protoc_insertion_point(field:google.spanner.v1.BatchCreateSessionsRequest.database)
    pub database: ::std::string::String,
    ///  Parameters to be applied to each created session.
    // @@protoc_insertion_point(field:google.spanner.v1.BatchCreateSessionsRequest.session_template)
    pub session_template: ::protobuf::MessageField<Session>,
    ///  Required. The number of sessions to be created in this batch call.
    ///  The API may return fewer than the requested number of sessions. If a
    ///  specific number of sessions are desired, the client can make additional
    ///  calls to BatchCreateSessions (adjusting
    ///  [session_count][google.spanner.v1.BatchCreateSessionsRequest.session_count]
    ///  as necessary).
    // @@protoc_insertion_point(field:google.spanner.v1.BatchCreateSessionsRequest.session_count)
    pub session_count: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.BatchCreateSessionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BatchCreateSessionsRequest {
    fn default() -> &'a BatchCreateSessionsRequest {
        <BatchCreateSessionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchCreateSessionsRequest {
    pub fn new() -> BatchCreateSessionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "database",
            |m: &BatchCreateSessionsRequest| { &m.database },
            |m: &mut BatchCreateSessionsRequest| { &mut m.database },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Session>(
            "session_template",
            |m: &BatchCreateSessionsRequest| { &m.session_template },
            |m: &mut BatchCreateSessionsRequest| { &mut m.session_template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_count",
            |m: &BatchCreateSessionsRequest| { &m.session_count },
            |m: &mut BatchCreateSessionsRequest| { &mut m.session_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BatchCreateSessionsRequest>(
            "BatchCreateSessionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BatchCreateSessionsRequest {
    const NAME: &'static str = "BatchCreateSessionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.database = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.session_template)?;
                },
                24 => {
                    self.session_count = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        if let Some(v) = self.session_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.session_count != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.session_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        if let Some(v) = self.session_template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.session_count != 0 {
            os.write_int32(3, self.session_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BatchCreateSessionsRequest {
        BatchCreateSessionsRequest::new()
    }

    fn clear(&mut self) {
        self.database.clear();
        self.session_template.clear();
        self.session_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BatchCreateSessionsRequest {
        static instance: BatchCreateSessionsRequest = BatchCreateSessionsRequest {
            database: ::std::string::String::new(),
            session_template: ::protobuf::MessageField::none(),
            session_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BatchCreateSessionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BatchCreateSessionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BatchCreateSessionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchCreateSessionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The response for
///  [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].
// @@protoc_insertion_point(message:google.spanner.v1.BatchCreateSessionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BatchCreateSessionsResponse {
    // message fields
    ///  The freshly created sessions.
    // @@protoc_insertion_point(field:google.spanner.v1.BatchCreateSessionsResponse.session)
    pub session: ::std::vec::Vec<Session>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.BatchCreateSessionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BatchCreateSessionsResponse {
    fn default() -> &'a BatchCreateSessionsResponse {
        <BatchCreateSessionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchCreateSessionsResponse {
    pub fn new() -> BatchCreateSessionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session",
            |m: &BatchCreateSessionsResponse| { &m.session },
            |m: &mut BatchCreateSessionsResponse| { &mut m.session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BatchCreateSessionsResponse>(
            "BatchCreateSessionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BatchCreateSessionsResponse {
    const NAME: &'static str = "BatchCreateSessionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.session {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.session {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BatchCreateSessionsResponse {
        BatchCreateSessionsResponse::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BatchCreateSessionsResponse {
        static instance: BatchCreateSessionsResponse = BatchCreateSessionsResponse {
            session: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BatchCreateSessionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BatchCreateSessionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BatchCreateSessionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchCreateSessionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A session in the Cloud Spanner API.
// @@protoc_insertion_point(message:google.spanner.v1.Session)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Session {
    // message fields
    ///  The name of the session. This is always system-assigned; values provided
    ///  when creating a session are ignored.
    // @@protoc_insertion_point(field:google.spanner.v1.Session.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:google.spanner.v1.Session.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  Output only. The timestamp when the session is created.
    // @@protoc_insertion_point(field:google.spanner.v1.Session.create_time)
    pub create_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Output only. The approximate timestamp when the session is last used. It is
    ///  typically earlier than the actual last use time.
    // @@protoc_insertion_point(field:google.spanner.v1.Session.approximate_last_use_time)
    pub approximate_last_use_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.Session.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Session {
    fn default() -> &'a Session {
        <Session as ::protobuf::Message>::default_instance()
    }
}

impl Session {
    pub fn new() -> Session {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Session| { &m.name },
            |m: &mut Session| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &Session| { &m.labels },
            |m: &mut Session| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "create_time",
            |m: &Session| { &m.create_time },
            |m: &mut Session| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "approximate_last_use_time",
            |m: &Session| { &m.approximate_last_use_time },
            |m: &mut Session| { &mut m.approximate_last_use_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Session>(
            "Session",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Session {
    const NAME: &'static str = "Session";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.create_time)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.approximate_last_use_time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.approximate_last_use_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.create_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.approximate_last_use_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Session {
        Session::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.labels.clear();
        self.create_time.clear();
        self.approximate_last_use_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Session {
        static instance: ::protobuf::rt::Lazy<Session> = ::protobuf::rt::Lazy::new();
        instance.get(Session::new)
    }
}

impl ::protobuf::MessageFull for Session {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Session").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Session {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Session {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [GetSession][google.spanner.v1.Spanner.GetSession].
// @@protoc_insertion_point(message:google.spanner.v1.GetSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSessionRequest {
    // message fields
    ///  Required. The name of the session to retrieve.
    // @@protoc_insertion_point(field:google.spanner.v1.GetSessionRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.GetSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSessionRequest {
    fn default() -> &'a GetSessionRequest {
        <GetSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSessionRequest {
    pub fn new() -> GetSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GetSessionRequest| { &m.name },
            |m: &mut GetSessionRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSessionRequest>(
            "GetSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSessionRequest {
    const NAME: &'static str = "GetSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSessionRequest {
        GetSessionRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSessionRequest {
        static instance: GetSessionRequest = GetSessionRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [ListSessions][google.spanner.v1.Spanner.ListSessions].
// @@protoc_insertion_point(message:google.spanner.v1.ListSessionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSessionsRequest {
    // message fields
    ///  Required. The database in which to list sessions.
    // @@protoc_insertion_point(field:google.spanner.v1.ListSessionsRequest.database)
    pub database: ::std::string::String,
    ///  Number of sessions to be returned in the response. If 0 or less, defaults
    ///  to the server's maximum allowed page size.
    // @@protoc_insertion_point(field:google.spanner.v1.ListSessionsRequest.page_size)
    pub page_size: i32,
    ///  If non-empty, `page_token` should contain a
    ///  [next_page_token][google.spanner.v1.ListSessionsResponse.next_page_token]
    ///  from a previous
    ///  [ListSessionsResponse][google.spanner.v1.ListSessionsResponse].
    // @@protoc_insertion_point(field:google.spanner.v1.ListSessionsRequest.page_token)
    pub page_token: ::std::string::String,
    // @@protoc_insertion_point(field:google.spanner.v1.ListSessionsRequest.filter)
    pub filter: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.ListSessionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSessionsRequest {
    fn default() -> &'a ListSessionsRequest {
        <ListSessionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionsRequest {
    pub fn new() -> ListSessionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "database",
            |m: &ListSessionsRequest| { &m.database },
            |m: &mut ListSessionsRequest| { &mut m.database },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListSessionsRequest| { &m.page_size },
            |m: &mut ListSessionsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListSessionsRequest| { &m.page_token },
            |m: &mut ListSessionsRequest| { &mut m.page_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filter",
            |m: &ListSessionsRequest| { &m.filter },
            |m: &mut ListSessionsRequest| { &mut m.filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSessionsRequest>(
            "ListSessionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSessionsRequest {
    const NAME: &'static str = "ListSessionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.database = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                34 => {
                    self.filter = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSessionsRequest {
        ListSessionsRequest::new()
    }

    fn clear(&mut self) {
        self.database.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSessionsRequest {
        static instance: ListSessionsRequest = ListSessionsRequest {
            database: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            filter: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSessionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSessionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSessionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The response for [ListSessions][google.spanner.v1.Spanner.ListSessions].
// @@protoc_insertion_point(message:google.spanner.v1.ListSessionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSessionsResponse {
    // message fields
    ///  The list of requested sessions.
    // @@protoc_insertion_point(field:google.spanner.v1.ListSessionsResponse.sessions)
    pub sessions: ::std::vec::Vec<Session>,
    ///  `next_page_token` can be sent in a subsequent
    ///  [ListSessions][google.spanner.v1.Spanner.ListSessions] call to fetch more
    ///  of the matching sessions.
    // @@protoc_insertion_point(field:google.spanner.v1.ListSessionsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.ListSessionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSessionsResponse {
    fn default() -> &'a ListSessionsResponse {
        <ListSessionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionsResponse {
    pub fn new() -> ListSessionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sessions",
            |m: &ListSessionsResponse| { &m.sessions },
            |m: &mut ListSessionsResponse| { &mut m.sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListSessionsResponse| { &m.next_page_token },
            |m: &mut ListSessionsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSessionsResponse>(
            "ListSessionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSessionsResponse {
    const NAME: &'static str = "ListSessionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sessions.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sessions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sessions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSessionsResponse {
        ListSessionsResponse::new()
    }

    fn clear(&mut self) {
        self.sessions.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSessionsResponse {
        static instance: ListSessionsResponse = ListSessionsResponse {
            sessions: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSessionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSessionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSessionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [DeleteSession][google.spanner.v1.Spanner.DeleteSession].
// @@protoc_insertion_point(message:google.spanner.v1.DeleteSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSessionRequest {
    // message fields
    ///  Required. The name of the session to delete.
    // @@protoc_insertion_point(field:google.spanner.v1.DeleteSessionRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.DeleteSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSessionRequest {
    fn default() -> &'a DeleteSessionRequest {
        <DeleteSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSessionRequest {
    pub fn new() -> DeleteSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeleteSessionRequest| { &m.name },
            |m: &mut DeleteSessionRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSessionRequest>(
            "DeleteSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSessionRequest {
    const NAME: &'static str = "DeleteSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSessionRequest {
        DeleteSessionRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSessionRequest {
        static instance: DeleteSessionRequest = DeleteSessionRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
///  [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql].
// @@protoc_insertion_point(message:google.spanner.v1.ExecuteSqlRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExecuteSqlRequest {
    // message fields
    ///  Required. The session in which the SQL query should be performed.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.session)
    pub session: ::std::string::String,
    ///  The transaction to use.
    ///
    ///  For queries, if none is provided, the default is a temporary read-only
    ///  transaction with strong concurrency.
    ///
    ///  Standard DML statements require a read-write transaction. To protect
    ///  against replays, single-use transactions are not supported.  The caller
    ///  must either supply an existing transaction ID or begin a new transaction.
    ///
    ///  Partitioned DML requires an existing Partitioned DML transaction ID.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.transaction)
    pub transaction: ::protobuf::MessageField<super::transaction::TransactionSelector>,
    ///  Required. The SQL string.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.sql)
    pub sql: ::std::string::String,
    ///  Parameter names and values that bind to placeholders in the SQL string.
    ///
    ///  A parameter placeholder consists of the `@` character followed by the
    ///  parameter name (for example, `@firstName`). Parameter names can contain
    ///  letters, numbers, and underscores.
    ///
    ///  Parameters can appear anywhere that a literal value is expected.  The same
    ///  parameter name can be used more than once, for example:
    ///
    ///  `"WHERE id > @msg_id AND id < @msg_id + 100"`
    ///
    ///  It is an error to execute a SQL statement with unbound parameters.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.params)
    pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  It is not always possible for Cloud Spanner to infer the right SQL type
    ///  from a JSON value.  For example, values of type `BYTES` and values
    ///  of type `STRING` both appear in
    ///  [params][google.spanner.v1.ExecuteSqlRequest.params] as JSON strings.
    ///
    ///  In these cases, `param_types` can be used to specify the exact
    ///  SQL type for some or all of the SQL statement parameters. See the
    ///  definition of [Type][google.spanner.v1.Type] for more information
    ///  about SQL types.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.param_types)
    pub param_types: ::std::collections::HashMap<::std::string::String, super::type_::Type>,
    ///  If this request is resuming a previously interrupted SQL statement
    ///  execution, `resume_token` should be copied from the last
    ///  [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the
    ///  interruption. Doing this enables the new SQL statement execution to resume
    ///  where the last one left off. The rest of the request parameters must
    ///  exactly match the request that yielded this token.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.resume_token)
    pub resume_token: ::std::vec::Vec<u8>,
    ///  Used to control the amount of debugging information returned in
    ///  [ResultSetStats][google.spanner.v1.ResultSetStats]. If
    ///  [partition_token][google.spanner.v1.ExecuteSqlRequest.partition_token] is
    ///  set, [query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode] can only
    ///  be set to
    ///  [QueryMode.NORMAL][google.spanner.v1.ExecuteSqlRequest.QueryMode.NORMAL].
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.query_mode)
    pub query_mode: ::protobuf::EnumOrUnknown<execute_sql_request::QueryMode>,
    ///  If present, results will be restricted to the specified partition
    ///  previously created using PartitionQuery().  There must be an exact
    ///  match for the values of fields common to this message and the
    ///  PartitionQueryRequest message used to create this partition_token.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.partition_token)
    pub partition_token: ::std::vec::Vec<u8>,
    ///  A per-transaction sequence number used to identify this request. This field
    ///  makes each request idempotent such that if the request is received multiple
    ///  times, at most one will succeed.
    ///
    ///  The sequence number must be monotonically increasing within the
    ///  transaction. If a request arrives for the first time with an out-of-order
    ///  sequence number, the transaction may be aborted. Replays of previously
    ///  handled requests will yield the same response as the first execution.
    ///
    ///  Required for DML statements. Ignored for queries.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteSqlRequest.seqno)
    pub seqno: i64,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.ExecuteSqlRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecuteSqlRequest {
    fn default() -> &'a ExecuteSqlRequest {
        <ExecuteSqlRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteSqlRequest {
    pub fn new() -> ExecuteSqlRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &ExecuteSqlRequest| { &m.session },
            |m: &mut ExecuteSqlRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::transaction::TransactionSelector>(
            "transaction",
            |m: &ExecuteSqlRequest| { &m.transaction },
            |m: &mut ExecuteSqlRequest| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sql",
            |m: &ExecuteSqlRequest| { &m.sql },
            |m: &mut ExecuteSqlRequest| { &mut m.sql },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "params",
            |m: &ExecuteSqlRequest| { &m.params },
            |m: &mut ExecuteSqlRequest| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "param_types",
            |m: &ExecuteSqlRequest| { &m.param_types },
            |m: &mut ExecuteSqlRequest| { &mut m.param_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resume_token",
            |m: &ExecuteSqlRequest| { &m.resume_token },
            |m: &mut ExecuteSqlRequest| { &mut m.resume_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query_mode",
            |m: &ExecuteSqlRequest| { &m.query_mode },
            |m: &mut ExecuteSqlRequest| { &mut m.query_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partition_token",
            |m: &ExecuteSqlRequest| { &m.partition_token },
            |m: &mut ExecuteSqlRequest| { &mut m.partition_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seqno",
            |m: &ExecuteSqlRequest| { &m.seqno },
            |m: &mut ExecuteSqlRequest| { &mut m.seqno },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteSqlRequest>(
            "ExecuteSqlRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecuteSqlRequest {
    const NAME: &'static str = "ExecuteSqlRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction)?;
                },
                26 => {
                    self.sql = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.param_types.insert(key, value);
                },
                50 => {
                    self.resume_token = is.read_bytes()?;
                },
                56 => {
                    self.query_mode = is.read_enum_or_unknown()?;
                },
                66 => {
                    self.partition_token = is.read_bytes()?;
                },
                72 => {
                    self.seqno = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        if let Some(v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.sql.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sql);
        }
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.param_types {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.resume_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.resume_token);
        }
        if self.query_mode != ::protobuf::EnumOrUnknown::new(execute_sql_request::QueryMode::NORMAL) {
            my_size += ::protobuf::rt::int32_size(7, self.query_mode.value());
        }
        if !self.partition_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.partition_token);
        }
        if self.seqno != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.seqno);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        if let Some(v) = self.transaction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.sql.is_empty() {
            os.write_string(3, &self.sql)?;
        }
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for (k, v) in &self.param_types {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.resume_token.is_empty() {
            os.write_bytes(6, &self.resume_token)?;
        }
        if self.query_mode != ::protobuf::EnumOrUnknown::new(execute_sql_request::QueryMode::NORMAL) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.query_mode))?;
        }
        if !self.partition_token.is_empty() {
            os.write_bytes(8, &self.partition_token)?;
        }
        if self.seqno != 0 {
            os.write_int64(9, self.seqno)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecuteSqlRequest {
        ExecuteSqlRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.transaction.clear();
        self.sql.clear();
        self.params.clear();
        self.param_types.clear();
        self.resume_token.clear();
        self.query_mode = ::protobuf::EnumOrUnknown::new(execute_sql_request::QueryMode::NORMAL);
        self.partition_token.clear();
        self.seqno = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecuteSqlRequest {
        static instance: ::protobuf::rt::Lazy<ExecuteSqlRequest> = ::protobuf::rt::Lazy::new();
        instance.get(ExecuteSqlRequest::new)
    }
}

impl ::protobuf::MessageFull for ExecuteSqlRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecuteSqlRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecuteSqlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteSqlRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExecuteSqlRequest`
pub mod execute_sql_request {
    ///  Mode in which the statement must be processed.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.spanner.v1.ExecuteSqlRequest.QueryMode)
    pub enum QueryMode {
        // @@protoc_insertion_point(enum_value:google.spanner.v1.ExecuteSqlRequest.QueryMode.NORMAL)
        NORMAL = 0,
        // @@protoc_insertion_point(enum_value:google.spanner.v1.ExecuteSqlRequest.QueryMode.PLAN)
        PLAN = 1,
        // @@protoc_insertion_point(enum_value:google.spanner.v1.ExecuteSqlRequest.QueryMode.PROFILE)
        PROFILE = 2,
    }

    impl ::protobuf::Enum for QueryMode {
        const NAME: &'static str = "QueryMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<QueryMode> {
            match value {
                0 => ::std::option::Option::Some(QueryMode::NORMAL),
                1 => ::std::option::Option::Some(QueryMode::PLAN),
                2 => ::std::option::Option::Some(QueryMode::PROFILE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<QueryMode> {
            match str {
                "NORMAL" => ::std::option::Option::Some(QueryMode::NORMAL),
                "PLAN" => ::std::option::Option::Some(QueryMode::PLAN),
                "PROFILE" => ::std::option::Option::Some(QueryMode::PROFILE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [QueryMode] = &[
            QueryMode::NORMAL,
            QueryMode::PLAN,
            QueryMode::PROFILE,
        ];
    }

    impl ::protobuf::EnumFull for QueryMode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExecuteSqlRequest.QueryMode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for QueryMode {
        fn default() -> Self {
            QueryMode::NORMAL
        }
    }

    impl QueryMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<QueryMode>("ExecuteSqlRequest.QueryMode")
        }
    }
}

///  The request for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml].
// @@protoc_insertion_point(message:google.spanner.v1.ExecuteBatchDmlRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExecuteBatchDmlRequest {
    // message fields
    ///  Required. The session in which the DML statements should be performed.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlRequest.session)
    pub session: ::std::string::String,
    ///  Required. The transaction to use. Must be a read-write transaction.
    ///
    ///  To protect against replays, single-use transactions are not supported. The
    ///  caller must either supply an existing transaction ID or begin a new
    ///  transaction.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlRequest.transaction)
    pub transaction: ::protobuf::MessageField<super::transaction::TransactionSelector>,
    ///  Required. The list of statements to execute in this batch. Statements are
    ///  executed serially, such that the effects of statement `i` are visible to
    ///  statement `i+1`. Each statement must be a DML statement. Execution stops at
    ///  the first failed statement; the remaining statements are not executed.
    ///
    ///  Callers must provide at least one statement.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlRequest.statements)
    pub statements: ::std::vec::Vec<execute_batch_dml_request::Statement>,
    ///  Required. A per-transaction sequence number used to identify this request.
    ///  This field makes each request idempotent such that if the request is
    ///  received multiple times, at most one will succeed.
    ///
    ///  The sequence number must be monotonically increasing within the
    ///  transaction. If a request arrives for the first time with an out-of-order
    ///  sequence number, the transaction may be aborted. Replays of previously
    ///  handled requests will yield the same response as the first execution.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlRequest.seqno)
    pub seqno: i64,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.ExecuteBatchDmlRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecuteBatchDmlRequest {
    fn default() -> &'a ExecuteBatchDmlRequest {
        <ExecuteBatchDmlRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteBatchDmlRequest {
    pub fn new() -> ExecuteBatchDmlRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &ExecuteBatchDmlRequest| { &m.session },
            |m: &mut ExecuteBatchDmlRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::transaction::TransactionSelector>(
            "transaction",
            |m: &ExecuteBatchDmlRequest| { &m.transaction },
            |m: &mut ExecuteBatchDmlRequest| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statements",
            |m: &ExecuteBatchDmlRequest| { &m.statements },
            |m: &mut ExecuteBatchDmlRequest| { &mut m.statements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seqno",
            |m: &ExecuteBatchDmlRequest| { &m.seqno },
            |m: &mut ExecuteBatchDmlRequest| { &mut m.seqno },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteBatchDmlRequest>(
            "ExecuteBatchDmlRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecuteBatchDmlRequest {
    const NAME: &'static str = "ExecuteBatchDmlRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction)?;
                },
                26 => {
                    self.statements.push(is.read_message()?);
                },
                32 => {
                    self.seqno = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        if let Some(v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.statements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.seqno != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.seqno);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        if let Some(v) = self.transaction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.statements {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.seqno != 0 {
            os.write_int64(4, self.seqno)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecuteBatchDmlRequest {
        ExecuteBatchDmlRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.transaction.clear();
        self.statements.clear();
        self.seqno = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecuteBatchDmlRequest {
        static instance: ExecuteBatchDmlRequest = ExecuteBatchDmlRequest {
            session: ::std::string::String::new(),
            transaction: ::protobuf::MessageField::none(),
            statements: ::std::vec::Vec::new(),
            seqno: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecuteBatchDmlRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecuteBatchDmlRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecuteBatchDmlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteBatchDmlRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExecuteBatchDmlRequest`
pub mod execute_batch_dml_request {
    ///  A single DML statement.
    // @@protoc_insertion_point(message:google.spanner.v1.ExecuteBatchDmlRequest.Statement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Statement {
        // message fields
        ///  Required. The DML string.
        // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlRequest.Statement.sql)
        pub sql: ::std::string::String,
        ///  Parameter names and values that bind to placeholders in the DML string.
        ///
        ///  A parameter placeholder consists of the `@` character followed by the
        ///  parameter name (for example, `@firstName`). Parameter names can contain
        ///  letters, numbers, and underscores.
        ///
        ///  Parameters can appear anywhere that a literal value is expected.  The
        ///  same parameter name can be used more than once, for example:
        ///
        ///  `"WHERE id > @msg_id AND id < @msg_id + 100"`
        ///
        ///  It is an error to execute a SQL statement with unbound parameters.
        // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlRequest.Statement.params)
        pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
        ///  It is not always possible for Cloud Spanner to infer the right SQL type
        ///  from a JSON value.  For example, values of type `BYTES` and values
        ///  of type `STRING` both appear in
        ///  [params][google.spanner.v1.ExecuteBatchDmlRequest.Statement.params] as
        ///  JSON strings.
        ///
        ///  In these cases, `param_types` can be used to specify the exact
        ///  SQL type for some or all of the SQL statement parameters. See the
        ///  definition of [Type][google.spanner.v1.Type] for more information
        ///  about SQL types.
        // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlRequest.Statement.param_types)
        pub param_types: ::std::collections::HashMap<::std::string::String, super::super::type_::Type>,
        // special fields
        // @@protoc_insertion_point(special_field:google.spanner.v1.ExecuteBatchDmlRequest.Statement.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Statement {
        fn default() -> &'a Statement {
            <Statement as ::protobuf::Message>::default_instance()
        }
    }

    impl Statement {
        pub fn new() -> Statement {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sql",
                |m: &Statement| { &m.sql },
                |m: &mut Statement| { &mut m.sql },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
                "params",
                |m: &Statement| { &m.params },
                |m: &mut Statement| { &mut m.params },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
                "param_types",
                |m: &Statement| { &m.param_types },
                |m: &mut Statement| { &mut m.param_types },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Statement>(
                "ExecuteBatchDmlRequest.Statement",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Statement {
        const NAME: &'static str = "Statement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.sql = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_message()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.param_types.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.sql.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.sql);
            }
            if let Some(v) = self.params.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for (k, v) in &self.param_types {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                let len = v.compute_size();
                entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.sql.is_empty() {
                os.write_string(1, &self.sql)?;
            }
            if let Some(v) = self.params.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for (k, v) in &self.param_types {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                let len = v.cached_size() as u64;
                entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Statement {
            Statement::new()
        }

        fn clear(&mut self) {
            self.sql.clear();
            self.params.clear();
            self.param_types.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Statement {
            static instance: ::protobuf::rt::Lazy<Statement> = ::protobuf::rt::Lazy::new();
            instance.get(Statement::new)
        }
    }

    impl ::protobuf::MessageFull for Statement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExecuteBatchDmlRequest.Statement").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Statement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Statement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:google.spanner.v1.ExecuteBatchDmlResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExecuteBatchDmlResponse {
    // message fields
    ///  One [ResultSet][google.spanner.v1.ResultSet] for each statement in the
    ///  request that ran successfully, in the same order as the statements in the
    ///  request. Each [ResultSet][google.spanner.v1.ResultSet] does not contain any
    ///  rows. The [ResultSetStats][google.spanner.v1.ResultSetStats] in each
    ///  [ResultSet][google.spanner.v1.ResultSet] contain the number of rows
    ///  modified by the statement.
    ///
    ///  Only the first [ResultSet][google.spanner.v1.ResultSet] in the response
    ///  contains valid [ResultSetMetadata][google.spanner.v1.ResultSetMetadata].
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlResponse.result_sets)
    pub result_sets: ::std::vec::Vec<super::result_set::ResultSet>,
    ///  If all DML statements are executed successfully, the status is `OK`.
    ///  Otherwise, the error status of the first failed statement.
    // @@protoc_insertion_point(field:google.spanner.v1.ExecuteBatchDmlResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.ExecuteBatchDmlResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecuteBatchDmlResponse {
    fn default() -> &'a ExecuteBatchDmlResponse {
        <ExecuteBatchDmlResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteBatchDmlResponse {
    pub fn new() -> ExecuteBatchDmlResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "result_sets",
            |m: &ExecuteBatchDmlResponse| { &m.result_sets },
            |m: &mut ExecuteBatchDmlResponse| { &mut m.result_sets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ExecuteBatchDmlResponse| { &m.status },
            |m: &mut ExecuteBatchDmlResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteBatchDmlResponse>(
            "ExecuteBatchDmlResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecuteBatchDmlResponse {
    const NAME: &'static str = "ExecuteBatchDmlResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.result_sets.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.result_sets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.result_sets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecuteBatchDmlResponse {
        ExecuteBatchDmlResponse::new()
    }

    fn clear(&mut self) {
        self.result_sets.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecuteBatchDmlResponse {
        static instance: ExecuteBatchDmlResponse = ExecuteBatchDmlResponse {
            result_sets: ::std::vec::Vec::new(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecuteBatchDmlResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecuteBatchDmlResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecuteBatchDmlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteBatchDmlResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Options for a PartitionQueryRequest and
///  PartitionReadRequest.
// @@protoc_insertion_point(message:google.spanner.v1.PartitionOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PartitionOptions {
    // message fields
    ///  **Note:** This hint is currently ignored by PartitionQuery and
    ///  PartitionRead requests.
    ///
    ///  The desired data size for each partition generated.  The default for this
    ///  option is currently 1 GiB.  This is only a hint. The actual size of each
    ///  partition may be smaller or larger than this size request.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionOptions.partition_size_bytes)
    pub partition_size_bytes: i64,
    ///  **Note:** This hint is currently ignored by PartitionQuery and
    ///  PartitionRead requests.
    ///
    ///  The desired maximum number of partitions to return.  For example, this may
    ///  be set to the number of workers available.  The default for this option
    ///  is currently 10,000. The maximum value is currently 200,000.  This is only
    ///  a hint.  The actual number of partitions returned may be smaller or larger
    ///  than this maximum count request.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionOptions.max_partitions)
    pub max_partitions: i64,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.PartitionOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartitionOptions {
    fn default() -> &'a PartitionOptions {
        <PartitionOptions as ::protobuf::Message>::default_instance()
    }
}

impl PartitionOptions {
    pub fn new() -> PartitionOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partition_size_bytes",
            |m: &PartitionOptions| { &m.partition_size_bytes },
            |m: &mut PartitionOptions| { &mut m.partition_size_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_partitions",
            |m: &PartitionOptions| { &m.max_partitions },
            |m: &mut PartitionOptions| { &mut m.max_partitions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartitionOptions>(
            "PartitionOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartitionOptions {
    const NAME: &'static str = "PartitionOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.partition_size_bytes = is.read_int64()?;
                },
                16 => {
                    self.max_partitions = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.partition_size_bytes != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.partition_size_bytes);
        }
        if self.max_partitions != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.max_partitions);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.partition_size_bytes != 0 {
            os.write_int64(1, self.partition_size_bytes)?;
        }
        if self.max_partitions != 0 {
            os.write_int64(2, self.max_partitions)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartitionOptions {
        PartitionOptions::new()
    }

    fn clear(&mut self) {
        self.partition_size_bytes = 0;
        self.max_partitions = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartitionOptions {
        static instance: PartitionOptions = PartitionOptions {
            partition_size_bytes: 0,
            max_partitions: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartitionOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartitionOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartitionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
// @@protoc_insertion_point(message:google.spanner.v1.PartitionQueryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PartitionQueryRequest {
    // message fields
    ///  Required. The session used to create the partitions.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionQueryRequest.session)
    pub session: ::std::string::String,
    ///  Read only snapshot transactions are supported, read/write and single use
    ///  transactions are not.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionQueryRequest.transaction)
    pub transaction: ::protobuf::MessageField<super::transaction::TransactionSelector>,
    ///  Required. The query request to generate partitions for. The request will
    ///  fail if the query is not root partitionable. The query plan of a root
    ///  partitionable query has a single distributed union operator. A distributed
    ///  union operator conceptually divides one or more tables into multiple
    ///  splits, remotely evaluates a subquery independently on each split, and
    ///  then unions all results.
    ///
    ///  This must not contain DML commands, such as INSERT, UPDATE, or
    ///  DELETE. Use
    ///  [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] with a
    ///  PartitionedDml transaction for large, partition-friendly DML operations.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionQueryRequest.sql)
    pub sql: ::std::string::String,
    ///  Parameter names and values that bind to placeholders in the SQL string.
    ///
    ///  A parameter placeholder consists of the `@` character followed by the
    ///  parameter name (for example, `@firstName`). Parameter names can contain
    ///  letters, numbers, and underscores.
    ///
    ///  Parameters can appear anywhere that a literal value is expected.  The same
    ///  parameter name can be used more than once, for example:
    ///
    ///  `"WHERE id > @msg_id AND id < @msg_id + 100"`
    ///
    ///  It is an error to execute a SQL statement with unbound parameters.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionQueryRequest.params)
    pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  It is not always possible for Cloud Spanner to infer the right SQL type
    ///  from a JSON value.  For example, values of type `BYTES` and values
    ///  of type `STRING` both appear in
    ///  [params][google.spanner.v1.PartitionQueryRequest.params] as JSON strings.
    ///
    ///  In these cases, `param_types` can be used to specify the exact
    ///  SQL type for some or all of the SQL query parameters. See the
    ///  definition of [Type][google.spanner.v1.Type] for more information
    ///  about SQL types.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionQueryRequest.param_types)
    pub param_types: ::std::collections::HashMap<::std::string::String, super::type_::Type>,
    ///  Additional options that affect how many partitions are created.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionQueryRequest.partition_options)
    pub partition_options: ::protobuf::MessageField<PartitionOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.PartitionQueryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartitionQueryRequest {
    fn default() -> &'a PartitionQueryRequest {
        <PartitionQueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl PartitionQueryRequest {
    pub fn new() -> PartitionQueryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &PartitionQueryRequest| { &m.session },
            |m: &mut PartitionQueryRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::transaction::TransactionSelector>(
            "transaction",
            |m: &PartitionQueryRequest| { &m.transaction },
            |m: &mut PartitionQueryRequest| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sql",
            |m: &PartitionQueryRequest| { &m.sql },
            |m: &mut PartitionQueryRequest| { &mut m.sql },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "params",
            |m: &PartitionQueryRequest| { &m.params },
            |m: &mut PartitionQueryRequest| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "param_types",
            |m: &PartitionQueryRequest| { &m.param_types },
            |m: &mut PartitionQueryRequest| { &mut m.param_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PartitionOptions>(
            "partition_options",
            |m: &PartitionQueryRequest| { &m.partition_options },
            |m: &mut PartitionQueryRequest| { &mut m.partition_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartitionQueryRequest>(
            "PartitionQueryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartitionQueryRequest {
    const NAME: &'static str = "PartitionQueryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction)?;
                },
                26 => {
                    self.sql = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.param_types.insert(key, value);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.partition_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        if let Some(v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.sql.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sql);
        }
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.param_types {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.partition_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        if let Some(v) = self.transaction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.sql.is_empty() {
            os.write_string(3, &self.sql)?;
        }
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for (k, v) in &self.param_types {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.partition_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartitionQueryRequest {
        PartitionQueryRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.transaction.clear();
        self.sql.clear();
        self.params.clear();
        self.param_types.clear();
        self.partition_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartitionQueryRequest {
        static instance: ::protobuf::rt::Lazy<PartitionQueryRequest> = ::protobuf::rt::Lazy::new();
        instance.get(PartitionQueryRequest::new)
    }
}

impl ::protobuf::MessageFull for PartitionQueryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartitionQueryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartitionQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionQueryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [PartitionRead][google.spanner.v1.Spanner.PartitionRead]
// @@protoc_insertion_point(message:google.spanner.v1.PartitionReadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PartitionReadRequest {
    // message fields
    ///  Required. The session used to create the partitions.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionReadRequest.session)
    pub session: ::std::string::String,
    ///  Read only snapshot transactions are supported, read/write and single use
    ///  transactions are not.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionReadRequest.transaction)
    pub transaction: ::protobuf::MessageField<super::transaction::TransactionSelector>,
    ///  Required. The name of the table in the database to be read.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionReadRequest.table)
    pub table: ::std::string::String,
    ///  If non-empty, the name of an index on
    ///  [table][google.spanner.v1.PartitionReadRequest.table]. This index is used
    ///  instead of the table primary key when interpreting
    ///  [key_set][google.spanner.v1.PartitionReadRequest.key_set] and sorting
    ///  result rows. See [key_set][google.spanner.v1.PartitionReadRequest.key_set]
    ///  for further information.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionReadRequest.index)
    pub index: ::std::string::String,
    ///  The columns of [table][google.spanner.v1.PartitionReadRequest.table] to be
    ///  returned for each row matching this request.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionReadRequest.columns)
    pub columns: ::std::vec::Vec<::std::string::String>,
    ///  Required. `key_set` identifies the rows to be yielded. `key_set` names the
    ///  primary keys of the rows in
    ///  [table][google.spanner.v1.PartitionReadRequest.table] to be yielded, unless
    ///  [index][google.spanner.v1.PartitionReadRequest.index] is present. If
    ///  [index][google.spanner.v1.PartitionReadRequest.index] is present, then
    ///  [key_set][google.spanner.v1.PartitionReadRequest.key_set] instead names
    ///  index keys in [index][google.spanner.v1.PartitionReadRequest.index].
    ///
    ///  It is not an error for the `key_set` to name rows that do not
    ///  exist in the database. Read yields nothing for nonexistent rows.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionReadRequest.key_set)
    pub key_set: ::protobuf::MessageField<super::keys::KeySet>,
    ///  Additional options that affect how many partitions are created.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionReadRequest.partition_options)
    pub partition_options: ::protobuf::MessageField<PartitionOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.PartitionReadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartitionReadRequest {
    fn default() -> &'a PartitionReadRequest {
        <PartitionReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl PartitionReadRequest {
    pub fn new() -> PartitionReadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &PartitionReadRequest| { &m.session },
            |m: &mut PartitionReadRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::transaction::TransactionSelector>(
            "transaction",
            |m: &PartitionReadRequest| { &m.transaction },
            |m: &mut PartitionReadRequest| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "table",
            |m: &PartitionReadRequest| { &m.table },
            |m: &mut PartitionReadRequest| { &mut m.table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &PartitionReadRequest| { &m.index },
            |m: &mut PartitionReadRequest| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "columns",
            |m: &PartitionReadRequest| { &m.columns },
            |m: &mut PartitionReadRequest| { &mut m.columns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::keys::KeySet>(
            "key_set",
            |m: &PartitionReadRequest| { &m.key_set },
            |m: &mut PartitionReadRequest| { &mut m.key_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PartitionOptions>(
            "partition_options",
            |m: &PartitionReadRequest| { &m.partition_options },
            |m: &mut PartitionReadRequest| { &mut m.partition_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartitionReadRequest>(
            "PartitionReadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartitionReadRequest {
    const NAME: &'static str = "PartitionReadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction)?;
                },
                26 => {
                    self.table = is.read_string()?;
                },
                34 => {
                    self.index = is.read_string()?;
                },
                42 => {
                    self.columns.push(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key_set)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.partition_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        if let Some(v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.table);
        }
        if !self.index.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.index);
        }
        for value in &self.columns {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.key_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.partition_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        if let Some(v) = self.transaction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.table.is_empty() {
            os.write_string(3, &self.table)?;
        }
        if !self.index.is_empty() {
            os.write_string(4, &self.index)?;
        }
        for v in &self.columns {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.key_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.partition_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartitionReadRequest {
        PartitionReadRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.transaction.clear();
        self.table.clear();
        self.index.clear();
        self.columns.clear();
        self.key_set.clear();
        self.partition_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartitionReadRequest {
        static instance: PartitionReadRequest = PartitionReadRequest {
            session: ::std::string::String::new(),
            transaction: ::protobuf::MessageField::none(),
            table: ::std::string::String::new(),
            index: ::std::string::String::new(),
            columns: ::std::vec::Vec::new(),
            key_set: ::protobuf::MessageField::none(),
            partition_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartitionReadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartitionReadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartitionReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionReadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Information returned for each partition returned in a
///  PartitionResponse.
// @@protoc_insertion_point(message:google.spanner.v1.Partition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Partition {
    // message fields
    ///  This token can be passed to Read, StreamingRead, ExecuteSql, or
    ///  ExecuteStreamingSql requests to restrict the results to those identified by
    ///  this partition token.
    // @@protoc_insertion_point(field:google.spanner.v1.Partition.partition_token)
    pub partition_token: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.Partition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Partition {
    fn default() -> &'a Partition {
        <Partition as ::protobuf::Message>::default_instance()
    }
}

impl Partition {
    pub fn new() -> Partition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partition_token",
            |m: &Partition| { &m.partition_token },
            |m: &mut Partition| { &mut m.partition_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Partition>(
            "Partition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Partition {
    const NAME: &'static str = "Partition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.partition_token = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.partition_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.partition_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.partition_token.is_empty() {
            os.write_bytes(1, &self.partition_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Partition {
        Partition::new()
    }

    fn clear(&mut self) {
        self.partition_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Partition {
        static instance: Partition = Partition {
            partition_token: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Partition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Partition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Partition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Partition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The response for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
///  or [PartitionRead][google.spanner.v1.Spanner.PartitionRead]
// @@protoc_insertion_point(message:google.spanner.v1.PartitionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PartitionResponse {
    // message fields
    ///  Partitions created by this request.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionResponse.partitions)
    pub partitions: ::std::vec::Vec<Partition>,
    ///  Transaction created by this request.
    // @@protoc_insertion_point(field:google.spanner.v1.PartitionResponse.transaction)
    pub transaction: ::protobuf::MessageField<super::transaction::Transaction>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.PartitionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartitionResponse {
    fn default() -> &'a PartitionResponse {
        <PartitionResponse as ::protobuf::Message>::default_instance()
    }
}

impl PartitionResponse {
    pub fn new() -> PartitionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "partitions",
            |m: &PartitionResponse| { &m.partitions },
            |m: &mut PartitionResponse| { &mut m.partitions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::transaction::Transaction>(
            "transaction",
            |m: &PartitionResponse| { &m.transaction },
            |m: &mut PartitionResponse| { &mut m.transaction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartitionResponse>(
            "PartitionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartitionResponse {
    const NAME: &'static str = "PartitionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.partitions.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.partitions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.partitions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.transaction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartitionResponse {
        PartitionResponse::new()
    }

    fn clear(&mut self) {
        self.partitions.clear();
        self.transaction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartitionResponse {
        static instance: PartitionResponse = PartitionResponse {
            partitions: ::std::vec::Vec::new(),
            transaction: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartitionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartitionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartitionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [Read][google.spanner.v1.Spanner.Read] and
///  [StreamingRead][google.spanner.v1.Spanner.StreamingRead].
// @@protoc_insertion_point(message:google.spanner.v1.ReadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReadRequest {
    // message fields
    ///  Required. The session in which the read should be performed.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.session)
    pub session: ::std::string::String,
    ///  The transaction to use. If none is provided, the default is a
    ///  temporary read-only transaction with strong concurrency.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.transaction)
    pub transaction: ::protobuf::MessageField<super::transaction::TransactionSelector>,
    ///  Required. The name of the table in the database to be read.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.table)
    pub table: ::std::string::String,
    ///  If non-empty, the name of an index on
    ///  [table][google.spanner.v1.ReadRequest.table]. This index is used instead of
    ///  the table primary key when interpreting
    ///  [key_set][google.spanner.v1.ReadRequest.key_set] and sorting result rows.
    ///  See [key_set][google.spanner.v1.ReadRequest.key_set] for further
    ///  information.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.index)
    pub index: ::std::string::String,
    ///  Required. The columns of [table][google.spanner.v1.ReadRequest.table] to be
    ///  returned for each row matching this request.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.columns)
    pub columns: ::std::vec::Vec<::std::string::String>,
    ///  Required. `key_set` identifies the rows to be yielded. `key_set` names the
    ///  primary keys of the rows in [table][google.spanner.v1.ReadRequest.table] to
    ///  be yielded, unless [index][google.spanner.v1.ReadRequest.index] is present.
    ///  If [index][google.spanner.v1.ReadRequest.index] is present, then
    ///  [key_set][google.spanner.v1.ReadRequest.key_set] instead names index keys
    ///  in [index][google.spanner.v1.ReadRequest.index].
    ///
    ///  If the [partition_token][google.spanner.v1.ReadRequest.partition_token]
    ///  field is empty, rows are yielded in table primary key order (if
    ///  [index][google.spanner.v1.ReadRequest.index] is empty) or index key order
    ///  (if [index][google.spanner.v1.ReadRequest.index] is non-empty).  If the
    ///  [partition_token][google.spanner.v1.ReadRequest.partition_token] field is
    ///  not empty, rows will be yielded in an unspecified order.
    ///
    ///  It is not an error for the `key_set` to name rows that do not
    ///  exist in the database. Read yields nothing for nonexistent rows.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.key_set)
    pub key_set: ::protobuf::MessageField<super::keys::KeySet>,
    ///  If greater than zero, only the first `limit` rows are yielded. If `limit`
    ///  is zero, the default is no limit. A limit cannot be specified if
    ///  `partition_token` is set.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.limit)
    pub limit: i64,
    ///  If this request is resuming a previously interrupted read,
    ///  `resume_token` should be copied from the last
    ///  [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the
    ///  interruption. Doing this enables the new read to resume where the last read
    ///  left off. The rest of the request parameters must exactly match the request
    ///  that yielded this token.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.resume_token)
    pub resume_token: ::std::vec::Vec<u8>,
    ///  If present, results will be restricted to the specified partition
    ///  previously created using PartitionRead().    There must be an exact
    ///  match for the values of fields common to this message and the
    ///  PartitionReadRequest message used to create this partition_token.
    // @@protoc_insertion_point(field:google.spanner.v1.ReadRequest.partition_token)
    pub partition_token: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.ReadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadRequest {
    fn default() -> &'a ReadRequest {
        <ReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadRequest {
    pub fn new() -> ReadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &ReadRequest| { &m.session },
            |m: &mut ReadRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::transaction::TransactionSelector>(
            "transaction",
            |m: &ReadRequest| { &m.transaction },
            |m: &mut ReadRequest| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "table",
            |m: &ReadRequest| { &m.table },
            |m: &mut ReadRequest| { &mut m.table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &ReadRequest| { &m.index },
            |m: &mut ReadRequest| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "columns",
            |m: &ReadRequest| { &m.columns },
            |m: &mut ReadRequest| { &mut m.columns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::keys::KeySet>(
            "key_set",
            |m: &ReadRequest| { &m.key_set },
            |m: &mut ReadRequest| { &mut m.key_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ReadRequest| { &m.limit },
            |m: &mut ReadRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resume_token",
            |m: &ReadRequest| { &m.resume_token },
            |m: &mut ReadRequest| { &mut m.resume_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partition_token",
            |m: &ReadRequest| { &m.partition_token },
            |m: &mut ReadRequest| { &mut m.partition_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadRequest>(
            "ReadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadRequest {
    const NAME: &'static str = "ReadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction)?;
                },
                26 => {
                    self.table = is.read_string()?;
                },
                34 => {
                    self.index = is.read_string()?;
                },
                42 => {
                    self.columns.push(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key_set)?;
                },
                64 => {
                    self.limit = is.read_int64()?;
                },
                74 => {
                    self.resume_token = is.read_bytes()?;
                },
                82 => {
                    self.partition_token = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        if let Some(v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.table);
        }
        if !self.index.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.index);
        }
        for value in &self.columns {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.key_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.limit);
        }
        if !self.resume_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.resume_token);
        }
        if !self.partition_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.partition_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        if let Some(v) = self.transaction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.table.is_empty() {
            os.write_string(3, &self.table)?;
        }
        if !self.index.is_empty() {
            os.write_string(4, &self.index)?;
        }
        for v in &self.columns {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.key_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.limit != 0 {
            os.write_int64(8, self.limit)?;
        }
        if !self.resume_token.is_empty() {
            os.write_bytes(9, &self.resume_token)?;
        }
        if !self.partition_token.is_empty() {
            os.write_bytes(10, &self.partition_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadRequest {
        ReadRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.transaction.clear();
        self.table.clear();
        self.index.clear();
        self.columns.clear();
        self.key_set.clear();
        self.limit = 0;
        self.resume_token.clear();
        self.partition_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadRequest {
        static instance: ReadRequest = ReadRequest {
            session: ::std::string::String::new(),
            transaction: ::protobuf::MessageField::none(),
            table: ::std::string::String::new(),
            index: ::std::string::String::new(),
            columns: ::std::vec::Vec::new(),
            key_set: ::protobuf::MessageField::none(),
            limit: 0,
            resume_token: ::std::vec::Vec::new(),
            partition_token: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for
///  [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction].
// @@protoc_insertion_point(message:google.spanner.v1.BeginTransactionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BeginTransactionRequest {
    // message fields
    ///  Required. The session in which the transaction runs.
    // @@protoc_insertion_point(field:google.spanner.v1.BeginTransactionRequest.session)
    pub session: ::std::string::String,
    ///  Required. Options for the new transaction.
    // @@protoc_insertion_point(field:google.spanner.v1.BeginTransactionRequest.options)
    pub options: ::protobuf::MessageField<super::transaction::TransactionOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.BeginTransactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BeginTransactionRequest {
    fn default() -> &'a BeginTransactionRequest {
        <BeginTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl BeginTransactionRequest {
    pub fn new() -> BeginTransactionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &BeginTransactionRequest| { &m.session },
            |m: &mut BeginTransactionRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::transaction::TransactionOptions>(
            "options",
            |m: &BeginTransactionRequest| { &m.options },
            |m: &mut BeginTransactionRequest| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BeginTransactionRequest>(
            "BeginTransactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BeginTransactionRequest {
    const NAME: &'static str = "BeginTransactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BeginTransactionRequest {
        BeginTransactionRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BeginTransactionRequest {
        static instance: BeginTransactionRequest = BeginTransactionRequest {
            session: ::std::string::String::new(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BeginTransactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BeginTransactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BeginTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BeginTransactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [Commit][google.spanner.v1.Spanner.Commit].
// @@protoc_insertion_point(message:google.spanner.v1.CommitRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommitRequest {
    // message fields
    ///  Required. The session in which the transaction to be committed is running.
    // @@protoc_insertion_point(field:google.spanner.v1.CommitRequest.session)
    pub session: ::std::string::String,
    ///  The mutations to be executed when this transaction commits. All
    ///  mutations are applied atomically, in the order they appear in
    ///  this list.
    // @@protoc_insertion_point(field:google.spanner.v1.CommitRequest.mutations)
    pub mutations: ::std::vec::Vec<super::mutation::Mutation>,
    // message oneof groups
    pub transaction: ::std::option::Option<commit_request::Transaction>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.CommitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommitRequest {
    fn default() -> &'a CommitRequest {
        <CommitRequest as ::protobuf::Message>::default_instance()
    }
}

impl CommitRequest {
    pub fn new() -> CommitRequest {
        ::std::default::Default::default()
    }

    // bytes transaction_id = 2;

    pub fn transaction_id(&self) -> &[u8] {
        match self.transaction {
            ::std::option::Option::Some(commit_request::Transaction::TransactionId(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_transaction_id(&mut self) {
        self.transaction = ::std::option::Option::None;
    }

    pub fn has_transaction_id(&self) -> bool {
        match self.transaction {
            ::std::option::Option::Some(commit_request::Transaction::TransactionId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.transaction = ::std::option::Option::Some(commit_request::Transaction::TransactionId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(commit_request::Transaction::TransactionId(_)) = self.transaction {
        } else {
            self.transaction = ::std::option::Option::Some(commit_request::Transaction::TransactionId(::std::vec::Vec::new()));
        }
        match self.transaction {
            ::std::option::Option::Some(commit_request::Transaction::TransactionId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_transaction_id() {
            match self.transaction.take() {
                ::std::option::Option::Some(commit_request::Transaction::TransactionId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.spanner.v1.TransactionOptions single_use_transaction = 3;

    pub fn single_use_transaction(&self) -> &super::transaction::TransactionOptions {
        match self.transaction {
            ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(ref v)) => v,
            _ => <super::transaction::TransactionOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_single_use_transaction(&mut self) {
        self.transaction = ::std::option::Option::None;
    }

    pub fn has_single_use_transaction(&self) -> bool {
        match self.transaction {
            ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_use_transaction(&mut self, v: super::transaction::TransactionOptions) {
        self.transaction = ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single_use_transaction(&mut self) -> &mut super::transaction::TransactionOptions {
        if let ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(_)) = self.transaction {
        } else {
            self.transaction = ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(super::transaction::TransactionOptions::new()));
        }
        match self.transaction {
            ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single_use_transaction(&mut self) -> super::transaction::TransactionOptions {
        if self.has_single_use_transaction() {
            match self.transaction.take() {
                ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(v)) => v,
                _ => panic!(),
            }
        } else {
            super::transaction::TransactionOptions::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &CommitRequest| { &m.session },
            |m: &mut CommitRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "transaction_id",
            CommitRequest::has_transaction_id,
            CommitRequest::transaction_id,
            CommitRequest::set_transaction_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::transaction::TransactionOptions>(
            "single_use_transaction",
            CommitRequest::has_single_use_transaction,
            CommitRequest::single_use_transaction,
            CommitRequest::mut_single_use_transaction,
            CommitRequest::set_single_use_transaction,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mutations",
            |m: &CommitRequest| { &m.mutations },
            |m: &mut CommitRequest| { &mut m.mutations },
        ));
        oneofs.push(commit_request::Transaction::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommitRequest>(
            "CommitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommitRequest {
    const NAME: &'static str = "CommitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    self.transaction = ::std::option::Option::Some(commit_request::Transaction::TransactionId(is.read_bytes()?));
                },
                26 => {
                    self.transaction = ::std::option::Option::Some(commit_request::Transaction::SingleUseTransaction(is.read_message()?));
                },
                34 => {
                    self.mutations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.transaction {
            match v {
                &commit_request::Transaction::TransactionId(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &commit_request::Transaction::SingleUseTransaction(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        for v in &self.mutations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.transaction {
            match v {
                &commit_request::Transaction::TransactionId(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &commit_request::Transaction::SingleUseTransaction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommitRequest {
        CommitRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.transaction = ::std::option::Option::None;
        self.transaction = ::std::option::Option::None;
        self.mutations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommitRequest {
        static instance: CommitRequest = CommitRequest {
            session: ::std::string::String::new(),
            mutations: ::std::vec::Vec::new(),
            transaction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CommitRequest`
pub mod commit_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.spanner.v1.CommitRequest.transaction)
    pub enum Transaction {
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.CommitRequest.transaction_id)
        TransactionId(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.CommitRequest.single_use_transaction)
        SingleUseTransaction(super::super::transaction::TransactionOptions),
    }

    impl ::protobuf::Oneof for Transaction {
    }

    impl ::protobuf::OneofFull for Transaction {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CommitRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("transaction").unwrap()).clone()
        }
    }

    impl Transaction {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Transaction>("transaction")
        }
    }
}

///  The response for [Commit][google.spanner.v1.Spanner.Commit].
// @@protoc_insertion_point(message:google.spanner.v1.CommitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommitResponse {
    // message fields
    ///  The Cloud Spanner timestamp at which the transaction committed.
    // @@protoc_insertion_point(field:google.spanner.v1.CommitResponse.commit_timestamp)
    pub commit_timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.CommitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommitResponse {
    fn default() -> &'a CommitResponse {
        <CommitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommitResponse {
    pub fn new() -> CommitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "commit_timestamp",
            |m: &CommitResponse| { &m.commit_timestamp },
            |m: &mut CommitResponse| { &mut m.commit_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommitResponse>(
            "CommitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommitResponse {
    const NAME: &'static str = "CommitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commit_timestamp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commit_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.commit_timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommitResponse {
        CommitResponse::new()
    }

    fn clear(&mut self) {
        self.commit_timestamp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommitResponse {
        static instance: CommitResponse = CommitResponse {
            commit_timestamp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request for [Rollback][google.spanner.v1.Spanner.Rollback].
// @@protoc_insertion_point(message:google.spanner.v1.RollbackRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollbackRequest {
    // message fields
    ///  Required. The session in which the transaction to roll back is running.
    // @@protoc_insertion_point(field:google.spanner.v1.RollbackRequest.session)
    pub session: ::std::string::String,
    ///  Required. The transaction to roll back.
    // @@protoc_insertion_point(field:google.spanner.v1.RollbackRequest.transaction_id)
    pub transaction_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.RollbackRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollbackRequest {
    fn default() -> &'a RollbackRequest {
        <RollbackRequest as ::protobuf::Message>::default_instance()
    }
}

impl RollbackRequest {
    pub fn new() -> RollbackRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session",
            |m: &RollbackRequest| { &m.session },
            |m: &mut RollbackRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction_id",
            |m: &RollbackRequest| { &m.transaction_id },
            |m: &mut RollbackRequest| { &mut m.transaction_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollbackRequest>(
            "RollbackRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollbackRequest {
    const NAME: &'static str = "RollbackRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = is.read_string()?;
                },
                18 => {
                    self.transaction_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session);
        }
        if !self.transaction_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.transaction_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session.is_empty() {
            os.write_string(1, &self.session)?;
        }
        if !self.transaction_id.is_empty() {
            os.write_bytes(2, &self.transaction_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollbackRequest {
        RollbackRequest::new()
    }

    fn clear(&mut self) {
        self.session.clear();
        self.transaction_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollbackRequest {
        static instance: RollbackRequest = RollbackRequest {
            session: ::std::string::String::new(),
            transaction_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollbackRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollbackRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollbackRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollbackRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fgoogle/spanner/v1/spanner.proto\x12\x11google.spanner.v1\x1a\x1cgo\
    ogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/\
    api/field_behavior.proto\x1a\x19google/api/resource.proto\x1a\x1bgoogle/\
    protobuf/empty.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/p\
    rotobuf/timestamp.proto\x1a\x17google/rpc/status.proto\x1a\x1cgoogle/spa\
    nner/v1/keys.proto\x1a\x20google/spanner/v1/mutation.proto\x1a\"google/s\
    panner/v1/result_set.proto\x1a#google/spanner/v1/transaction.proto\x1a\
    \x1cgoogle/spanner/v1/type.proto\"\x91\x01\n\x14CreateSessionRequest\x12\
    C\n\x08database\x18\x01\x20\x01(\tR\x08databaseB'\xfaA!\n\x1fspanner.goo\
    gleapis.com/Database\xe0A\x02\x124\n\x07session\x18\x02\x20\x01(\x0b2\
    \x1a.google.spanner.v1.SessionR\x07session\"\xd2\x01\n\x1aBatchCreateSes\
    sionsRequest\x12C\n\x08database\x18\x01\x20\x01(\tR\x08databaseB'\xfaA!\
    \n\x1fspanner.googleapis.com/Database\xe0A\x02\x12E\n\x10session_templat\
    e\x18\x02\x20\x01(\x0b2\x1a.google.spanner.v1.SessionR\x0fsessionTemplat\
    e\x12(\n\rsession_count\x18\x03\x20\x01(\x05R\x0csessionCountB\x03\xe0A\
    \x02\"S\n\x1bBatchCreateSessionsResponse\x124\n\x07session\x18\x01\x20\
    \x03(\x0b2\x1a.google.spanner.v1.SessionR\x07session\"\xa2\x03\n\x07Sess\
    ion\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12>\n\x06labels\x18\
    \x02\x20\x03(\x0b2&.google.spanner.v1.Session.LabelsEntryR\x06labels\x12\
    ;\n\x0bcreate_time\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \ncreateTime\x12U\n\x19approximate_last_use_time\x18\x04\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x16approximateLastUseTime\x1a9\n\x0bLabe\
    lsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01:t\xeaAq\n\x1espanner.googleapis.\
    com/Session\x12Oprojects/{project}/instances/{instance}/databases/{datab\
    ase}/sessions/{session}\"O\n\x11GetSessionRequest\x12:\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB&\xfaA\x20\n\x1espanner.googleapis.com/Session\xe0A\
    \x02\"\xae\x01\n\x13ListSessionsRequest\x12C\n\x08database\x18\x01\x20\
    \x01(\tR\x08databaseB'\xfaA!\n\x1fspanner.googleapis.com/Database\xe0A\
    \x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\np\
    age_token\x18\x03\x20\x01(\tR\tpageToken\x12\x16\n\x06filter\x18\x04\x20\
    \x01(\tR\x06filter\"v\n\x14ListSessionsResponse\x126\n\x08sessions\x18\
    \x01\x20\x03(\x0b2\x1a.google.spanner.v1.SessionR\x08sessions\x12&\n\x0f\
    next_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"R\n\x14DeleteSession\
    Request\x12:\n\x04name\x18\x01\x20\x01(\tR\x04nameB&\xfaA\x20\n\x1espann\
    er.googleapis.com/Session\xe0A\x02\"\xf7\x04\n\x11ExecuteSqlRequest\x12@\
    \n\x07session\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\x20\n\x1espanner.goo\
    gleapis.com/Session\xe0A\x02\x12H\n\x0btransaction\x18\x02\x20\x01(\x0b2\
    &.google.spanner.v1.TransactionSelectorR\x0btransaction\x12\x15\n\x03sql\
    \x18\x03\x20\x01(\tR\x03sqlB\x03\xe0A\x02\x12/\n\x06params\x18\x04\x20\
    \x01(\x0b2\x17.google.protobuf.StructR\x06params\x12U\n\x0bparam_types\
    \x18\x05\x20\x03(\x0b24.google.spanner.v1.ExecuteSqlRequest.ParamTypesEn\
    tryR\nparamTypes\x12!\n\x0cresume_token\x18\x06\x20\x01(\x0cR\x0bresumeT\
    oken\x12M\n\nquery_mode\x18\x07\x20\x01(\x0e2..google.spanner.v1.Execute\
    SqlRequest.QueryModeR\tqueryMode\x12'\n\x0fpartition_token\x18\x08\x20\
    \x01(\x0cR\x0epartitionToken\x12\x14\n\x05seqno\x18\t\x20\x01(\x03R\x05s\
    eqno\x1aV\n\x0fParamTypesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12-\n\x05value\x18\x02\x20\x01(\x0b2\x17.google.spanner.v1.TypeR\x05\
    value:\x028\x01\".\n\tQueryMode\x12\n\n\x06NORMAL\x10\0\x12\x08\n\x04PLA\
    N\x10\x01\x12\x0b\n\x07PROFILE\x10\x02\"\xad\x04\n\x16ExecuteBatchDmlReq\
    uest\x12@\n\x07session\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\x20\n\x1esp\
    anner.googleapis.com/Session\xe0A\x02\x12M\n\x0btransaction\x18\x02\x20\
    \x01(\x0b2&.google.spanner.v1.TransactionSelectorR\x0btransactionB\x03\
    \xe0A\x02\x12X\n\nstatements\x18\x03\x20\x03(\x0b23.google.spanner.v1.Ex\
    ecuteBatchDmlRequest.StatementR\nstatementsB\x03\xe0A\x02\x12\x19\n\x05s\
    eqno\x18\x04\x20\x01(\x03R\x05seqnoB\x03\xe0A\x02\x1a\x8c\x02\n\tStateme\
    nt\x12\x10\n\x03sql\x18\x01\x20\x01(\tR\x03sql\x12/\n\x06params\x18\x02\
    \x20\x01(\x0b2\x17.google.protobuf.StructR\x06params\x12d\n\x0bparam_typ\
    es\x18\x03\x20\x03(\x0b2C.google.spanner.v1.ExecuteBatchDmlRequest.State\
    ment.ParamTypesEntryR\nparamTypes\x1aV\n\x0fParamTypesEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12-\n\x05value\x18\x02\x20\x01(\x0b2\
    \x17.google.spanner.v1.TypeR\x05value:\x028\x01\"\x84\x01\n\x17ExecuteBa\
    tchDmlResponse\x12=\n\x0bresult_sets\x18\x01\x20\x03(\x0b2\x1c.google.sp\
    anner.v1.ResultSetR\nresultSets\x12*\n\x06status\x18\x02\x20\x01(\x0b2\
    \x12.google.rpc.StatusR\x06status\"k\n\x10PartitionOptions\x120\n\x14par\
    tition_size_bytes\x18\x01\x20\x01(\x03R\x12partitionSizeBytes\x12%\n\x0e\
    max_partitions\x18\x02\x20\x01(\x03R\rmaxPartitions\"\xf0\x03\n\x15Parti\
    tionQueryRequest\x12@\n\x07session\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\
    \x20\n\x1espanner.googleapis.com/Session\xe0A\x02\x12H\n\x0btransaction\
    \x18\x02\x20\x01(\x0b2&.google.spanner.v1.TransactionSelectorR\x0btransa\
    ction\x12\x15\n\x03sql\x18\x03\x20\x01(\tR\x03sqlB\x03\xe0A\x02\x12/\n\
    \x06params\x18\x04\x20\x01(\x0b2\x17.google.protobuf.StructR\x06params\
    \x12Y\n\x0bparam_types\x18\x05\x20\x03(\x0b28.google.spanner.v1.Partitio\
    nQueryRequest.ParamTypesEntryR\nparamTypes\x12P\n\x11partition_options\
    \x18\x06\x20\x01(\x0b2#.google.spanner.v1.PartitionOptionsR\x10partition\
    Options\x1aV\n\x0fParamTypesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12-\n\x05value\x18\x02\x20\x01(\x0b2\x17.google.spanner.v1.Type\
    R\x05value:\x028\x01\"\xf8\x02\n\x14PartitionReadRequest\x12@\n\x07sessi\
    on\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\x20\n\x1espanner.googleapis.com\
    /Session\xe0A\x02\x12H\n\x0btransaction\x18\x02\x20\x01(\x0b2&.google.sp\
    anner.v1.TransactionSelectorR\x0btransaction\x12\x19\n\x05table\x18\x03\
    \x20\x01(\tR\x05tableB\x03\xe0A\x02\x12\x14\n\x05index\x18\x04\x20\x01(\
    \tR\x05index\x12\x18\n\x07columns\x18\x05\x20\x03(\tR\x07columns\x127\n\
    \x07key_set\x18\x06\x20\x01(\x0b2\x19.google.spanner.v1.KeySetR\x06keySe\
    tB\x03\xe0A\x02\x12P\n\x11partition_options\x18\t\x20\x01(\x0b2#.google.\
    spanner.v1.PartitionOptionsR\x10partitionOptions\"4\n\tPartition\x12'\n\
    \x0fpartition_token\x18\x01\x20\x01(\x0cR\x0epartitionToken\"\x93\x01\n\
    \x11PartitionResponse\x12<\n\npartitions\x18\x01\x20\x03(\x0b2\x1c.googl\
    e.spanner.v1.PartitionR\npartitions\x12@\n\x0btransaction\x18\x02\x20\
    \x01(\x0b2\x1e.google.spanner.v1.TransactionR\x0btransaction\"\x84\x03\n\
    \x0bReadRequest\x12@\n\x07session\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\
    \x20\n\x1espanner.googleapis.com/Session\xe0A\x02\x12H\n\x0btransaction\
    \x18\x02\x20\x01(\x0b2&.google.spanner.v1.TransactionSelectorR\x0btransa\
    ction\x12\x19\n\x05table\x18\x03\x20\x01(\tR\x05tableB\x03\xe0A\x02\x12\
    \x14\n\x05index\x18\x04\x20\x01(\tR\x05index\x12\x1d\n\x07columns\x18\
    \x05\x20\x03(\tR\x07columnsB\x03\xe0A\x02\x127\n\x07key_set\x18\x06\x20\
    \x01(\x0b2\x19.google.spanner.v1.KeySetR\x06keySetB\x03\xe0A\x02\x12\x14\
    \n\x05limit\x18\x08\x20\x01(\x03R\x05limit\x12!\n\x0cresume_token\x18\t\
    \x20\x01(\x0cR\x0bresumeToken\x12'\n\x0fpartition_token\x18\n\x20\x01(\
    \x0cR\x0epartitionToken\"\xa1\x01\n\x17BeginTransactionRequest\x12@\n\
    \x07session\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\x20\n\x1espanner.googl\
    eapis.com/Session\xe0A\x02\x12D\n\x07options\x18\x02\x20\x01(\x0b2%.goog\
    le.spanner.v1.TransactionOptionsR\x07optionsB\x03\xe0A\x02\"\xa3\x02\n\r\
    CommitRequest\x12@\n\x07session\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\
    \x20\n\x1espanner.googleapis.com/Session\xe0A\x02\x12'\n\x0etransaction_\
    id\x18\x02\x20\x01(\x0cH\0R\rtransactionId\x12]\n\x16single_use_transact\
    ion\x18\x03\x20\x01(\x0b2%.google.spanner.v1.TransactionOptionsH\0R\x14s\
    ingleUseTransaction\x129\n\tmutations\x18\x04\x20\x03(\x0b2\x1b.google.s\
    panner.v1.MutationR\tmutationsB\r\n\x0btransaction\"W\n\x0eCommitRespons\
    e\x12E\n\x10commit_timestamp\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\x0fcommitTimestamp\"\x7f\n\x0fRollbackRequest\x12@\n\x07sessio\
    n\x18\x01\x20\x01(\tR\x07sessionB&\xfaA\x20\n\x1espanner.googleapis.com/\
    Session\xe0A\x02\x12*\n\x0etransaction_id\x18\x02\x20\x01(\x0cR\rtransac\
    tionIdB\x03\xe0A\x022\xc0\x16\n\x07Spanner\x12\xa6\x01\n\rCreateSession\
    \x12'.google.spanner.v1.CreateSessionRequest\x1a\x1a.google.spanner.v1.S\
    ession\"P\x82\xd3\xe4\x93\x02?\":/v1/{database=projects/*/instances/*/da\
    tabases/*}/sessions:\x01*\xdaA\x08database\x12\xe0\x01\n\x13BatchCreateS\
    essions\x12-.google.spanner.v1.BatchCreateSessionsRequest\x1a..google.sp\
    anner.v1.BatchCreateSessionsResponse\"j\x82\xd3\xe4\x93\x02K\"F/v1/{data\
    base=projects/*/instances/*/databases/*}/sessions:batchCreate:\x01*\xdaA\
    \x16database,session_count\x12\x97\x01\n\nGetSession\x12$.google.spanner\
    .v1.GetSessionRequest\x1a\x1a.google.spanner.v1.Session\"G\x82\xd3\xe4\
    \x93\x02:\x128/v1/{name=projects/*/instances/*/databases/*/sessions/*}\
    \xdaA\x04name\x12\xae\x01\n\x0cListSessions\x12&.google.spanner.v1.ListS\
    essionsRequest\x1a'.google.spanner.v1.ListSessionsResponse\"M\x82\xd3\
    \xe4\x93\x02<\x12:/v1/{database=projects/*/instances/*/databases/*}/sess\
    ions\xdaA\x08database\x12\x99\x01\n\rDeleteSession\x12'.google.spanner.v\
    1.DeleteSessionRequest\x1a\x16.google.protobuf.Empty\"G\x82\xd3\xe4\x93\
    \x02:*8/v1/{name=projects/*/instances/*/databases/*/sessions/*}\xdaA\x04\
    name\x12\xa3\x01\n\nExecuteSql\x12$.google.spanner.v1.ExecuteSqlRequest\
    \x1a\x1c.google.spanner.v1.ResultSet\"Q\x82\xd3\xe4\x93\x02K\"F/v1/{sess\
    ion=projects/*/instances/*/databases/*/sessions/*}:executeSql:\x01*\x12\
    \xbe\x01\n\x13ExecuteStreamingSql\x12$.google.spanner.v1.ExecuteSqlReque\
    st\x1a#.google.spanner.v1.PartialResultSet\"Z\x82\xd3\xe4\x93\x02T\"O/v1\
    /{session=projects/*/instances/*/databases/*/sessions/*}:executeStreamin\
    gSql:\x01*0\x01\x12\xc0\x01\n\x0fExecuteBatchDml\x12).google.spanner.v1.\
    ExecuteBatchDmlRequest\x1a*.google.spanner.v1.ExecuteBatchDmlResponse\"V\
    \x82\xd3\xe4\x93\x02P\"K/v1/{session=projects/*/instances/*/databases/*/\
    sessions/*}:executeBatchDml:\x01*\x12\x91\x01\n\x04Read\x12\x1e.google.s\
    panner.v1.ReadRequest\x1a\x1c.google.spanner.v1.ResultSet\"K\x82\xd3\xe4\
    \x93\x02E\"@/v1/{session=projects/*/instances/*/databases/*/sessions/*}:\
    read:\x01*\x12\xac\x01\n\rStreamingRead\x12\x1e.google.spanner.v1.ReadRe\
    quest\x1a#.google.spanner.v1.PartialResultSet\"T\x82\xd3\xe4\x93\x02N\"I\
    /v1/{session=projects/*/instances/*/databases/*/sessions/*}:streamingRea\
    d:\x01*0\x01\x12\xc9\x01\n\x10BeginTransaction\x12*.google.spanner.v1.Be\
    ginTransactionRequest\x1a\x1e.google.spanner.v1.Transaction\"i\x82\xd3\
    \xe4\x93\x02Q\"L/v1/{session=projects/*/instances/*/databases/*/sessions\
    /*}:beginTransaction:\x01*\xdaA\x0fsession,options\x12\xeb\x01\n\x06Comm\
    it\x12\x20.google.spanner.v1.CommitRequest\x1a!.google.spanner.v1.Commit\
    Response\"\x9b\x01\x82\xd3\xe4\x93\x02G\"B/v1/{session=projects/*/instan\
    ces/*/databases/*/sessions/*}:commit:\x01*\xdaA\x20session,transaction_i\
    d,mutations\xdaA(session,single_use_transaction,mutations\x12\xb0\x01\n\
    \x08Rollback\x12\".google.spanner.v1.RollbackRequest\x1a\x16.google.prot\
    obuf.Empty\"h\x82\xd3\xe4\x93\x02I\"D/v1/{session=projects/*/instances/*\
    /databases/*/sessions/*}:rollback:\x01*\xdaA\x16session,transaction_id\
    \x12\xb7\x01\n\x0ePartitionQuery\x12(.google.spanner.v1.PartitionQueryRe\
    quest\x1a$.google.spanner.v1.PartitionResponse\"U\x82\xd3\xe4\x93\x02O\"\
    J/v1/{session=projects/*/instances/*/databases/*/sessions/*}:partitionQu\
    ery:\x01*\x12\xb4\x01\n\rPartitionRead\x12'.google.spanner.v1.PartitionR\
    eadRequest\x1a$.google.spanner.v1.PartitionResponse\"T\x82\xd3\xe4\x93\
    \x02N\"I/v1/{session=projects/*/instances/*/databases/*/sessions/*}:part\
    itionRead:\x01*\x1aw\xd2A[https://www.googleapis.com/auth/cloud-platform\
    ,https://www.googleapis.com/auth/spanner.data\xcaA\x16spanner.googleapis\
    .comB\xf7\x01\n\x15com.google.spanner.v1B\x0cSpannerProtoP\x01Z8google.g\
    olang.org/genproto/googleapis/spanner/v1;spanner\xaa\x02\x17Google.Cloud\
    .Spanner.V1\xca\x02\x17Google\\Cloud\\Spanner\\V1\xeaA_\n\x1fspanner.goo\
    gleapis.com/Database\x12<projects/{project}/instances/{instance}/databas\
    es/{database}J\x8d\x96\x02\n\x07\x12\x05\x0f\0\x90\x07\x01\n\xbe\x04\n\
    \x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20LL\
    C.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202\
    .0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20fil\
    e\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20m\
    ay\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1a\n\t\n\x02\x03\0\x12\
    \x03\x13\0&\n\t\n\x02\x03\x01\x12\x03\x14\0!\n\t\n\x02\x03\x02\x12\x03\
    \x15\0)\n\t\n\x02\x03\x03\x12\x03\x16\0#\n\t\n\x02\x03\x04\x12\x03\x17\0\
    %\n\t\n\x02\x03\x05\x12\x03\x18\0&\n\t\n\x02\x03\x06\x12\x03\x19\0)\n\t\
    \n\x02\x03\x07\x12\x03\x1a\0!\n\t\n\x02\x03\x08\x12\x03\x1b\0&\n\t\n\x02\
    \x03\t\x12\x03\x1c\0*\n\t\n\x02\x03\n\x12\x03\x1d\0,\n\t\n\x02\x03\x0b\
    \x12\x03\x1e\0-\n\t\n\x02\x03\x0c\x12\x03\x1f\0&\n\x08\n\x01\x08\x12\x03\
    !\04\n\t\n\x02\x08%\x12\x03!\04\n\x08\n\x01\x08\x12\x03\"\0O\n\t\n\x02\
    \x08\x0b\x12\x03\"\0O\n\x08\n\x01\x08\x12\x03#\0\"\n\t\n\x02\x08\n\x12\
    \x03#\0\"\n\x08\n\x01\x08\x12\x03$\0-\n\t\n\x02\x08\x08\x12\x03$\0-\n\
    \x08\n\x01\x08\x12\x03%\0.\n\t\n\x02\x08\x01\x12\x03%\0.\n\x08\n\x01\x08\
    \x12\x03&\04\n\t\n\x02\x08)\x12\x03&\04\n\t\n\x01\x08\x12\x04+\0.\x02\n\
    \xc1\x01\n\x04\x08\x9d\x08\0\x12\x04+\0.\x02\x1a\xb2\x01\x20The\x20Datab\
    ase\x20resource\x20is\x20defined\x20in\x20`google.spanner.admin.database\
    .v1`.\n\x20Because\x20this\x20is\x20a\x20separate,\x20independent\x20API\
    \x20(technically),\x20we\x20redefine\n\x20the\x20resource\x20name\x20pat\
    tern\x20here.\n\n\x9d\x01\n\x02\x06\0\x12\x054\0\xaa\x02\x01\x1a\x8f\x01\
    \x20Cloud\x20Spanner\x20API\n\n\x20The\x20Cloud\x20Spanner\x20API\x20can\
    \x20be\x20used\x20to\x20manage\x20sessions\x20and\x20execute\n\x20transa\
    ctions\x20on\x20data\x20stored\x20in\x20Cloud\x20Spanner\x20databases.\n\
    \n\n\n\x03\x06\0\x01\x12\x034\x08\x0f\n\n\n\x03\x06\0\x03\x12\x035\x02>\
    \n\x0c\n\x05\x06\0\x03\x99\x08\x12\x035\x02>\n\x0b\n\x03\x06\0\x03\x12\
    \x046\x0285\n\r\n\x05\x06\0\x03\x9a\x08\x12\x046\x0285\n\xe7\x06\n\x04\
    \x06\0\x02\0\x12\x04M\x02S\x03\x1a\xd8\x06\x20Creates\x20a\x20new\x20ses\
    sion.\x20A\x20session\x20can\x20be\x20used\x20to\x20perform\n\x20transac\
    tions\x20that\x20read\x20and/or\x20modify\x20data\x20in\x20a\x20Cloud\
    \x20Spanner\x20database.\n\x20Sessions\x20are\x20meant\x20to\x20be\x20re\
    used\x20for\x20many\x20consecutive\n\x20transactions.\n\n\x20Sessions\
    \x20can\x20only\x20execute\x20one\x20transaction\x20at\x20a\x20time.\x20\
    To\x20execute\n\x20multiple\x20concurrent\x20read-write/write-only\x20tr\
    ansactions,\x20create\n\x20multiple\x20sessions.\x20Note\x20that\x20stan\
    dalone\x20reads\x20and\x20queries\x20use\x20a\n\x20transaction\x20intern\
    ally,\x20and\x20count\x20toward\x20the\x20one\x20transaction\n\x20limit.\
    \n\n\x20Active\x20sessions\x20use\x20additional\x20server\x20resources,\
    \x20so\x20it\x20is\x20a\x20good\x20idea\x20to\n\x20delete\x20idle\x20and\
    \x20unneeded\x20sessions.\n\x20Aside\x20from\x20explicit\x20deletes,\x20\
    Cloud\x20Spanner\x20can\x20delete\x20sessions\x20for\x20which\x20no\n\
    \x20operations\x20are\x20sent\x20for\x20more\x20than\x20an\x20hour.\x20I\
    f\x20a\x20session\x20is\x20deleted,\n\x20requests\x20to\x20it\x20return\
    \x20`NOT_FOUND`.\n\n\x20Idle\x20sessions\x20can\x20be\x20kept\x20alive\
    \x20by\x20sending\x20a\x20trivial\x20SQL\x20query\n\x20periodically,\x20\
    e.g.,\x20`\"SELECT\x201\"`.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03M\x06\
    \x13\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03M\x14(\n\x0c\n\x05\x06\0\x02\0\
    \x03\x12\x03M3:\n\r\n\x05\x06\0\x02\0\x04\x12\x04N\x04Q\x06\n\x11\n\t\
    \x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04N\x04Q\x06\n\x0c\n\x05\x06\0\x02\0\
    \x04\x12\x03R\x046\n\x0f\n\x08\x06\0\x02\0\x04\x9b\x08\0\x12\x03R\x046\n\
    \xbf\x01\n\x04\x06\0\x02\x01\x12\x04Y\x02`\x03\x1a\xb0\x01\x20Creates\
    \x20multiple\x20new\x20sessions.\n\n\x20This\x20API\x20can\x20be\x20used\
    \x20to\x20initialize\x20a\x20session\x20cache\x20on\x20the\x20clients.\n\
    \x20See\x20https://goo.gl/TgSFN2\x20for\x20best\x20practices\x20on\x20se\
    ssion\x20cache\x20management.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03Y\
    \x06\x19\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03Y\x1a4\n\x0c\n\x05\x06\0\
    \x02\x01\x03\x12\x03Z\x0f*\n\r\n\x05\x06\0\x02\x01\x04\x12\x04[\x04^\x06\
    \n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04[\x04^\x06\n\x0c\n\x05\
    \x06\0\x02\x01\x04\x12\x03_\x04D\n\x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\
    \x12\x03_\x04D\n\x9d\x01\n\x04\x06\0\x02\x02\x12\x04e\x02j\x03\x1a\x8e\
    \x01\x20Gets\x20a\x20session.\x20Returns\x20`NOT_FOUND`\x20if\x20the\x20\
    session\x20does\x20not\x20exist.\n\x20This\x20is\x20mainly\x20useful\x20\
    for\x20determining\x20whether\x20a\x20session\x20is\x20still\n\x20alive.\
    \n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03e\x06\x10\n\x0c\n\x05\x06\0\x02\
    \x02\x02\x12\x03e\x11\"\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03e-4\n\r\n\
    \x05\x06\0\x02\x02\x04\x12\x04f\x04h\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\
    \xca\xbc\"\x12\x04f\x04h\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03i\x042\
    \n\x0f\n\x08\x06\0\x02\x02\x04\x9b\x08\0\x12\x03i\x042\n7\n\x04\x06\0\
    \x02\x03\x12\x04m\x02r\x03\x1a)\x20Lists\x20all\x20sessions\x20in\x20a\
    \x20given\x20database.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03m\x06\x12\
    \n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03m\x13&\n\x0c\n\x05\x06\0\x02\x03\
    \x03\x12\x03m1E\n\r\n\x05\x06\0\x02\x03\x04\x12\x04n\x04p\x06\n\x11\n\t\
    \x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04n\x04p\x06\n\x0c\n\x05\x06\0\x02\
    \x03\x04\x12\x03q\x046\n\x0f\n\x08\x06\0\x02\x03\x04\x9b\x08\0\x12\x03q\
    \x046\n\xb5\x01\n\x04\x06\0\x02\x04\x12\x04w\x02|\x03\x1a\xa6\x01\x20End\
    s\x20a\x20session,\x20releasing\x20server\x20resources\x20associated\x20\
    with\x20it.\x20This\x20will\n\x20asynchronously\x20trigger\x20cancellati\
    on\x20of\x20any\x20operations\x20that\x20are\x20running\x20with\n\x20thi\
    s\x20session.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03w\x06\x13\n\x0c\n\
    \x05\x06\0\x02\x04\x02\x12\x03w\x14(\n\x0c\n\x05\x06\0\x02\x04\x03\x12\
    \x03w3H\n\r\n\x05\x06\0\x02\x04\x04\x12\x04x\x04z\x06\n\x11\n\t\x06\0\
    \x02\x04\x04\xb0\xca\xbc\"\x12\x04x\x04z\x06\n\x0c\n\x05\x06\0\x02\x04\
    \x04\x12\x03{\x042\n\x0f\n\x08\x06\0\x02\x04\x04\x9b\x08\0\x12\x03{\x042\
    \n\xed\x04\n\x04\x06\0\x02\x05\x12\x06\x8b\x01\x02\x90\x01\x03\x1a\xdc\
    \x04\x20Executes\x20an\x20SQL\x20statement,\x20returning\x20all\x20resul\
    ts\x20in\x20a\x20single\x20reply.\x20This\n\x20method\x20cannot\x20be\
    \x20used\x20to\x20return\x20a\x20result\x20set\x20larger\x20than\x2010\
    \x20MiB;\n\x20if\x20the\x20query\x20yields\x20more\x20data\x20than\x20th\
    at,\x20the\x20query\x20fails\x20with\n\x20a\x20`FAILED_PRECONDITION`\x20\
    error.\n\n\x20Operations\x20inside\x20read-write\x20transactions\x20migh\
    t\x20return\x20`ABORTED`.\x20If\n\x20this\x20occurs,\x20the\x20applicati\
    on\x20should\x20restart\x20the\x20transaction\x20from\n\x20the\x20beginn\
    ing.\x20See\x20[Transaction][google.spanner.v1.Transaction]\x20for\x20mo\
    re\n\x20details.\n\n\x20Larger\x20result\x20sets\x20can\x20be\x20fetched\
    \x20in\x20streaming\x20fashion\x20by\x20calling\n\x20[ExecuteStreamingSq\
    l][google.spanner.v1.Spanner.ExecuteStreamingSql]\n\x20instead.\n\n\r\n\
    \x05\x06\0\x02\x05\x01\x12\x04\x8b\x01\x06\x10\n\r\n\x05\x06\0\x02\x05\
    \x02\x12\x04\x8b\x01\x11\"\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\x8b\x01-6\
    \n\x0f\n\x05\x06\0\x02\x05\x04\x12\x06\x8c\x01\x04\x8f\x01\x06\n\x13\n\t\
    \x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x06\x8c\x01\x04\x8f\x01\x06\n\xd7\
    \x02\n\x04\x06\0\x02\x06\x12\x06\x97\x01\x02\x9c\x01\x03\x1a\xc6\x02\x20\
    Like\x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],\x20except\
    \x20returns\x20the\n\x20result\x20set\x20as\x20a\x20stream.\x20Unlike\n\
    \x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],\x20there\x20is\
    \x20no\x20limit\x20on\n\x20the\x20size\x20of\x20the\x20returned\x20resul\
    t\x20set.\x20However,\x20no\x20individual\x20row\x20in\x20the\n\x20resul\
    t\x20set\x20can\x20exceed\x20100\x20MiB,\x20and\x20no\x20column\x20value\
    \x20can\x20exceed\x2010\x20MiB.\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\
    \x97\x01\x06\x19\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x97\x01\x1a+\n\r\n\
    \x05\x06\0\x02\x06\x06\x12\x04\x97\x016<\n\r\n\x05\x06\0\x02\x06\x03\x12\
    \x04\x97\x01=M\n\x0f\n\x05\x06\0\x02\x06\x04\x12\x06\x98\x01\x04\x9b\x01\
    \x06\n\x13\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x06\x98\x01\x04\x9b\
    \x01\x06\n\x86\x05\n\x04\x06\0\x02\x07\x12\x06\xaa\x01\x02\xb0\x01\x03\
    \x1a\xf5\x04\x20Executes\x20a\x20batch\x20of\x20SQL\x20DML\x20statements\
    .\x20This\x20method\x20allows\x20many\x20statements\n\x20to\x20be\x20run\
    \x20with\x20lower\x20latency\x20than\x20submitting\x20them\x20sequential\
    ly\x20with\n\x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].\n\n\
    \x20Statements\x20are\x20executed\x20in\x20sequential\x20order.\x20A\x20\
    request\x20can\x20succeed\x20even\x20if\n\x20a\x20statement\x20fails.\
    \x20The\n\x20[ExecuteBatchDmlResponse.status][google.spanner.v1.ExecuteB\
    atchDmlResponse.status]\n\x20field\x20in\x20the\x20response\x20provides\
    \x20information\x20about\x20the\x20statement\x20that\x20failed.\n\x20Cli\
    ents\x20must\x20inspect\x20this\x20field\x20to\x20determine\x20whether\
    \x20an\x20error\x20occurred.\n\n\x20Execution\x20stops\x20after\x20the\
    \x20first\x20failed\x20statement;\x20the\x20remaining\x20statements\n\
    \x20are\x20not\x20executed.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\xaa\
    \x01\x06\x15\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\xaa\x01\x16,\n\r\n\x05\
    \x06\0\x02\x07\x03\x12\x04\xab\x01\x0f&\n\x0f\n\x05\x06\0\x02\x07\x04\
    \x12\x06\xac\x01\x04\xaf\x01\x06\n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\
    \"\x12\x06\xac\x01\x04\xaf\x01\x06\n\xb2\x05\n\x04\x06\0\x02\x08\x12\x06\
    \xc0\x01\x02\xc5\x01\x03\x1a\xa1\x05\x20Reads\x20rows\x20from\x20the\x20\
    database\x20using\x20key\x20lookups\x20and\x20scans,\x20as\x20a\n\x20sim\
    ple\x20key/value\x20style\x20alternative\x20to\n\x20[ExecuteSql][google.\
    spanner.v1.Spanner.ExecuteSql].\x20\x20This\x20method\x20cannot\x20be\n\
    \x20used\x20to\x20return\x20a\x20result\x20set\x20larger\x20than\x2010\
    \x20MiB;\x20if\x20the\x20read\x20matches\x20more\n\x20data\x20than\x20th\
    at,\x20the\x20read\x20fails\x20with\x20a\x20`FAILED_PRECONDITION`\n\x20e\
    rror.\n\n\x20Reads\x20inside\x20read-write\x20transactions\x20might\x20r\
    eturn\x20`ABORTED`.\x20If\n\x20this\x20occurs,\x20the\x20application\x20\
    should\x20restart\x20the\x20transaction\x20from\n\x20the\x20beginning.\
    \x20See\x20[Transaction][google.spanner.v1.Transaction]\x20for\x20more\n\
    \x20details.\n\n\x20Larger\x20result\x20sets\x20can\x20be\x20yielded\x20\
    in\x20streaming\x20fashion\x20by\x20calling\n\x20[StreamingRead][google.\
    spanner.v1.Spanner.StreamingRead]\x20instead.\n\n\r\n\x05\x06\0\x02\x08\
    \x01\x12\x04\xc0\x01\x06\n\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\xc0\x01\
    \x0b\x16\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\xc0\x01!*\n\x0f\n\x05\x06\0\
    \x02\x08\x04\x12\x06\xc1\x01\x04\xc4\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\
    \xb0\xca\xbc\"\x12\x06\xc1\x01\x04\xc4\x01\x06\n\xbf\x02\n\x04\x06\0\x02\
    \t\x12\x06\xcc\x01\x02\xd1\x01\x03\x1a\xae\x02\x20Like\x20[Read][google.\
    spanner.v1.Spanner.Read],\x20except\x20returns\x20the\x20result\x20set\n\
    \x20as\x20a\x20stream.\x20Unlike\x20[Read][google.spanner.v1.Spanner.Rea\
    d],\x20there\x20is\x20no\n\x20limit\x20on\x20the\x20size\x20of\x20the\
    \x20returned\x20result\x20set.\x20However,\x20no\x20individual\x20row\
    \x20in\n\x20the\x20result\x20set\x20can\x20exceed\x20100\x20MiB,\x20and\
    \x20no\x20column\x20value\x20can\x20exceed\n\x2010\x20MiB.\n\n\r\n\x05\
    \x06\0\x02\t\x01\x12\x04\xcc\x01\x06\x13\n\r\n\x05\x06\0\x02\t\x02\x12\
    \x04\xcc\x01\x14\x1f\n\r\n\x05\x06\0\x02\t\x06\x12\x04\xcc\x01*0\n\r\n\
    \x05\x06\0\x02\t\x03\x12\x04\xcc\x011A\n\x0f\n\x05\x06\0\x02\t\x04\x12\
    \x06\xcd\x01\x04\xd0\x01\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\
    \x06\xcd\x01\x04\xd0\x01\x06\n\x88\x02\n\x04\x06\0\x02\n\x12\x06\xd8\x01\
    \x02\xde\x01\x03\x1a\xf7\x01\x20Begins\x20a\x20new\x20transaction.\x20Th\
    is\x20step\x20can\x20often\x20be\x20skipped:\n\x20[Read][google.spanner.\
    v1.Spanner.Read],\n\x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql\
    ]\x20and\n\x20[Commit][google.spanner.v1.Spanner.Commit]\x20can\x20begin\
    \x20a\x20new\x20transaction\x20as\x20a\n\x20side-effect.\n\n\r\n\x05\x06\
    \0\x02\n\x01\x12\x04\xd8\x01\x06\x16\n\r\n\x05\x06\0\x02\n\x02\x12\x04\
    \xd8\x01\x17.\n\r\n\x05\x06\0\x02\n\x03\x12\x04\xd8\x019D\n\x0f\n\x05\
    \x06\0\x02\n\x04\x12\x06\xd9\x01\x04\xdc\x01\x06\n\x13\n\t\x06\0\x02\n\
    \x04\xb0\xca\xbc\"\x12\x06\xd9\x01\x04\xdc\x01\x06\n\r\n\x05\x06\0\x02\n\
    \x04\x12\x04\xdd\x01\x04=\n\x10\n\x08\x06\0\x02\n\x04\x9b\x08\0\x12\x04\
    \xdd\x01\x04=\n\xb6\x03\n\x04\x06\0\x02\x0b\x12\x06\xe8\x01\x02\xf0\x01\
    \x03\x1a\xa5\x03\x20Commits\x20a\x20transaction.\x20The\x20request\x20in\
    cludes\x20the\x20mutations\x20to\x20be\n\x20applied\x20to\x20rows\x20in\
    \x20the\x20database.\n\n\x20`Commit`\x20might\x20return\x20an\x20`ABORTE\
    D`\x20error.\x20This\x20can\x20occur\x20at\x20any\x20time;\n\x20commonly\
    ,\x20the\x20cause\x20is\x20conflicts\x20with\x20concurrent\n\x20transact\
    ions.\x20However,\x20it\x20can\x20also\x20happen\x20for\x20a\x20variety\
    \x20of\x20other\n\x20reasons.\x20If\x20`Commit`\x20returns\x20`ABORTED`,\
    \x20the\x20caller\x20should\x20re-attempt\n\x20the\x20transaction\x20fro\
    m\x20the\x20beginning,\x20re-using\x20the\x20same\x20session.\n\n\r\n\
    \x05\x06\0\x02\x0b\x01\x12\x04\xe8\x01\x06\x0c\n\r\n\x05\x06\0\x02\x0b\
    \x02\x12\x04\xe8\x01\r\x1a\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xe8\x01%3\
    \n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xe9\x01\x04\xec\x01\x06\n\x13\n\t\
    \x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xe9\x01\x04\xec\x01\x06\n\r\n\
    \x05\x06\0\x02\x0b\x04\x12\x04\xed\x01\x04N\n\x10\n\x08\x06\0\x02\x0b\
    \x04\x9b\x08\0\x12\x04\xed\x01\x04N\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\
    \x06\xee\x01\x04\xef\x013\n\x12\n\x08\x06\0\x02\x0b\x04\x9b\x08\x01\x12\
    \x06\xee\x01\x04\xef\x013\n\xd8\x03\n\x04\x06\0\x02\x0c\x12\x06\xfb\x01\
    \x02\x81\x02\x03\x1a\xc7\x03\x20Rolls\x20back\x20a\x20transaction,\x20re\
    leasing\x20any\x20locks\x20it\x20holds.\x20It\x20is\x20a\x20good\n\x20id\
    ea\x20to\x20call\x20this\x20for\x20any\x20transaction\x20that\x20include\
    s\x20one\x20or\x20more\n\x20[Read][google.spanner.v1.Spanner.Read]\x20or\
    \n\x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql]\x20requests\x20\
    and\x20ultimately\n\x20decides\x20not\x20to\x20commit.\n\n\x20`Rollback`\
    \x20returns\x20`OK`\x20if\x20it\x20successfully\x20aborts\x20the\x20tran\
    saction,\x20the\n\x20transaction\x20was\x20already\x20aborted,\x20or\x20\
    the\x20transaction\x20is\x20not\n\x20found.\x20`Rollback`\x20never\x20re\
    turns\x20`ABORTED`.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xfb\x01\x06\
    \x0e\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xfb\x01\x0f\x1e\n\r\n\x05\x06\0\
    \x02\x0c\x03\x12\x04\xfb\x01)>\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\x06\xfc\
    \x01\x04\xff\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\x06\
    \xfc\x01\x04\xff\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\x80\x02\x04\
    D\n\x10\n\x08\x06\0\x02\x0c\x04\x9b\x08\0\x12\x04\x80\x02\x04D\n\xf0\x05\
    \n\x04\x06\0\x02\r\x12\x06\x8f\x02\x02\x94\x02\x03\x1a\xdf\x05\x20Create\
    s\x20a\x20set\x20of\x20partition\x20tokens\x20that\x20can\x20be\x20used\
    \x20to\x20execute\x20a\x20query\n\x20operation\x20in\x20parallel.\x20\
    \x20Each\x20of\x20the\x20returned\x20partition\x20tokens\x20can\x20be\
    \x20used\n\x20by\x20[ExecuteStreamingSql][google.spanner.v1.Spanner.Exec\
    uteStreamingSql]\x20to\n\x20specify\x20a\x20subset\x20of\x20the\x20query\
    \x20result\x20to\x20read.\x20\x20The\x20same\x20session\x20and\n\x20read\
    -only\x20transaction\x20must\x20be\x20used\x20by\x20the\x20PartitionQuer\
    yRequest\x20used\x20to\n\x20create\x20the\x20partition\x20tokens\x20and\
    \x20the\x20ExecuteSqlRequests\x20that\x20use\x20the\n\x20partition\x20to\
    kens.\n\n\x20Partition\x20tokens\x20become\x20invalid\x20when\x20the\x20\
    session\x20used\x20to\x20create\x20them\n\x20is\x20deleted,\x20is\x20idl\
    e\x20for\x20too\x20long,\x20begins\x20a\x20new\x20transaction,\x20or\x20\
    becomes\x20too\n\x20old.\x20\x20When\x20any\x20of\x20these\x20happen,\
    \x20it\x20is\x20not\x20possible\x20to\x20resume\x20the\x20query,\x20and\
    \n\x20the\x20whole\x20operation\x20must\x20be\x20restarted\x20from\x20th\
    e\x20beginning.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\x8f\x02\x06\x14\n\r\
    \n\x05\x06\0\x02\r\x02\x12\x04\x8f\x02\x15*\n\r\n\x05\x06\0\x02\r\x03\
    \x12\x04\x8f\x025F\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\x90\x02\x04\x93\
    \x02\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\x90\x02\x04\x93\
    \x02\x06\n\x85\x07\n\x04\x06\0\x02\x0e\x12\x06\xa4\x02\x02\xa9\x02\x03\
    \x1a\xf4\x06\x20Creates\x20a\x20set\x20of\x20partition\x20tokens\x20that\
    \x20can\x20be\x20used\x20to\x20execute\x20a\x20read\n\x20operation\x20in\
    \x20parallel.\x20\x20Each\x20of\x20the\x20returned\x20partition\x20token\
    s\x20can\x20be\x20used\n\x20by\x20[StreamingRead][google.spanner.v1.Span\
    ner.StreamingRead]\x20to\x20specify\x20a\n\x20subset\x20of\x20the\x20rea\
    d\x20result\x20to\x20read.\x20\x20The\x20same\x20session\x20and\x20read-\
    only\n\x20transaction\x20must\x20be\x20used\x20by\x20the\x20PartitionRea\
    dRequest\x20used\x20to\x20create\x20the\n\x20partition\x20tokens\x20and\
    \x20the\x20ReadRequests\x20that\x20use\x20the\x20partition\x20tokens.\
    \x20\x20There\n\x20are\x20no\x20ordering\x20guarantees\x20on\x20rows\x20\
    returned\x20among\x20the\x20returned\x20partition\n\x20tokens,\x20or\x20\
    even\x20within\x20each\x20individual\x20StreamingRead\x20call\x20issued\
    \x20with\x20a\n\x20partition_token.\n\n\x20Partition\x20tokens\x20become\
    \x20invalid\x20when\x20the\x20session\x20used\x20to\x20create\x20them\n\
    \x20is\x20deleted,\x20is\x20idle\x20for\x20too\x20long,\x20begins\x20a\
    \x20new\x20transaction,\x20or\x20becomes\x20too\n\x20old.\x20\x20When\
    \x20any\x20of\x20these\x20happen,\x20it\x20is\x20not\x20possible\x20to\
    \x20resume\x20the\x20read,\x20and\n\x20the\x20whole\x20operation\x20must\
    \x20be\x20restarted\x20from\x20the\x20beginning.\n\n\r\n\x05\x06\0\x02\
    \x0e\x01\x12\x04\xa4\x02\x06\x13\n\r\n\x05\x06\0\x02\x0e\x02\x12\x04\xa4\
    \x02\x14(\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\xa4\x023D\n\x0f\n\x05\x06\
    \0\x02\x0e\x04\x12\x06\xa5\x02\x04\xa8\x02\x06\n\x13\n\t\x06\0\x02\x0e\
    \x04\xb0\xca\xbc\"\x12\x06\xa5\x02\x04\xa8\x02\x06\nY\n\x02\x04\0\x12\
    \x06\xad\x02\0\xb8\x02\x01\x1aK\x20The\x20request\x20for\x20[CreateSessi\
    on][google.spanner.v1.Spanner.CreateSession].\n\n\x0b\n\x03\x04\0\x01\
    \x12\x04\xad\x02\x08\x1c\nM\n\x04\x04\0\x02\0\x12\x06\xaf\x02\x02\xb4\
    \x02\x04\x1a=\x20Required.\x20The\x20database\x20in\x20which\x20the\x20n\
    ew\x20session\x20is\x20created.\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xaf\
    \x02\x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xaf\x02\t\x11\n\r\n\x05\
    \x04\0\x02\0\x03\x12\x04\xaf\x02\x14\x15\n\x0f\n\x05\x04\0\x02\0\x08\x12\
    \x06\xaf\x02\x16\xb4\x02\x03\n\x10\n\x08\x04\0\x02\0\x08\x9c\x08\0\x12\
    \x04\xb0\x02\x04*\n\x11\n\x07\x04\0\x02\0\x08\x9f\x08\x12\x06\xb1\x02\
    \x04\xb3\x02\x05\n&\n\x04\x04\0\x02\x01\x12\x04\xb7\x02\x02\x16\x1a\x18\
    \x20The\x20session\x20to\x20create.\n\n\r\n\x05\x04\0\x02\x01\x06\x12\
    \x04\xb7\x02\x02\t\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xb7\x02\n\x11\n\r\
    \n\x05\x04\0\x02\x01\x03\x12\x04\xb7\x02\x14\x15\nf\n\x02\x04\x01\x12\
    \x06\xbc\x02\0\xcf\x02\x01\x1aX\x20The\x20request\x20for\n\x20[BatchCrea\
    teSessions][google.spanner.v1.Spanner.BatchCreateSessions].\n\n\x0b\n\
    \x03\x04\x01\x01\x12\x04\xbc\x02\x08\"\nO\n\x04\x04\x01\x02\0\x12\x06\
    \xbe\x02\x02\xc3\x02\x04\x1a?\x20Required.\x20The\x20database\x20in\x20w\
    hich\x20the\x20new\x20sessions\x20are\x20created.\n\n\r\n\x05\x04\x01\
    \x02\0\x05\x12\x04\xbe\x02\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\
    \xbe\x02\t\x11\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xbe\x02\x14\x15\n\x0f\
    \n\x05\x04\x01\x02\0\x08\x12\x06\xbe\x02\x16\xc3\x02\x03\n\x10\n\x08\x04\
    \x01\x02\0\x08\x9c\x08\0\x12\x04\xbf\x02\x04*\n\x11\n\x07\x04\x01\x02\0\
    \x08\x9f\x08\x12\x06\xc0\x02\x04\xc2\x02\x05\nA\n\x04\x04\x01\x02\x01\
    \x12\x04\xc6\x02\x02\x1f\x1a3\x20Parameters\x20to\x20be\x20applied\x20to\
    \x20each\x20created\x20session.\n\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\
    \xc6\x02\x02\t\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xc6\x02\n\x1a\n\r\n\
    \x05\x04\x01\x02\x01\x03\x12\x04\xc6\x02\x1d\x1e\n\xe8\x02\n\x04\x04\x01\
    \x02\x02\x12\x04\xce\x02\x02C\x1a\xd9\x02\x20Required.\x20The\x20number\
    \x20of\x20sessions\x20to\x20be\x20created\x20in\x20this\x20batch\x20call\
    .\n\x20The\x20API\x20may\x20return\x20fewer\x20than\x20the\x20requested\
    \x20number\x20of\x20sessions.\x20If\x20a\n\x20specific\x20number\x20of\
    \x20sessions\x20are\x20desired,\x20the\x20client\x20can\x20make\x20addit\
    ional\n\x20calls\x20to\x20BatchCreateSessions\x20(adjusting\n\x20[sessio\
    n_count][google.spanner.v1.BatchCreateSessionsRequest.session_count]\n\
    \x20as\x20necessary).\n\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xce\x02\
    \x02\x07\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xce\x02\x08\x15\n\r\n\x05\
    \x04\x01\x02\x02\x03\x12\x04\xce\x02\x18\x19\n\r\n\x05\x04\x01\x02\x02\
    \x08\x12\x04\xce\x02\x1aB\n\x10\n\x08\x04\x01\x02\x02\x08\x9c\x08\0\x12\
    \x04\xce\x02\x1bA\ng\n\x02\x04\x02\x12\x06\xd3\x02\0\xd6\x02\x01\x1aY\
    \x20The\x20response\x20for\n\x20[BatchCreateSessions][google.spanner.v1.\
    Spanner.BatchCreateSessions].\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xd3\x02\
    \x08#\n-\n\x04\x04\x02\x02\0\x12\x04\xd5\x02\x02\x1f\x1a\x1f\x20The\x20f\
    reshly\x20created\x20sessions.\n\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\xd5\
    \x02\x02\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xd5\x02\x0b\x12\n\r\n\x05\
    \x04\x02\x02\0\x01\x12\x04\xd5\x02\x13\x1a\n\r\n\x05\x04\x02\x02\0\x03\
    \x12\x04\xd5\x02\x1d\x1e\n3\n\x02\x04\x03\x12\x06\xd9\x02\0\xf4\x02\x01\
    \x1a%\x20A\x20session\x20in\x20the\x20Cloud\x20Spanner\x20API.\n\n\x0b\n\
    \x03\x04\x03\x01\x12\x04\xd9\x02\x08\x0f\n\r\n\x03\x04\x03\x07\x12\x06\
    \xda\x02\x02\xdd\x02\x04\n\x0f\n\x05\x04\x03\x07\x9d\x08\x12\x06\xda\x02\
    \x02\xdd\x02\x04\n~\n\x04\x04\x03\x02\0\x12\x04\xe1\x02\x02\x12\x1ap\x20\
    The\x20name\x20of\x20the\x20session.\x20This\x20is\x20always\x20system-a\
    ssigned;\x20values\x20provided\n\x20when\x20creating\x20a\x20session\x20\
    are\x20ignored.\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xe1\x02\x02\x08\n\
    \r\n\x05\x04\x03\x02\0\x01\x12\x04\xe1\x02\t\r\n\r\n\x05\x04\x03\x02\0\
    \x03\x12\x04\xe1\x02\x10\x11\n\xd6\x03\n\x04\x04\x03\x02\x01\x12\x04\xec\
    \x02\x02!\x1a\xc7\x03\x20The\x20labels\x20for\x20the\x20session.\n\n\x20\
    \x20*\x20Label\x20keys\x20must\x20be\x20between\x201\x20and\x2063\x20cha\
    racters\x20long\x20and\x20must\x20conform\x20to\n\x20\x20\x20\x20the\x20\
    following\x20regular\x20expression:\x20`[a-z]([-a-z0-9]*[a-z0-9])?`.\n\
    \x20\x20*\x20Label\x20values\x20must\x20be\x20between\x200\x20and\x2063\
    \x20characters\x20long\x20and\x20must\x20conform\n\x20\x20\x20\x20to\x20\
    the\x20regular\x20expression\x20`([a-z]([-a-z0-9]*[a-z0-9])?)?`.\n\x20\
    \x20*\x20No\x20more\x20than\x2064\x20labels\x20can\x20be\x20associated\
    \x20with\x20a\x20given\x20session.\n\n\x20See\x20https://goo.gl/xmQnxf\
    \x20for\x20more\x20information\x20on\x20and\x20examples\x20of\x20labels.\
    \n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xec\x02\x02\x15\n\r\n\x05\x04\
    \x03\x02\x01\x01\x12\x04\xec\x02\x16\x1c\n\r\n\x05\x04\x03\x02\x01\x03\
    \x12\x04\xec\x02\x1f\x20\nG\n\x04\x04\x03\x02\x02\x12\x04\xef\x02\x02,\
    \x1a9\x20Output\x20only.\x20The\x20timestamp\x20when\x20the\x20session\
    \x20is\x20created.\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\xef\x02\x02\
    \x1b\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xef\x02\x1c'\n\r\n\x05\x04\
    \x03\x02\x02\x03\x12\x04\xef\x02*+\n\x8d\x01\n\x04\x04\x03\x02\x03\x12\
    \x04\xf3\x02\x02:\x1a\x7f\x20Output\x20only.\x20The\x20approximate\x20ti\
    mestamp\x20when\x20the\x20session\x20is\x20last\x20used.\x20It\x20is\n\
    \x20typically\x20earlier\x20than\x20the\x20actual\x20last\x20use\x20time\
    .\n\n\r\n\x05\x04\x03\x02\x03\x06\x12\x04\xf3\x02\x02\x1b\n\r\n\x05\x04\
    \x03\x02\x03\x01\x12\x04\xf3\x02\x1c5\n\r\n\x05\x04\x03\x02\x03\x03\x12\
    \x04\xf3\x0289\nS\n\x02\x04\x04\x12\x06\xf7\x02\0\xfd\x02\x01\x1aE\x20Th\
    e\x20request\x20for\x20[GetSession][google.spanner.v1.Spanner.GetSession\
    ].\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xf7\x02\x08\x19\n@\n\x04\x04\x04\
    \x02\0\x12\x06\xf9\x02\x02\xfc\x02\x04\x1a0\x20Required.\x20The\x20name\
    \x20of\x20the\x20session\x20to\x20retrieve.\n\n\r\n\x05\x04\x04\x02\0\
    \x05\x12\x04\xf9\x02\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xf9\x02\
    \t\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xf9\x02\x10\x11\n\x0f\n\x05\x04\
    \x04\x02\0\x08\x12\x06\xf9\x02\x12\xfc\x02\x03\n\x10\n\x08\x04\x04\x02\0\
    \x08\x9c\x08\0\x12\x04\xfa\x02\x04*\n\x0f\n\x07\x04\x04\x02\0\x08\x9f\
    \x08\x12\x04\xfb\x02\x04P\nW\n\x02\x04\x05\x12\x06\x80\x03\0\x9e\x03\x01\
    \x1aI\x20The\x20request\x20for\x20[ListSessions][google.spanner.v1.Spann\
    er.ListSessions].\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x80\x03\x08\x1b\nC\n\
    \x04\x04\x05\x02\0\x12\x06\x82\x03\x02\x87\x03\x04\x1a3\x20Required.\x20\
    The\x20database\x20in\x20which\x20to\x20list\x20sessions.\n\n\r\n\x05\
    \x04\x05\x02\0\x05\x12\x04\x82\x03\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\x82\x03\t\x11\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x82\x03\x14\
    \x15\n\x0f\n\x05\x04\x05\x02\0\x08\x12\x06\x82\x03\x16\x87\x03\x03\n\x10\
    \n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\x83\x03\x04*\n\x11\n\x07\x04\
    \x05\x02\0\x08\x9f\x08\x12\x06\x84\x03\x04\x86\x03\x05\n\x85\x01\n\x04\
    \x04\x05\x02\x01\x12\x04\x8b\x03\x02\x16\x1aw\x20Number\x20of\x20session\
    s\x20to\x20be\x20returned\x20in\x20the\x20response.\x20If\x200\x20or\x20\
    less,\x20defaults\n\x20to\x20the\x20server's\x20maximum\x20allowed\x20pa\
    ge\x20size.\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x8b\x03\x02\x07\n\r\
    \n\x05\x04\x05\x02\x01\x01\x12\x04\x8b\x03\x08\x11\n\r\n\x05\x04\x05\x02\
    \x01\x03\x12\x04\x8b\x03\x14\x15\n\xd9\x01\n\x04\x04\x05\x02\x02\x12\x04\
    \x91\x03\x02\x18\x1a\xca\x01\x20If\x20non-empty,\x20`page_token`\x20shou\
    ld\x20contain\x20a\n\x20[next_page_token][google.spanner.v1.ListSessions\
    Response.next_page_token]\n\x20from\x20a\x20previous\n\x20[ListSessionsR\
    esponse][google.spanner.v1.ListSessionsResponse].\n\n\r\n\x05\x04\x05\
    \x02\x02\x05\x12\x04\x91\x03\x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\
    \x04\x91\x03\t\x13\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x91\x03\x16\x17\
    \n\xaf\x03\n\x04\x04\x05\x02\x03\x12\x04\x9d\x03\x02\x14\x1a\xa0\x03\x20\
    An\x20expression\x20for\x20filtering\x20the\x20results\x20of\x20the\x20r\
    equest.\x20Filter\x20rules\x20are\n\x20case\x20insensitive.\x20The\x20fi\
    elds\x20eligible\x20for\x20filtering\x20are:\n\n\x20\x20\x20*\x20`labels\
    .key`\x20where\x20key\x20is\x20the\x20name\x20of\x20a\x20label\n\n\x20So\
    me\x20examples\x20of\x20using\x20filters\x20are:\n\n\x20\x20\x20*\x20`la\
    bels.env:*`\x20-->\x20The\x20session\x20has\x20the\x20label\x20\"env\".\
    \n\x20\x20\x20*\x20`labels.env:dev`\x20-->\x20The\x20session\x20has\x20t\
    he\x20label\x20\"env\"\x20and\x20the\x20value\x20of\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20the\x20label\x20contains\x20the\x20string\x20\"dev\".\n\n\r\n\
    \x05\x04\x05\x02\x03\x05\x12\x04\x9d\x03\x02\x08\n\r\n\x05\x04\x05\x02\
    \x03\x01\x12\x04\x9d\x03\t\x0f\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x9d\
    \x03\x12\x13\nX\n\x02\x04\x06\x12\x06\xa1\x03\0\xa9\x03\x01\x1aJ\x20The\
    \x20response\x20for\x20[ListSessions][google.spanner.v1.Spanner.ListSess\
    ions].\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xa1\x03\x08\x1c\n/\n\x04\x04\
    \x06\x02\0\x12\x04\xa3\x03\x02\x20\x1a!\x20The\x20list\x20of\x20requeste\
    d\x20sessions.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xa3\x03\x02\n\n\r\n\
    \x05\x04\x06\x02\0\x06\x12\x04\xa3\x03\x0b\x12\n\r\n\x05\x04\x06\x02\0\
    \x01\x12\x04\xa3\x03\x13\x1b\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xa3\x03\
    \x1e\x1f\n\xa4\x01\n\x04\x04\x06\x02\x01\x12\x04\xa8\x03\x02\x1d\x1a\x95\
    \x01\x20`next_page_token`\x20can\x20be\x20sent\x20in\x20a\x20subsequent\
    \n\x20[ListSessions][google.spanner.v1.Spanner.ListSessions]\x20call\x20\
    to\x20fetch\x20more\n\x20of\x20the\x20matching\x20sessions.\n\n\r\n\x05\
    \x04\x06\x02\x01\x05\x12\x04\xa8\x03\x02\x08\n\r\n\x05\x04\x06\x02\x01\
    \x01\x12\x04\xa8\x03\t\x18\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xa8\x03\
    \x1b\x1c\nY\n\x02\x04\x07\x12\x06\xac\x03\0\xb2\x03\x01\x1aK\x20The\x20r\
    equest\x20for\x20[DeleteSession][google.spanner.v1.Spanner.DeleteSession\
    ].\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xac\x03\x08\x1c\n>\n\x04\x04\x07\
    \x02\0\x12\x06\xae\x03\x02\xb1\x03\x04\x1a.\x20Required.\x20The\x20name\
    \x20of\x20the\x20session\x20to\x20delete.\n\n\r\n\x05\x04\x07\x02\0\x05\
    \x12\x04\xae\x03\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xae\x03\t\r\
    \n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xae\x03\x10\x11\n\x0f\n\x05\x04\x07\
    \x02\0\x08\x12\x06\xae\x03\x12\xb1\x03\x03\n\x10\n\x08\x04\x07\x02\0\x08\
    \x9c\x08\0\x12\x04\xaf\x03\x04*\n\x0f\n\x07\x04\x07\x02\0\x08\x9f\x08\
    \x12\x04\xb0\x03\x04P\n\x9e\x01\n\x02\x04\x08\x12\x06\xb6\x03\0\x94\x04\
    \x01\x1a\x8f\x01\x20The\x20request\x20for\x20[ExecuteSql][google.spanner\
    .v1.Spanner.ExecuteSql]\x20and\n\x20[ExecuteStreamingSql][google.spanner\
    .v1.Spanner.ExecuteStreamingSql].\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xb6\
    \x03\x08\x19\n@\n\x04\x04\x08\x04\0\x12\x06\xb8\x03\x02\xc3\x03\x03\x1a0\
    \x20Mode\x20in\x20which\x20the\x20statement\x20must\x20be\x20processed.\
    \n\n\r\n\x05\x04\x08\x04\0\x01\x12\x04\xb8\x03\x07\x10\nL\n\x06\x04\x08\
    \x04\0\x02\0\x12\x04\xba\x03\x04\x0f\x1a<\x20The\x20default\x20mode.\x20\
    Only\x20the\x20statement\x20results\x20are\x20returned.\n\n\x0f\n\x07\
    \x04\x08\x04\0\x02\0\x01\x12\x04\xba\x03\x04\n\n\x0f\n\x07\x04\x08\x04\0\
    \x02\0\x02\x12\x04\xba\x03\r\x0e\nr\n\x06\x04\x08\x04\0\x02\x01\x12\x04\
    \xbe\x03\x04\r\x1ab\x20This\x20mode\x20returns\x20only\x20the\x20query\
    \x20plan,\x20without\x20any\x20results\x20or\n\x20execution\x20statistic\
    s\x20information.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x04\xbe\
    \x03\x04\x08\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x02\x12\x04\xbe\x03\x0b\
    \x0c\nm\n\x06\x04\x08\x04\0\x02\x02\x12\x04\xc2\x03\x04\x10\x1a]\x20This\
    \x20mode\x20returns\x20both\x20the\x20query\x20plan\x20and\x20the\x20exe\
    cution\x20statistics\x20along\n\x20with\x20the\x20results.\n\n\x0f\n\x07\
    \x04\x08\x04\0\x02\x02\x01\x12\x04\xc2\x03\x04\x0b\n\x0f\n\x07\x04\x08\
    \x04\0\x02\x02\x02\x12\x04\xc2\x03\x0e\x0f\nS\n\x04\x04\x08\x02\0\x12\
    \x06\xc6\x03\x02\xc9\x03\x04\x1aC\x20Required.\x20The\x20session\x20in\
    \x20which\x20the\x20SQL\x20query\x20should\x20be\x20performed.\n\n\r\n\
    \x05\x04\x08\x02\0\x05\x12\x04\xc6\x03\x02\x08\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\xc6\x03\t\x10\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc6\x03\
    \x13\x14\n\x0f\n\x05\x04\x08\x02\0\x08\x12\x06\xc6\x03\x15\xc9\x03\x03\n\
    \x10\n\x08\x04\x08\x02\0\x08\x9c\x08\0\x12\x04\xc7\x03\x04*\n\x0f\n\x07\
    \x04\x08\x02\0\x08\x9f\x08\x12\x04\xc8\x03\x04P\n\xb9\x03\n\x04\x04\x08\
    \x02\x01\x12\x04\xd5\x03\x02&\x1a\xaa\x03\x20The\x20transaction\x20to\
    \x20use.\n\n\x20For\x20queries,\x20if\x20none\x20is\x20provided,\x20the\
    \x20default\x20is\x20a\x20temporary\x20read-only\n\x20transaction\x20wit\
    h\x20strong\x20concurrency.\n\n\x20Standard\x20DML\x20statements\x20requ\
    ire\x20a\x20read-write\x20transaction.\x20To\x20protect\n\x20against\x20\
    replays,\x20single-use\x20transactions\x20are\x20not\x20supported.\x20\
    \x20The\x20caller\n\x20must\x20either\x20supply\x20an\x20existing\x20tra\
    nsaction\x20ID\x20or\x20begin\x20a\x20new\x20transaction.\n\n\x20Partiti\
    oned\x20DML\x20requires\x20an\x20existing\x20Partitioned\x20DML\x20trans\
    action\x20ID.\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xd5\x03\x02\x15\n\
    \r\n\x05\x04\x08\x02\x01\x01\x12\x04\xd5\x03\x16!\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xd5\x03$%\n)\n\x04\x04\x08\x02\x02\x12\x04\xd8\x03\x02:\
    \x1a\x1b\x20Required.\x20The\x20SQL\x20string.\n\n\r\n\x05\x04\x08\x02\
    \x02\x05\x12\x04\xd8\x03\x02\x08\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\
    \xd8\x03\t\x0c\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xd8\x03\x0f\x10\n\r\
    \n\x05\x04\x08\x02\x02\x08\x12\x04\xd8\x03\x119\n\x10\n\x08\x04\x08\x02\
    \x02\x08\x9c\x08\0\x12\x04\xd8\x03\x128\n\x88\x04\n\x04\x04\x08\x02\x03\
    \x12\x04\xe6\x03\x02$\x1a\xf9\x03\x20Parameter\x20names\x20and\x20values\
    \x20that\x20bind\x20to\x20placeholders\x20in\x20the\x20SQL\x20string.\n\
    \n\x20A\x20parameter\x20placeholder\x20consists\x20of\x20the\x20`@`\x20c\
    haracter\x20followed\x20by\x20the\n\x20parameter\x20name\x20(for\x20exam\
    ple,\x20`@firstName`).\x20Parameter\x20names\x20can\x20contain\n\x20lett\
    ers,\x20numbers,\x20and\x20underscores.\n\n\x20Parameters\x20can\x20appe\
    ar\x20anywhere\x20that\x20a\x20literal\x20value\x20is\x20expected.\x20\
    \x20The\x20same\n\x20parameter\x20name\x20can\x20be\x20used\x20more\x20t\
    han\x20once,\x20for\x20example:\n\n\x20`\"WHERE\x20id\x20>\x20@msg_id\
    \x20AND\x20id\x20<\x20@msg_id\x20+\x20100\"`\n\n\x20It\x20is\x20an\x20er\
    ror\x20to\x20execute\x20a\x20SQL\x20statement\x20with\x20unbound\x20para\
    meters.\n\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\xe6\x03\x02\x18\n\r\n\
    \x05\x04\x08\x02\x03\x01\x12\x04\xe6\x03\x19\x1f\n\r\n\x05\x04\x08\x02\
    \x03\x03\x12\x04\xe6\x03\"#\n\xdd\x03\n\x04\x04\x08\x02\x04\x12\x04\xf1\
    \x03\x02$\x1a\xce\x03\x20It\x20is\x20not\x20always\x20possible\x20for\
    \x20Cloud\x20Spanner\x20to\x20infer\x20the\x20right\x20SQL\x20type\n\x20\
    from\x20a\x20JSON\x20value.\x20\x20For\x20example,\x20values\x20of\x20ty\
    pe\x20`BYTES`\x20and\x20values\n\x20of\x20type\x20`STRING`\x20both\x20ap\
    pear\x20in\n\x20[params][google.spanner.v1.ExecuteSqlRequest.params]\x20\
    as\x20JSON\x20strings.\n\n\x20In\x20these\x20cases,\x20`param_types`\x20\
    can\x20be\x20used\x20to\x20specify\x20the\x20exact\n\x20SQL\x20type\x20f\
    or\x20some\x20or\x20all\x20of\x20the\x20SQL\x20statement\x20parameters.\
    \x20See\x20the\n\x20definition\x20of\x20[Type][google.spanner.v1.Type]\
    \x20for\x20more\x20information\n\x20about\x20SQL\x20types.\n\n\r\n\x05\
    \x04\x08\x02\x04\x06\x12\x04\xf1\x03\x02\x13\n\r\n\x05\x04\x08\x02\x04\
    \x01\x12\x04\xf1\x03\x14\x1f\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xf1\
    \x03\"#\n\x9e\x03\n\x04\x04\x08\x02\x05\x12\x04\xf9\x03\x02\x19\x1a\x8f\
    \x03\x20If\x20this\x20request\x20is\x20resuming\x20a\x20previously\x20in\
    terrupted\x20SQL\x20statement\n\x20execution,\x20`resume_token`\x20shoul\
    d\x20be\x20copied\x20from\x20the\x20last\n\x20[PartialResultSet][google.\
    spanner.v1.PartialResultSet]\x20yielded\x20before\x20the\n\x20interrupti\
    on.\x20Doing\x20this\x20enables\x20the\x20new\x20SQL\x20statement\x20exe\
    cution\x20to\x20resume\n\x20where\x20the\x20last\x20one\x20left\x20off.\
    \x20The\x20rest\x20of\x20the\x20request\x20parameters\x20must\n\x20exact\
    ly\x20match\x20the\x20request\x20that\x20yielded\x20this\x20token.\n\n\r\
    \n\x05\x04\x08\x02\x05\x05\x12\x04\xf9\x03\x02\x07\n\r\n\x05\x04\x08\x02\
    \x05\x01\x12\x04\xf9\x03\x08\x14\n\r\n\x05\x04\x08\x02\x05\x03\x12\x04\
    \xf9\x03\x17\x18\n\xf5\x02\n\x04\x04\x08\x02\x06\x12\x04\x81\x04\x02\x1b\
    \x1a\xe6\x02\x20Used\x20to\x20control\x20the\x20amount\x20of\x20debuggin\
    g\x20information\x20returned\x20in\n\x20[ResultSetStats][google.spanner.\
    v1.ResultSetStats].\x20If\n\x20[partition_token][google.spanner.v1.Execu\
    teSqlRequest.partition_token]\x20is\n\x20set,\x20[query_mode][google.spa\
    nner.v1.ExecuteSqlRequest.query_mode]\x20can\x20only\n\x20be\x20set\x20t\
    o\n\x20[QueryMode.NORMAL][google.spanner.v1.ExecuteSqlRequest.QueryMode.\
    NORMAL].\n\n\r\n\x05\x04\x08\x02\x06\x06\x12\x04\x81\x04\x02\x0b\n\r\n\
    \x05\x04\x08\x02\x06\x01\x12\x04\x81\x04\x0c\x16\n\r\n\x05\x04\x08\x02\
    \x06\x03\x12\x04\x81\x04\x19\x1a\n\x99\x02\n\x04\x04\x08\x02\x07\x12\x04\
    \x87\x04\x02\x1c\x1a\x8a\x02\x20If\x20present,\x20results\x20will\x20be\
    \x20restricted\x20to\x20the\x20specified\x20partition\n\x20previously\
    \x20created\x20using\x20PartitionQuery().\x20\x20There\x20must\x20be\x20\
    an\x20exact\n\x20match\x20for\x20the\x20values\x20of\x20fields\x20common\
    \x20to\x20this\x20message\x20and\x20the\n\x20PartitionQueryRequest\x20me\
    ssage\x20used\x20to\x20create\x20this\x20partition_token.\n\n\r\n\x05\
    \x04\x08\x02\x07\x05\x12\x04\x87\x04\x02\x07\n\r\n\x05\x04\x08\x02\x07\
    \x01\x12\x04\x87\x04\x08\x17\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\x87\
    \x04\x1a\x1b\n\x9b\x04\n\x04\x04\x08\x02\x08\x12\x04\x93\x04\x02\x12\x1a\
    \x8c\x04\x20A\x20per-transaction\x20sequence\x20number\x20used\x20to\x20\
    identify\x20this\x20request.\x20This\x20field\n\x20makes\x20each\x20requ\
    est\x20idempotent\x20such\x20that\x20if\x20the\x20request\x20is\x20recei\
    ved\x20multiple\n\x20times,\x20at\x20most\x20one\x20will\x20succeed.\n\n\
    \x20The\x20sequence\x20number\x20must\x20be\x20monotonically\x20increasi\
    ng\x20within\x20the\n\x20transaction.\x20If\x20a\x20request\x20arrives\
    \x20for\x20the\x20first\x20time\x20with\x20an\x20out-of-order\n\x20seque\
    nce\x20number,\x20the\x20transaction\x20may\x20be\x20aborted.\x20Replays\
    \x20of\x20previously\n\x20handled\x20requests\x20will\x20yield\x20the\
    \x20same\x20response\x20as\x20the\x20first\x20execution.\n\n\x20Required\
    \x20for\x20DML\x20statements.\x20Ignored\x20for\x20queries.\n\n\r\n\x05\
    \x04\x08\x02\x08\x05\x12\x04\x93\x04\x02\x07\n\r\n\x05\x04\x08\x02\x08\
    \x01\x12\x04\x93\x04\x08\r\n\r\n\x05\x04\x08\x02\x08\x03\x12\x04\x93\x04\
    \x10\x11\n]\n\x02\x04\t\x12\x06\x97\x04\0\xd6\x04\x01\x1aO\x20The\x20req\
    uest\x20for\x20[ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchD\
    ml].\n\n\x0b\n\x03\x04\t\x01\x12\x04\x97\x04\x08\x1e\n)\n\x04\x04\t\x03\
    \0\x12\x06\x99\x04\x02\xb6\x04\x03\x1a\x19\x20A\x20single\x20DML\x20stat\
    ement.\n\n\r\n\x05\x04\t\x03\0\x01\x12\x04\x99\x04\n\x13\n+\n\x06\x04\t\
    \x03\0\x02\0\x12\x04\x9b\x04\x04\x13\x1a\x1b\x20Required.\x20The\x20DML\
    \x20string.\n\n\x0f\n\x07\x04\t\x03\0\x02\0\x05\x12\x04\x9b\x04\x04\n\n\
    \x0f\n\x07\x04\t\x03\0\x02\0\x01\x12\x04\x9b\x04\x0b\x0e\n\x0f\n\x07\x04\
    \t\x03\0\x02\0\x03\x12\x04\x9b\x04\x11\x12\n\x8a\x04\n\x06\x04\t\x03\0\
    \x02\x01\x12\x04\xa9\x04\x04&\x1a\xf9\x03\x20Parameter\x20names\x20and\
    \x20values\x20that\x20bind\x20to\x20placeholders\x20in\x20the\x20DML\x20\
    string.\n\n\x20A\x20parameter\x20placeholder\x20consists\x20of\x20the\
    \x20`@`\x20character\x20followed\x20by\x20the\n\x20parameter\x20name\x20\
    (for\x20example,\x20`@firstName`).\x20Parameter\x20names\x20can\x20conta\
    in\n\x20letters,\x20numbers,\x20and\x20underscores.\n\n\x20Parameters\
    \x20can\x20appear\x20anywhere\x20that\x20a\x20literal\x20value\x20is\x20\
    expected.\x20\x20The\n\x20same\x20parameter\x20name\x20can\x20be\x20used\
    \x20more\x20than\x20once,\x20for\x20example:\n\n\x20`\"WHERE\x20id\x20>\
    \x20@msg_id\x20AND\x20id\x20<\x20@msg_id\x20+\x20100\"`\n\n\x20It\x20is\
    \x20an\x20error\x20to\x20execute\x20a\x20SQL\x20statement\x20with\x20unb\
    ound\x20parameters.\n\n\x0f\n\x07\x04\t\x03\0\x02\x01\x06\x12\x04\xa9\
    \x04\x04\x1a\n\x0f\n\x07\x04\t\x03\0\x02\x01\x01\x12\x04\xa9\x04\x1b!\n\
    \x0f\n\x07\x04\t\x03\0\x02\x01\x03\x12\x04\xa9\x04$%\n\xef\x03\n\x06\x04\
    \t\x03\0\x02\x02\x12\x04\xb5\x04\x04&\x1a\xde\x03\x20It\x20is\x20not\x20\
    always\x20possible\x20for\x20Cloud\x20Spanner\x20to\x20infer\x20the\x20r\
    ight\x20SQL\x20type\n\x20from\x20a\x20JSON\x20value.\x20\x20For\x20examp\
    le,\x20values\x20of\x20type\x20`BYTES`\x20and\x20values\n\x20of\x20type\
    \x20`STRING`\x20both\x20appear\x20in\n\x20[params][google.spanner.v1.Exe\
    cuteBatchDmlRequest.Statement.params]\x20as\n\x20JSON\x20strings.\n\n\
    \x20In\x20these\x20cases,\x20`param_types`\x20can\x20be\x20used\x20to\
    \x20specify\x20the\x20exact\n\x20SQL\x20type\x20for\x20some\x20or\x20all\
    \x20of\x20the\x20SQL\x20statement\x20parameters.\x20See\x20the\n\x20defi\
    nition\x20of\x20[Type][google.spanner.v1.Type]\x20for\x20more\x20informa\
    tion\n\x20about\x20SQL\x20types.\n\n\x0f\n\x07\x04\t\x03\0\x02\x02\x06\
    \x12\x04\xb5\x04\x04\x15\n\x0f\n\x07\x04\t\x03\0\x02\x02\x01\x12\x04\xb5\
    \x04\x16!\n\x0f\n\x07\x04\t\x03\0\x02\x02\x03\x12\x04\xb5\x04$%\nX\n\x04\
    \x04\t\x02\0\x12\x06\xb9\x04\x02\xbc\x04\x04\x1aH\x20Required.\x20The\
    \x20session\x20in\x20which\x20the\x20DML\x20statements\x20should\x20be\
    \x20performed.\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xb9\x04\x02\x08\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xb9\x04\t\x10\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\xb9\x04\x13\x14\n\x0f\n\x05\x04\t\x02\0\x08\x12\x06\xb9\x04\x15\xbc\
    \x04\x03\n\x10\n\x08\x04\t\x02\0\x08\x9c\x08\0\x12\x04\xba\x04\x04*\n\
    \x0f\n\x07\x04\t\x02\0\x08\x9f\x08\x12\x04\xbb\x04\x04P\n\xf4\x01\n\x04\
    \x04\t\x02\x01\x12\x04\xc3\x04\x02O\x1a\xe5\x01\x20Required.\x20The\x20t\
    ransaction\x20to\x20use.\x20Must\x20be\x20a\x20read-write\x20transaction\
    .\n\n\x20To\x20protect\x20against\x20replays,\x20single-use\x20transacti\
    ons\x20are\x20not\x20supported.\x20The\n\x20caller\x20must\x20either\x20\
    supply\x20an\x20existing\x20transaction\x20ID\x20or\x20begin\x20a\x20new\
    \n\x20transaction.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xc3\x04\x02\x15\
    \n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xc3\x04\x16!\n\r\n\x05\x04\t\x02\
    \x01\x03\x12\x04\xc3\x04$%\n\r\n\x05\x04\t\x02\x01\x08\x12\x04\xc3\x04&N\
    \n\x10\n\x08\x04\t\x02\x01\x08\x9c\x08\0\x12\x04\xc3\x04'M\n\xe8\x02\n\
    \x04\x04\t\x02\x02\x12\x04\xcb\x04\x02M\x1a\xd9\x02\x20Required.\x20The\
    \x20list\x20of\x20statements\x20to\x20execute\x20in\x20this\x20batch.\
    \x20Statements\x20are\n\x20executed\x20serially,\x20such\x20that\x20the\
    \x20effects\x20of\x20statement\x20`i`\x20are\x20visible\x20to\n\x20state\
    ment\x20`i+1`.\x20Each\x20statement\x20must\x20be\x20a\x20DML\x20stateme\
    nt.\x20Execution\x20stops\x20at\n\x20the\x20first\x20failed\x20statement\
    ;\x20the\x20remaining\x20statements\x20are\x20not\x20executed.\n\n\x20Ca\
    llers\x20must\x20provide\x20at\x20least\x20one\x20statement.\n\n\r\n\x05\
    \x04\t\x02\x02\x04\x12\x04\xcb\x04\x02\n\n\r\n\x05\x04\t\x02\x02\x06\x12\
    \x04\xcb\x04\x0b\x14\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xcb\x04\x15\x1f\
    \n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xcb\x04\"#\n\r\n\x05\x04\t\x02\x02\
    \x08\x12\x04\xcb\x04$L\n\x10\n\x08\x04\t\x02\x02\x08\x9c\x08\0\x12\x04\
    \xcb\x04%K\n\xf1\x03\n\x04\x04\t\x02\x03\x12\x04\xd5\x04\x02;\x1a\xe2\
    \x03\x20Required.\x20A\x20per-transaction\x20sequence\x20number\x20used\
    \x20to\x20identify\x20this\x20request.\n\x20This\x20field\x20makes\x20ea\
    ch\x20request\x20idempotent\x20such\x20that\x20if\x20the\x20request\x20i\
    s\n\x20received\x20multiple\x20times,\x20at\x20most\x20one\x20will\x20su\
    cceed.\n\n\x20The\x20sequence\x20number\x20must\x20be\x20monotonically\
    \x20increasing\x20within\x20the\n\x20transaction.\x20If\x20a\x20request\
    \x20arrives\x20for\x20the\x20first\x20time\x20with\x20an\x20out-of-order\
    \n\x20sequence\x20number,\x20the\x20transaction\x20may\x20be\x20aborted.\
    \x20Replays\x20of\x20previously\n\x20handled\x20requests\x20will\x20yiel\
    d\x20the\x20same\x20response\x20as\x20the\x20first\x20execution.\n\n\r\n\
    \x05\x04\t\x02\x03\x05\x12\x04\xd5\x04\x02\x07\n\r\n\x05\x04\t\x02\x03\
    \x01\x12\x04\xd5\x04\x08\r\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xd5\x04\
    \x10\x11\n\r\n\x05\x04\t\x02\x03\x08\x12\x04\xd5\x04\x12:\n\x10\n\x08\
    \x04\t\x02\x03\x08\x9c\x08\0\x12\x04\xd5\x04\x139\n\xcb\n\n\x02\x04\n\
    \x12\x06\xf7\x04\0\x86\x05\x01\x1a\xbc\n\x20The\x20response\x20for\n\x20\
    [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml].\x20Contain\
    s\x20a\x20list\n\x20of\x20[ResultSet][google.spanner.v1.ResultSet]\x20me\
    ssages,\x20one\x20for\x20each\x20DML\n\x20statement\x20that\x20has\x20su\
    ccessfully\x20executed,\x20in\x20the\x20same\x20order\x20as\x20the\x20st\
    atements\n\x20in\x20the\x20request.\x20If\x20a\x20statement\x20fails,\
    \x20the\x20status\x20in\x20the\x20response\x20body\n\x20identifies\x20th\
    e\x20cause\x20of\x20the\x20failure.\n\n\x20To\x20check\x20for\x20DML\x20\
    statements\x20that\x20failed,\x20use\x20the\x20following\x20approach:\n\
    \n\x201.\x20Check\x20the\x20status\x20in\x20the\x20response\x20message.\
    \x20The\n\x20[google.rpc.Code][google.rpc.Code]\x20enum\n\x20\x20\x20\
    \x20value\x20`OK`\x20indicates\x20that\x20all\x20statements\x20were\x20e\
    xecuted\x20successfully.\n\x202.\x20If\x20the\x20status\x20was\x20not\
    \x20`OK`,\x20check\x20the\x20number\x20of\x20result\x20sets\x20in\x20the\
    \n\x20\x20\x20\x20response.\x20If\x20the\x20response\x20contains\x20`N`\
    \n\x20\x20\x20\x20[ResultSet][google.spanner.v1.ResultSet]\x20messages,\
    \x20then\x20statement\x20`N+1`\x20in\n\x20\x20\x20\x20the\x20request\x20\
    failed.\n\n\x20Example\x201:\n\n\x20*\x20Request:\x205\x20DML\x20stateme\
    nts,\x20all\x20executed\x20successfully.\n\x20*\x20Response:\x205\x20[Re\
    sultSet][google.spanner.v1.ResultSet]\x20messages,\x20with\x20the\n\x20s\
    tatus\x20`OK`.\n\n\x20Example\x202:\n\n\x20*\x20Request:\x205\x20DML\x20\
    statements.\x20The\x20third\x20statement\x20has\x20a\x20syntax\x20error.\
    \n\x20*\x20Response:\x202\x20[ResultSet][google.spanner.v1.ResultSet]\
    \x20messages,\x20and\x20a\x20syntax\n\x20error\x20(`INVALID_ARGUMENT`)\n\
    \x20\x20\x20status.\x20The\x20number\x20of\x20[ResultSet][google.spanner\
    .v1.ResultSet]\x20messages\n\x20\x20\x20indicates\x20that\x20the\x20thir\
    d\x20statement\x20failed,\x20and\x20the\x20fourth\x20and\x20fifth\n\x20\
    \x20\x20statements\x20were\x20not\x20executed.\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xf7\x04\x08\x1f\n\xaa\x04\n\x04\x04\n\x02\0\x12\x04\x81\x05\x02\
    %\x1a\x9b\x04\x20One\x20[ResultSet][google.spanner.v1.ResultSet]\x20for\
    \x20each\x20statement\x20in\x20the\n\x20request\x20that\x20ran\x20succes\
    sfully,\x20in\x20the\x20same\x20order\x20as\x20the\x20statements\x20in\
    \x20the\n\x20request.\x20Each\x20[ResultSet][google.spanner.v1.ResultSet\
    ]\x20does\x20not\x20contain\x20any\n\x20rows.\x20The\x20[ResultSetStats]\
    [google.spanner.v1.ResultSetStats]\x20in\x20each\n\x20[ResultSet][google\
    .spanner.v1.ResultSet]\x20contain\x20the\x20number\x20of\x20rows\n\x20mo\
    dified\x20by\x20the\x20statement.\n\n\x20Only\x20the\x20first\x20[Result\
    Set][google.spanner.v1.ResultSet]\x20in\x20the\x20response\n\x20contains\
    \x20valid\x20[ResultSetMetadata][google.spanner.v1.ResultSetMetadata].\n\
    \n\r\n\x05\x04\n\x02\0\x04\x12\x04\x81\x05\x02\n\n\r\n\x05\x04\n\x02\0\
    \x06\x12\x04\x81\x05\x0b\x14\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x81\x05\
    \x15\x20\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x81\x05#$\n\x91\x01\n\x04\x04\
    \n\x02\x01\x12\x04\x85\x05\x02\x1f\x1a\x82\x01\x20If\x20all\x20DML\x20st\
    atements\x20are\x20executed\x20successfully,\x20the\x20status\x20is\x20`\
    OK`.\n\x20Otherwise,\x20the\x20error\x20status\x20of\x20the\x20first\x20\
    failed\x20statement.\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x85\x05\x02\
    \x13\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x85\x05\x14\x1a\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\x85\x05\x1d\x1e\nN\n\x02\x04\x0b\x12\x06\x8a\x05\0\
    \x9c\x05\x01\x1a@\x20Options\x20for\x20a\x20PartitionQueryRequest\x20and\
    \n\x20PartitionReadRequest.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x8a\x05\
    \x08\x18\n\xba\x02\n\x04\x04\x0b\x02\0\x12\x04\x91\x05\x02!\x1a\xab\x02\
    \x20**Note:**\x20This\x20hint\x20is\x20currently\x20ignored\x20by\x20Par\
    titionQuery\x20and\n\x20PartitionRead\x20requests.\n\n\x20The\x20desired\
    \x20data\x20size\x20for\x20each\x20partition\x20generated.\x20\x20The\
    \x20default\x20for\x20this\n\x20option\x20is\x20currently\x201\x20GiB.\
    \x20\x20This\x20is\x20only\x20a\x20hint.\x20The\x20actual\x20size\x20of\
    \x20each\n\x20partition\x20may\x20be\x20smaller\x20or\x20larger\x20than\
    \x20this\x20size\x20request.\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x91\
    \x05\x02\x07\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x91\x05\x08\x1c\n\r\n\
    \x05\x04\x0b\x02\0\x03\x12\x04\x91\x05\x1f\x20\n\xb8\x03\n\x04\x04\x0b\
    \x02\x01\x12\x04\x9b\x05\x02\x1b\x1a\xa9\x03\x20**Note:**\x20This\x20hin\
    t\x20is\x20currently\x20ignored\x20by\x20PartitionQuery\x20and\n\x20Part\
    itionRead\x20requests.\n\n\x20The\x20desired\x20maximum\x20number\x20of\
    \x20partitions\x20to\x20return.\x20\x20For\x20example,\x20this\x20may\n\
    \x20be\x20set\x20to\x20the\x20number\x20of\x20workers\x20available.\x20\
    \x20The\x20default\x20for\x20this\x20option\n\x20is\x20currently\x2010,0\
    00.\x20The\x20maximum\x20value\x20is\x20currently\x20200,000.\x20\x20Thi\
    s\x20is\x20only\n\x20a\x20hint.\x20\x20The\x20actual\x20number\x20of\x20\
    partitions\x20returned\x20may\x20be\x20smaller\x20or\x20larger\n\x20than\
    \x20this\x20maximum\x20count\x20request.\n\n\r\n\x05\x04\x0b\x02\x01\x05\
    \x12\x04\x9b\x05\x02\x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x9b\x05\
    \x08\x16\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x9b\x05\x19\x1a\nZ\n\x02\
    \x04\x0c\x12\x06\x9f\x05\0\xd2\x05\x01\x1aL\x20The\x20request\x20for\x20\
    [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\x9f\x05\x08\x1d\nF\n\x04\x04\x0c\x02\0\x12\x06\xa1\
    \x05\x02\xa4\x05\x04\x1a6\x20Required.\x20The\x20session\x20used\x20to\
    \x20create\x20the\x20partitions.\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\
    \xa1\x05\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa1\x05\t\x10\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\xa1\x05\x13\x14\n\x0f\n\x05\x04\x0c\x02\0\
    \x08\x12\x06\xa1\x05\x15\xa4\x05\x03\n\x10\n\x08\x04\x0c\x02\0\x08\x9c\
    \x08\0\x12\x04\xa2\x05\x04*\n\x0f\n\x07\x04\x0c\x02\0\x08\x9f\x08\x12\
    \x04\xa3\x05\x04P\no\n\x04\x04\x0c\x02\x01\x12\x04\xa8\x05\x02&\x1aa\x20\
    Read\x20only\x20snapshot\x20transactions\x20are\x20supported,\x20read/wr\
    ite\x20and\x20single\x20use\n\x20transactions\x20are\x20not.\n\n\r\n\x05\
    \x04\x0c\x02\x01\x06\x12\x04\xa8\x05\x02\x15\n\r\n\x05\x04\x0c\x02\x01\
    \x01\x12\x04\xa8\x05\x16!\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xa8\x05$\
    %\n\xf9\x04\n\x04\x04\x0c\x02\x02\x12\x04\xb5\x05\x02:\x1a\xea\x04\x20Re\
    quired.\x20The\x20query\x20request\x20to\x20generate\x20partitions\x20fo\
    r.\x20The\x20request\x20will\n\x20fail\x20if\x20the\x20query\x20is\x20no\
    t\x20root\x20partitionable.\x20The\x20query\x20plan\x20of\x20a\x20root\n\
    \x20partitionable\x20query\x20has\x20a\x20single\x20distributed\x20union\
    \x20operator.\x20A\x20distributed\n\x20union\x20operator\x20conceptually\
    \x20divides\x20one\x20or\x20more\x20tables\x20into\x20multiple\n\x20spli\
    ts,\x20remotely\x20evaluates\x20a\x20subquery\x20independently\x20on\x20\
    each\x20split,\x20and\n\x20then\x20unions\x20all\x20results.\n\n\x20This\
    \x20must\x20not\x20contain\x20DML\x20commands,\x20such\x20as\x20INSERT,\
    \x20UPDATE,\x20or\n\x20DELETE.\x20Use\n\x20[ExecuteStreamingSql][google.\
    spanner.v1.Spanner.ExecuteStreamingSql]\x20with\x20a\n\x20PartitionedDml\
    \x20transaction\x20for\x20large,\x20partition-friendly\x20DML\x20operati\
    ons.\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xb5\x05\x02\x08\n\r\n\x05\
    \x04\x0c\x02\x02\x01\x12\x04\xb5\x05\t\x0c\n\r\n\x05\x04\x0c\x02\x02\x03\
    \x12\x04\xb5\x05\x0f\x10\n\r\n\x05\x04\x0c\x02\x02\x08\x12\x04\xb5\x05\
    \x119\n\x10\n\x08\x04\x0c\x02\x02\x08\x9c\x08\0\x12\x04\xb5\x05\x128\n\
    \x88\x04\n\x04\x04\x0c\x02\x03\x12\x04\xc3\x05\x02$\x1a\xf9\x03\x20Param\
    eter\x20names\x20and\x20values\x20that\x20bind\x20to\x20placeholders\x20\
    in\x20the\x20SQL\x20string.\n\n\x20A\x20parameter\x20placeholder\x20cons\
    ists\x20of\x20the\x20`@`\x20character\x20followed\x20by\x20the\n\x20para\
    meter\x20name\x20(for\x20example,\x20`@firstName`).\x20Parameter\x20name\
    s\x20can\x20contain\n\x20letters,\x20numbers,\x20and\x20underscores.\n\n\
    \x20Parameters\x20can\x20appear\x20anywhere\x20that\x20a\x20literal\x20v\
    alue\x20is\x20expected.\x20\x20The\x20same\n\x20parameter\x20name\x20can\
    \x20be\x20used\x20more\x20than\x20once,\x20for\x20example:\n\n\x20`\"WHE\
    RE\x20id\x20>\x20@msg_id\x20AND\x20id\x20<\x20@msg_id\x20+\x20100\"`\n\n\
    \x20It\x20is\x20an\x20error\x20to\x20execute\x20a\x20SQL\x20statement\
    \x20with\x20unbound\x20parameters.\n\n\r\n\x05\x04\x0c\x02\x03\x06\x12\
    \x04\xc3\x05\x02\x18\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xc3\x05\x19\
    \x1f\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xc3\x05\"#\n\xdd\x03\n\x04\
    \x04\x0c\x02\x04\x12\x04\xce\x05\x02$\x1a\xce\x03\x20It\x20is\x20not\x20\
    always\x20possible\x20for\x20Cloud\x20Spanner\x20to\x20infer\x20the\x20r\
    ight\x20SQL\x20type\n\x20from\x20a\x20JSON\x20value.\x20\x20For\x20examp\
    le,\x20values\x20of\x20type\x20`BYTES`\x20and\x20values\n\x20of\x20type\
    \x20`STRING`\x20both\x20appear\x20in\n\x20[params][google.spanner.v1.Par\
    titionQueryRequest.params]\x20as\x20JSON\x20strings.\n\n\x20In\x20these\
    \x20cases,\x20`param_types`\x20can\x20be\x20used\x20to\x20specify\x20the\
    \x20exact\n\x20SQL\x20type\x20for\x20some\x20or\x20all\x20of\x20the\x20S\
    QL\x20query\x20parameters.\x20See\x20the\n\x20definition\x20of\x20[Type]\
    [google.spanner.v1.Type]\x20for\x20more\x20information\n\x20about\x20SQL\
    \x20types.\n\n\r\n\x05\x04\x0c\x02\x04\x06\x12\x04\xce\x05\x02\x13\n\r\n\
    \x05\x04\x0c\x02\x04\x01\x12\x04\xce\x05\x14\x1f\n\r\n\x05\x04\x0c\x02\
    \x04\x03\x12\x04\xce\x05\"#\nO\n\x04\x04\x0c\x02\x05\x12\x04\xd1\x05\x02\
    )\x1aA\x20Additional\x20options\x20that\x20affect\x20how\x20many\x20part\
    itions\x20are\x20created.\n\n\r\n\x05\x04\x0c\x02\x05\x06\x12\x04\xd1\
    \x05\x02\x12\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xd1\x05\x13$\n\r\n\
    \x05\x04\x0c\x02\x05\x03\x12\x04\xd1\x05'(\nX\n\x02\x04\r\x12\x06\xd5\
    \x05\0\xfd\x05\x01\x1aJ\x20The\x20request\x20for\x20[PartitionRead][goog\
    le.spanner.v1.Spanner.PartitionRead]\n\n\x0b\n\x03\x04\r\x01\x12\x04\xd5\
    \x05\x08\x1c\nF\n\x04\x04\r\x02\0\x12\x06\xd7\x05\x02\xda\x05\x04\x1a6\
    \x20Required.\x20The\x20session\x20used\x20to\x20create\x20the\x20partit\
    ions.\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xd7\x05\x02\x08\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\xd7\x05\t\x10\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xd7\
    \x05\x13\x14\n\x0f\n\x05\x04\r\x02\0\x08\x12\x06\xd7\x05\x15\xda\x05\x03\
    \n\x10\n\x08\x04\r\x02\0\x08\x9c\x08\0\x12\x04\xd8\x05\x04*\n\x0f\n\x07\
    \x04\r\x02\0\x08\x9f\x08\x12\x04\xd9\x05\x04P\no\n\x04\x04\r\x02\x01\x12\
    \x04\xde\x05\x02&\x1aa\x20Read\x20only\x20snapshot\x20transactions\x20ar\
    e\x20supported,\x20read/write\x20and\x20single\x20use\n\x20transactions\
    \x20are\x20not.\n\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xde\x05\x02\x15\n\
    \r\n\x05\x04\r\x02\x01\x01\x12\x04\xde\x05\x16!\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\xde\x05$%\nK\n\x04\x04\r\x02\x02\x12\x04\xe1\x05\x02<\x1a=\
    \x20Required.\x20The\x20name\x20of\x20the\x20table\x20in\x20the\x20datab\
    ase\x20to\x20be\x20read.\n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xe1\x05\
    \x02\x08\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xe1\x05\t\x0e\n\r\n\x05\x04\
    \r\x02\x02\x03\x12\x04\xe1\x05\x11\x12\n\r\n\x05\x04\r\x02\x02\x08\x12\
    \x04\xe1\x05\x13;\n\x10\n\x08\x04\r\x02\x02\x08\x9c\x08\0\x12\x04\xe1\
    \x05\x14:\n\xe2\x02\n\x04\x04\r\x02\x03\x12\x04\xe9\x05\x02\x13\x1a\xd3\
    \x02\x20If\x20non-empty,\x20the\x20name\x20of\x20an\x20index\x20on\n\x20\
    [table][google.spanner.v1.PartitionReadRequest.table].\x20This\x20index\
    \x20is\x20used\n\x20instead\x20of\x20the\x20table\x20primary\x20key\x20w\
    hen\x20interpreting\n\x20[key_set][google.spanner.v1.PartitionReadReques\
    t.key_set]\x20and\x20sorting\n\x20result\x20rows.\x20See\x20[key_set][go\
    ogle.spanner.v1.PartitionReadRequest.key_set]\n\x20for\x20further\x20inf\
    ormation.\n\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xe9\x05\x02\x08\n\r\n\
    \x05\x04\r\x02\x03\x01\x12\x04\xe9\x05\t\x0e\n\r\n\x05\x04\r\x02\x03\x03\
    \x12\x04\xe9\x05\x11\x12\n\x88\x01\n\x04\x04\r\x02\x04\x12\x04\xed\x05\
    \x02\x1e\x1az\x20The\x20columns\x20of\x20[table][google.spanner.v1.Parti\
    tionReadRequest.table]\x20to\x20be\n\x20returned\x20for\x20each\x20row\
    \x20matching\x20this\x20request.\n\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\
    \xed\x05\x02\n\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xed\x05\x0b\x11\n\r\n\
    \x05\x04\r\x02\x04\x01\x12\x04\xed\x05\x12\x19\n\r\n\x05\x04\r\x02\x04\
    \x03\x12\x04\xed\x05\x1c\x1d\n\xe4\x04\n\x04\x04\r\x02\x05\x12\x04\xf9\
    \x05\x02>\x1a\xd5\x04\x20Required.\x20`key_set`\x20identifies\x20the\x20\
    rows\x20to\x20be\x20yielded.\x20`key_set`\x20names\x20the\n\x20primary\
    \x20keys\x20of\x20the\x20rows\x20in\n\x20[table][google.spanner.v1.Parti\
    tionReadRequest.table]\x20to\x20be\x20yielded,\x20unless\n\x20[index][go\
    ogle.spanner.v1.PartitionReadRequest.index]\x20is\x20present.\x20If\n\
    \x20[index][google.spanner.v1.PartitionReadRequest.index]\x20is\x20prese\
    nt,\x20then\n\x20[key_set][google.spanner.v1.PartitionReadRequest.key_se\
    t]\x20instead\x20names\n\x20index\x20keys\x20in\x20[index][google.spanne\
    r.v1.PartitionReadRequest.index].\n\n\x20It\x20is\x20not\x20an\x20error\
    \x20for\x20the\x20`key_set`\x20to\x20name\x20rows\x20that\x20do\x20not\n\
    \x20exist\x20in\x20the\x20database.\x20Read\x20yields\x20nothing\x20for\
    \x20nonexistent\x20rows.\n\n\r\n\x05\x04\r\x02\x05\x06\x12\x04\xf9\x05\
    \x02\x08\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xf9\x05\t\x10\n\r\n\x05\x04\
    \r\x02\x05\x03\x12\x04\xf9\x05\x13\x14\n\r\n\x05\x04\r\x02\x05\x08\x12\
    \x04\xf9\x05\x15=\n\x10\n\x08\x04\r\x02\x05\x08\x9c\x08\0\x12\x04\xf9\
    \x05\x16<\nO\n\x04\x04\r\x02\x06\x12\x04\xfc\x05\x02)\x1aA\x20Additional\
    \x20options\x20that\x20affect\x20how\x20many\x20partitions\x20are\x20cre\
    ated.\n\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\xfc\x05\x02\x12\n\r\n\x05\
    \x04\r\x02\x06\x01\x12\x04\xfc\x05\x13$\n\r\n\x05\x04\r\x02\x06\x03\x12\
    \x04\xfc\x05'(\nY\n\x02\x04\x0e\x12\x06\x81\x06\0\x86\x06\x01\x1aK\x20In\
    formation\x20returned\x20for\x20each\x20partition\x20returned\x20in\x20a\
    \n\x20PartitionResponse.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x81\x06\x08\
    \x11\n\xb4\x01\n\x04\x04\x0e\x02\0\x12\x04\x85\x06\x02\x1c\x1a\xa5\x01\
    \x20This\x20token\x20can\x20be\x20passed\x20to\x20Read,\x20StreamingRead\
    ,\x20ExecuteSql,\x20or\n\x20ExecuteStreamingSql\x20requests\x20to\x20res\
    trict\x20the\x20results\x20to\x20those\x20identified\x20by\n\x20this\x20\
    partition\x20token.\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x85\x06\x02\
    \x07\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x85\x06\x08\x17\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\x85\x06\x1a\x1b\n\x99\x01\n\x02\x04\x0f\x12\x06\
    \x8a\x06\0\x90\x06\x01\x1a\x8a\x01\x20The\x20response\x20for\x20[Partiti\
    onQuery][google.spanner.v1.Spanner.PartitionQuery]\n\x20or\x20[Partition\
    Read][google.spanner.v1.Spanner.PartitionRead]\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\x8a\x06\x08\x19\n3\n\x04\x04\x0f\x02\0\x12\x04\x8c\x06\x02$\x1a\
    %\x20Partitions\x20created\x20by\x20this\x20request.\n\n\r\n\x05\x04\x0f\
    \x02\0\x04\x12\x04\x8c\x06\x02\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x8c\
    \x06\x0b\x14\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x8c\x06\x15\x1f\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\x8c\x06\"#\n4\n\x04\x04\x0f\x02\x01\x12\
    \x04\x8f\x06\x02\x1e\x1a&\x20Transaction\x20created\x20by\x20this\x20req\
    uest.\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\x8f\x06\x02\r\n\r\n\x05\
    \x04\x0f\x02\x01\x01\x12\x04\x8f\x06\x0e\x19\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\x8f\x06\x1c\x1d\n\x85\x01\n\x02\x04\x10\x12\x06\x94\x06\0\
    \xd2\x06\x01\x1aw\x20The\x20request\x20for\x20[Read][google.spanner.v1.S\
    panner.Read]\x20and\n\x20[StreamingRead][google.spanner.v1.Spanner.Strea\
    mingRead].\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x94\x06\x08\x13\nN\n\x04\
    \x04\x10\x02\0\x12\x06\x96\x06\x02\x99\x06\x04\x1a>\x20Required.\x20The\
    \x20session\x20in\x20which\x20the\x20read\x20should\x20be\x20performed.\
    \n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x96\x06\x02\x08\n\r\n\x05\x04\x10\
    \x02\0\x01\x12\x04\x96\x06\t\x10\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x96\
    \x06\x13\x14\n\x0f\n\x05\x04\x10\x02\0\x08\x12\x06\x96\x06\x15\x99\x06\
    \x03\n\x10\n\x08\x04\x10\x02\0\x08\x9c\x08\0\x12\x04\x97\x06\x04*\n\x0f\
    \n\x07\x04\x10\x02\0\x08\x9f\x08\x12\x04\x98\x06\x04P\n\x87\x01\n\x04\
    \x04\x10\x02\x01\x12\x04\x9d\x06\x02&\x1ay\x20The\x20transaction\x20to\
    \x20use.\x20If\x20none\x20is\x20provided,\x20the\x20default\x20is\x20a\n\
    \x20temporary\x20read-only\x20transaction\x20with\x20strong\x20concurren\
    cy.\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\x9d\x06\x02\x15\n\r\n\x05\
    \x04\x10\x02\x01\x01\x12\x04\x9d\x06\x16!\n\r\n\x05\x04\x10\x02\x01\x03\
    \x12\x04\x9d\x06$%\nK\n\x04\x04\x10\x02\x02\x12\x04\xa0\x06\x02<\x1a=\
    \x20Required.\x20The\x20name\x20of\x20the\x20table\x20in\x20the\x20datab\
    ase\x20to\x20be\x20read.\n\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xa0\x06\
    \x02\x08\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xa0\x06\t\x0e\n\r\n\x05\
    \x04\x10\x02\x02\x03\x12\x04\xa0\x06\x11\x12\n\r\n\x05\x04\x10\x02\x02\
    \x08\x12\x04\xa0\x06\x13;\n\x10\n\x08\x04\x10\x02\x02\x08\x9c\x08\0\x12\
    \x04\xa0\x06\x14:\n\xc7\x02\n\x04\x04\x10\x02\x03\x12\x04\xa8\x06\x02\
    \x13\x1a\xb8\x02\x20If\x20non-empty,\x20the\x20name\x20of\x20an\x20index\
    \x20on\n\x20[table][google.spanner.v1.ReadRequest.table].\x20This\x20ind\
    ex\x20is\x20used\x20instead\x20of\n\x20the\x20table\x20primary\x20key\
    \x20when\x20interpreting\n\x20[key_set][google.spanner.v1.ReadRequest.ke\
    y_set]\x20and\x20sorting\x20result\x20rows.\n\x20See\x20[key_set][google\
    .spanner.v1.ReadRequest.key_set]\x20for\x20further\n\x20information.\n\n\
    \r\n\x05\x04\x10\x02\x03\x05\x12\x04\xa8\x06\x02\x08\n\r\n\x05\x04\x10\
    \x02\x03\x01\x12\x04\xa8\x06\t\x0e\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\
    \xa8\x06\x11\x12\n\x89\x01\n\x04\x04\x10\x02\x04\x12\x04\xac\x06\x02G\
    \x1a{\x20Required.\x20The\x20columns\x20of\x20[table][google.spanner.v1.\
    ReadRequest.table]\x20to\x20be\n\x20returned\x20for\x20each\x20row\x20ma\
    tching\x20this\x20request.\n\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\xac\
    \x06\x02\n\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xac\x06\x0b\x11\n\r\n\
    \x05\x04\x10\x02\x04\x01\x12\x04\xac\x06\x12\x19\n\r\n\x05\x04\x10\x02\
    \x04\x03\x12\x04\xac\x06\x1c\x1d\n\r\n\x05\x04\x10\x02\x04\x08\x12\x04\
    \xac\x06\x1eF\n\x10\n\x08\x04\x10\x02\x04\x08\x9c\x08\0\x12\x04\xac\x06\
    \x1fE\n\xda\x07\n\x04\x04\x10\x02\x05\x12\x04\xbe\x06\x02>\x1a\xcb\x07\
    \x20Required.\x20`key_set`\x20identifies\x20the\x20rows\x20to\x20be\x20y\
    ielded.\x20`key_set`\x20names\x20the\n\x20primary\x20keys\x20of\x20the\
    \x20rows\x20in\x20[table][google.spanner.v1.ReadRequest.table]\x20to\n\
    \x20be\x20yielded,\x20unless\x20[index][google.spanner.v1.ReadRequest.in\
    dex]\x20is\x20present.\n\x20If\x20[index][google.spanner.v1.ReadRequest.\
    index]\x20is\x20present,\x20then\n\x20[key_set][google.spanner.v1.ReadRe\
    quest.key_set]\x20instead\x20names\x20index\x20keys\n\x20in\x20[index][g\
    oogle.spanner.v1.ReadRequest.index].\n\n\x20If\x20the\x20[partition_toke\
    n][google.spanner.v1.ReadRequest.partition_token]\n\x20field\x20is\x20em\
    pty,\x20rows\x20are\x20yielded\x20in\x20table\x20primary\x20key\x20order\
    \x20(if\n\x20[index][google.spanner.v1.ReadRequest.index]\x20is\x20empty\
    )\x20or\x20index\x20key\x20order\n\x20(if\x20[index][google.spanner.v1.R\
    eadRequest.index]\x20is\x20non-empty).\x20\x20If\x20the\n\x20[partition_\
    token][google.spanner.v1.ReadRequest.partition_token]\x20field\x20is\n\
    \x20not\x20empty,\x20rows\x20will\x20be\x20yielded\x20in\x20an\x20unspec\
    ified\x20order.\n\n\x20It\x20is\x20not\x20an\x20error\x20for\x20the\x20`\
    key_set`\x20to\x20name\x20rows\x20that\x20do\x20not\n\x20exist\x20in\x20\
    the\x20database.\x20Read\x20yields\x20nothing\x20for\x20nonexistent\x20r\
    ows.\n\n\r\n\x05\x04\x10\x02\x05\x06\x12\x04\xbe\x06\x02\x08\n\r\n\x05\
    \x04\x10\x02\x05\x01\x12\x04\xbe\x06\t\x10\n\r\n\x05\x04\x10\x02\x05\x03\
    \x12\x04\xbe\x06\x13\x14\n\r\n\x05\x04\x10\x02\x05\x08\x12\x04\xbe\x06\
    \x15=\n\x10\n\x08\x04\x10\x02\x05\x08\x9c\x08\0\x12\x04\xbe\x06\x16<\n\
    \xb7\x01\n\x04\x04\x10\x02\x06\x12\x04\xc3\x06\x02\x12\x1a\xa8\x01\x20If\
    \x20greater\x20than\x20zero,\x20only\x20the\x20first\x20`limit`\x20rows\
    \x20are\x20yielded.\x20If\x20`limit`\n\x20is\x20zero,\x20the\x20default\
    \x20is\x20no\x20limit.\x20A\x20limit\x20cannot\x20be\x20specified\x20if\
    \n\x20`partition_token`\x20is\x20set.\n\n\r\n\x05\x04\x10\x02\x06\x05\
    \x12\x04\xc3\x06\x02\x07\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xc3\x06\
    \x08\r\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\xc3\x06\x10\x11\n\xf9\x02\n\
    \x04\x04\x10\x02\x07\x12\x04\xcb\x06\x02\x19\x1a\xea\x02\x20If\x20this\
    \x20request\x20is\x20resuming\x20a\x20previously\x20interrupted\x20read,\
    \n\x20`resume_token`\x20should\x20be\x20copied\x20from\x20the\x20last\n\
    \x20[PartialResultSet][google.spanner.v1.PartialResultSet]\x20yielded\
    \x20before\x20the\n\x20interruption.\x20Doing\x20this\x20enables\x20the\
    \x20new\x20read\x20to\x20resume\x20where\x20the\x20last\x20read\n\x20lef\
    t\x20off.\x20The\x20rest\x20of\x20the\x20request\x20parameters\x20must\
    \x20exactly\x20match\x20the\x20request\n\x20that\x20yielded\x20this\x20t\
    oken.\n\n\r\n\x05\x04\x10\x02\x07\x05\x12\x04\xcb\x06\x02\x07\n\r\n\x05\
    \x04\x10\x02\x07\x01\x12\x04\xcb\x06\x08\x14\n\r\n\x05\x04\x10\x02\x07\
    \x03\x12\x04\xcb\x06\x17\x18\n\x99\x02\n\x04\x04\x10\x02\x08\x12\x04\xd1\
    \x06\x02\x1d\x1a\x8a\x02\x20If\x20present,\x20results\x20will\x20be\x20r\
    estricted\x20to\x20the\x20specified\x20partition\n\x20previously\x20crea\
    ted\x20using\x20PartitionRead().\x20\x20\x20\x20There\x20must\x20be\x20a\
    n\x20exact\n\x20match\x20for\x20the\x20values\x20of\x20fields\x20common\
    \x20to\x20this\x20message\x20and\x20the\n\x20PartitionReadRequest\x20mes\
    sage\x20used\x20to\x20create\x20this\x20partition_token.\n\n\r\n\x05\x04\
    \x10\x02\x08\x05\x12\x04\xd1\x06\x02\x07\n\r\n\x05\x04\x10\x02\x08\x01\
    \x12\x04\xd1\x06\x08\x17\n\r\n\x05\x04\x10\x02\x08\x03\x12\x04\xd1\x06\
    \x1a\x1c\n`\n\x02\x04\x11\x12\x06\xd6\x06\0\xdf\x06\x01\x1aR\x20The\x20r\
    equest\x20for\n\x20[BeginTransaction][google.spanner.v1.Spanner.BeginTra\
    nsaction].\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xd6\x06\x08\x1f\nF\n\x04\
    \x04\x11\x02\0\x12\x06\xd8\x06\x02\xdb\x06\x04\x1a6\x20Required.\x20The\
    \x20session\x20in\x20which\x20the\x20transaction\x20runs.\n\n\r\n\x05\
    \x04\x11\x02\0\x05\x12\x04\xd8\x06\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\
    \x12\x04\xd8\x06\t\x10\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xd8\x06\x13\
    \x14\n\x0f\n\x05\x04\x11\x02\0\x08\x12\x06\xd8\x06\x15\xdb\x06\x03\n\x10\
    \n\x08\x04\x11\x02\0\x08\x9c\x08\0\x12\x04\xd9\x06\x04*\n\x0f\n\x07\x04\
    \x11\x02\0\x08\x9f\x08\x12\x04\xda\x06\x04P\n:\n\x04\x04\x11\x02\x01\x12\
    \x04\xde\x06\x02J\x1a,\x20Required.\x20Options\x20for\x20the\x20new\x20t\
    ransaction.\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xde\x06\x02\x14\n\r\
    \n\x05\x04\x11\x02\x01\x01\x12\x04\xde\x06\x15\x1c\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xde\x06\x1f\x20\n\r\n\x05\x04\x11\x02\x01\x08\x12\x04\
    \xde\x06!I\n\x10\n\x08\x04\x11\x02\x01\x08\x9c\x08\0\x12\x04\xde\x06\"H\
    \nK\n\x02\x04\x12\x12\x06\xe2\x06\0\xfe\x06\x01\x1a=\x20The\x20request\
    \x20for\x20[Commit][google.spanner.v1.Spanner.Commit].\n\n\x0b\n\x03\x04\
    \x12\x01\x12\x04\xe2\x06\x08\x15\n\\\n\x04\x04\x12\x02\0\x12\x06\xe4\x06\
    \x02\xe7\x06\x04\x1aL\x20Required.\x20The\x20session\x20in\x20which\x20t\
    he\x20transaction\x20to\x20be\x20committed\x20is\x20running.\n\n\r\n\x05\
    \x04\x12\x02\0\x05\x12\x04\xe4\x06\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\
    \x12\x04\xe4\x06\t\x10\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xe4\x06\x13\
    \x14\n\x0f\n\x05\x04\x12\x02\0\x08\x12\x06\xe4\x06\x15\xe7\x06\x03\n\x10\
    \n\x08\x04\x12\x02\0\x08\x9c\x08\0\x12\x04\xe5\x06\x04*\n\x0f\n\x07\x04\
    \x12\x02\0\x08\x9f\x08\x12\x04\xe6\x06\x04P\n?\n\x04\x04\x12\x08\0\x12\
    \x06\xea\x06\x02\xf8\x06\x03\x1a/\x20Required.\x20The\x20transaction\x20\
    in\x20which\x20to\x20commit.\n\n\r\n\x05\x04\x12\x08\0\x01\x12\x04\xea\
    \x06\x08\x13\n8\n\x04\x04\x12\x02\x01\x12\x04\xec\x06\x04\x1d\x1a*\x20Co\
    mmit\x20a\x20previously-started\x20transaction.\n\n\r\n\x05\x04\x12\x02\
    \x01\x05\x12\x04\xec\x06\x04\t\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xec\
    \x06\n\x18\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xec\x06\x1b\x1c\n\xa4\
    \x04\n\x04\x04\x12\x02\x02\x12\x04\xf7\x06\x042\x1a\x95\x04\x20Execute\
    \x20mutations\x20in\x20a\x20temporary\x20transaction.\x20Note\x20that\
    \x20unlike\n\x20commit\x20of\x20a\x20previously-started\x20transaction,\
    \x20commit\x20with\x20a\n\x20temporary\x20transaction\x20is\x20non-idemp\
    otent.\x20That\x20is,\x20if\x20the\n\x20`CommitRequest`\x20is\x20sent\
    \x20to\x20Cloud\x20Spanner\x20more\x20than\x20once\x20(for\n\x20instance\
    ,\x20due\x20to\x20retries\x20in\x20the\x20application,\x20or\x20in\x20th\
    e\n\x20transport\x20library),\x20it\x20is\x20possible\x20that\x20the\x20\
    mutations\x20are\n\x20executed\x20more\x20than\x20once.\x20If\x20this\
    \x20is\x20undesirable,\x20use\n\x20[BeginTransaction][google.spanner.v1.\
    Spanner.BeginTransaction]\x20and\n\x20[Commit][google.spanner.v1.Spanner\
    .Commit]\x20instead.\n\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xf7\x06\x04\
    \x16\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xf7\x06\x17-\n\r\n\x05\x04\
    \x12\x02\x02\x03\x12\x04\xf7\x0601\n\x9b\x01\n\x04\x04\x12\x02\x03\x12\
    \x04\xfd\x06\x02\"\x1a\x8c\x01\x20The\x20mutations\x20to\x20be\x20execut\
    ed\x20when\x20this\x20transaction\x20commits.\x20All\n\x20mutations\x20a\
    re\x20applied\x20atomically,\x20in\x20the\x20order\x20they\x20appear\x20\
    in\n\x20this\x20list.\n\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xfd\x06\
    \x02\n\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\xfd\x06\x0b\x13\n\r\n\x05\
    \x04\x12\x02\x03\x01\x12\x04\xfd\x06\x14\x1d\n\r\n\x05\x04\x12\x02\x03\
    \x03\x12\x04\xfd\x06\x20!\nL\n\x02\x04\x13\x12\x06\x81\x07\0\x84\x07\x01\
    \x1a>\x20The\x20response\x20for\x20[Commit][google.spanner.v1.Spanner.Co\
    mmit].\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x81\x07\x08\x16\nO\n\x04\x04\
    \x13\x02\0\x12\x04\x83\x07\x021\x1aA\x20The\x20Cloud\x20Spanner\x20times\
    tamp\x20at\x20which\x20the\x20transaction\x20committed.\n\n\r\n\x05\x04\
    \x13\x02\0\x06\x12\x04\x83\x07\x02\x1b\n\r\n\x05\x04\x13\x02\0\x01\x12\
    \x04\x83\x07\x1c,\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x83\x07/0\nO\n\x02\
    \x04\x14\x12\x06\x87\x07\0\x90\x07\x01\x1aA\x20The\x20request\x20for\x20\
    [Rollback][google.spanner.v1.Spanner.Rollback].\n\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\x87\x07\x08\x17\nY\n\x04\x04\x14\x02\0\x12\x06\x89\x07\x02\
    \x8c\x07\x04\x1aI\x20Required.\x20The\x20session\x20in\x20which\x20the\
    \x20transaction\x20to\x20roll\x20back\x20is\x20running.\n\n\r\n\x05\x04\
    \x14\x02\0\x05\x12\x04\x89\x07\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\x89\x07\t\x10\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x89\x07\x13\x14\n\
    \x0f\n\x05\x04\x14\x02\0\x08\x12\x06\x89\x07\x15\x8c\x07\x03\n\x10\n\x08\
    \x04\x14\x02\0\x08\x9c\x08\0\x12\x04\x8a\x07\x04*\n\x0f\n\x07\x04\x14\
    \x02\0\x08\x9f\x08\x12\x04\x8b\x07\x04P\n7\n\x04\x04\x14\x02\x01\x12\x04\
    \x8f\x07\x02D\x1a)\x20Required.\x20The\x20transaction\x20to\x20roll\x20b\
    ack.\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\x8f\x07\x02\x07\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\x8f\x07\x08\x16\n\r\n\x05\x04\x14\x02\x01\
    \x03\x12\x04\x8f\x07\x19\x1a\n\r\n\x05\x04\x14\x02\x01\x08\x12\x04\x8f\
    \x07\x1bC\n\x10\n\x08\x04\x14\x02\x01\x08\x9c\x08\0\x12\x04\x8f\x07\x1cB\
    b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(13);
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::client::file_descriptor().clone());
            deps.push(super::field_behavior::file_descriptor().clone());
            deps.push(super::resource::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::struct_::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::status::file_descriptor().clone());
            deps.push(super::keys::file_descriptor().clone());
            deps.push(super::mutation::file_descriptor().clone());
            deps.push(super::result_set::file_descriptor().clone());
            deps.push(super::transaction::file_descriptor().clone());
            deps.push(super::type_::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(22);
            messages.push(CreateSessionRequest::generated_message_descriptor_data());
            messages.push(BatchCreateSessionsRequest::generated_message_descriptor_data());
            messages.push(BatchCreateSessionsResponse::generated_message_descriptor_data());
            messages.push(Session::generated_message_descriptor_data());
            messages.push(GetSessionRequest::generated_message_descriptor_data());
            messages.push(ListSessionsRequest::generated_message_descriptor_data());
            messages.push(ListSessionsResponse::generated_message_descriptor_data());
            messages.push(DeleteSessionRequest::generated_message_descriptor_data());
            messages.push(ExecuteSqlRequest::generated_message_descriptor_data());
            messages.push(ExecuteBatchDmlRequest::generated_message_descriptor_data());
            messages.push(ExecuteBatchDmlResponse::generated_message_descriptor_data());
            messages.push(PartitionOptions::generated_message_descriptor_data());
            messages.push(PartitionQueryRequest::generated_message_descriptor_data());
            messages.push(PartitionReadRequest::generated_message_descriptor_data());
            messages.push(Partition::generated_message_descriptor_data());
            messages.push(PartitionResponse::generated_message_descriptor_data());
            messages.push(ReadRequest::generated_message_descriptor_data());
            messages.push(BeginTransactionRequest::generated_message_descriptor_data());
            messages.push(CommitRequest::generated_message_descriptor_data());
            messages.push(CommitResponse::generated_message_descriptor_data());
            messages.push(RollbackRequest::generated_message_descriptor_data());
            messages.push(execute_batch_dml_request::Statement::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(execute_sql_request::QueryMode::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
