// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/spanner/v1/transaction.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:google.spanner.v1.TransactionOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TransactionOptions {
    // message oneof groups
    pub mode: ::std::option::Option<transaction_options::Mode>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.TransactionOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionOptions {
    fn default() -> &'a TransactionOptions {
        <TransactionOptions as ::protobuf::Message>::default_instance()
    }
}

impl TransactionOptions {
    pub fn new() -> TransactionOptions {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;

    pub fn read_write(&self) -> &transaction_options::ReadWrite {
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::ReadWrite(ref v)) => v,
            _ => <transaction_options::ReadWrite as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_write(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_write(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::ReadWrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_write(&mut self, v: transaction_options::ReadWrite) {
        self.mode = ::std::option::Option::Some(transaction_options::Mode::ReadWrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_write(&mut self) -> &mut transaction_options::ReadWrite {
        if let ::std::option::Option::Some(transaction_options::Mode::ReadWrite(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(transaction_options::Mode::ReadWrite(transaction_options::ReadWrite::new()));
        }
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::ReadWrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_write(&mut self) -> transaction_options::ReadWrite {
        if self.has_read_write() {
            match self.mode.take() {
                ::std::option::Option::Some(transaction_options::Mode::ReadWrite(v)) => v,
                _ => panic!(),
            }
        } else {
            transaction_options::ReadWrite::new()
        }
    }

    // .google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;

    pub fn partitioned_dml(&self) -> &transaction_options::PartitionedDml {
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(ref v)) => v,
            _ => <transaction_options::PartitionedDml as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_partitioned_dml(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_partitioned_dml(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_partitioned_dml(&mut self, v: transaction_options::PartitionedDml) {
        self.mode = ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(v))
    }

    // Mutable pointer to the field.
    pub fn mut_partitioned_dml(&mut self) -> &mut transaction_options::PartitionedDml {
        if let ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(transaction_options::PartitionedDml::new()));
        }
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_partitioned_dml(&mut self) -> transaction_options::PartitionedDml {
        if self.has_partitioned_dml() {
            match self.mode.take() {
                ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(v)) => v,
                _ => panic!(),
            }
        } else {
            transaction_options::PartitionedDml::new()
        }
    }

    // .google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;

    pub fn read_only(&self) -> &transaction_options::ReadOnly {
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::ReadOnly(ref v)) => v,
            _ => <transaction_options::ReadOnly as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_only(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_only(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::ReadOnly(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_only(&mut self, v: transaction_options::ReadOnly) {
        self.mode = ::std::option::Option::Some(transaction_options::Mode::ReadOnly(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_only(&mut self) -> &mut transaction_options::ReadOnly {
        if let ::std::option::Option::Some(transaction_options::Mode::ReadOnly(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(transaction_options::Mode::ReadOnly(transaction_options::ReadOnly::new()));
        }
        match self.mode {
            ::std::option::Option::Some(transaction_options::Mode::ReadOnly(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_only(&mut self) -> transaction_options::ReadOnly {
        if self.has_read_only() {
            match self.mode.take() {
                ::std::option::Option::Some(transaction_options::Mode::ReadOnly(v)) => v,
                _ => panic!(),
            }
        } else {
            transaction_options::ReadOnly::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, transaction_options::ReadWrite>(
            "read_write",
            TransactionOptions::has_read_write,
            TransactionOptions::read_write,
            TransactionOptions::mut_read_write,
            TransactionOptions::set_read_write,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, transaction_options::PartitionedDml>(
            "partitioned_dml",
            TransactionOptions::has_partitioned_dml,
            TransactionOptions::partitioned_dml,
            TransactionOptions::mut_partitioned_dml,
            TransactionOptions::set_partitioned_dml,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, transaction_options::ReadOnly>(
            "read_only",
            TransactionOptions::has_read_only,
            TransactionOptions::read_only,
            TransactionOptions::mut_read_only,
            TransactionOptions::set_read_only,
        ));
        oneofs.push(transaction_options::Mode::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionOptions>(
            "TransactionOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionOptions {
    const NAME: &'static str = "TransactionOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mode = ::std::option::Option::Some(transaction_options::Mode::ReadWrite(is.read_message()?));
                },
                26 => {
                    self.mode = ::std::option::Option::Some(transaction_options::Mode::PartitionedDml(is.read_message()?));
                },
                18 => {
                    self.mode = ::std::option::Option::Some(transaction_options::Mode::ReadOnly(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &transaction_options::Mode::ReadWrite(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_options::Mode::PartitionedDml(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_options::Mode::ReadOnly(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &transaction_options::Mode::ReadWrite(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &transaction_options::Mode::PartitionedDml(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &transaction_options::Mode::ReadOnly(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionOptions {
        TransactionOptions::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionOptions {
        static instance: TransactionOptions = TransactionOptions {
            mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionOptions`
pub mod transaction_options {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.spanner.v1.TransactionOptions.mode)
    pub enum Mode {
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.read_write)
        ReadWrite(ReadWrite),
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.partitioned_dml)
        PartitionedDml(PartitionedDml),
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.read_only)
        ReadOnly(ReadOnly),
    }

    impl ::protobuf::Oneof for Mode {
    }

    impl ::protobuf::OneofFull for Mode {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TransactionOptions as ::protobuf::MessageFull>::descriptor().oneof_by_name("mode").unwrap()).clone()
        }
    }

    impl Mode {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Mode>("mode")
        }
    }
    ///  Message type to initiate a read-write transaction. Currently this
    ///  transaction type has no options.
    // @@protoc_insertion_point(message:google.spanner.v1.TransactionOptions.ReadWrite)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReadWrite {
        // special fields
        // @@protoc_insertion_point(special_field:google.spanner.v1.TransactionOptions.ReadWrite.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReadWrite {
        fn default() -> &'a ReadWrite {
            <ReadWrite as ::protobuf::Message>::default_instance()
        }
    }

    impl ReadWrite {
        pub fn new() -> ReadWrite {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadWrite>(
                "TransactionOptions.ReadWrite",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReadWrite {
        const NAME: &'static str = "ReadWrite";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReadWrite {
            ReadWrite::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReadWrite {
            static instance: ReadWrite = ReadWrite {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReadWrite {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TransactionOptions.ReadWrite").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReadWrite {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReadWrite {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Message type to initiate a Partitioned DML transaction.
    // @@protoc_insertion_point(message:google.spanner.v1.TransactionOptions.PartitionedDml)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartitionedDml {
        // special fields
        // @@protoc_insertion_point(special_field:google.spanner.v1.TransactionOptions.PartitionedDml.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartitionedDml {
        fn default() -> &'a PartitionedDml {
            <PartitionedDml as ::protobuf::Message>::default_instance()
        }
    }

    impl PartitionedDml {
        pub fn new() -> PartitionedDml {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartitionedDml>(
                "TransactionOptions.PartitionedDml",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PartitionedDml {
        const NAME: &'static str = "PartitionedDml";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartitionedDml {
            PartitionedDml::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartitionedDml {
            static instance: PartitionedDml = PartitionedDml {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PartitionedDml {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TransactionOptions.PartitionedDml").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PartitionedDml {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PartitionedDml {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Message type to initiate a read-only transaction.
    // @@protoc_insertion_point(message:google.spanner.v1.TransactionOptions.ReadOnly)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReadOnly {
        // message fields
        ///  If true, the Cloud Spanner-selected read timestamp is included in
        ///  the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
        // @@protoc_insertion_point(field:google.spanner.v1.TransactionOptions.ReadOnly.return_read_timestamp)
        pub return_read_timestamp: bool,
        // message oneof groups
        pub timestamp_bound: ::std::option::Option<read_only::Timestamp_bound>,
        // special fields
        // @@protoc_insertion_point(special_field:google.spanner.v1.TransactionOptions.ReadOnly.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReadOnly {
        fn default() -> &'a ReadOnly {
            <ReadOnly as ::protobuf::Message>::default_instance()
        }
    }

    impl ReadOnly {
        pub fn new() -> ReadOnly {
            ::std::default::Default::default()
        }

        // bool strong = 1;

        pub fn strong(&self) -> bool {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::Strong(v)) => v,
                _ => false,
            }
        }

        pub fn clear_strong(&mut self) {
            self.timestamp_bound = ::std::option::Option::None;
        }

        pub fn has_strong(&self) -> bool {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::Strong(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_strong(&mut self, v: bool) {
            self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::Strong(v))
        }

        // .google.protobuf.Timestamp min_read_timestamp = 2;

        pub fn min_read_timestamp(&self) -> &::protobuf::well_known_types::timestamp::Timestamp {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(ref v)) => v,
                _ => <::protobuf::well_known_types::timestamp::Timestamp as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_min_read_timestamp(&mut self) {
            self.timestamp_bound = ::std::option::Option::None;
        }

        pub fn has_min_read_timestamp(&self) -> bool {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_min_read_timestamp(&mut self, v: ::protobuf::well_known_types::timestamp::Timestamp) {
            self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(v))
        }

        // Mutable pointer to the field.
        pub fn mut_min_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::timestamp::Timestamp {
            if let ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(_)) = self.timestamp_bound {
            } else {
                self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(::protobuf::well_known_types::timestamp::Timestamp::new()));
            }
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_min_read_timestamp(&mut self) -> ::protobuf::well_known_types::timestamp::Timestamp {
            if self.has_min_read_timestamp() {
                match self.timestamp_bound.take() {
                    ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::protobuf::well_known_types::timestamp::Timestamp::new()
            }
        }

        // .google.protobuf.Duration max_staleness = 3;

        pub fn max_staleness(&self) -> &::protobuf::well_known_types::duration::Duration {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(ref v)) => v,
                _ => <::protobuf::well_known_types::duration::Duration as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_max_staleness(&mut self) {
            self.timestamp_bound = ::std::option::Option::None;
        }

        pub fn has_max_staleness(&self) -> bool {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_max_staleness(&mut self, v: ::protobuf::well_known_types::duration::Duration) {
            self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(v))
        }

        // Mutable pointer to the field.
        pub fn mut_max_staleness(&mut self) -> &mut ::protobuf::well_known_types::duration::Duration {
            if let ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(_)) = self.timestamp_bound {
            } else {
                self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(::protobuf::well_known_types::duration::Duration::new()));
            }
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_max_staleness(&mut self) -> ::protobuf::well_known_types::duration::Duration {
            if self.has_max_staleness() {
                match self.timestamp_bound.take() {
                    ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::protobuf::well_known_types::duration::Duration::new()
            }
        }

        // .google.protobuf.Timestamp read_timestamp = 4;

        pub fn read_timestamp(&self) -> &::protobuf::well_known_types::timestamp::Timestamp {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(ref v)) => v,
                _ => <::protobuf::well_known_types::timestamp::Timestamp as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_read_timestamp(&mut self) {
            self.timestamp_bound = ::std::option::Option::None;
        }

        pub fn has_read_timestamp(&self) -> bool {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_read_timestamp(&mut self, v: ::protobuf::well_known_types::timestamp::Timestamp) {
            self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(v))
        }

        // Mutable pointer to the field.
        pub fn mut_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::timestamp::Timestamp {
            if let ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(_)) = self.timestamp_bound {
            } else {
                self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(::protobuf::well_known_types::timestamp::Timestamp::new()));
            }
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_read_timestamp(&mut self) -> ::protobuf::well_known_types::timestamp::Timestamp {
            if self.has_read_timestamp() {
                match self.timestamp_bound.take() {
                    ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::protobuf::well_known_types::timestamp::Timestamp::new()
            }
        }

        // .google.protobuf.Duration exact_staleness = 5;

        pub fn exact_staleness(&self) -> &::protobuf::well_known_types::duration::Duration {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(ref v)) => v,
                _ => <::protobuf::well_known_types::duration::Duration as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_exact_staleness(&mut self) {
            self.timestamp_bound = ::std::option::Option::None;
        }

        pub fn has_exact_staleness(&self) -> bool {
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_exact_staleness(&mut self, v: ::protobuf::well_known_types::duration::Duration) {
            self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(v))
        }

        // Mutable pointer to the field.
        pub fn mut_exact_staleness(&mut self) -> &mut ::protobuf::well_known_types::duration::Duration {
            if let ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(_)) = self.timestamp_bound {
            } else {
                self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(::protobuf::well_known_types::duration::Duration::new()));
            }
            match self.timestamp_bound {
                ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_exact_staleness(&mut self) -> ::protobuf::well_known_types::duration::Duration {
            if self.has_exact_staleness() {
                match self.timestamp_bound.take() {
                    ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::protobuf::well_known_types::duration::Duration::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "strong",
                ReadOnly::has_strong,
                ReadOnly::strong,
                ReadOnly::set_strong,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                "min_read_timestamp",
                ReadOnly::has_min_read_timestamp,
                ReadOnly::min_read_timestamp,
                ReadOnly::mut_min_read_timestamp,
                ReadOnly::set_min_read_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
                "max_staleness",
                ReadOnly::has_max_staleness,
                ReadOnly::max_staleness,
                ReadOnly::mut_max_staleness,
                ReadOnly::set_max_staleness,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                "read_timestamp",
                ReadOnly::has_read_timestamp,
                ReadOnly::read_timestamp,
                ReadOnly::mut_read_timestamp,
                ReadOnly::set_read_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
                "exact_staleness",
                ReadOnly::has_exact_staleness,
                ReadOnly::exact_staleness,
                ReadOnly::mut_exact_staleness,
                ReadOnly::set_exact_staleness,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "return_read_timestamp",
                |m: &ReadOnly| { &m.return_read_timestamp },
                |m: &mut ReadOnly| { &mut m.return_read_timestamp },
            ));
            oneofs.push(read_only::Timestamp_bound::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadOnly>(
                "TransactionOptions.ReadOnly",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReadOnly {
        const NAME: &'static str = "ReadOnly";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::Strong(is.read_bool()?));
                    },
                    18 => {
                        self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::MinReadTimestamp(is.read_message()?));
                    },
                    26 => {
                        self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::MaxStaleness(is.read_message()?));
                    },
                    34 => {
                        self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::ReadTimestamp(is.read_message()?));
                    },
                    42 => {
                        self.timestamp_bound = ::std::option::Option::Some(read_only::Timestamp_bound::ExactStaleness(is.read_message()?));
                    },
                    48 => {
                        self.return_read_timestamp = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.return_read_timestamp != false {
                my_size += 1 + 1;
            }
            if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
                match v {
                    &read_only::Timestamp_bound::Strong(v) => {
                        my_size += 1 + 1;
                    },
                    &read_only::Timestamp_bound::MinReadTimestamp(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &read_only::Timestamp_bound::MaxStaleness(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &read_only::Timestamp_bound::ReadTimestamp(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &read_only::Timestamp_bound::ExactStaleness(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.return_read_timestamp != false {
                os.write_bool(6, self.return_read_timestamp)?;
            }
            if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
                match v {
                    &read_only::Timestamp_bound::Strong(v) => {
                        os.write_bool(1, v)?;
                    },
                    &read_only::Timestamp_bound::MinReadTimestamp(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &read_only::Timestamp_bound::MaxStaleness(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &read_only::Timestamp_bound::ReadTimestamp(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &read_only::Timestamp_bound::ExactStaleness(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReadOnly {
            ReadOnly::new()
        }

        fn clear(&mut self) {
            self.timestamp_bound = ::std::option::Option::None;
            self.timestamp_bound = ::std::option::Option::None;
            self.timestamp_bound = ::std::option::Option::None;
            self.timestamp_bound = ::std::option::Option::None;
            self.timestamp_bound = ::std::option::Option::None;
            self.return_read_timestamp = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReadOnly {
            static instance: ReadOnly = ReadOnly {
                return_read_timestamp: false,
                timestamp_bound: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReadOnly {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TransactionOptions.ReadOnly").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReadOnly {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReadOnly {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ReadOnly`
    pub mod read_only {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:google.spanner.v1.TransactionOptions.ReadOnly.timestamp_bound)
        pub enum Timestamp_bound {
            // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.ReadOnly.strong)
            Strong(bool),
            // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp)
            MinReadTimestamp(::protobuf::well_known_types::timestamp::Timestamp),
            // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.ReadOnly.max_staleness)
            MaxStaleness(::protobuf::well_known_types::duration::Duration),
            // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp)
            ReadTimestamp(::protobuf::well_known_types::timestamp::Timestamp),
            // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness)
            ExactStaleness(::protobuf::well_known_types::duration::Duration),
        }

        impl ::protobuf::Oneof for Timestamp_bound {
        }

        impl ::protobuf::OneofFull for Timestamp_bound {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::ReadOnly as ::protobuf::MessageFull>::descriptor().oneof_by_name("timestamp_bound").unwrap()).clone()
            }
        }

        impl Timestamp_bound {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Timestamp_bound>("timestamp_bound")
            }
        }
    }
}

///  A transaction.
// @@protoc_insertion_point(message:google.spanner.v1.Transaction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Transaction {
    // message fields
    ///  `id` may be used to identify the transaction in subsequent
    ///  [Read][google.spanner.v1.Spanner.Read],
    ///  [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],
    ///  [Commit][google.spanner.v1.Spanner.Commit], or
    ///  [Rollback][google.spanner.v1.Spanner.Rollback] calls.
    ///
    ///  Single-use read-only transactions do not have IDs, because
    ///  single-use transactions do not support multiple requests.
    // @@protoc_insertion_point(field:google.spanner.v1.Transaction.id)
    pub id: ::std::vec::Vec<u8>,
    ///  For snapshot read-only transactions, the read timestamp chosen
    ///  for the transaction. Not returned by default: see
    ///  [TransactionOptions.ReadOnly.return_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.return_read_timestamp].
    ///
    ///  A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
    ///  Example: `"2014-10-02T15:01:23.045123456Z"`.
    // @@protoc_insertion_point(field:google.spanner.v1.Transaction.read_timestamp)
    pub read_timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.Transaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Transaction| { &m.id },
            |m: &mut Transaction| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "read_timestamp",
            |m: &Transaction| { &m.read_timestamp },
            |m: &mut Transaction| { &mut m.read_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transaction>(
            "Transaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transaction {
    const NAME: &'static str = "Transaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.read_timestamp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if let Some(v) = self.read_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if let Some(v) = self.read_timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.read_timestamp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transaction {
        static instance: Transaction = Transaction {
            id: ::std::vec::Vec::new(),
            read_timestamp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This message is used to select the transaction in which a
///  [Read][google.spanner.v1.Spanner.Read] or
///  [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] call runs.
///
///  See [TransactionOptions][google.spanner.v1.TransactionOptions] for more information about transactions.
// @@protoc_insertion_point(message:google.spanner.v1.TransactionSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TransactionSelector {
    // message oneof groups
    pub selector: ::std::option::Option<transaction_selector::Selector>,
    // special fields
    // @@protoc_insertion_point(special_field:google.spanner.v1.TransactionSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionSelector {
    fn default() -> &'a TransactionSelector {
        <TransactionSelector as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSelector {
    pub fn new() -> TransactionSelector {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions single_use = 1;

    pub fn single_use(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::SingleUse(ref v)) => v,
            _ => <TransactionOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_single_use(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_single_use(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::SingleUse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_use(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(transaction_selector::Selector::SingleUse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single_use(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(transaction_selector::Selector::SingleUse(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(transaction_selector::Selector::SingleUse(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::SingleUse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single_use(&mut self) -> TransactionOptions {
        if self.has_single_use() {
            match self.selector.take() {
                ::std::option::Option::Some(transaction_selector::Selector::SingleUse(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }

    // bytes id = 2;

    pub fn id(&self) -> &[u8] {
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::Id(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_id(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::Id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.selector = ::std::option::Option::Some(transaction_selector::Selector::Id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(transaction_selector::Selector::Id(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(transaction_selector::Selector::Id(::std::vec::Vec::new()));
        }
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::Id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_id() {
            match self.selector.take() {
                ::std::option::Option::Some(transaction_selector::Selector::Id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.spanner.v1.TransactionOptions begin = 3;

    pub fn begin(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::Begin(ref v)) => v,
            _ => <TransactionOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_begin(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::Begin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(transaction_selector::Selector::Begin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_begin(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(transaction_selector::Selector::Begin(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(transaction_selector::Selector::Begin(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(transaction_selector::Selector::Begin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_begin(&mut self) -> TransactionOptions {
        if self.has_begin() {
            match self.selector.take() {
                ::std::option::Option::Some(transaction_selector::Selector::Begin(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TransactionOptions>(
            "single_use",
            TransactionSelector::has_single_use,
            TransactionSelector::single_use,
            TransactionSelector::mut_single_use,
            TransactionSelector::set_single_use,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "id",
            TransactionSelector::has_id,
            TransactionSelector::id,
            TransactionSelector::set_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TransactionOptions>(
            "begin",
            TransactionSelector::has_begin,
            TransactionSelector::begin,
            TransactionSelector::mut_begin,
            TransactionSelector::set_begin,
        ));
        oneofs.push(transaction_selector::Selector::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionSelector>(
            "TransactionSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionSelector {
    const NAME: &'static str = "TransactionSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selector = ::std::option::Option::Some(transaction_selector::Selector::SingleUse(is.read_message()?));
                },
                18 => {
                    self.selector = ::std::option::Option::Some(transaction_selector::Selector::Id(is.read_bytes()?));
                },
                26 => {
                    self.selector = ::std::option::Option::Some(transaction_selector::Selector::Begin(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &transaction_selector::Selector::SingleUse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_selector::Selector::Id(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &transaction_selector::Selector::Begin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &transaction_selector::Selector::SingleUse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &transaction_selector::Selector::Id(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &transaction_selector::Selector::Begin(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionSelector {
        TransactionSelector::new()
    }

    fn clear(&mut self) {
        self.selector = ::std::option::Option::None;
        self.selector = ::std::option::Option::None;
        self.selector = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionSelector {
        static instance: TransactionSelector = TransactionSelector {
            selector: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionSelector`
pub mod transaction_selector {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.spanner.v1.TransactionSelector.selector)
    pub enum Selector {
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionSelector.single_use)
        SingleUse(super::TransactionOptions),
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionSelector.id)
        Id(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.spanner.v1.TransactionSelector.begin)
        Begin(super::TransactionOptions),
    }

    impl ::protobuf::Oneof for Selector {
    }

    impl ::protobuf::OneofFull for Selector {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TransactionSelector as ::protobuf::MessageFull>::descriptor().oneof_by_name("selector").unwrap()).clone()
        }
    }

    impl Selector {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Selector>("selector")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#google/spanner/v1/transaction.proto\x12\x11google.spanner.v1\x1a\x1eg\
    oogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\
    \x1cgoogle/api/annotations.proto\"\xc4\x05\n\x12TransactionOptions\x12P\
    \n\nread_write\x18\x01\x20\x01(\x0b2/.google.spanner.v1.TransactionOptio\
    ns.ReadWriteH\0R\treadWrite\x12_\n\x0fpartitioned_dml\x18\x03\x20\x01(\
    \x0b24.google.spanner.v1.TransactionOptions.PartitionedDmlH\0R\x0epartit\
    ionedDml\x12M\n\tread_only\x18\x02\x20\x01(\x0b2..google.spanner.v1.Tran\
    sactionOptions.ReadOnlyH\0R\x08readOnly\x1a\x0b\n\tReadWrite\x1a\x10\n\
    \x0ePartitionedDml\x1a\x84\x03\n\x08ReadOnly\x12\x18\n\x06strong\x18\x01\
    \x20\x01(\x08H\0R\x06strong\x12J\n\x12min_read_timestamp\x18\x02\x20\x01\
    (\x0b2\x1a.google.protobuf.TimestampH\0R\x10minReadTimestamp\x12@\n\rmax\
    _staleness\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationH\0R\x0cmax\
    Staleness\x12C\n\x0eread_timestamp\x18\x04\x20\x01(\x0b2\x1a.google.prot\
    obuf.TimestampH\0R\rreadTimestamp\x12D\n\x0fexact_staleness\x18\x05\x20\
    \x01(\x0b2\x19.google.protobuf.DurationH\0R\x0eexactStaleness\x122\n\x15\
    return_read_timestamp\x18\x06\x20\x01(\x08R\x13returnReadTimestampB\x11\
    \n\x0ftimestamp_boundB\x06\n\x04mode\"`\n\x0bTransaction\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x0cR\x02id\x12A\n\x0eread_timestamp\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\rreadTimestamp\"\xba\x01\n\x13Trans\
    actionSelector\x12F\n\nsingle_use\x18\x01\x20\x01(\x0b2%.google.spanner.\
    v1.TransactionOptionsH\0R\tsingleUse\x12\x10\n\x02id\x18\x02\x20\x01(\
    \x0cH\0R\x02id\x12=\n\x05begin\x18\x03\x20\x01(\x0b2%.google.spanner.v1.\
    TransactionOptionsH\0R\x05beginB\n\n\x08selectorB\x99\x01\n\x15com.googl\
    e.spanner.v1B\x10TransactionProtoP\x01Z8google.golang.org/genproto/googl\
    eapis/spanner/v1;spanner\xaa\x02\x17Google.Cloud.Spanner.V1\xca\x02\x17G\
    oogle\\Cloud\\Spanner\\V1J\x9b\x99\x01\n\x07\x12\x05\x0f\0\xc7\x03\x01\n\
    \xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Go\
    ogle\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ve\
    rsion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20t\
    his\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1a\n\t\n\x02\x03\
    \0\x12\x03\x13\0(\n\t\n\x02\x03\x01\x12\x03\x14\0)\n\t\n\x02\x03\x02\x12\
    \x03\x15\0&\n\x08\n\x01\x08\x12\x03\x17\04\n\t\n\x02\x08%\x12\x03\x17\04\
    \n\x08\n\x01\x08\x12\x03\x18\0O\n\t\n\x02\x08\x0b\x12\x03\x18\0O\n\x08\n\
    \x01\x08\x12\x03\x19\0\"\n\t\n\x02\x08\n\x12\x03\x19\0\"\n\x08\n\x01\x08\
    \x12\x03\x1a\01\n\t\n\x02\x08\x08\x12\x03\x1a\01\n\x08\n\x01\x08\x12\x03\
    \x1b\0.\n\t\n\x02\x08\x01\x12\x03\x1b\0.\n\x08\n\x01\x08\x12\x03\x1c\04\
    \n\t\n\x02\x08)\x12\x03\x1c\04\n\x80e\n\x02\x04\0\x12\x06\xb3\x02\0\x9a\
    \x03\x01\x1a\xf1d\x20#\x20Transactions\n\n\n\x20Each\x20session\x20can\
    \x20have\x20at\x20most\x20one\x20active\x20transaction\x20at\x20a\x20tim\
    e.\x20After\x20the\n\x20active\x20transaction\x20is\x20completed,\x20the\
    \x20session\x20can\x20immediately\x20be\n\x20re-used\x20for\x20the\x20ne\
    xt\x20transaction.\x20It\x20is\x20not\x20necessary\x20to\x20create\x20a\
    \n\x20new\x20session\x20for\x20each\x20transaction.\n\n\x20#\x20Transact\
    ion\x20Modes\n\n\x20Cloud\x20Spanner\x20supports\x20three\x20transaction\
    \x20modes:\n\n\x20\x20\x201.\x20Locking\x20read-write.\x20This\x20type\
    \x20of\x20transaction\x20is\x20the\x20only\x20way\n\x20\x20\x20\x20\x20\
    \x20to\x20write\x20data\x20into\x20Cloud\x20Spanner.\x20These\x20transac\
    tions\x20rely\x20on\n\x20\x20\x20\x20\x20\x20pessimistic\x20locking\x20a\
    nd,\x20if\x20necessary,\x20two-phase\x20commit.\n\x20\x20\x20\x20\x20\
    \x20Locking\x20read-write\x20transactions\x20may\x20abort,\x20requiring\
    \x20the\n\x20\x20\x20\x20\x20\x20application\x20to\x20retry.\n\n\x20\x20\
    \x202.\x20Snapshot\x20read-only.\x20This\x20transaction\x20type\x20provi\
    des\x20guaranteed\n\x20\x20\x20\x20\x20\x20consistency\x20across\x20seve\
    ral\x20reads,\x20but\x20does\x20not\x20allow\n\x20\x20\x20\x20\x20\x20wr\
    ites.\x20Snapshot\x20read-only\x20transactions\x20can\x20be\x20configure\
    d\x20to\n\x20\x20\x20\x20\x20\x20read\x20at\x20timestamps\x20in\x20the\
    \x20past.\x20Snapshot\x20read-only\n\x20\x20\x20\x20\x20\x20transactions\
    \x20do\x20not\x20need\x20to\x20be\x20committed.\n\n\x20\x20\x203.\x20Par\
    titioned\x20DML.\x20This\x20type\x20of\x20transaction\x20is\x20used\x20t\
    o\x20execute\n\x20\x20\x20\x20\x20\x20a\x20single\x20Partitioned\x20DML\
    \x20statement.\x20Partitioned\x20DML\x20partitions\n\x20\x20\x20\x20\x20\
    \x20the\x20key\x20space\x20and\x20runs\x20the\x20DML\x20statement\x20ove\
    r\x20each\x20partition\n\x20\x20\x20\x20\x20\x20in\x20parallel\x20using\
    \x20separate,\x20internal\x20transactions\x20that\x20commit\n\x20\x20\
    \x20\x20\x20\x20independently.\x20Partitioned\x20DML\x20transactions\x20\
    do\x20not\x20need\x20to\x20be\n\x20\x20\x20\x20\x20\x20committed.\n\n\
    \x20For\x20transactions\x20that\x20only\x20read,\x20snapshot\x20read-onl\
    y\x20transactions\n\x20provide\x20simpler\x20semantics\x20and\x20are\x20\
    almost\x20always\x20faster.\x20In\n\x20particular,\x20read-only\x20trans\
    actions\x20do\x20not\x20take\x20locks,\x20so\x20they\x20do\n\x20not\x20c\
    onflict\x20with\x20read-write\x20transactions.\x20As\x20a\x20consequence\
    \x20of\x20not\n\x20taking\x20locks,\x20they\x20also\x20do\x20not\x20abor\
    t,\x20so\x20retry\x20loops\x20are\x20not\x20needed.\n\n\x20Transactions\
    \x20may\x20only\x20read/write\x20data\x20in\x20a\x20single\x20database.\
    \x20They\n\x20may,\x20however,\x20read/write\x20data\x20in\x20different\
    \x20tables\x20within\x20that\n\x20database.\n\n\x20##\x20Locking\x20Read\
    -Write\x20Transactions\n\n\x20Locking\x20transactions\x20may\x20be\x20us\
    ed\x20to\x20atomically\x20read-modify-write\n\x20data\x20anywhere\x20in\
    \x20a\x20database.\x20This\x20type\x20of\x20transaction\x20is\x20externa\
    lly\n\x20consistent.\n\n\x20Clients\x20should\x20attempt\x20to\x20minimi\
    ze\x20the\x20amount\x20of\x20time\x20a\x20transaction\n\x20is\x20active.\
    \x20Faster\x20transactions\x20commit\x20with\x20higher\x20probability\n\
    \x20and\x20cause\x20less\x20contention.\x20Cloud\x20Spanner\x20attempts\
    \x20to\x20keep\x20read\x20locks\n\x20active\x20as\x20long\x20as\x20the\
    \x20transaction\x20continues\x20to\x20do\x20reads,\x20and\x20the\n\x20tr\
    ansaction\x20has\x20not\x20been\x20terminated\x20by\n\x20[Commit][google\
    .spanner.v1.Spanner.Commit]\x20or\n\x20[Rollback][google.spanner.v1.Span\
    ner.Rollback].\x20\x20Long\x20periods\x20of\n\x20inactivity\x20at\x20the\
    \x20client\x20may\x20cause\x20Cloud\x20Spanner\x20to\x20release\x20a\n\
    \x20transaction's\x20locks\x20and\x20abort\x20it.\n\n\x20Conceptually,\
    \x20a\x20read-write\x20transaction\x20consists\x20of\x20zero\x20or\x20mo\
    re\n\x20reads\x20or\x20SQL\x20statements\x20followed\x20by\n\x20[Commit]\
    [google.spanner.v1.Spanner.Commit].\x20At\x20any\x20time\x20before\n\x20\
    [Commit][google.spanner.v1.Spanner.Commit],\x20the\x20client\x20can\x20s\
    end\x20a\n\x20[Rollback][google.spanner.v1.Spanner.Rollback]\x20request\
    \x20to\x20abort\x20the\n\x20transaction.\n\n\x20###\x20Semantics\n\n\x20\
    Cloud\x20Spanner\x20can\x20commit\x20the\x20transaction\x20if\x20all\x20\
    read\x20locks\x20it\x20acquired\n\x20are\x20still\x20valid\x20at\x20comm\
    it\x20time,\x20and\x20it\x20is\x20able\x20to\x20acquire\x20write\n\x20lo\
    cks\x20for\x20all\x20writes.\x20Cloud\x20Spanner\x20can\x20abort\x20the\
    \x20transaction\x20for\x20any\n\x20reason.\x20If\x20a\x20commit\x20attem\
    pt\x20returns\x20`ABORTED`,\x20Cloud\x20Spanner\x20guarantees\n\x20that\
    \x20the\x20transaction\x20has\x20not\x20modified\x20any\x20user\x20data\
    \x20in\x20Cloud\x20Spanner.\n\n\x20Unless\x20the\x20transaction\x20commi\
    ts,\x20Cloud\x20Spanner\x20makes\x20no\x20guarantees\x20about\n\x20how\
    \x20long\x20the\x20transaction's\x20locks\x20were\x20held\x20for.\x20It\
    \x20is\x20an\x20error\x20to\n\x20use\x20Cloud\x20Spanner\x20locks\x20for\
    \x20any\x20sort\x20of\x20mutual\x20exclusion\x20other\x20than\n\x20betwe\
    en\x20Cloud\x20Spanner\x20transactions\x20themselves.\n\n\x20###\x20Retr\
    ying\x20Aborted\x20Transactions\n\n\x20When\x20a\x20transaction\x20abort\
    s,\x20the\x20application\x20can\x20choose\x20to\x20retry\x20the\n\x20who\
    le\x20transaction\x20again.\x20To\x20maximize\x20the\x20chances\x20of\
    \x20successfully\n\x20committing\x20the\x20retry,\x20the\x20client\x20sh\
    ould\x20execute\x20the\x20retry\x20in\x20the\n\x20same\x20session\x20as\
    \x20the\x20original\x20attempt.\x20The\x20original\x20session's\x20lock\
    \n\x20priority\x20increases\x20with\x20each\x20consecutive\x20abort,\x20\
    meaning\x20that\x20each\n\x20attempt\x20has\x20a\x20slightly\x20better\
    \x20chance\x20of\x20success\x20than\x20the\x20previous.\n\n\x20Under\x20\
    some\x20circumstances\x20(e.g.,\x20many\x20transactions\x20attempting\
    \x20to\n\x20modify\x20the\x20same\x20row(s)),\x20a\x20transaction\x20can\
    \x20abort\x20many\x20times\x20in\x20a\n\x20short\x20period\x20before\x20\
    successfully\x20committing.\x20Thus,\x20it\x20is\x20not\x20a\x20good\n\
    \x20idea\x20to\x20cap\x20the\x20number\x20of\x20retries\x20a\x20transact\
    ion\x20can\x20attempt;\n\x20instead,\x20it\x20is\x20better\x20to\x20limi\
    t\x20the\x20total\x20amount\x20of\x20wall\x20time\x20spent\n\x20retrying\
    .\n\n\x20###\x20Idle\x20Transactions\n\n\x20A\x20transaction\x20is\x20co\
    nsidered\x20idle\x20if\x20it\x20has\x20no\x20outstanding\x20reads\x20or\
    \n\x20SQL\x20queries\x20and\x20has\x20not\x20started\x20a\x20read\x20or\
    \x20SQL\x20query\x20within\x20the\x20last\x2010\n\x20seconds.\x20Idle\
    \x20transactions\x20can\x20be\x20aborted\x20by\x20Cloud\x20Spanner\x20so\
    \x20that\x20they\n\x20don't\x20hold\x20on\x20to\x20locks\x20indefinitely\
    .\x20In\x20that\x20case,\x20the\x20commit\x20will\n\x20fail\x20with\x20e\
    rror\x20`ABORTED`.\n\n\x20If\x20this\x20behavior\x20is\x20undesirable,\
    \x20periodically\x20executing\x20a\x20simple\n\x20SQL\x20query\x20in\x20\
    the\x20transaction\x20(e.g.,\x20`SELECT\x201`)\x20prevents\x20the\n\x20t\
    ransaction\x20from\x20becoming\x20idle.\n\n\x20##\x20Snapshot\x20Read-On\
    ly\x20Transactions\n\n\x20Snapshot\x20read-only\x20transactions\x20provi\
    des\x20a\x20simpler\x20method\x20than\n\x20locking\x20read-write\x20tran\
    sactions\x20for\x20doing\x20several\x20consistent\n\x20reads.\x20However\
    ,\x20this\x20type\x20of\x20transaction\x20does\x20not\x20support\x20writ\
    es.\n\n\x20Snapshot\x20transactions\x20do\x20not\x20take\x20locks.\x20In\
    stead,\x20they\x20work\x20by\n\x20choosing\x20a\x20Cloud\x20Spanner\x20t\
    imestamp,\x20then\x20executing\x20all\x20reads\x20at\x20that\n\x20timest\
    amp.\x20Since\x20they\x20do\x20not\x20acquire\x20locks,\x20they\x20do\
    \x20not\x20block\n\x20concurrent\x20read-write\x20transactions.\n\n\x20U\
    nlike\x20locking\x20read-write\x20transactions,\x20snapshot\x20read-only\
    \n\x20transactions\x20never\x20abort.\x20They\x20can\x20fail\x20if\x20th\
    e\x20chosen\x20read\n\x20timestamp\x20is\x20garbage\x20collected;\x20how\
    ever,\x20the\x20default\x20garbage\n\x20collection\x20policy\x20is\x20ge\
    nerous\x20enough\x20that\x20most\x20applications\x20do\x20not\n\x20need\
    \x20to\x20worry\x20about\x20this\x20in\x20practice.\n\n\x20Snapshot\x20r\
    ead-only\x20transactions\x20do\x20not\x20need\x20to\x20call\n\x20[Commit\
    ][google.spanner.v1.Spanner.Commit]\x20or\n\x20[Rollback][google.spanner\
    .v1.Spanner.Rollback]\x20(and\x20in\x20fact\x20are\x20not\n\x20permitted\
    \x20to\x20do\x20so).\n\n\x20To\x20execute\x20a\x20snapshot\x20transactio\
    n,\x20the\x20client\x20specifies\x20a\x20timestamp\n\x20bound,\x20which\
    \x20tells\x20Cloud\x20Spanner\x20how\x20to\x20choose\x20a\x20read\x20tim\
    estamp.\n\n\x20The\x20types\x20of\x20timestamp\x20bound\x20are:\n\n\x20\
    \x20\x20-\x20Strong\x20(the\x20default).\n\x20\x20\x20-\x20Bounded\x20st\
    aleness.\n\x20\x20\x20-\x20Exact\x20staleness.\n\n\x20If\x20the\x20Cloud\
    \x20Spanner\x20database\x20to\x20be\x20read\x20is\x20geographically\x20d\
    istributed,\n\x20stale\x20read-only\x20transactions\x20can\x20execute\
    \x20more\x20quickly\x20than\x20strong\n\x20or\x20read-write\x20transacti\
    on,\x20because\x20they\x20are\x20able\x20to\x20execute\x20far\n\x20from\
    \x20the\x20leader\x20replica.\n\n\x20Each\x20type\x20of\x20timestamp\x20\
    bound\x20is\x20discussed\x20in\x20detail\x20below.\n\n\x20###\x20Strong\
    \n\n\x20Strong\x20reads\x20are\x20guaranteed\x20to\x20see\x20the\x20effe\
    cts\x20of\x20all\x20transactions\n\x20that\x20have\x20committed\x20befor\
    e\x20the\x20start\x20of\x20the\x20read.\x20Furthermore,\x20all\n\x20rows\
    \x20yielded\x20by\x20a\x20single\x20read\x20are\x20consistent\x20with\
    \x20each\x20other\x20--\x20if\n\x20any\x20part\x20of\x20the\x20read\x20o\
    bserves\x20a\x20transaction,\x20all\x20parts\x20of\x20the\x20read\n\x20s\
    ee\x20the\x20transaction.\n\n\x20Strong\x20reads\x20are\x20not\x20repeat\
    able:\x20two\x20consecutive\x20strong\x20read-only\n\x20transactions\x20\
    might\x20return\x20inconsistent\x20results\x20if\x20there\x20are\n\x20co\
    ncurrent\x20writes.\x20If\x20consistency\x20across\x20reads\x20is\x20req\
    uired,\x20the\n\x20reads\x20should\x20be\x20executed\x20within\x20a\x20t\
    ransaction\x20or\x20at\x20an\x20exact\x20read\n\x20timestamp.\n\n\x20See\
    \x20[TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOp\
    tions.ReadOnly.strong].\n\n\x20###\x20Exact\x20Staleness\n\n\x20These\
    \x20timestamp\x20bounds\x20execute\x20reads\x20at\x20a\x20user-specified\
    \n\x20timestamp.\x20Reads\x20at\x20a\x20timestamp\x20are\x20guaranteed\
    \x20to\x20see\x20a\x20consistent\n\x20prefix\x20of\x20the\x20global\x20t\
    ransaction\x20history:\x20they\x20observe\n\x20modifications\x20done\x20\
    by\x20all\x20transactions\x20with\x20a\x20commit\x20timestamp\x20<=\n\
    \x20the\x20read\x20timestamp,\x20and\x20observe\x20none\x20of\x20the\x20\
    modifications\x20done\x20by\n\x20transactions\x20with\x20a\x20larger\x20\
    commit\x20timestamp.\x20They\x20will\x20block\x20until\n\x20all\x20confl\
    icting\x20transactions\x20that\x20may\x20be\x20assigned\x20commit\x20tim\
    estamps\n\x20<=\x20the\x20read\x20timestamp\x20have\x20finished.\n\n\x20\
    The\x20timestamp\x20can\x20either\x20be\x20expressed\x20as\x20an\x20abso\
    lute\x20Cloud\x20Spanner\x20commit\n\x20timestamp\x20or\x20a\x20stalenes\
    s\x20relative\x20to\x20the\x20current\x20time.\n\n\x20These\x20modes\x20\
    do\x20not\x20require\x20a\x20\"negotiation\x20phase\"\x20to\x20pick\x20a\
    \n\x20timestamp.\x20As\x20a\x20result,\x20they\x20execute\x20slightly\
    \x20faster\x20than\x20the\n\x20equivalent\x20boundedly\x20stale\x20concu\
    rrency\x20modes.\x20On\x20the\x20other\x20hand,\n\x20boundedly\x20stale\
    \x20reads\x20usually\x20return\x20fresher\x20results.\n\n\x20See\x20[Tra\
    nsactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOp\
    tions.ReadOnly.read_timestamp]\x20and\n\x20[TransactionOptions.ReadOnly.\
    exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_sta\
    leness].\n\n\x20###\x20Bounded\x20Staleness\n\n\x20Bounded\x20staleness\
    \x20modes\x20allow\x20Cloud\x20Spanner\x20to\x20pick\x20the\x20read\x20t\
    imestamp,\n\x20subject\x20to\x20a\x20user-provided\x20staleness\x20bound\
    .\x20Cloud\x20Spanner\x20chooses\x20the\n\x20newest\x20timestamp\x20with\
    in\x20the\x20staleness\x20bound\x20that\x20allows\x20execution\n\x20of\
    \x20the\x20reads\x20at\x20the\x20closest\x20available\x20replica\x20with\
    out\x20blocking.\n\n\x20All\x20rows\x20yielded\x20are\x20consistent\x20w\
    ith\x20each\x20other\x20--\x20if\x20any\x20part\x20of\n\x20the\x20read\
    \x20observes\x20a\x20transaction,\x20all\x20parts\x20of\x20the\x20read\
    \x20see\x20the\n\x20transaction.\x20Boundedly\x20stale\x20reads\x20are\
    \x20not\x20repeatable:\x20two\x20stale\n\x20reads,\x20even\x20if\x20they\
    \x20use\x20the\x20same\x20staleness\x20bound,\x20can\x20execute\x20at\n\
    \x20different\x20timestamps\x20and\x20thus\x20return\x20inconsistent\x20\
    results.\n\n\x20Boundedly\x20stale\x20reads\x20execute\x20in\x20two\x20p\
    hases:\x20the\x20first\x20phase\n\x20negotiates\x20a\x20timestamp\x20amo\
    ng\x20all\x20replicas\x20needed\x20to\x20serve\x20the\n\x20read.\x20In\
    \x20the\x20second\x20phase,\x20reads\x20are\x20executed\x20at\x20the\x20\
    negotiated\n\x20timestamp.\n\n\x20As\x20a\x20result\x20of\x20the\x20two\
    \x20phase\x20execution,\x20bounded\x20staleness\x20reads\x20are\n\x20usu\
    ally\x20a\x20little\x20slower\x20than\x20comparable\x20exact\x20stalenes\
    s\n\x20reads.\x20However,\x20they\x20are\x20typically\x20able\x20to\x20r\
    eturn\x20fresher\n\x20results,\x20and\x20are\x20more\x20likely\x20to\x20\
    execute\x20at\x20the\x20closest\x20replica.\n\n\x20Because\x20the\x20tim\
    estamp\x20negotiation\x20requires\x20up-front\x20knowledge\x20of\n\x20wh\
    ich\x20rows\x20will\x20be\x20read,\x20it\x20can\x20only\x20be\x20used\
    \x20with\x20single-use\n\x20read-only\x20transactions.\n\n\x20See\x20[Tr\
    ansactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOp\
    tions.ReadOnly.max_staleness]\x20and\n\x20[TransactionOptions.ReadOnly.m\
    in_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_rea\
    d_timestamp].\n\n\x20###\x20Old\x20Read\x20Timestamps\x20and\x20Garbage\
    \x20Collection\n\n\x20Cloud\x20Spanner\x20continuously\x20garbage\x20col\
    lects\x20deleted\x20and\x20overwritten\x20data\n\x20in\x20the\x20backgro\
    und\x20to\x20reclaim\x20storage\x20space.\x20This\x20process\x20is\x20kn\
    own\n\x20as\x20\"version\x20GC\".\x20By\x20default,\x20version\x20GC\x20\
    reclaims\x20versions\x20after\x20they\n\x20are\x20one\x20hour\x20old.\
    \x20Because\x20of\x20this,\x20Cloud\x20Spanner\x20cannot\x20perform\x20r\
    eads\n\x20at\x20read\x20timestamps\x20more\x20than\x20one\x20hour\x20in\
    \x20the\x20past.\x20This\n\x20restriction\x20also\x20applies\x20to\x20in\
    -progress\x20reads\x20and/or\x20SQL\x20queries\x20whose\n\x20timestamp\
    \x20become\x20too\x20old\x20while\x20executing.\x20Reads\x20and\x20SQL\
    \x20queries\x20with\n\x20too-old\x20read\x20timestamps\x20fail\x20with\
    \x20the\x20error\x20`FAILED_PRECONDITION`.\n\n\x20##\x20Partitioned\x20D\
    ML\x20Transactions\n\n\x20Partitioned\x20DML\x20transactions\x20are\x20u\
    sed\x20to\x20execute\x20DML\x20statements\x20with\x20a\n\x20different\
    \x20execution\x20strategy\x20that\x20provides\x20different,\x20and\x20of\
    ten\x20better,\n\x20scalability\x20properties\x20for\x20large,\x20table-\
    wide\x20operations\x20than\x20DML\x20in\x20a\n\x20ReadWrite\x20transacti\
    on.\x20Smaller\x20scoped\x20statements,\x20such\x20as\x20an\x20OLTP\x20w\
    orkload,\n\x20should\x20prefer\x20using\x20ReadWrite\x20transactions.\n\
    \n\x20Partitioned\x20DML\x20partitions\x20the\x20keyspace\x20and\x20runs\
    \x20the\x20DML\x20statement\x20on\x20each\n\x20partition\x20in\x20separa\
    te,\x20internal\x20transactions.\x20These\x20transactions\x20commit\n\
    \x20automatically\x20when\x20complete,\x20and\x20run\x20independently\
    \x20from\x20one\x20another.\n\n\x20To\x20reduce\x20lock\x20contention,\
    \x20this\x20execution\x20strategy\x20only\x20acquires\x20read\x20locks\n\
    \x20on\x20rows\x20that\x20match\x20the\x20WHERE\x20clause\x20of\x20the\
    \x20statement.\x20Additionally,\x20the\n\x20smaller\x20per-partition\x20\
    transactions\x20hold\x20locks\x20for\x20less\x20time.\n\n\x20That\x20sai\
    d,\x20Partitioned\x20DML\x20is\x20not\x20a\x20drop-in\x20replacement\x20\
    for\x20standard\x20DML\x20used\n\x20in\x20ReadWrite\x20transactions.\n\n\
    \x20\x20-\x20The\x20DML\x20statement\x20must\x20be\x20fully-partitionabl\
    e.\x20Specifically,\x20the\x20statement\n\x20\x20\x20\x20must\x20be\x20e\
    xpressible\x20as\x20the\x20union\x20of\x20many\x20statements\x20which\
    \x20each\x20access\x20only\n\x20\x20\x20\x20a\x20single\x20row\x20of\x20\
    the\x20table.\n\n\x20\x20-\x20The\x20statement\x20is\x20not\x20applied\
    \x20atomically\x20to\x20all\x20rows\x20of\x20the\x20table.\x20Rather,\n\
    \x20\x20\x20\x20the\x20statement\x20is\x20applied\x20atomically\x20to\
    \x20partitions\x20of\x20the\x20table,\x20in\n\x20\x20\x20\x20independent\
    \x20transactions.\x20Secondary\x20index\x20rows\x20are\x20updated\x20ato\
    mically\n\x20\x20\x20\x20with\x20the\x20base\x20table\x20rows.\n\n\x20\
    \x20-\x20Partitioned\x20DML\x20does\x20not\x20guarantee\x20exactly-once\
    \x20execution\x20semantics\n\x20\x20\x20\x20against\x20a\x20partition.\
    \x20The\x20statement\x20will\x20be\x20applied\x20at\x20least\x20once\x20\
    to\x20each\n\x20\x20\x20\x20partition.\x20It\x20is\x20strongly\x20recomm\
    ended\x20that\x20the\x20DML\x20statement\x20should\x20be\n\x20\x20\x20\
    \x20idempotent\x20to\x20avoid\x20unexpected\x20results.\x20For\x20instan\
    ce,\x20it\x20is\x20potentially\n\x20\x20\x20\x20dangerous\x20to\x20run\
    \x20a\x20statement\x20such\x20as\n\x20\x20\x20\x20`UPDATE\x20table\x20SE\
    T\x20column\x20=\x20column\x20+\x201`\x20as\x20it\x20could\x20be\x20run\
    \x20multiple\x20times\n\x20\x20\x20\x20against\x20some\x20rows.\n\n\x20\
    \x20-\x20The\x20partitions\x20are\x20committed\x20automatically\x20-\x20\
    there\x20is\x20no\x20support\x20for\n\x20\x20\x20\x20Commit\x20or\x20Rol\
    lback.\x20If\x20the\x20call\x20returns\x20an\x20error,\x20or\x20if\x20th\
    e\x20client\x20issuing\n\x20\x20\x20\x20the\x20ExecuteSql\x20call\x20die\
    s,\x20it\x20is\x20possible\x20that\x20some\x20rows\x20had\x20the\x20stat\
    ement\n\x20\x20\x20\x20executed\x20on\x20them\x20successfully.\x20It\x20\
    is\x20also\x20possible\x20that\x20statement\x20was\n\x20\x20\x20\x20neve\
    r\x20executed\x20against\x20other\x20rows.\n\n\x20\x20-\x20Partitioned\
    \x20DML\x20transactions\x20may\x20only\x20contain\x20the\x20execution\
    \x20of\x20a\x20single\n\x20\x20\x20\x20DML\x20statement\x20via\x20Execut\
    eSql\x20or\x20ExecuteStreamingSql.\n\n\x20\x20-\x20If\x20any\x20error\
    \x20is\x20encountered\x20during\x20the\x20execution\x20of\x20the\x20part\
    itioned\x20DML\n\x20\x20\x20\x20operation\x20(for\x20instance,\x20a\x20U\
    NIQUE\x20INDEX\x20violation,\x20division\x20by\x20zero,\x20or\x20a\n\x20\
    \x20\x20\x20value\x20that\x20cannot\x20be\x20stored\x20due\x20to\x20sche\
    ma\x20constraints),\x20then\x20the\n\x20\x20\x20\x20operation\x20is\x20s\
    topped\x20at\x20that\x20point\x20and\x20an\x20error\x20is\x20returned.\
    \x20It\x20is\n\x20\x20\x20\x20possible\x20that\x20at\x20this\x20point,\
    \x20some\x20partitions\x20have\x20been\x20committed\x20(or\x20even\n\x20\
    \x20\x20\x20committed\x20multiple\x20times),\x20and\x20other\x20partitio\
    ns\x20have\x20not\x20been\x20run\x20at\x20all.\n\n\x20Given\x20the\x20ab\
    ove,\x20Partitioned\x20DML\x20is\x20good\x20fit\x20for\x20large,\x20data\
    base-wide,\n\x20operations\x20that\x20are\x20idempotent,\x20such\x20as\
    \x20deleting\x20old\x20rows\x20from\x20a\x20very\x20large\n\x20table.\n\
    \n\x0b\n\x03\x04\0\x01\x12\x04\xb3\x02\x08\x1a\nu\n\x04\x04\0\x03\0\x12\
    \x06\xb6\x02\x02\xb8\x02\x03\x1ae\x20Message\x20type\x20to\x20initiate\
    \x20a\x20read-write\x20transaction.\x20Currently\x20this\n\x20transactio\
    n\x20type\x20has\x20no\x20options.\n\n\r\n\x05\x04\0\x03\0\x01\x12\x04\
    \xb6\x02\n\x13\nI\n\x04\x04\0\x03\x01\x12\x06\xbb\x02\x02\xbd\x02\x03\
    \x1a9\x20Message\x20type\x20to\x20initiate\x20a\x20Partitioned\x20DML\
    \x20transaction.\n\n\r\n\x05\x04\0\x03\x01\x01\x12\x04\xbb\x02\n\x18\nC\
    \n\x04\x04\0\x03\x02\x12\x06\xc0\x02\x02\x81\x03\x03\x1a3\x20Message\x20\
    type\x20to\x20initiate\x20a\x20read-only\x20transaction.\n\n\r\n\x05\x04\
    \0\x03\x02\x01\x12\x04\xc0\x02\n\x12\nN\n\x06\x04\0\x03\x02\x08\0\x12\
    \x06\xc2\x02\x04\xfc\x02\x05\x1a<\x20How\x20to\x20choose\x20the\x20times\
    tamp\x20for\x20the\x20read-only\x20transaction.\n\n\x0f\n\x07\x04\0\x03\
    \x02\x08\0\x01\x12\x04\xc2\x02\n\x19\n_\n\x06\x04\0\x03\x02\x02\0\x12\
    \x04\xc5\x02\x06\x16\x1aO\x20Read\x20at\x20a\x20timestamp\x20where\x20al\
    l\x20previously\x20committed\x20transactions\n\x20are\x20visible.\n\n\
    \x0f\n\x07\x04\0\x03\x02\x02\0\x05\x12\x04\xc5\x02\x06\n\n\x0f\n\x07\x04\
    \0\x03\x02\x02\0\x01\x12\x04\xc5\x02\x0b\x11\n\x0f\n\x07\x04\0\x03\x02\
    \x02\0\x03\x12\x04\xc5\x02\x14\x15\n\xc6\x03\n\x06\x04\0\x03\x02\x02\x01\
    \x12\x04\xd1\x02\x067\x1a\xb5\x03\x20Executes\x20all\x20reads\x20at\x20a\
    \x20timestamp\x20>=\x20`min_read_timestamp`.\n\n\x20This\x20is\x20useful\
    \x20for\x20requesting\x20fresher\x20data\x20than\x20some\x20previous\n\
    \x20read,\x20or\x20data\x20that\x20is\x20fresh\x20enough\x20to\x20observ\
    e\x20the\x20effects\x20of\x20some\n\x20previously\x20committed\x20transa\
    ction\x20whose\x20timestamp\x20is\x20known.\n\n\x20Note\x20that\x20this\
    \x20option\x20can\x20only\x20be\x20used\x20in\x20single-use\x20transacti\
    ons.\n\n\x20A\x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20fo\
    rmat,\x20accurate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T1\
    5:01:23.045123456Z\"`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x06\x12\x04\
    \xd1\x02\x06\x1f\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x01\x12\x04\xd1\x02\
    \x202\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x03\x12\x04\xd1\x0256\n\xba\x04\
    \n\x06\x04\0\x03\x02\x02\x02\x12\x04\xe0\x02\x061\x1a\xa9\x04\x20Read\
    \x20data\x20at\x20a\x20timestamp\x20>=\x20`NOW\x20-\x20max_staleness`\n\
    \x20seconds.\x20Guarantees\x20that\x20all\x20writes\x20that\x20have\x20c\
    ommitted\x20more\n\x20than\x20the\x20specified\x20number\x20of\x20second\
    s\x20ago\x20are\x20visible.\x20Because\n\x20Cloud\x20Spanner\x20chooses\
    \x20the\x20exact\x20timestamp,\x20this\x20mode\x20works\x20even\x20if\n\
    \x20the\x20client's\x20local\x20clock\x20is\x20substantially\x20skewed\
    \x20from\x20Cloud\x20Spanner\n\x20commit\x20timestamps.\n\n\x20Useful\
    \x20for\x20reading\x20the\x20freshest\x20data\x20available\x20at\x20a\
    \x20nearby\n\x20replica,\x20while\x20bounding\x20the\x20possible\x20stal\
    eness\x20if\x20the\x20local\n\x20replica\x20has\x20fallen\x20behind.\n\n\
    \x20Note\x20that\x20this\x20option\x20can\x20only\x20be\x20used\x20in\
    \x20single-use\n\x20transactions.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x02\
    \x06\x12\x04\xe0\x02\x06\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x01\x12\
    \x04\xe0\x02\x1f,\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x03\x12\x04\xe0\x02/\
    0\n\xb6\x04\n\x06\x04\0\x03\x02\x02\x03\x12\x04\xee\x02\x063\x1a\xa5\x04\
    \x20Executes\x20all\x20reads\x20at\x20the\x20given\x20timestamp.\x20Unli\
    ke\x20other\x20modes,\n\x20reads\x20at\x20a\x20specific\x20timestamp\x20\
    are\x20repeatable;\x20the\x20same\x20read\x20at\n\x20the\x20same\x20time\
    stamp\x20always\x20returns\x20the\x20same\x20data.\x20If\x20the\n\x20tim\
    estamp\x20is\x20in\x20the\x20future,\x20the\x20read\x20will\x20block\x20\
    until\x20the\n\x20specified\x20timestamp,\x20modulo\x20the\x20read's\x20\
    deadline.\n\n\x20Useful\x20for\x20large\x20scale\x20consistent\x20reads\
    \x20such\x20as\x20mapreduces,\x20or\n\x20for\x20coordinating\x20many\x20\
    reads\x20against\x20a\x20consistent\x20snapshot\x20of\x20the\n\x20data.\
    \n\n\x20A\x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format\
    ,\x20accurate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01\
    :23.045123456Z\"`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x03\x06\x12\x04\xee\
    \x02\x06\x1f\n\x0f\n\x07\x04\0\x03\x02\x02\x03\x01\x12\x04\xee\x02\x20.\
    \n\x0f\n\x07\x04\0\x03\x02\x02\x03\x03\x12\x04\xee\x0212\n\x92\x04\n\x06\
    \x04\0\x03\x02\x02\x04\x12\x04\xfb\x02\x063\x1a\x81\x04\x20Executes\x20a\
    ll\x20reads\x20at\x20a\x20timestamp\x20that\x20is\x20`exact_staleness`\n\
    \x20old.\x20The\x20timestamp\x20is\x20chosen\x20soon\x20after\x20the\x20\
    read\x20is\x20started.\n\n\x20Guarantees\x20that\x20all\x20writes\x20tha\
    t\x20have\x20committed\x20more\x20than\x20the\n\x20specified\x20number\
    \x20of\x20seconds\x20ago\x20are\x20visible.\x20Because\x20Cloud\x20Spann\
    er\n\x20chooses\x20the\x20exact\x20timestamp,\x20this\x20mode\x20works\
    \x20even\x20if\x20the\x20client's\n\x20local\x20clock\x20is\x20substanti\
    ally\x20skewed\x20from\x20Cloud\x20Spanner\x20commit\n\x20timestamps.\n\
    \n\x20Useful\x20for\x20reading\x20at\x20nearby\x20replicas\x20without\
    \x20the\x20distributed\n\x20timestamp\x20negotiation\x20overhead\x20of\
    \x20`max_staleness`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x04\x06\x12\x04\xfb\
    \x02\x06\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x04\x01\x12\x04\xfb\x02\x1f.\
    \n\x0f\n\x07\x04\0\x03\x02\x02\x04\x03\x12\x04\xfb\x0212\n\xae\x01\n\x06\
    \x04\0\x03\x02\x02\x05\x12\x04\x80\x03\x04#\x1a\x9d\x01\x20If\x20true,\
    \x20the\x20Cloud\x20Spanner-selected\x20read\x20timestamp\x20is\x20inclu\
    ded\x20in\n\x20the\x20[Transaction][google.spanner.v1.Transaction]\x20me\
    ssage\x20that\x20describes\x20the\x20transaction.\n\n\x0f\n\x07\x04\0\
    \x03\x02\x02\x05\x05\x12\x04\x80\x03\x04\x08\n\x0f\n\x07\x04\0\x03\x02\
    \x02\x05\x01\x12\x04\x80\x03\t\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x05\x03\
    \x12\x04\x80\x03!\"\n4\n\x04\x04\0\x08\0\x12\x06\x84\x03\x02\x99\x03\x03\
    \x1a$\x20Required.\x20The\x20type\x20of\x20transaction.\n\n\r\n\x05\x04\
    \0\x08\0\x01\x12\x04\x84\x03\x08\x0c\n\xc2\x01\n\x04\x04\0\x02\0\x12\x04\
    \x8a\x03\x04\x1d\x1a\xb3\x01\x20Transaction\x20may\x20write.\n\n\x20Auth\
    orization\x20to\x20begin\x20a\x20read-write\x20transaction\x20requires\n\
    \x20`spanner.databases.beginOrRollbackReadWriteTransaction`\x20permissio\
    n\n\x20on\x20the\x20`session`\x20resource.\n\n\r\n\x05\x04\0\x02\0\x06\
    \x12\x04\x8a\x03\x04\r\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x8a\x03\x0e\x18\
    \n\r\n\x05\x04\0\x02\0\x03\x12\x04\x8a\x03\x1b\x1c\n\xc8\x01\n\x04\x04\0\
    \x02\x01\x12\x04\x91\x03\x04'\x1a\xb9\x01\x20Partitioned\x20DML\x20trans\
    action.\n\n\x20Authorization\x20to\x20begin\x20a\x20Partitioned\x20DML\
    \x20transaction\x20requires\n\x20`spanner.databases.beginPartitionedDmlT\
    ransaction`\x20permission\n\x20on\x20the\x20`session`\x20resource.\n\n\r\
    \n\x05\x04\0\x02\x01\x06\x12\x04\x91\x03\x04\x12\n\r\n\x05\x04\0\x02\x01\
    \x01\x12\x04\x91\x03\x13\"\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x91\x03%&\
    \n\xbb\x01\n\x04\x04\0\x02\x02\x12\x04\x98\x03\x04\x1b\x1a\xac\x01\x20Tr\
    ansaction\x20will\x20not\x20write.\n\n\x20Authorization\x20to\x20begin\
    \x20a\x20read-only\x20transaction\x20requires\n\x20`spanner.databases.be\
    ginReadOnlyTransaction`\x20permission\n\x20on\x20the\x20`session`\x20res\
    ource.\n\n\r\n\x05\x04\0\x02\x02\x06\x12\x04\x98\x03\x04\x0c\n\r\n\x05\
    \x04\0\x02\x02\x01\x12\x04\x98\x03\r\x16\n\r\n\x05\x04\0\x02\x02\x03\x12\
    \x04\x98\x03\x19\x1a\n\x1e\n\x02\x04\x01\x12\x06\x9d\x03\0\xaf\x03\x01\
    \x1a\x10\x20A\x20transaction.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x9d\x03\
    \x08\x13\n\x88\x03\n\x04\x04\x01\x02\0\x12\x04\xa6\x03\x02\x0f\x1a\xf9\
    \x02\x20`id`\x20may\x20be\x20used\x20to\x20identify\x20the\x20transactio\
    n\x20in\x20subsequent\n\x20[Read][google.spanner.v1.Spanner.Read],\n\x20\
    [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],\n\x20[Commit][google\
    .spanner.v1.Spanner.Commit],\x20or\n\x20[Rollback][google.spanner.v1.Spa\
    nner.Rollback]\x20calls.\n\n\x20Single-use\x20read-only\x20transactions\
    \x20do\x20not\x20have\x20IDs,\x20because\n\x20single-use\x20transactions\
    \x20do\x20not\x20support\x20multiple\x20requests.\n\n\r\n\x05\x04\x01\
    \x02\0\x05\x12\x04\xa6\x03\x02\x07\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\
    \xa6\x03\x08\n\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xa6\x03\r\x0e\n\xf2\
    \x02\n\x04\x04\x01\x02\x01\x12\x04\xae\x03\x02/\x1a\xe3\x02\x20For\x20sn\
    apshot\x20read-only\x20transactions,\x20the\x20read\x20timestamp\x20chos\
    en\n\x20for\x20the\x20transaction.\x20Not\x20returned\x20by\x20default:\
    \x20see\n\x20[TransactionOptions.ReadOnly.return_read_timestamp][google.\
    spanner.v1.TransactionOptions.ReadOnly.return_read_timestamp].\n\n\x20A\
    \x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format,\x20accu\
    rate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01:23.04512\
    3456Z\"`.\n\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\xae\x03\x02\x1b\n\r\n\
    \x05\x04\x01\x02\x01\x01\x12\x04\xae\x03\x1c*\n\r\n\x05\x04\x01\x02\x01\
    \x03\x12\x04\xae\x03-.\n\x9e\x02\n\x02\x04\x02\x12\x06\xb6\x03\0\xc7\x03\
    \x01\x1a\x8f\x02\x20This\x20message\x20is\x20used\x20to\x20select\x20the\
    \x20transaction\x20in\x20which\x20a\n\x20[Read][google.spanner.v1.Spanne\
    r.Read]\x20or\n\x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql]\
    \x20call\x20runs.\n\n\x20See\x20[TransactionOptions][google.spanner.v1.T\
    ransactionOptions]\x20for\x20more\x20information\x20about\x20transaction\
    s.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xb6\x03\x08\x1b\ni\n\x04\x04\x02\
    \x08\0\x12\x06\xb9\x03\x02\xc6\x03\x03\x1aY\x20If\x20no\x20fields\x20are\
    \x20set,\x20the\x20default\x20is\x20a\x20single\x20use\x20transaction\n\
    \x20with\x20strong\x20concurrency.\n\n\r\n\x05\x04\x02\x08\0\x01\x12\x04\
    \xb9\x03\x08\x10\n\xa9\x01\n\x04\x04\x02\x02\0\x12\x04\xbd\x03\x04&\x1a\
    \x9a\x01\x20Execute\x20the\x20read\x20or\x20SQL\x20query\x20in\x20a\x20t\
    emporary\x20transaction.\n\x20This\x20is\x20the\x20most\x20efficient\x20\
    way\x20to\x20execute\x20a\x20transaction\x20that\n\x20consists\x20of\x20\
    a\x20single\x20SQL\x20query.\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xbd\
    \x03\x04\x16\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xbd\x03\x17!\n\r\n\x05\
    \x04\x02\x02\0\x03\x12\x04\xbd\x03$%\nR\n\x04\x04\x02\x02\x01\x12\x04\
    \xc0\x03\x04\x11\x1aD\x20Execute\x20the\x20read\x20or\x20SQL\x20query\
    \x20in\x20a\x20previously-started\x20transaction.\n\n\r\n\x05\x04\x02\
    \x02\x01\x05\x12\x04\xc0\x03\x04\t\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\
    \xc0\x03\n\x0c\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xc0\x03\x0f\x10\n\
    \x98\x02\n\x04\x04\x02\x02\x02\x12\x04\xc5\x03\x04!\x1a\x89\x02\x20Begin\
    \x20a\x20new\x20transaction\x20and\x20execute\x20this\x20read\x20or\x20S\
    QL\x20query\x20in\n\x20it.\x20The\x20transaction\x20ID\x20of\x20the\x20n\
    ew\x20transaction\x20is\x20returned\x20in\n\x20[ResultSetMetadata.transa\
    ction][google.spanner.v1.ResultSetMetadata.transaction],\x20which\x20is\
    \x20a\x20[Transaction][google.spanner.v1.Transaction].\n\n\r\n\x05\x04\
    \x02\x02\x02\x06\x12\x04\xc5\x03\x04\x16\n\r\n\x05\x04\x02\x02\x02\x01\
    \x12\x04\xc5\x03\x17\x1c\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xc5\x03\
    \x1f\x20b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(TransactionOptions::generated_message_descriptor_data());
            messages.push(Transaction::generated_message_descriptor_data());
            messages.push(TransactionSelector::generated_message_descriptor_data());
            messages.push(transaction_options::ReadWrite::generated_message_descriptor_data());
            messages.push(transaction_options::PartitionedDml::generated_message_descriptor_data());
            messages.push(transaction_options::ReadOnly::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
