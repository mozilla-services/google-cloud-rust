// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/spanner/admin/database/v1/backup.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Backup {
    // message fields
    pub database: ::std::string::String,
    pub version_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub expire_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub name: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub size_bytes: i64,
    pub state: Backup_State,
    pub referencing_databases: ::protobuf::RepeatedField<::std::string::String>,
    pub encryption_info: ::protobuf::SingularPtrField<super::common::EncryptionInfo>,
    pub database_dialect: super::common::DatabaseDialect,
    pub referencing_backups: ::protobuf::RepeatedField<::std::string::String>,
    pub max_expire_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Backup {
    fn default() -> &'a Backup {
        <Backup as ::protobuf::Message>::default_instance()
    }
}

impl Backup {
    pub fn new() -> Backup {
        ::std::default::Default::default()
    }

    // string database = 2;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp version_time = 9;


    pub fn get_version_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.version_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version_time(&mut self) {
        self.version_time.clear();
    }

    pub fn has_version_time(&self) -> bool {
        self.version_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.version_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.version_time.is_none() {
            self.version_time.set_default();
        }
        self.version_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.version_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp expire_time = 3;


    pub fn get_expire_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expire_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time.clear();
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expire_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expire_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expire_time.is_none() {
            self.expire_time.set_default();
        }
        self.expire_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_expire_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expire_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp create_time = 4;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // int64 size_bytes = 5;


    pub fn get_size_bytes(&self) -> i64 {
        self.size_bytes
    }
    pub fn clear_size_bytes(&mut self) {
        self.size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_bytes(&mut self, v: i64) {
        self.size_bytes = v;
    }

    // .google.spanner.admin.database.v1.Backup.State state = 6;


    pub fn get_state(&self) -> Backup_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Backup_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Backup_State) {
        self.state = v;
    }

    // repeated string referencing_databases = 7;


    pub fn get_referencing_databases(&self) -> &[::std::string::String] {
        &self.referencing_databases
    }
    pub fn clear_referencing_databases(&mut self) {
        self.referencing_databases.clear();
    }

    // Param is passed by value, moved
    pub fn set_referencing_databases(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.referencing_databases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_referencing_databases(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.referencing_databases
    }

    // Take field
    pub fn take_referencing_databases(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.referencing_databases, ::protobuf::RepeatedField::new())
    }

    // .google.spanner.admin.database.v1.EncryptionInfo encryption_info = 8;


    pub fn get_encryption_info(&self) -> &super::common::EncryptionInfo {
        self.encryption_info.as_ref().unwrap_or_else(|| <super::common::EncryptionInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_info(&mut self) {
        self.encryption_info.clear();
    }

    pub fn has_encryption_info(&self) -> bool {
        self.encryption_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_info(&mut self, v: super::common::EncryptionInfo) {
        self.encryption_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_info(&mut self) -> &mut super::common::EncryptionInfo {
        if self.encryption_info.is_none() {
            self.encryption_info.set_default();
        }
        self.encryption_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_info(&mut self) -> super::common::EncryptionInfo {
        self.encryption_info.take().unwrap_or_else(|| super::common::EncryptionInfo::new())
    }

    // .google.spanner.admin.database.v1.DatabaseDialect database_dialect = 10;


    pub fn get_database_dialect(&self) -> super::common::DatabaseDialect {
        self.database_dialect
    }
    pub fn clear_database_dialect(&mut self) {
        self.database_dialect = super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_database_dialect(&mut self, v: super::common::DatabaseDialect) {
        self.database_dialect = v;
    }

    // repeated string referencing_backups = 11;


    pub fn get_referencing_backups(&self) -> &[::std::string::String] {
        &self.referencing_backups
    }
    pub fn clear_referencing_backups(&mut self) {
        self.referencing_backups.clear();
    }

    // Param is passed by value, moved
    pub fn set_referencing_backups(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.referencing_backups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_referencing_backups(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.referencing_backups
    }

    // Take field
    pub fn take_referencing_backups(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.referencing_backups, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp max_expire_time = 12;


    pub fn get_max_expire_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.max_expire_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_expire_time(&mut self) {
        self.max_expire_time.clear();
    }

    pub fn has_max_expire_time(&self) -> bool {
        self.max_expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_expire_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.max_expire_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_expire_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.max_expire_time.is_none() {
            self.max_expire_time.set_default();
        }
        self.max_expire_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_expire_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.max_expire_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Backup {
    fn is_initialized(&self) -> bool {
        for v in &self.version_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expire_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_expire_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expire_time)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size_bytes = tmp;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.referencing_databases)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_info)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.database_dialect, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.referencing_backups)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_expire_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.database);
        }
        if let Some(ref v) = self.version_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(5, self.size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != Backup_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.state);
        }
        for value in &self.referencing_databases {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.encryption_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.database_dialect != super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(10, self.database_dialect);
        }
        for value in &self.referencing_backups {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.max_expire_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(2, &self.database)?;
        }
        if let Some(ref v) = self.version_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size_bytes != 0 {
            os.write_int64(5, self.size_bytes)?;
        }
        if self.state != Backup_State::STATE_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        for v in &self.referencing_databases {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.encryption_info.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.database_dialect != super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.database_dialect))?;
        }
        for v in &self.referencing_backups {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.max_expire_time.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Backup {
        Backup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &Backup| { &m.database },
                |m: &mut Backup| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "version_time",
                |m: &Backup| { &m.version_time },
                |m: &mut Backup| { &mut m.version_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expire_time",
                |m: &Backup| { &m.expire_time },
                |m: &mut Backup| { &mut m.expire_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Backup| { &m.name },
                |m: &mut Backup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &Backup| { &m.create_time },
                |m: &mut Backup| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size_bytes",
                |m: &Backup| { &m.size_bytes },
                |m: &mut Backup| { &mut m.size_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Backup_State>>(
                "state",
                |m: &Backup| { &m.state },
                |m: &mut Backup| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "referencing_databases",
                |m: &Backup| { &m.referencing_databases },
                |m: &mut Backup| { &mut m.referencing_databases },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionInfo>>(
                "encryption_info",
                |m: &Backup| { &m.encryption_info },
                |m: &mut Backup| { &mut m.encryption_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::DatabaseDialect>>(
                "database_dialect",
                |m: &Backup| { &m.database_dialect },
                |m: &mut Backup| { &mut m.database_dialect },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "referencing_backups",
                |m: &Backup| { &m.referencing_backups },
                |m: &mut Backup| { &mut m.referencing_backups },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "max_expire_time",
                |m: &Backup| { &m.max_expire_time },
                |m: &mut Backup| { &mut m.max_expire_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Backup>(
                "Backup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Backup {
        static instance: ::protobuf::rt::LazyV2<Backup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Backup::new)
    }
}

impl ::protobuf::Clear for Backup {
    fn clear(&mut self) {
        self.database.clear();
        self.version_time.clear();
        self.expire_time.clear();
        self.name.clear();
        self.create_time.clear();
        self.size_bytes = 0;
        self.state = Backup_State::STATE_UNSPECIFIED;
        self.referencing_databases.clear();
        self.encryption_info.clear();
        self.database_dialect = super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED;
        self.referencing_backups.clear();
        self.max_expire_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Backup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Backup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Backup_State {
    STATE_UNSPECIFIED = 0,
    CREATING = 1,
    READY = 2,
}

impl ::protobuf::ProtobufEnum for Backup_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Backup_State> {
        match value {
            0 => ::std::option::Option::Some(Backup_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Backup_State::CREATING),
            2 => ::std::option::Option::Some(Backup_State::READY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Backup_State] = &[
            Backup_State::STATE_UNSPECIFIED,
            Backup_State::CREATING,
            Backup_State::READY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Backup_State>("Backup.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Backup_State {
}

impl ::std::default::Default for Backup_State {
    fn default() -> Self {
        Backup_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Backup_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateBackupRequest {
    // message fields
    pub parent: ::std::string::String,
    pub backup_id: ::std::string::String,
    pub backup: ::protobuf::SingularPtrField<Backup>,
    pub encryption_config: ::protobuf::SingularPtrField<CreateBackupEncryptionConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateBackupRequest {
    fn default() -> &'a CreateBackupRequest {
        <CreateBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateBackupRequest {
    pub fn new() -> CreateBackupRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string backup_id = 2;


    pub fn get_backup_id(&self) -> &str {
        &self.backup_id
    }
    pub fn clear_backup_id(&mut self) {
        self.backup_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_backup_id(&mut self, v: ::std::string::String) {
        self.backup_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup_id(&mut self) -> &mut ::std::string::String {
        &mut self.backup_id
    }

    // Take field
    pub fn take_backup_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backup_id, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.Backup backup = 3;


    pub fn get_backup(&self) -> &Backup {
        self.backup.as_ref().unwrap_or_else(|| <Backup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_backup(&mut self) {
        self.backup.clear();
    }

    pub fn has_backup(&self) -> bool {
        self.backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: Backup) {
        self.backup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup(&mut self) -> &mut Backup {
        if self.backup.is_none() {
            self.backup.set_default();
        }
        self.backup.as_mut().unwrap()
    }

    // Take field
    pub fn take_backup(&mut self) -> Backup {
        self.backup.take().unwrap_or_else(|| Backup::new())
    }

    // .google.spanner.admin.database.v1.CreateBackupEncryptionConfig encryption_config = 4;


    pub fn get_encryption_config(&self) -> &CreateBackupEncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <CreateBackupEncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: CreateBackupEncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut CreateBackupEncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> CreateBackupEncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| CreateBackupEncryptionConfig::new())
    }
}

impl ::protobuf::Message for CreateBackupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.backup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backup_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backup)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.backup_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.backup_id);
        }
        if let Some(ref v) = self.backup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.backup_id.is_empty() {
            os.write_string(2, &self.backup_id)?;
        }
        if let Some(ref v) = self.backup.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateBackupRequest {
        CreateBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateBackupRequest| { &m.parent },
                |m: &mut CreateBackupRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backup_id",
                |m: &CreateBackupRequest| { &m.backup_id },
                |m: &mut CreateBackupRequest| { &mut m.backup_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Backup>>(
                "backup",
                |m: &CreateBackupRequest| { &m.backup },
                |m: &mut CreateBackupRequest| { &mut m.backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateBackupEncryptionConfig>>(
                "encryption_config",
                |m: &CreateBackupRequest| { &m.encryption_config },
                |m: &mut CreateBackupRequest| { &mut m.encryption_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateBackupRequest>(
                "CreateBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateBackupRequest {
        static instance: ::protobuf::rt::LazyV2<CreateBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateBackupRequest::new)
    }
}

impl ::protobuf::Clear for CreateBackupRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.backup_id.clear();
        self.backup.clear();
        self.encryption_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateBackupMetadata {
    // message fields
    pub name: ::std::string::String,
    pub database: ::std::string::String,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateBackupMetadata {
    fn default() -> &'a CreateBackupMetadata {
        <CreateBackupMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CreateBackupMetadata {
    pub fn new() -> CreateBackupMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string database = 2;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 3;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }

    // .google.protobuf.Timestamp cancel_time = 4;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for CreateBackupMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.database);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.database.is_empty() {
            os.write_string(2, &self.database)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateBackupMetadata {
        CreateBackupMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateBackupMetadata| { &m.name },
                |m: &mut CreateBackupMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &CreateBackupMetadata| { &m.database },
                |m: &mut CreateBackupMetadata| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &CreateBackupMetadata| { &m.progress },
                |m: &mut CreateBackupMetadata| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "cancel_time",
                |m: &CreateBackupMetadata| { &m.cancel_time },
                |m: &mut CreateBackupMetadata| { &mut m.cancel_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateBackupMetadata>(
                "CreateBackupMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateBackupMetadata {
        static instance: ::protobuf::rt::LazyV2<CreateBackupMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateBackupMetadata::new)
    }
}

impl ::protobuf::Clear for CreateBackupMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.database.clear();
        self.progress.clear();
        self.cancel_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateBackupMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyBackupRequest {
    // message fields
    pub parent: ::std::string::String,
    pub backup_id: ::std::string::String,
    pub source_backup: ::std::string::String,
    pub expire_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub encryption_config: ::protobuf::SingularPtrField<CopyBackupEncryptionConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyBackupRequest {
    fn default() -> &'a CopyBackupRequest {
        <CopyBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl CopyBackupRequest {
    pub fn new() -> CopyBackupRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string backup_id = 2;


    pub fn get_backup_id(&self) -> &str {
        &self.backup_id
    }
    pub fn clear_backup_id(&mut self) {
        self.backup_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_backup_id(&mut self, v: ::std::string::String) {
        self.backup_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup_id(&mut self) -> &mut ::std::string::String {
        &mut self.backup_id
    }

    // Take field
    pub fn take_backup_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backup_id, ::std::string::String::new())
    }

    // string source_backup = 3;


    pub fn get_source_backup(&self) -> &str {
        &self.source_backup
    }
    pub fn clear_source_backup(&mut self) {
        self.source_backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_backup(&mut self, v: ::std::string::String) {
        self.source_backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_backup(&mut self) -> &mut ::std::string::String {
        &mut self.source_backup
    }

    // Take field
    pub fn take_source_backup(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_backup, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp expire_time = 4;


    pub fn get_expire_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expire_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time.clear();
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expire_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expire_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expire_time.is_none() {
            self.expire_time.set_default();
        }
        self.expire_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_expire_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expire_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.spanner.admin.database.v1.CopyBackupEncryptionConfig encryption_config = 5;


    pub fn get_encryption_config(&self) -> &CopyBackupEncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <CopyBackupEncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: CopyBackupEncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut CopyBackupEncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> CopyBackupEncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| CopyBackupEncryptionConfig::new())
    }
}

impl ::protobuf::Message for CopyBackupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.expire_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backup_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_backup)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expire_time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.backup_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.backup_id);
        }
        if !self.source_backup.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_backup);
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.backup_id.is_empty() {
            os.write_string(2, &self.backup_id)?;
        }
        if !self.source_backup.is_empty() {
            os.write_string(3, &self.source_backup)?;
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyBackupRequest {
        CopyBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CopyBackupRequest| { &m.parent },
                |m: &mut CopyBackupRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backup_id",
                |m: &CopyBackupRequest| { &m.backup_id },
                |m: &mut CopyBackupRequest| { &mut m.backup_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_backup",
                |m: &CopyBackupRequest| { &m.source_backup },
                |m: &mut CopyBackupRequest| { &mut m.source_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expire_time",
                |m: &CopyBackupRequest| { &m.expire_time },
                |m: &mut CopyBackupRequest| { &mut m.expire_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CopyBackupEncryptionConfig>>(
                "encryption_config",
                |m: &CopyBackupRequest| { &m.encryption_config },
                |m: &mut CopyBackupRequest| { &mut m.encryption_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyBackupRequest>(
                "CopyBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyBackupRequest {
        static instance: ::protobuf::rt::LazyV2<CopyBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyBackupRequest::new)
    }
}

impl ::protobuf::Clear for CopyBackupRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.backup_id.clear();
        self.source_backup.clear();
        self.expire_time.clear();
        self.encryption_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyBackupMetadata {
    // message fields
    pub name: ::std::string::String,
    pub source_backup: ::std::string::String,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyBackupMetadata {
    fn default() -> &'a CopyBackupMetadata {
        <CopyBackupMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CopyBackupMetadata {
    pub fn new() -> CopyBackupMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string source_backup = 2;


    pub fn get_source_backup(&self) -> &str {
        &self.source_backup
    }
    pub fn clear_source_backup(&mut self) {
        self.source_backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_backup(&mut self, v: ::std::string::String) {
        self.source_backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_backup(&mut self) -> &mut ::std::string::String {
        &mut self.source_backup
    }

    // Take field
    pub fn take_source_backup(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_backup, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 3;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }

    // .google.protobuf.Timestamp cancel_time = 4;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for CopyBackupMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_backup)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.source_backup.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_backup);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.source_backup.is_empty() {
            os.write_string(2, &self.source_backup)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyBackupMetadata {
        CopyBackupMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CopyBackupMetadata| { &m.name },
                |m: &mut CopyBackupMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_backup",
                |m: &CopyBackupMetadata| { &m.source_backup },
                |m: &mut CopyBackupMetadata| { &mut m.source_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &CopyBackupMetadata| { &m.progress },
                |m: &mut CopyBackupMetadata| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "cancel_time",
                |m: &CopyBackupMetadata| { &m.cancel_time },
                |m: &mut CopyBackupMetadata| { &mut m.cancel_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyBackupMetadata>(
                "CopyBackupMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyBackupMetadata {
        static instance: ::protobuf::rt::LazyV2<CopyBackupMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyBackupMetadata::new)
    }
}

impl ::protobuf::Clear for CopyBackupMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.source_backup.clear();
        self.progress.clear();
        self.cancel_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyBackupMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyBackupMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBackupRequest {
    // message fields
    pub backup: ::protobuf::SingularPtrField<Backup>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBackupRequest {
    fn default() -> &'a UpdateBackupRequest {
        <UpdateBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBackupRequest {
    pub fn new() -> UpdateBackupRequest {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.Backup backup = 1;


    pub fn get_backup(&self) -> &Backup {
        self.backup.as_ref().unwrap_or_else(|| <Backup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_backup(&mut self) {
        self.backup.clear();
    }

    pub fn has_backup(&self) -> bool {
        self.backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: Backup) {
        self.backup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup(&mut self) -> &mut Backup {
        if self.backup.is_none() {
            self.backup.set_default();
        }
        self.backup.as_mut().unwrap()
    }

    // Take field
    pub fn take_backup(&mut self) -> Backup {
        self.backup.take().unwrap_or_else(|| Backup::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateBackupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.backup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backup)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backup.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBackupRequest {
        UpdateBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Backup>>(
                "backup",
                |m: &UpdateBackupRequest| { &m.backup },
                |m: &mut UpdateBackupRequest| { &mut m.backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateBackupRequest| { &m.update_mask },
                |m: &mut UpdateBackupRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateBackupRequest>(
                "UpdateBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateBackupRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateBackupRequest::new)
    }
}

impl ::protobuf::Clear for UpdateBackupRequest {
    fn clear(&mut self) {
        self.backup.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBackupRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBackupRequest {
    fn default() -> &'a GetBackupRequest {
        <GetBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBackupRequest {
    pub fn new() -> GetBackupRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetBackupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBackupRequest {
        GetBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetBackupRequest| { &m.name },
                |m: &mut GetBackupRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBackupRequest>(
                "GetBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBackupRequest {
        static instance: ::protobuf::rt::LazyV2<GetBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBackupRequest::new)
    }
}

impl ::protobuf::Clear for GetBackupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteBackupRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteBackupRequest {
    fn default() -> &'a DeleteBackupRequest {
        <DeleteBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBackupRequest {
    pub fn new() -> DeleteBackupRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteBackupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteBackupRequest {
        DeleteBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteBackupRequest| { &m.name },
                |m: &mut DeleteBackupRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteBackupRequest>(
                "DeleteBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteBackupRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteBackupRequest::new)
    }
}

impl ::protobuf::Clear for DeleteBackupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupsRequest {
    fn default() -> &'a ListBackupsRequest {
        <ListBackupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupsRequest {
    pub fn new() -> ListBackupsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupsRequest {
        ListBackupsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListBackupsRequest| { &m.parent },
                |m: &mut ListBackupsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListBackupsRequest| { &m.filter },
                |m: &mut ListBackupsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListBackupsRequest| { &m.page_size },
                |m: &mut ListBackupsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListBackupsRequest| { &m.page_token },
                |m: &mut ListBackupsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupsRequest>(
                "ListBackupsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupsRequest {
        static instance: ::protobuf::rt::LazyV2<ListBackupsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupsRequest::new)
    }
}

impl ::protobuf::Clear for ListBackupsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupsResponse {
    // message fields
    pub backups: ::protobuf::RepeatedField<Backup>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupsResponse {
    fn default() -> &'a ListBackupsResponse {
        <ListBackupsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupsResponse {
    pub fn new() -> ListBackupsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.spanner.admin.database.v1.Backup backups = 1;


    pub fn get_backups(&self) -> &[Backup] {
        &self.backups
    }
    pub fn clear_backups(&mut self) {
        self.backups.clear();
    }

    // Param is passed by value, moved
    pub fn set_backups(&mut self, v: ::protobuf::RepeatedField<Backup>) {
        self.backups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_backups(&mut self) -> &mut ::protobuf::RepeatedField<Backup> {
        &mut self.backups
    }

    // Take field
    pub fn take_backups(&mut self) -> ::protobuf::RepeatedField<Backup> {
        ::std::mem::replace(&mut self.backups, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.backups)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.backups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.backups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupsResponse {
        ListBackupsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Backup>>(
                "backups",
                |m: &ListBackupsResponse| { &m.backups },
                |m: &mut ListBackupsResponse| { &mut m.backups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListBackupsResponse| { &m.next_page_token },
                |m: &mut ListBackupsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupsResponse>(
                "ListBackupsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupsResponse {
        static instance: ::protobuf::rt::LazyV2<ListBackupsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupsResponse::new)
    }
}

impl ::protobuf::Clear for ListBackupsResponse {
    fn clear(&mut self) {
        self.backups.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupOperationsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupOperationsRequest {
    fn default() -> &'a ListBackupOperationsRequest {
        <ListBackupOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupOperationsRequest {
    pub fn new() -> ListBackupOperationsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupOperationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupOperationsRequest {
        ListBackupOperationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListBackupOperationsRequest| { &m.parent },
                |m: &mut ListBackupOperationsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListBackupOperationsRequest| { &m.filter },
                |m: &mut ListBackupOperationsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListBackupOperationsRequest| { &m.page_size },
                |m: &mut ListBackupOperationsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListBackupOperationsRequest| { &m.page_token },
                |m: &mut ListBackupOperationsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupOperationsRequest>(
                "ListBackupOperationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupOperationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListBackupOperationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupOperationsRequest::new)
    }
}

impl ::protobuf::Clear for ListBackupOperationsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupOperationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupOperationsResponse {
    // message fields
    pub operations: ::protobuf::RepeatedField<super::operations::Operation>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupOperationsResponse {
    fn default() -> &'a ListBackupOperationsResponse {
        <ListBackupOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupOperationsResponse {
    pub fn new() -> ListBackupOperationsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.longrunning.Operation operations = 1;


    pub fn get_operations(&self) -> &[super::operations::Operation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<super::operations::Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<super::operations::Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<super::operations::Operation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupOperationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.operations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupOperationsResponse {
        ListBackupOperationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::operations::Operation>>(
                "operations",
                |m: &ListBackupOperationsResponse| { &m.operations },
                |m: &mut ListBackupOperationsResponse| { &mut m.operations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListBackupOperationsResponse| { &m.next_page_token },
                |m: &mut ListBackupOperationsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupOperationsResponse>(
                "ListBackupOperationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupOperationsResponse {
        static instance: ::protobuf::rt::LazyV2<ListBackupOperationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupOperationsResponse::new)
    }
}

impl ::protobuf::Clear for ListBackupOperationsResponse {
    fn clear(&mut self) {
        self.operations.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupOperationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BackupInfo {
    // message fields
    pub backup: ::std::string::String,
    pub version_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub source_database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackupInfo {
    fn default() -> &'a BackupInfo {
        <BackupInfo as ::protobuf::Message>::default_instance()
    }
}

impl BackupInfo {
    pub fn new() -> BackupInfo {
        ::std::default::Default::default()
    }

    // string backup = 1;


    pub fn get_backup(&self) -> &str {
        &self.backup
    }
    pub fn clear_backup(&mut self) {
        self.backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: ::std::string::String) {
        self.backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup(&mut self) -> &mut ::std::string::String {
        &mut self.backup
    }

    // Take field
    pub fn take_backup(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backup, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp version_time = 4;


    pub fn get_version_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.version_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version_time(&mut self) {
        self.version_time.clear();
    }

    pub fn has_version_time(&self) -> bool {
        self.version_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.version_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.version_time.is_none() {
            self.version_time.set_default();
        }
        self.version_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.version_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp create_time = 2;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string source_database = 3;


    pub fn get_source_database(&self) -> &str {
        &self.source_database
    }
    pub fn clear_source_database(&mut self) {
        self.source_database.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_database(&mut self, v: ::std::string::String) {
        self.source_database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_database(&mut self) -> &mut ::std::string::String {
        &mut self.source_database
    }

    // Take field
    pub fn take_source_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BackupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.version_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backup)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.backup.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.backup);
        }
        if let Some(ref v) = self.version_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.source_database.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.backup.is_empty() {
            os.write_string(1, &self.backup)?;
        }
        if let Some(ref v) = self.version_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.source_database.is_empty() {
            os.write_string(3, &self.source_database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupInfo {
        BackupInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backup",
                |m: &BackupInfo| { &m.backup },
                |m: &mut BackupInfo| { &mut m.backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "version_time",
                |m: &BackupInfo| { &m.version_time },
                |m: &mut BackupInfo| { &mut m.version_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &BackupInfo| { &m.create_time },
                |m: &mut BackupInfo| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_database",
                |m: &BackupInfo| { &m.source_database },
                |m: &mut BackupInfo| { &mut m.source_database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackupInfo>(
                "BackupInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackupInfo {
        static instance: ::protobuf::rt::LazyV2<BackupInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackupInfo::new)
    }
}

impl ::protobuf::Clear for BackupInfo {
    fn clear(&mut self) {
        self.backup.clear();
        self.version_time.clear();
        self.create_time.clear();
        self.source_database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateBackupEncryptionConfig {
    // message fields
    pub encryption_type: CreateBackupEncryptionConfig_EncryptionType,
    pub kms_key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateBackupEncryptionConfig {
    fn default() -> &'a CreateBackupEncryptionConfig {
        <CreateBackupEncryptionConfig as ::protobuf::Message>::default_instance()
    }
}

impl CreateBackupEncryptionConfig {
    pub fn new() -> CreateBackupEncryptionConfig {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.CreateBackupEncryptionConfig.EncryptionType encryption_type = 1;


    pub fn get_encryption_type(&self) -> CreateBackupEncryptionConfig_EncryptionType {
        self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type = CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: CreateBackupEncryptionConfig_EncryptionType) {
        self.encryption_type = v;
    }

    // string kms_key_name = 2;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateBackupEncryptionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.encryption_type != CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.encryption_type);
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.encryption_type != CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.encryption_type))?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(2, &self.kms_key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateBackupEncryptionConfig {
        CreateBackupEncryptionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CreateBackupEncryptionConfig_EncryptionType>>(
                "encryption_type",
                |m: &CreateBackupEncryptionConfig| { &m.encryption_type },
                |m: &mut CreateBackupEncryptionConfig| { &mut m.encryption_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &CreateBackupEncryptionConfig| { &m.kms_key_name },
                |m: &mut CreateBackupEncryptionConfig| { &mut m.kms_key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateBackupEncryptionConfig>(
                "CreateBackupEncryptionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateBackupEncryptionConfig {
        static instance: ::protobuf::rt::LazyV2<CreateBackupEncryptionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateBackupEncryptionConfig::new)
    }
}

impl ::protobuf::Clear for CreateBackupEncryptionConfig {
    fn clear(&mut self) {
        self.encryption_type = CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
        self.kms_key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateBackupEncryptionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupEncryptionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateBackupEncryptionConfig_EncryptionType {
    ENCRYPTION_TYPE_UNSPECIFIED = 0,
    USE_DATABASE_ENCRYPTION = 1,
    GOOGLE_DEFAULT_ENCRYPTION = 2,
    CUSTOMER_MANAGED_ENCRYPTION = 3,
}

impl ::protobuf::ProtobufEnum for CreateBackupEncryptionConfig_EncryptionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateBackupEncryptionConfig_EncryptionType> {
        match value {
            0 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::USE_DATABASE_ENCRYPTION),
            2 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION),
            3 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateBackupEncryptionConfig_EncryptionType] = &[
            CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED,
            CreateBackupEncryptionConfig_EncryptionType::USE_DATABASE_ENCRYPTION,
            CreateBackupEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION,
            CreateBackupEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CreateBackupEncryptionConfig_EncryptionType>("CreateBackupEncryptionConfig.EncryptionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CreateBackupEncryptionConfig_EncryptionType {
}

impl ::std::default::Default for CreateBackupEncryptionConfig_EncryptionType {
    fn default() -> Self {
        CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupEncryptionConfig_EncryptionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyBackupEncryptionConfig {
    // message fields
    pub encryption_type: CopyBackupEncryptionConfig_EncryptionType,
    pub kms_key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyBackupEncryptionConfig {
    fn default() -> &'a CopyBackupEncryptionConfig {
        <CopyBackupEncryptionConfig as ::protobuf::Message>::default_instance()
    }
}

impl CopyBackupEncryptionConfig {
    pub fn new() -> CopyBackupEncryptionConfig {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.CopyBackupEncryptionConfig.EncryptionType encryption_type = 1;


    pub fn get_encryption_type(&self) -> CopyBackupEncryptionConfig_EncryptionType {
        self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type = CopyBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: CopyBackupEncryptionConfig_EncryptionType) {
        self.encryption_type = v;
    }

    // string kms_key_name = 2;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CopyBackupEncryptionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.encryption_type != CopyBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.encryption_type);
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.encryption_type != CopyBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.encryption_type))?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(2, &self.kms_key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyBackupEncryptionConfig {
        CopyBackupEncryptionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CopyBackupEncryptionConfig_EncryptionType>>(
                "encryption_type",
                |m: &CopyBackupEncryptionConfig| { &m.encryption_type },
                |m: &mut CopyBackupEncryptionConfig| { &mut m.encryption_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &CopyBackupEncryptionConfig| { &m.kms_key_name },
                |m: &mut CopyBackupEncryptionConfig| { &mut m.kms_key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyBackupEncryptionConfig>(
                "CopyBackupEncryptionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyBackupEncryptionConfig {
        static instance: ::protobuf::rt::LazyV2<CopyBackupEncryptionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyBackupEncryptionConfig::new)
    }
}

impl ::protobuf::Clear for CopyBackupEncryptionConfig {
    fn clear(&mut self) {
        self.encryption_type = CopyBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
        self.kms_key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyBackupEncryptionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyBackupEncryptionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CopyBackupEncryptionConfig_EncryptionType {
    ENCRYPTION_TYPE_UNSPECIFIED = 0,
    USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION = 1,
    GOOGLE_DEFAULT_ENCRYPTION = 2,
    CUSTOMER_MANAGED_ENCRYPTION = 3,
}

impl ::protobuf::ProtobufEnum for CopyBackupEncryptionConfig_EncryptionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CopyBackupEncryptionConfig_EncryptionType> {
        match value {
            0 => ::std::option::Option::Some(CopyBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(CopyBackupEncryptionConfig_EncryptionType::USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION),
            2 => ::std::option::Option::Some(CopyBackupEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION),
            3 => ::std::option::Option::Some(CopyBackupEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CopyBackupEncryptionConfig_EncryptionType] = &[
            CopyBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED,
            CopyBackupEncryptionConfig_EncryptionType::USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION,
            CopyBackupEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION,
            CopyBackupEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CopyBackupEncryptionConfig_EncryptionType>("CopyBackupEncryptionConfig.EncryptionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CopyBackupEncryptionConfig_EncryptionType {
}

impl ::std::default::Default for CopyBackupEncryptionConfig_EncryptionType {
    fn default() -> Self {
        CopyBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyBackupEncryptionConfig_EncryptionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-google/spanner/admin/database/v1/backup.proto\x12\x20google.spanner.a\
    dmin.database.v1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/ap\
    i/resource.proto\x1a#google/longrunning/operations.proto\x1a\x20google/p\
    rotobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a-goog\
    le/spanner/admin/database/v1/common.proto\"\xe4\x07\n\x06Backup\x12@\n\
    \x08database\x18\x02\x20\x01(\tR\x08databaseB$\xfaA!\n\x1fspanner.google\
    apis.com/Database\x12=\n\x0cversion_time\x18\t\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\x0bversionTime\x12;\n\x0bexpire_time\x18\x03\x20\x01\
    (\x0b2\x1a.google.protobuf.TimestampR\nexpireTime\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12@\n\x0bcreate_time\x18\x04\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\ncreateTimeB\x03\xe0A\x03\x12\"\n\nsize_byte\
    s\x18\x05\x20\x01(\x03R\tsizeBytesB\x03\xe0A\x03\x12I\n\x05state\x18\x06\
    \x20\x01(\x0e2..google.spanner.admin.database.v1.Backup.StateR\x05stateB\
    \x03\xe0A\x03\x12\\\n\x15referencing_databases\x18\x07\x20\x03(\tR\x14re\
    ferencingDatabasesB'\xfaA!\n\x1fspanner.googleapis.com/Database\xe0A\x03\
    \x12^\n\x0fencryption_info\x18\x08\x20\x01(\x0b20.google.spanner.admin.d\
    atabase.v1.EncryptionInfoR\x0eencryptionInfoB\x03\xe0A\x03\x12a\n\x10dat\
    abase_dialect\x18\n\x20\x01(\x0e21.google.spanner.admin.database.v1.Data\
    baseDialectR\x0fdatabaseDialectB\x03\xe0A\x03\x12V\n\x13referencing_back\
    ups\x18\x0b\x20\x03(\tR\x12referencingBackupsB%\xfaA\x1f\n\x1dspanner.go\
    ogleapis.com/Backup\xe0A\x03\x12G\n\x0fmax_expire_time\x18\x0c\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\rmaxExpireTimeB\x03\xe0A\x03\"7\n\
    \x05State\x12\x15\n\x11STATE_UNSPECIFIED\x10\0\x12\x0c\n\x08CREATING\x10\
    \x01\x12\t\n\x05READY\x10\x02:\\\xeaAY\n\x1dspanner.googleapis.com/Backu\
    p\x128projects/{project}/instances/{instance}/backups/{backup}\"\xb1\x02\
    \n\x13CreateBackupRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parent\
    B'\xfaA!\n\x1fspanner.googleapis.com/Instance\xe0A\x02\x12\x20\n\tbackup\
    _id\x18\x02\x20\x01(\tR\x08backupIdB\x03\xe0A\x02\x12E\n\x06backup\x18\
    \x03\x20\x01(\x0b2(.google.spanner.admin.database.v1.BackupR\x06backupB\
    \x03\xe0A\x02\x12p\n\x11encryption_config\x18\x04\x20\x01(\x0b2>.google.\
    spanner.admin.database.v1.CreateBackupEncryptionConfigR\x10encryptionCon\
    figB\x03\xe0A\x01\"\x9e\x02\n\x14CreateBackupMetadata\x126\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB\"\xfaA\x1f\n\x1dspanner.googleapis.com/Backup\
    \x12@\n\x08database\x18\x02\x20\x01(\tR\x08databaseB$\xfaA!\n\x1fspanner\
    .googleapis.com/Database\x12O\n\x08progress\x18\x03\x20\x01(\x0b23.googl\
    e.spanner.admin.database.v1.OperationProgressR\x08progress\x12;\n\x0bcan\
    cel_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncancelTim\
    e\"\xf4\x02\n\x11CopyBackupRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\
    \x06parentB'\xfaA!\n\x1fspanner.googleapis.com/Instance\xe0A\x02\x12\x20\
    \n\tbackup_id\x18\x02\x20\x01(\tR\x08backupIdB\x03\xe0A\x02\x12J\n\rsour\
    ce_backup\x18\x03\x20\x01(\tR\x0csourceBackupB%\xfaA\x1f\n\x1dspanner.go\
    ogleapis.com/Backup\xe0A\x02\x12@\n\x0bexpire_time\x18\x04\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\nexpireTimeB\x03\xe0A\x02\x12n\n\x11encr\
    yption_config\x18\x05\x20\x01(\x0b2<.google.spanner.admin.database.v1.Co\
    pyBackupEncryptionConfigR\x10encryptionConfigB\x03\xe0A\x01\"\xa3\x02\n\
    \x12CopyBackupMetadata\x126\n\x04name\x18\x01\x20\x01(\tR\x04nameB\"\xfa\
    A\x1f\n\x1dspanner.googleapis.com/Backup\x12G\n\rsource_backup\x18\x02\
    \x20\x01(\tR\x0csourceBackupB\"\xfaA\x1f\n\x1dspanner.googleapis.com/Bac\
    kup\x12O\n\x08progress\x18\x03\x20\x01(\x0b23.google.spanner.admin.datab\
    ase.v1.OperationProgressR\x08progress\x12;\n\x0bcancel_time\x18\x04\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\ncancelTime\"\x9e\x01\n\x13Upd\
    ateBackupRequest\x12E\n\x06backup\x18\x01\x20\x01(\x0b2(.google.spanner.\
    admin.database.v1.BackupR\x06backupB\x03\xe0A\x02\x12@\n\x0bupdate_mask\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMaskB\x03\
    \xe0A\x02\"M\n\x10GetBackupRequest\x129\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB%\xfaA\x1f\n\x1dspanner.googleapis.com/Backup\xe0A\x02\"P\n\x13\
    DeleteBackupRequest\x129\n\x04name\x18\x01\x20\x01(\tR\x04nameB%\xfaA\
    \x1f\n\x1dspanner.googleapis.com/Backup\xe0A\x02\"\xa9\x01\n\x12ListBack\
    upsRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\n\x1fs\
    panner.googleapis.com/Instance\xe0A\x02\x12\x16\n\x06filter\x18\x02\x20\
    \x01(\tR\x06filter\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSiz\
    e\x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\x81\x01\n\x13Li\
    stBackupsResponse\x12B\n\x07backups\x18\x01\x20\x03(\x0b2(.google.spanne\
    r.admin.database.v1.BackupR\x07backups\x12&\n\x0fnext_page_token\x18\x02\
    \x20\x01(\tR\rnextPageToken\"\xb2\x01\n\x1bListBackupOperationsRequest\
    \x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\n\x1fspanner.goo\
    gleapis.com/Instance\xe0A\x02\x12\x16\n\x06filter\x18\x02\x20\x01(\tR\
    \x06filter\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\x85\x01\n\x1cListBac\
    kupOperationsResponse\x12=\n\noperations\x18\x01\x20\x03(\x0b2\x1d.googl\
    e.longrunning.OperationR\noperations\x12&\n\x0fnext_page_token\x18\x02\
    \x20\x01(\tR\rnextPageToken\"\x93\x02\n\nBackupInfo\x12:\n\x06backup\x18\
    \x01\x20\x01(\tR\x06backupB\"\xfaA\x1f\n\x1dspanner.googleapis.com/Backu\
    p\x12=\n\x0cversion_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.Times\
    tampR\x0bversionTime\x12;\n\x0bcreate_time\x18\x02\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\ncreateTime\x12M\n\x0fsource_database\x18\x03\
    \x20\x01(\tR\x0esourceDatabaseB$\xfaA!\n\x1fspanner.googleapis.com/Datab\
    ase\"\xf9\x02\n\x1cCreateBackupEncryptionConfig\x12{\n\x0fencryption_typ\
    e\x18\x01\x20\x01(\x0e2M.google.spanner.admin.database.v1.CreateBackupEn\
    cryptionConfig.EncryptionTypeR\x0eencryptionTypeB\x03\xe0A\x02\x12K\n\
    \x0ckms_key_name\x18\x02\x20\x01(\tR\nkmsKeyNameB)\xfaA#\n!cloudkms.goog\
    leapis.com/CryptoKey\xe0A\x01\"\x8e\x01\n\x0eEncryptionType\x12\x1f\n\
    \x1bENCRYPTION_TYPE_UNSPECIFIED\x10\0\x12\x1b\n\x17USE_DATABASE_ENCRYPTI\
    ON\x10\x01\x12\x1d\n\x19GOOGLE_DEFAULT_ENCRYPTION\x10\x02\x12\x1f\n\x1bC\
    USTOMER_MANAGED_ENCRYPTION\x10\x03\"\x85\x03\n\x1aCopyBackupEncryptionCo\
    nfig\x12y\n\x0fencryption_type\x18\x01\x20\x01(\x0e2K.google.spanner.adm\
    in.database.v1.CopyBackupEncryptionConfig.EncryptionTypeR\x0eencryptionT\
    ypeB\x03\xe0A\x02\x12K\n\x0ckms_key_name\x18\x02\x20\x01(\tR\nkmsKeyName\
    B)\xfaA#\n!cloudkms.googleapis.com/CryptoKey\xe0A\x01\"\x9e\x01\n\x0eEnc\
    ryptionType\x12\x1f\n\x1bENCRYPTION_TYPE_UNSPECIFIED\x10\0\x12+\n'USE_CO\
    NFIG_DEFAULT_OR_BACKUP_ENCRYPTION\x10\x01\x12\x1d\n\x19GOOGLE_DEFAULT_EN\
    CRYPTION\x10\x02\x12\x1f\n\x1bCUSTOMER_MANAGED_ENCRYPTION\x10\x03B\xfd\
    \x01\n$com.google.spanner.admin.database.v1B\x0bBackupProtoP\x01ZFcloud.\
    google.com/go/spanner/admin/database/apiv1/databasepb;databasepb\xaa\x02\
    &Google.Cloud.Spanner.Admin.Database.V1\xca\x02&Google\\Cloud\\Spanner\\\
    Admin\\Database\\V1\xea\x02+Google::Cloud::Spanner::Admin::Database::V1J\
    \xdb\xce\x01\n\x07\x12\x05\x0e\0\xe0\x04\x01\n\xbc\x04\n\x01\x0c\x12\x03\
    \x0e\0\x122\xb1\x04\x20Copyright\x202022\x20Google\x20LLC\n\n\x20License\
    d\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"L\
    icense\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\
    \x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\
    \x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www\
    .apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20appl\
    icable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20d\
    istributed\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\
    \x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITION\
    S\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\
    \x20the\x20License\x20for\x20the\x20specific\x20language\x20governing\
    \x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\
    \x08\n\x01\x02\x12\x03\x10\0)\n\t\n\x02\x03\0\x12\x03\x12\0)\n\t\n\x02\
    \x03\x01\x12\x03\x13\0#\n\t\n\x02\x03\x02\x12\x03\x14\0-\n\t\n\x02\x03\
    \x03\x12\x03\x15\0*\n\t\n\x02\x03\x04\x12\x03\x16\0)\n\t\n\x02\x03\x05\
    \x12\x03\x17\07\n\x08\n\x01\x08\x12\x03\x19\0C\n\t\n\x02\x08%\x12\x03\
    \x19\0C\n\x08\n\x01\x08\x12\x03\x1a\0]\n\t\n\x02\x08\x0b\x12\x03\x1a\0]\
    \n\x08\n\x01\x08\x12\x03\x1b\0\"\n\t\n\x02\x08\n\x12\x03\x1b\0\"\n\x08\n\
    \x01\x08\x12\x03\x1c\0,\n\t\n\x02\x08\x08\x12\x03\x1c\0,\n\x08\n\x01\x08\
    \x12\x03\x1d\0=\n\t\n\x02\x08\x01\x12\x03\x1d\0=\n\x08\n\x01\x08\x12\x03\
    \x1e\0E\n\t\n\x02\x08)\x12\x03\x1e\0E\n\x08\n\x01\x08\x12\x03\x1f\0D\n\t\
    \n\x02\x08-\x12\x03\x1f\0D\n4\n\x02\x04\0\x12\x05\"\0\x8e\x01\x01\x1a'\
    \x20A\x20backup\x20of\x20a\x20Cloud\x20Spanner\x20database.\n\n\n\n\x03\
    \x04\0\x01\x12\x03\"\x08\x0e\n\x0b\n\x03\x04\0\x07\x12\x04#\x02&\x04\n\r\
    \n\x05\x04\0\x07\x9d\x08\x12\x04#\x02&\x04\n:\n\x04\x04\0\x04\0\x12\x04)\
    \x023\x03\x1a,\x20Indicates\x20the\x20current\x20state\x20of\x20the\x20b\
    ackup.\n\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03)\x07\x0c\n\x1f\n\x06\x04\0\
    \x04\0\x02\0\x12\x03+\x04\x1a\x1a\x10\x20Not\x20specified.\n\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x01\x12\x03+\x04\x15\n\x0e\n\x07\x04\0\x04\0\x02\0\
    \x02\x12\x03+\x18\x19\n\x88\x01\n\x06\x04\0\x04\0\x02\x01\x12\x03/\x04\
    \x11\x1ay\x20The\x20pending\x20backup\x20is\x20still\x20being\x20created\
    .\x20Operations\x20on\x20the\n\x20backup\x20may\x20fail\x20with\x20`FAIL\
    ED_PRECONDITION`\x20in\x20this\x20state.\n\n\x0e\n\x07\x04\0\x04\0\x02\
    \x01\x01\x12\x03/\x04\x0c\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x03/\
    \x0f\x10\n:\n\x06\x04\0\x04\0\x02\x02\x12\x032\x04\x0e\x1a+\x20The\x20ba\
    ckup\x20is\x20complete\x20and\x20ready\x20for\x20use.\n\n\x0e\n\x07\x04\
    \0\x04\0\x02\x02\x01\x12\x032\x04\t\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\
    \x12\x032\x0c\r\n\xc1\x02\n\x04\x04\0\x02\0\x12\x04:\x02<\x1a\x1a\xb2\
    \x02\x20Required\x20for\x20the\x20[CreateBackup][google.spanner.admin.da\
    tabase.v1.DatabaseAdmin.CreateBackup]\x20operation.\n\x20Name\x20of\x20t\
    he\x20database\x20from\x20which\x20this\x20backup\x20was\n\x20created.\
    \x20This\x20needs\x20to\x20be\x20in\x20the\x20same\x20instance\x20as\x20\
    the\x20backup.\n\x20Values\x20are\x20of\x20the\x20form\n\x20`projects/<p\
    roject>/instances/<instance>/databases/<database>`.\n\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03:\t\x11\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03:\x14\x15\n\r\n\x05\x04\0\x02\0\x08\
    \x12\x04:\x16<\x19\n\x0f\n\x07\x04\0\x02\0\x08\x9f\x08\x12\x04:\x17<\x18\
    \n\xf1\x01\n\x04\x04\0\x02\x01\x12\x03B\x02-\x1a\xe3\x01\x20The\x20backu\
    p\x20will\x20contain\x20an\x20externally\x20consistent\x20copy\x20of\x20\
    the\x20database\x20at\n\x20the\x20timestamp\x20specified\x20by\x20`versi\
    on_time`.\x20If\x20`version_time`\x20is\x20not\n\x20specified,\x20the\
    \x20system\x20will\x20set\x20`version_time`\x20to\x20the\x20`create_time\
    `\x20of\x20the\n\x20backup.\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03B\x02\
    \x1b\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03B\x1c(\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x03B+,\n\xb6\x03\n\x04\x04\0\x02\x02\x12\x03J\x02,\x1a\xa8\
    \x03\x20Required\x20for\x20the\x20[CreateBackup][google.spanner.admin.da\
    tabase.v1.DatabaseAdmin.CreateBackup]\n\x20operation.\x20The\x20expirati\
    on\x20time\x20of\x20the\x20backup,\x20with\x20microseconds\n\x20granular\
    ity\x20that\x20must\x20be\x20at\x20least\x206\x20hours\x20and\x20at\x20m\
    ost\x20366\x20days\n\x20from\x20the\x20time\x20the\x20CreateBackup\x20re\
    quest\x20is\x20processed.\x20Once\x20the\x20`expire_time`\n\x20has\x20pa\
    ssed,\x20the\x20backup\x20is\x20eligible\x20to\x20be\x20automatically\
    \x20deleted\x20by\x20Cloud\n\x20Spanner\x20to\x20free\x20the\x20resource\
    s\x20used\x20by\x20the\x20backup.\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\
    \x03J\x02\x1b\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03J\x1c'\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03J*+\n\xbd\x05\n\x04\x04\0\x02\x03\x12\x03Y\x02\
    \x12\x1a\xaf\x05\x20Output\x20only\x20for\x20the\x20[CreateBackup][googl\
    e.spanner.admin.database.v1.DatabaseAdmin.CreateBackup]\x20operation.\n\
    \x20Required\x20for\x20the\x20[UpdateBackup][google.spanner.admin.databa\
    se.v1.DatabaseAdmin.UpdateBackup]\x20operation.\n\n\x20A\x20globally\x20\
    unique\x20identifier\x20for\x20the\x20backup\x20which\x20cannot\x20be\n\
    \x20changed.\x20Values\x20are\x20of\x20the\x20form\n\x20`projects/<proje\
    ct>/instances/<instance>/backups/[a-z][a-z0-9_\\-]*[a-z0-9]`\n\x20The\
    \x20final\x20segment\x20of\x20the\x20name\x20must\x20be\x20between\x202\
    \x20and\x2060\x20characters\n\x20in\x20length.\n\n\x20The\x20backup\x20i\
    s\x20stored\x20in\x20the\x20location(s)\x20specified\x20in\x20the\x20ins\
    tance\n\x20configuration\x20of\x20the\x20instance\x20containing\x20the\
    \x20backup,\x20identified\n\x20by\x20the\x20prefix\x20of\x20the\x20backu\
    p\x20name\x20of\x20the\x20form\n\x20`projects/<project>/instances/<insta\
    nce>`.\n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x03\x01\x12\x03Y\t\r\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03Y\x10\
    \x11\n\x86\x02\n\x04\x04\0\x02\x04\x12\x03^\x02X\x1a\xf8\x01\x20Output\
    \x20only.\x20The\x20time\x20the\x20[CreateBackup][google.spanner.admin.d\
    atabase.v1.DatabaseAdmin.CreateBackup]\n\x20request\x20is\x20received.\
    \x20If\x20the\x20request\x20does\x20not\x20specify\x20`version_time`,\
    \x20the\n\x20`version_time`\x20of\x20the\x20backup\x20will\x20be\x20equi\
    valent\x20to\x20the\x20`create_time`.\n\n\x0c\n\x05\x04\0\x02\x04\x06\
    \x12\x03^\x02\x1b\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03^\x1c'\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x03^*+\n\x0c\n\x05\x04\0\x02\x04\x08\x12\x03^\
    ,W\n\x0f\n\x08\x04\0\x02\x04\x08\x9c\x08\0\x12\x03^-V\n8\n\x04\x04\0\x02\
    \x05\x12\x03a\x02C\x1a+\x20Output\x20only.\x20Size\x20of\x20the\x20backu\
    p\x20in\x20bytes.\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03a\x02\x07\n\x0c\
    \n\x05\x04\0\x02\x05\x01\x12\x03a\x08\x12\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03a\x15\x16\n\x0c\n\x05\x04\0\x02\x05\x08\x12\x03a\x17B\n\x0f\n\
    \x08\x04\0\x02\x05\x08\x9c\x08\0\x12\x03a\x18A\n<\n\x04\x04\0\x02\x06\
    \x12\x03d\x02>\x1a/\x20Output\x20only.\x20The\x20current\x20state\x20of\
    \x20the\x20backup.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03d\x02\x07\n\
    \x0c\n\x05\x04\0\x02\x06\x01\x12\x03d\x08\r\n\x0c\n\x05\x04\0\x02\x06\
    \x03\x12\x03d\x10\x11\n\x0c\n\x05\x04\0\x02\x06\x08\x12\x03d\x12=\n\x0f\
    \n\x08\x04\0\x02\x06\x08\x9c\x08\0\x12\x03d\x13<\n\xba\x03\n\x04\x04\0\
    \x02\x07\x12\x04m\x02r\x04\x1a\xab\x03\x20Output\x20only.\x20The\x20name\
    s\x20of\x20the\x20restored\x20databases\x20that\x20reference\x20the\x20b\
    ackup.\n\x20The\x20database\x20names\x20are\x20of\n\x20the\x20form\x20`p\
    rojects/<project>/instances/<instance>/databases/<database>`.\n\x20Refer\
    encing\x20databases\x20may\x20exist\x20in\x20different\x20instances.\x20\
    The\x20existence\x20of\n\x20any\x20referencing\x20database\x20prevents\
    \x20the\x20backup\x20from\x20being\x20deleted.\x20When\x20a\n\x20restore\
    d\x20database\x20from\x20the\x20backup\x20enters\x20the\x20`READY`\x20st\
    ate,\x20the\x20reference\n\x20to\x20the\x20backup\x20is\x20removed.\n\n\
    \x0c\n\x05\x04\0\x02\x07\x04\x12\x03m\x02\n\n\x0c\n\x05\x04\0\x02\x07\
    \x05\x12\x03m\x0b\x11\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03m\x12'\n\x0c\
    \n\x05\x04\0\x02\x07\x03\x12\x03m*+\n\r\n\x05\x04\0\x02\x07\x08\x12\x04m\
    ,r\x03\n\x0f\n\x08\x04\0\x02\x07\x08\x9c\x08\0\x12\x03n\x04-\n\x0f\n\x07\
    \x04\0\x02\x07\x08\x9f\x08\x12\x04o\x04q\x05\nF\n\x04\x04\0\x02\x08\x12\
    \x03u\x02Q\x1a9\x20Output\x20only.\x20The\x20encryption\x20information\
    \x20for\x20the\x20backup.\n\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03u\x02\
    \x10\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03u\x11\x20\n\x0c\n\x05\x04\0\
    \x02\x08\x03\x12\x03u#$\n\x0c\n\x05\x04\0\x02\x08\x08\x12\x03u%P\n\x0f\n\
    \x08\x04\0\x02\x08\x08\x9c\x08\0\x12\x03u&O\nL\n\x04\x04\0\x02\t\x12\x03\
    x\x02T\x1a?\x20Output\x20only.\x20The\x20database\x20dialect\x20informat\
    ion\x20for\x20the\x20backup.\n\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03x\x02\
    \x11\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03x\x12\"\n\x0c\n\x05\x04\0\x02\t\
    \x03\x12\x03x%'\n\x0c\n\x05\x04\0\x02\t\x08\x12\x03x(S\n\x0f\n\x08\x04\0\
    \x02\t\x08\x9c\x08\0\x12\x03x)R\n\xf5\x03\n\x04\x04\0\x02\n\x12\x06\x81\
    \x01\x02\x86\x01\x04\x1a\xe4\x03\x20Output\x20only.\x20The\x20names\x20o\
    f\x20the\x20destination\x20backups\x20being\x20created\x20by\x20copying\
    \n\x20this\x20source\x20backup.\x20The\x20backup\x20names\x20are\x20of\
    \x20the\x20form\n\x20`projects/<project>/instances/<instance>/backups/<b\
    ackup>`.\n\x20Referencing\x20backups\x20may\x20exist\x20in\x20different\
    \x20instances.\x20The\x20existence\x20of\n\x20any\x20referencing\x20back\
    up\x20prevents\x20the\x20backup\x20from\x20being\x20deleted.\x20When\x20\
    the\n\x20copy\x20operation\x20is\x20done\x20(either\x20successfully\x20c\
    ompleted\x20or\x20cancelled\x20or\x20the\n\x20destination\x20backup\x20i\
    s\x20deleted),\x20the\x20reference\x20to\x20the\x20backup\x20is\x20remov\
    ed.\n\n\r\n\x05\x04\0\x02\n\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\x04\0\
    \x02\n\x05\x12\x04\x81\x01\x0b\x11\n\r\n\x05\x04\0\x02\n\x01\x12\x04\x81\
    \x01\x12%\n\r\n\x05\x04\0\x02\n\x03\x12\x04\x81\x01(*\n\x0f\n\x05\x04\0\
    \x02\n\x08\x12\x06\x81\x01+\x86\x01\x03\n\x10\n\x08\x04\0\x02\n\x08\x9c\
    \x08\0\x12\x04\x82\x01\x04-\n\x11\n\x07\x04\0\x02\n\x08\x9f\x08\x12\x06\
    \x83\x01\x04\x85\x01\x05\n\xcd\x02\n\x04\x04\0\x02\x0b\x12\x04\x8d\x01\
    \x02]\x1a\xbe\x02\x20Output\x20only.\x20The\x20max\x20allowed\x20expirat\
    ion\x20time\x20of\x20the\x20backup,\x20with\n\x20microseconds\x20granula\
    rity.\x20A\x20backup's\x20expiration\x20time\x20can\x20be\x20configured\
    \x20in\n\x20multiple\x20APIs:\x20CreateBackup,\x20UpdateBackup,\x20CopyB\
    ackup.\x20When\x20updating\x20or\n\x20copying\x20an\x20existing\x20backu\
    p,\x20the\x20expiration\x20time\x20specified\x20must\x20be\n\x20less\x20\
    than\x20`Backup.max_expire_time`.\n\n\r\n\x05\x04\0\x02\x0b\x06\x12\x04\
    \x8d\x01\x02\x1b\n\r\n\x05\x04\0\x02\x0b\x01\x12\x04\x8d\x01\x1c+\n\r\n\
    \x05\x04\0\x02\x0b\x03\x12\x04\x8d\x01.0\n\r\n\x05\x04\0\x02\x0b\x08\x12\
    \x04\x8d\x011\\\n\x10\n\x08\x04\0\x02\x0b\x08\x9c\x08\0\x12\x04\x8d\x012\
    [\nl\n\x02\x04\x01\x12\x06\x91\x01\0\xad\x01\x01\x1a^\x20The\x20request\
    \x20for\x20[CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin\
    .CreateBackup].\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x91\x01\x08\x1b\n\xe3\
    \x02\n\x04\x04\x01\x02\0\x12\x06\x98\x01\x02\x9d\x01\x04\x1a\xd2\x02\x20\
    Required.\x20The\x20name\x20of\x20the\x20instance\x20in\x20which\x20the\
    \x20backup\x20will\x20be\n\x20created.\x20This\x20must\x20be\x20the\x20s\
    ame\x20instance\x20that\x20contains\x20the\x20database\x20the\n\x20backu\
    p\x20will\x20be\x20created\x20from.\x20The\x20backup\x20will\x20be\x20st\
    ored\x20in\x20the\n\x20location(s)\x20specified\x20in\x20the\x20instance\
    \x20configuration\x20of\x20this\n\x20instance.\x20Values\x20are\x20of\
    \x20the\x20form\n\x20`projects/<project>/instances/<instance>`.\n\n\r\n\
    \x05\x04\x01\x02\0\x05\x12\x04\x98\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\
    \x01\x12\x04\x98\x01\t\x0f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x98\x01\
    \x12\x13\n\x0f\n\x05\x04\x01\x02\0\x08\x12\x06\x98\x01\x14\x9d\x01\x03\n\
    \x10\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\x04\x99\x01\x04*\n\x11\n\x07\
    \x04\x01\x02\0\x08\x9f\x08\x12\x06\x9a\x01\x04\x9c\x01\x05\n\xcb\x01\n\
    \x04\x04\x01\x02\x01\x12\x04\xa2\x01\x02@\x1a\xbc\x01\x20Required.\x20Th\
    e\x20id\x20of\x20the\x20backup\x20to\x20be\x20created.\x20The\x20`backup\
    _id`\x20appended\x20to\n\x20`parent`\x20forms\x20the\x20full\x20backup\
    \x20name\x20of\x20the\x20form\n\x20`projects/<project>/instances/<instan\
    ce>/backups/<backup_id>`.\n\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\xa2\
    \x01\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xa2\x01\t\x12\n\r\n\
    \x05\x04\x01\x02\x01\x03\x12\x04\xa2\x01\x15\x16\n\r\n\x05\x04\x01\x02\
    \x01\x08\x12\x04\xa2\x01\x17?\n\x10\n\x08\x04\x01\x02\x01\x08\x9c\x08\0\
    \x12\x04\xa2\x01\x18>\n/\n\x04\x04\x01\x02\x02\x12\x04\xa5\x01\x02=\x1a!\
    \x20Required.\x20The\x20backup\x20to\x20create.\n\n\r\n\x05\x04\x01\x02\
    \x02\x06\x12\x04\xa5\x01\x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\
    \xa5\x01\t\x0f\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xa5\x01\x12\x13\n\r\
    \n\x05\x04\x01\x02\x02\x08\x12\x04\xa5\x01\x14<\n\x10\n\x08\x04\x01\x02\
    \x02\x08\x9c\x08\0\x12\x04\xa5\x01\x15;\n\xce\x02\n\x04\x04\x01\x02\x03\
    \x12\x04\xac\x01\x02^\x1a\xbf\x02\x20Optional.\x20The\x20encryption\x20c\
    onfiguration\x20used\x20to\x20encrypt\x20the\x20backup.\x20If\x20this\
    \x20field\x20is\n\x20not\x20specified,\x20the\x20backup\x20will\x20use\
    \x20the\x20same\n\x20encryption\x20configuration\x20as\x20the\x20databas\
    e\x20by\x20default,\x20namely\n\x20[encryption_type][google.spanner.admi\
    n.database.v1.CreateBackupEncryptionConfig.encryption_type]\x20=\n\x20`U\
    SE_DATABASE_ENCRYPTION`.\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\xac\x01\
    \x02\x1e\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\xac\x01\x1f0\n\r\n\x05\
    \x04\x01\x02\x03\x03\x12\x04\xac\x0134\n\r\n\x05\x04\x01\x02\x03\x08\x12\
    \x04\xac\x015]\n\x10\n\x08\x04\x01\x02\x03\x08\x9c\x08\0\x12\x04\xac\x01\
    6\\\n\x89\x01\n\x02\x04\x02\x12\x06\xb1\x01\0\xcd\x01\x01\x1a{\x20Metada\
    ta\x20type\x20for\x20the\x20operation\x20returned\x20by\n\x20[CreateBack\
    up][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup].\n\n\
    \x0b\n\x03\x04\x02\x01\x12\x04\xb1\x01\x08\x1c\n7\n\x04\x04\x02\x02\0\
    \x12\x06\xb3\x01\x02\xb5\x01\x16\x1a'\x20The\x20name\x20of\x20the\x20bac\
    kup\x20being\x20created.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xb3\x01\
    \x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xb3\x01\t\r\n\r\n\x05\x04\
    \x02\x02\0\x03\x12\x04\xb3\x01\x10\x11\n\x0f\n\x05\x04\x02\x02\0\x08\x12\
    \x06\xb3\x01\x12\xb5\x01\x15\n\x11\n\x07\x04\x02\x02\0\x08\x9f\x08\x12\
    \x06\xb3\x01\x13\xb5\x01\x14\nF\n\x04\x04\x02\x02\x01\x12\x06\xb8\x01\
    \x02\xba\x01\x1a\x1a6\x20The\x20name\x20of\x20the\x20database\x20the\x20\
    backup\x20is\x20created\x20from.\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\
    \xb8\x01\x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xb8\x01\t\x11\n\r\
    \n\x05\x04\x02\x02\x01\x03\x12\x04\xb8\x01\x14\x15\n\x0f\n\x05\x04\x02\
    \x02\x01\x08\x12\x06\xb8\x01\x16\xba\x01\x19\n\x11\n\x07\x04\x02\x02\x01\
    \x08\x9f\x08\x12\x06\xb8\x01\x17\xba\x01\x18\n{\n\x04\x04\x02\x02\x02\
    \x12\x04\xbe\x01\x02!\x1am\x20The\x20progress\x20of\x20the\n\x20[CreateB\
    ackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup]\x20o\
    peration.\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xbe\x01\x02\x13\n\r\n\
    \x05\x04\x02\x02\x02\x01\x12\x04\xbe\x01\x14\x1c\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\xbe\x01\x1f\x20\n\x87\x06\n\x04\x04\x02\x02\x03\x12\x04\
    \xcc\x01\x02,\x1a\xf8\x05\x20The\x20time\x20at\x20which\x20cancellation\
    \x20of\x20this\x20operation\x20was\x20received.\n\x20[Operations.CancelO\
    peration][google.longrunning.Operations.CancelOperation]\n\x20starts\x20\
    asynchronous\x20cancellation\x20on\x20a\x20long-running\x20operation.\
    \x20The\x20server\n\x20makes\x20a\x20best\x20effort\x20to\x20cancel\x20t\
    he\x20operation,\x20but\x20success\x20is\x20not\x20guaranteed.\n\x20Clie\
    nts\x20can\x20use\n\x20[Operations.GetOperation][google.longrunning.Oper\
    ations.GetOperation]\x20or\n\x20other\x20methods\x20to\x20check\x20wheth\
    er\x20the\x20cancellation\x20succeeded\x20or\x20whether\x20the\n\x20oper\
    ation\x20completed\x20despite\x20cancellation.\x20On\x20successful\x20ca\
    ncellation,\n\x20the\x20operation\x20is\x20not\x20deleted;\x20instead,\
    \x20it\x20becomes\x20an\x20operation\x20with\n\x20an\x20[Operation.error\
    ][google.longrunning.Operation.error]\x20value\x20with\x20a\n\x20[google\
    .rpc.Status.code][google.rpc.Status.code]\x20of\x201,\n\x20corresponding\
    \x20to\x20`Code.CANCELLED`.\n\n\r\n\x05\x04\x02\x02\x03\x06\x12\x04\xcc\
    \x01\x02\x1b\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xcc\x01\x1c'\n\r\n\
    \x05\x04\x02\x02\x03\x03\x12\x04\xcc\x01*+\nh\n\x02\x04\x03\x12\x06\xd0\
    \x01\0\xf9\x01\x01\x1aZ\x20The\x20request\x20for\x20[CopyBackup][google.\
    spanner.admin.database.v1.DatabaseAdmin.CopyBackup].\n\n\x0b\n\x03\x04\
    \x03\x01\x12\x04\xd0\x01\x08\x19\n\xa8\x01\n\x04\x04\x03\x02\0\x12\x06\
    \xd3\x01\x02\xd8\x01\x04\x1a\x97\x01\x20Required.\x20The\x20name\x20of\
    \x20the\x20destination\x20instance\x20that\x20will\x20contain\x20the\x20\
    backup\x20copy.\n\x20Values\x20are\x20of\x20the\x20form:\x20`projects/<p\
    roject>/instances/<instance>`.\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xd3\
    \x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xd3\x01\t\x0f\n\r\n\x05\
    \x04\x03\x02\0\x03\x12\x04\xd3\x01\x12\x13\n\x0f\n\x05\x04\x03\x02\0\x08\
    \x12\x06\xd3\x01\x14\xd8\x01\x03\n\x10\n\x08\x04\x03\x02\0\x08\x9c\x08\0\
    \x12\x04\xd4\x01\x04*\n\x11\n\x07\x04\x03\x02\0\x08\x9f\x08\x12\x06\xd5\
    \x01\x04\xd7\x01\x05\n\xbe\x01\n\x04\x04\x03\x02\x01\x12\x04\xdd\x01\x02\
    @\x1a\xaf\x01\x20Required.\x20The\x20id\x20of\x20the\x20backup\x20copy.\
    \n\x20The\x20`backup_id`\x20appended\x20to\x20`parent`\x20forms\x20the\
    \x20full\x20backup_uri\x20of\x20the\x20form\n\x20`projects/<project>/ins\
    tances/<instance>/backups/<backup>`.\n\n\r\n\x05\x04\x03\x02\x01\x05\x12\
    \x04\xdd\x01\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xdd\x01\t\x12\
    \n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xdd\x01\x15\x16\n\r\n\x05\x04\x03\
    \x02\x01\x08\x12\x04\xdd\x01\x17?\n\x10\n\x08\x04\x03\x02\x01\x08\x9c\
    \x08\0\x12\x04\xdd\x01\x18>\n\xd5\x02\n\x04\x04\x03\x02\x02\x12\x06\xe5\
    \x01\x02\xea\x01\x04\x1a\xc4\x02\x20Required.\x20The\x20source\x20backup\
    \x20to\x20be\x20copied.\n\x20The\x20source\x20backup\x20needs\x20to\x20b\
    e\x20in\x20READY\x20state\x20for\x20it\x20to\x20be\x20copied.\n\x20Once\
    \x20CopyBackup\x20is\x20in\x20progress,\x20the\x20source\x20backup\x20ca\
    nnot\x20be\x20deleted\x20or\n\x20cleaned\x20up\x20on\x20expiration\x20un\
    til\x20CopyBackup\x20is\x20finished.\n\x20Values\x20are\x20of\x20the\x20\
    form:\n\x20`projects/<project>/instances/<instance>/backups/<backup>`.\n\
    \n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xe5\x01\x02\x08\n\r\n\x05\x04\x03\
    \x02\x02\x01\x12\x04\xe5\x01\t\x16\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\
    \xe5\x01\x19\x1a\n\x0f\n\x05\x04\x03\x02\x02\x08\x12\x06\xe5\x01\x1b\xea\
    \x01\x03\n\x10\n\x08\x04\x03\x02\x02\x08\x9c\x08\0\x12\x04\xe6\x01\x04*\
    \n\x11\n\x07\x04\x03\x02\x02\x08\x9f\x08\x12\x06\xe7\x01\x04\xe9\x01\x05\
    \n\xdc\x02\n\x04\x04\x03\x02\x03\x12\x04\xf1\x01\x02U\x1a\xcd\x02\x20Req\
    uired.\x20The\x20expiration\x20time\x20of\x20the\x20backup\x20in\x20micr\
    osecond\x20granularity.\n\x20The\x20expiration\x20time\x20must\x20be\x20\
    at\x20least\x206\x20hours\x20and\x20at\x20most\x20366\x20days\n\x20from\
    \x20the\x20`create_time`\x20of\x20the\x20source\x20backup.\x20Once\x20th\
    e\x20`expire_time`\x20has\n\x20passed,\x20the\x20backup\x20is\x20eligibl\
    e\x20to\x20be\x20automatically\x20deleted\x20by\x20Cloud\x20Spanner\n\
    \x20to\x20free\x20the\x20resources\x20used\x20by\x20the\x20backup.\n\n\r\
    \n\x05\x04\x03\x02\x03\x06\x12\x04\xf1\x01\x02\x1b\n\r\n\x05\x04\x03\x02\
    \x03\x01\x12\x04\xf1\x01\x1c'\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xf1\
    \x01*+\n\r\n\x05\x04\x03\x02\x03\x08\x12\x04\xf1\x01,T\n\x10\n\x08\x04\
    \x03\x02\x03\x08\x9c\x08\0\x12\x04\xf1\x01-S\n\xe1\x02\n\x04\x04\x03\x02\
    \x04\x12\x04\xf8\x01\x02\\\x1a\xd2\x02\x20Optional.\x20The\x20encryption\
    \x20configuration\x20used\x20to\x20encrypt\x20the\x20backup.\x20If\x20th\
    is\x20field\x20is\n\x20not\x20specified,\x20the\x20backup\x20will\x20use\
    \x20the\x20same\n\x20encryption\x20configuration\x20as\x20the\x20source\
    \x20backup\x20by\x20default,\x20namely\n\x20[encryption_type][google.spa\
    nner.admin.database.v1.CopyBackupEncryptionConfig.encryption_type]\x20=\
    \n\x20`USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION`.\n\n\r\n\x05\x04\x03\x02\
    \x04\x06\x12\x04\xf8\x01\x02\x1c\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\
    \xf8\x01\x1d.\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xf8\x0112\n\r\n\x05\
    \x04\x03\x02\x04\x08\x12\x04\xf8\x013[\n\x10\n\x08\x04\x03\x02\x04\x08\
    \x9c\x08\0\x12\x04\xf8\x014Z\n\x99\x01\n\x02\x04\x04\x12\x06\xfd\x01\0\
    \x9d\x02\x01\x1a\x8a\x01\x20Metadata\x20type\x20for\x20the\x20google.lon\
    grunning.Operation\x20returned\x20by\n\x20[CopyBackup][google.spanner.ad\
    min.database.v1.DatabaseAdmin.CopyBackup].\n\n\x0b\n\x03\x04\x04\x01\x12\
    \x04\xfd\x01\x08\x1a\n\xa8\x01\n\x04\x04\x04\x02\0\x12\x06\x81\x02\x02\
    \x83\x02\x16\x1a\x97\x01\x20The\x20name\x20of\x20the\x20backup\x20being\
    \x20created\x20through\x20the\x20copy\x20operation.\n\x20Values\x20are\
    \x20of\x20the\x20form\n\x20`projects/<project>/instances/<instance>/back\
    ups/<backup>`.\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x81\x02\x02\x08\n\r\
    \n\x05\x04\x04\x02\0\x01\x12\x04\x81\x02\t\r\n\r\n\x05\x04\x04\x02\0\x03\
    \x12\x04\x81\x02\x10\x11\n\x0f\n\x05\x04\x04\x02\0\x08\x12\x06\x81\x02\
    \x12\x83\x02\x15\n\x11\n\x07\x04\x04\x02\0\x08\x9f\x08\x12\x06\x81\x02\
    \x13\x83\x02\x14\n\x9b\x01\n\x04\x04\x04\x02\x01\x12\x06\x88\x02\x02\x8a\
    \x02\x1f\x1a\x8a\x01\x20The\x20name\x20of\x20the\x20source\x20backup\x20\
    that\x20is\x20being\x20copied.\n\x20Values\x20are\x20of\x20the\x20form\n\
    \x20`projects/<project>/instances/<instance>/backups/<backup>`.\n\n\r\n\
    \x05\x04\x04\x02\x01\x05\x12\x04\x88\x02\x02\x08\n\r\n\x05\x04\x04\x02\
    \x01\x01\x12\x04\x88\x02\t\x16\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x88\
    \x02\x19\x1a\n\x0f\n\x05\x04\x04\x02\x01\x08\x12\x06\x88\x02\x1b\x8a\x02\
    \x1e\n\x11\n\x07\x04\x04\x02\x01\x08\x9f\x08\x12\x06\x88\x02\x1c\x8a\x02\
    \x1d\nw\n\x04\x04\x04\x02\x02\x12\x04\x8e\x02\x02!\x1ai\x20The\x20progre\
    ss\x20of\x20the\n\x20[CopyBackup][google.spanner.admin.database.v1.Datab\
    aseAdmin.CopyBackup]\x20operation.\n\n\r\n\x05\x04\x04\x02\x02\x06\x12\
    \x04\x8e\x02\x02\x13\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\x8e\x02\x14\
    \x1c\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x8e\x02\x1f\x20\n\x8d\x06\n\
    \x04\x04\x04\x02\x03\x12\x04\x9c\x02\x02,\x1a\xfe\x05\x20The\x20time\x20\
    at\x20which\x20cancellation\x20of\x20CopyBackup\x20operation\x20was\x20r\
    eceived.\n\x20[Operations.CancelOperation][google.longrunning.Operations\
    .CancelOperation]\n\x20starts\x20asynchronous\x20cancellation\x20on\x20a\
    \x20long-running\x20operation.\x20The\x20server\n\x20makes\x20a\x20best\
    \x20effort\x20to\x20cancel\x20the\x20operation,\x20but\x20success\x20is\
    \x20not\x20guaranteed.\n\x20Clients\x20can\x20use\n\x20[Operations.GetOp\
    eration][google.longrunning.Operations.GetOperation]\x20or\n\x20other\
    \x20methods\x20to\x20check\x20whether\x20the\x20cancellation\x20succeede\
    d\x20or\x20whether\x20the\n\x20operation\x20completed\x20despite\x20canc\
    ellation.\x20On\x20successful\x20cancellation,\n\x20the\x20operation\x20\
    is\x20not\x20deleted;\x20instead,\x20it\x20becomes\x20an\x20operation\
    \x20with\n\x20an\x20[Operation.error][google.longrunning.Operation.error\
    ]\x20value\x20with\x20a\n\x20[google.rpc.Status.code][google.rpc.Status.\
    code]\x20of\x201,\n\x20corresponding\x20to\x20`Code.CANCELLED`.\n\n\r\n\
    \x05\x04\x04\x02\x03\x06\x12\x04\x9c\x02\x02\x1b\n\r\n\x05\x04\x04\x02\
    \x03\x01\x12\x04\x9c\x02\x1c'\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\x9c\
    \x02*+\nl\n\x02\x04\x05\x12\x06\xa0\x02\0\xad\x02\x01\x1a^\x20The\x20req\
    uest\x20for\x20[UpdateBackup][google.spanner.admin.database.v1.DatabaseA\
    dmin.UpdateBackup].\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xa0\x02\x08\x1b\n\
    \xf1\x01\n\x04\x04\x05\x02\0\x12\x04\xa5\x02\x02=\x1a\xe2\x01\x20Require\
    d.\x20The\x20backup\x20to\x20update.\x20`backup.name`,\x20and\x20the\x20\
    fields\x20to\x20be\x20updated\n\x20as\x20specified\x20by\x20`update_mask\
    `\x20are\x20required.\x20Other\x20fields\x20are\x20ignored.\n\x20Update\
    \x20is\x20only\x20supported\x20for\x20the\x20following\x20fields:\n\x20\
    \x20*\x20`backup.expire_time`.\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xa5\
    \x02\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xa5\x02\t\x0f\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xa5\x02\x12\x13\n\r\n\x05\x04\x05\x02\0\x08\
    \x12\x04\xa5\x02\x14<\n\x10\n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\
    \xa5\x02\x15;\n\xd6\x02\n\x04\x04\x05\x02\x01\x12\x04\xac\x02\x02U\x1a\
    \xc7\x02\x20Required.\x20A\x20mask\x20specifying\x20which\x20fields\x20(\
    e.g.\x20`expire_time`)\x20in\x20the\n\x20Backup\x20resource\x20should\
    \x20be\x20updated.\x20This\x20mask\x20is\x20relative\x20to\x20the\x20Bac\
    kup\n\x20resource,\x20not\x20to\x20the\x20request\x20message.\x20The\x20\
    field\x20mask\x20must\x20always\x20be\n\x20specified;\x20this\x20prevent\
    s\x20any\x20future\x20fields\x20from\x20being\x20erased\x20accidentally\
    \n\x20by\x20clients\x20that\x20do\x20not\x20know\x20about\x20them.\n\n\r\
    \n\x05\x04\x05\x02\x01\x06\x12\x04\xac\x02\x02\x1b\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\xac\x02\x1c'\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xac\
    \x02*+\n\r\n\x05\x04\x05\x02\x01\x08\x12\x04\xac\x02,T\n\x10\n\x08\x04\
    \x05\x02\x01\x08\x9c\x08\0\x12\x04\xac\x02-S\nf\n\x02\x04\x06\x12\x06\
    \xb0\x02\0\xba\x02\x01\x1aX\x20The\x20request\x20for\x20[GetBackup][goog\
    le.spanner.admin.database.v1.DatabaseAdmin.GetBackup].\n\n\x0b\n\x03\x04\
    \x06\x01\x12\x04\xb0\x02\x08\x18\n\x84\x01\n\x04\x04\x06\x02\0\x12\x06\
    \xb4\x02\x02\xb9\x02\x04\x1at\x20Required.\x20Name\x20of\x20the\x20backu\
    p.\n\x20Values\x20are\x20of\x20the\x20form\n\x20`projects/<project>/inst\
    ances/<instance>/backups/<backup>`.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\
    \x04\xb4\x02\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xb4\x02\t\r\n\r\
    \n\x05\x04\x06\x02\0\x03\x12\x04\xb4\x02\x10\x11\n\x0f\n\x05\x04\x06\x02\
    \0\x08\x12\x06\xb4\x02\x12\xb9\x02\x03\n\x10\n\x08\x04\x06\x02\0\x08\x9c\
    \x08\0\x12\x04\xb5\x02\x04*\n\x11\n\x07\x04\x06\x02\0\x08\x9f\x08\x12\
    \x06\xb6\x02\x04\xb8\x02\x05\nl\n\x02\x04\x07\x12\x06\xbd\x02\0\xc7\x02\
    \x01\x1a^\x20The\x20request\x20for\x20[DeleteBackup][google.spanner.admi\
    n.database.v1.DatabaseAdmin.DeleteBackup].\n\n\x0b\n\x03\x04\x07\x01\x12\
    \x04\xbd\x02\x08\x1b\n\x8e\x01\n\x04\x04\x07\x02\0\x12\x06\xc1\x02\x02\
    \xc6\x02\x04\x1a~\x20Required.\x20Name\x20of\x20the\x20backup\x20to\x20d\
    elete.\n\x20Values\x20are\x20of\x20the\x20form\n\x20`projects/<project>/\
    instances/<instance>/backups/<backup>`.\n\n\r\n\x05\x04\x07\x02\0\x05\
    \x12\x04\xc1\x02\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xc1\x02\t\r\
    \n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xc1\x02\x10\x11\n\x0f\n\x05\x04\x07\
    \x02\0\x08\x12\x06\xc1\x02\x12\xc6\x02\x03\n\x10\n\x08\x04\x07\x02\0\x08\
    \x9c\x08\0\x12\x04\xc2\x02\x04*\n\x11\n\x07\x04\x07\x02\0\x08\x9f\x08\
    \x12\x06\xc3\x02\x04\xc5\x02\x05\nj\n\x02\x04\x08\x12\x06\xca\x02\0\x82\
    \x03\x01\x1a\\\x20The\x20request\x20for\x20[ListBackups][google.spanner.\
    admin.database.v1.DatabaseAdmin.ListBackups].\n\n\x0b\n\x03\x04\x08\x01\
    \x12\x04\xca\x02\x08\x1a\n\x82\x01\n\x04\x04\x08\x02\0\x12\x06\xcd\x02\
    \x02\xd2\x02\x04\x1ar\x20Required.\x20The\x20instance\x20to\x20list\x20b\
    ackups\x20from.\x20\x20Values\x20are\x20of\x20the\n\x20form\x20`projects\
    /<project>/instances/<instance>`.\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\
    \xcd\x02\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xcd\x02\t\x0f\n\r\n\
    \x05\x04\x08\x02\0\x03\x12\x04\xcd\x02\x12\x13\n\x0f\n\x05\x04\x08\x02\0\
    \x08\x12\x06\xcd\x02\x14\xd2\x02\x03\n\x10\n\x08\x04\x08\x02\0\x08\x9c\
    \x08\0\x12\x04\xce\x02\x04*\n\x11\n\x07\x04\x08\x02\0\x08\x9f\x08\x12\
    \x06\xcf\x02\x04\xd1\x02\x05\n\xea\x0c\n\x04\x04\x08\x02\x01\x12\x04\xf7\
    \x02\x02\x14\x1a\xdb\x0c\x20An\x20expression\x20that\x20filters\x20the\
    \x20list\x20of\x20returned\x20backups.\n\n\x20A\x20filter\x20expression\
    \x20consists\x20of\x20a\x20field\x20name,\x20a\x20comparison\x20operator\
    ,\x20and\x20a\n\x20value\x20for\x20filtering.\n\x20The\x20value\x20must\
    \x20be\x20a\x20string,\x20a\x20number,\x20or\x20a\x20boolean.\x20The\x20\
    comparison\x20operator\n\x20must\x20be\x20one\x20of:\x20`<`,\x20`>`,\x20\
    `<=`,\x20`>=`,\x20`!=`,\x20`=`,\x20or\x20`:`.\n\x20Colon\x20`:`\x20is\
    \x20the\x20contains\x20operator.\x20Filter\x20rules\x20are\x20not\x20cas\
    e\x20sensitive.\n\n\x20The\x20following\x20fields\x20in\x20the\x20[Backu\
    p][google.spanner.admin.database.v1.Backup]\x20are\x20eligible\x20for\
    \x20filtering:\n\n\x20\x20\x20*\x20`name`\n\x20\x20\x20*\x20`database`\n\
    \x20\x20\x20*\x20`state`\n\x20\x20\x20*\x20`create_time`\x20\x20(and\x20\
    values\x20are\x20of\x20the\x20format\x20YYYY-MM-DDTHH:MM:SSZ)\n\x20\x20\
    \x20*\x20`expire_time`\x20\x20(and\x20values\x20are\x20of\x20the\x20form\
    at\x20YYYY-MM-DDTHH:MM:SSZ)\n\x20\x20\x20*\x20`version_time`\x20(and\x20\
    values\x20are\x20of\x20the\x20format\x20YYYY-MM-DDTHH:MM:SSZ)\n\x20\x20\
    \x20*\x20`size_bytes`\n\n\x20You\x20can\x20combine\x20multiple\x20expres\
    sions\x20by\x20enclosing\x20each\x20expression\x20in\n\x20parentheses.\
    \x20By\x20default,\x20expressions\x20are\x20combined\x20with\x20AND\x20l\
    ogic,\x20but\n\x20you\x20can\x20specify\x20AND,\x20OR,\x20and\x20NOT\x20\
    logic\x20explicitly.\n\n\x20Here\x20are\x20a\x20few\x20examples:\n\n\x20\
    \x20\x20*\x20`name:Howl`\x20-\x20The\x20backup's\x20name\x20contains\x20\
    the\x20string\x20\"howl\".\n\x20\x20\x20*\x20`database:prod`\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20-\x20The\x20database's\x20name\x20contai\
    ns\x20the\x20string\x20\"prod\".\n\x20\x20\x20*\x20`state:CREATING`\x20-\
    \x20The\x20backup\x20is\x20pending\x20creation.\n\x20\x20\x20*\x20`state\
    :READY`\x20-\x20The\x20backup\x20is\x20fully\x20created\x20and\x20ready\
    \x20for\x20use.\n\x20\x20\x20*\x20`(name:howl)\x20AND\x20(create_time\
    \x20<\x20\\\"2018-03-28T14:50:00Z\\\")`\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20-\x20The\x20backup\x20name\x20contains\x20the\x20string\x20\
    \"howl\"\x20and\x20`create_time`\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20of\x20the\x20backup\x20is\x20before\x202018-03-28T14\
    :50:00Z.\n\x20\x20\x20*\x20`expire_time\x20<\x20\\\"2018-03-28T14:50:00Z\
    \\\"`\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20The\x20backup\x20`ex\
    pire_time`\x20is\x20before\x202018-03-28T14:50:00Z.\n\x20\x20\x20*\x20`s\
    ize_bytes\x20>\x2010000000000`\x20-\x20The\x20backup's\x20size\x20is\x20\
    greater\x20than\x2010GB\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xf7\x02\
    \x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xf7\x02\t\x0f\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\xf7\x02\x12\x13\n\x84\x01\n\x04\x04\x08\x02\
    \x02\x12\x04\xfb\x02\x02\x16\x1av\x20Number\x20of\x20backups\x20to\x20be\
    \x20returned\x20in\x20the\x20response.\x20If\x200\x20or\n\x20less,\x20de\
    faults\x20to\x20the\x20server's\x20maximum\x20allowed\x20page\x20size.\n\
    \n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xfb\x02\x02\x07\n\r\n\x05\x04\x08\
    \x02\x02\x01\x12\x04\xfb\x02\x08\x11\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\xfb\x02\x14\x15\n\xa4\x02\n\x04\x04\x08\x02\x03\x12\x04\x81\x03\x02\
    \x18\x1a\x95\x02\x20If\x20non-empty,\x20`page_token`\x20should\x20contai\
    n\x20a\n\x20[next_page_token][google.spanner.admin.database.v1.ListBacku\
    psResponse.next_page_token]\x20from\x20a\n\x20previous\x20[ListBackupsRe\
    sponse][google.spanner.admin.database.v1.ListBackupsResponse]\x20to\x20t\
    he\x20same\x20`parent`\x20and\x20with\x20the\x20same\n\x20`filter`.\n\n\
    \r\n\x05\x04\x08\x02\x03\x05\x12\x04\x81\x03\x02\x08\n\r\n\x05\x04\x08\
    \x02\x03\x01\x12\x04\x81\x03\t\x13\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\
    \x81\x03\x16\x17\nk\n\x02\x04\t\x12\x06\x85\x03\0\x8e\x03\x01\x1a]\x20Th\
    e\x20response\x20for\x20[ListBackups][google.spanner.admin.database.v1.D\
    atabaseAdmin.ListBackups].\n\n\x0b\n\x03\x04\t\x01\x12\x04\x85\x03\x08\
    \x1b\n\x9f\x01\n\x04\x04\t\x02\0\x12\x04\x88\x03\x02\x1e\x1a\x90\x01\x20\
    The\x20list\x20of\x20matching\x20backups.\x20Backups\x20returned\x20are\
    \x20ordered\x20by\x20`create_time`\n\x20in\x20descending\x20order,\x20st\
    arting\x20from\x20the\x20most\x20recent\x20`create_time`.\n\n\r\n\x05\
    \x04\t\x02\0\x04\x12\x04\x88\x03\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\
    \x88\x03\x0b\x11\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x88\x03\x12\x19\n\r\n\
    \x05\x04\t\x02\0\x03\x12\x04\x88\x03\x1c\x1d\n\xb6\x01\n\x04\x04\t\x02\
    \x01\x12\x04\x8d\x03\x02\x1d\x1a\xa7\x01\x20`next_page_token`\x20can\x20\
    be\x20sent\x20in\x20a\x20subsequent\n\x20[ListBackups][google.spanner.ad\
    min.database.v1.DatabaseAdmin.ListBackups]\x20call\x20to\x20fetch\x20mor\
    e\n\x20of\x20the\x20matching\x20backups.\n\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\x8d\x03\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x8d\x03\t\
    \x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x8d\x03\x1b\x1c\n}\n\x02\x04\n\
    \x12\x06\x92\x03\0\xe9\x03\x01\x1ao\x20The\x20request\x20for\n\x20[ListB\
    ackupOperations][google.spanner.admin.database.v1.DatabaseAdmin.ListBack\
    upOperations].\n\n\x0b\n\x03\x04\n\x01\x12\x04\x92\x03\x08#\n\x85\x01\n\
    \x04\x04\n\x02\0\x12\x06\x95\x03\x02\x9a\x03\x04\x1au\x20Required.\x20Th\
    e\x20instance\x20of\x20the\x20backup\x20operations.\x20Values\x20are\x20\
    of\n\x20the\x20form\x20`projects/<project>/instances/<instance>`.\n\n\r\
    \n\x05\x04\n\x02\0\x05\x12\x04\x95\x03\x02\x08\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\x95\x03\t\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x95\x03\x12\x13\
    \n\x0f\n\x05\x04\n\x02\0\x08\x12\x06\x95\x03\x14\x9a\x03\x03\n\x10\n\x08\
    \x04\n\x02\0\x08\x9c\x08\0\x12\x04\x96\x03\x04*\n\x11\n\x07\x04\n\x02\0\
    \x08\x9f\x08\x12\x06\x97\x03\x04\x99\x03\x05\n\xc5\x1d\n\x04\x04\n\x02\
    \x01\x12\x04\xde\x03\x02\x14\x1a\xb6\x1d\x20An\x20expression\x20that\x20\
    filters\x20the\x20list\x20of\x20returned\x20backup\x20operations.\n\n\
    \x20A\x20filter\x20expression\x20consists\x20of\x20a\x20field\x20name,\
    \x20a\n\x20comparison\x20operator,\x20and\x20a\x20value\x20for\x20filter\
    ing.\n\x20The\x20value\x20must\x20be\x20a\x20string,\x20a\x20number,\x20\
    or\x20a\x20boolean.\x20The\x20comparison\x20operator\n\x20must\x20be\x20\
    one\x20of:\x20`<`,\x20`>`,\x20`<=`,\x20`>=`,\x20`!=`,\x20`=`,\x20or\x20`\
    :`.\n\x20Colon\x20`:`\x20is\x20the\x20contains\x20operator.\x20Filter\
    \x20rules\x20are\x20not\x20case\x20sensitive.\n\n\x20The\x20following\
    \x20fields\x20in\x20the\x20[operation][google.longrunning.Operation]\n\
    \x20are\x20eligible\x20for\x20filtering:\n\n\x20\x20\x20*\x20`name`\x20-\
    \x20The\x20name\x20of\x20the\x20long-running\x20operation\n\x20\x20\x20*\
    \x20`done`\x20-\x20False\x20if\x20the\x20operation\x20is\x20in\x20progre\
    ss,\x20else\x20true.\n\x20\x20\x20*\x20`metadata.@type`\x20-\x20the\x20t\
    ype\x20of\x20metadata.\x20For\x20example,\x20the\x20type\x20string\n\x20\
    \x20\x20\x20\x20\x20for\x20[CreateBackupMetadata][google.spanner.admin.d\
    atabase.v1.CreateBackupMetadata]\x20is\n\x20\x20\x20\x20\x20\x20`type.go\
    ogleapis.com/google.spanner.admin.database.v1.CreateBackupMetadata`.\n\
    \x20\x20\x20*\x20`metadata.<field_name>`\x20-\x20any\x20field\x20in\x20m\
    etadata.value.\n\x20\x20\x20\x20\x20\x20`metadata.@type`\x20must\x20be\
    \x20specified\x20first\x20if\x20filtering\x20on\x20metadata\n\x20\x20\
    \x20\x20\x20\x20fields.\n\x20\x20\x20*\x20`error`\x20-\x20Error\x20assoc\
    iated\x20with\x20the\x20long-running\x20operation.\n\x20\x20\x20*\x20`re\
    sponse.@type`\x20-\x20the\x20type\x20of\x20response.\n\x20\x20\x20*\x20`\
    response.<field_name>`\x20-\x20any\x20field\x20in\x20response.value.\n\n\
    \x20You\x20can\x20combine\x20multiple\x20expressions\x20by\x20enclosing\
    \x20each\x20expression\x20in\n\x20parentheses.\x20By\x20default,\x20expr\
    essions\x20are\x20combined\x20with\x20AND\x20logic,\x20but\n\x20you\x20c\
    an\x20specify\x20AND,\x20OR,\x20and\x20NOT\x20logic\x20explicitly.\n\n\
    \x20Here\x20are\x20a\x20few\x20examples:\n\n\x20\x20\x20*\x20`done:true`\
    \x20-\x20The\x20operation\x20is\x20complete.\n\x20\x20\x20*\x20`(metadat\
    a.@type=type.googleapis.com/google.spanner.admin.database.v1.CreateBacku\
    pMetadata)\x20AND`\x20\\\n\x20\x20\x20\x20\x20\x20`metadata.database:pro\
    d`\x20-\x20Returns\x20operations\x20where:\n\x20\x20\x20\x20\x20\x20*\
    \x20The\x20operation's\x20metadata\x20type\x20is\x20[CreateBackupMetadat\
    a][google.spanner.admin.database.v1.CreateBackupMetadata].\n\x20\x20\x20\
    \x20\x20\x20*\x20The\x20database\x20the\x20backup\x20was\x20taken\x20fro\
    m\x20has\x20a\x20name\x20containing\x20the\n\x20\x20\x20\x20\x20\x20stri\
    ng\x20\"prod\".\n\x20\x20\x20*\x20`(metadata.@type=type.googleapis.com/g\
    oogle.spanner.admin.database.v1.CreateBackupMetadata)\x20AND`\x20\\\n\
    \x20\x20\x20\x20\x20`(metadata.name:howl)\x20AND`\x20\\\n\x20\x20\x20\
    \x20\x20`(metadata.progress.start_time\x20<\x20\\\"2018-03-28T14:50:00Z\
    \\\")\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(error:*)`\x20-\x20Returns\x20\
    operations\x20where:\n\x20\x20\x20\x20\x20*\x20The\x20operation's\x20met\
    adata\x20type\x20is\x20[CreateBackupMetadata][google.spanner.admin.datab\
    ase.v1.CreateBackupMetadata].\n\x20\x20\x20\x20\x20*\x20The\x20backup\
    \x20name\x20contains\x20the\x20string\x20\"howl\".\n\x20\x20\x20\x20\x20\
    *\x20The\x20operation\x20started\x20before\x202018-03-28T14:50:00Z.\n\
    \x20\x20\x20\x20\x20*\x20The\x20operation\x20resulted\x20in\x20an\x20err\
    or.\n\x20\x20\x20*\x20`(metadata.@type=type.googleapis.com/google.spanne\
    r.admin.database.v1.CopyBackupMetadata)\x20AND`\x20\\\n\x20\x20\x20\x20\
    \x20`(metadata.source_backup:test)\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(\
    metadata.progress.start_time\x20<\x20\\\"2022-01-18T14:50:00Z\\\")\x20AN\
    D`\x20\\\n\x20\x20\x20\x20\x20`(error:*)`\x20-\x20Returns\x20operations\
    \x20where:\n\x20\x20\x20\x20\x20*\x20The\x20operation's\x20metadata\x20t\
    ype\x20is\x20[CopyBackupMetadata][google.spanner.admin.database.v1.CopyB\
    ackupMetadata].\n\x20\x20\x20\x20\x20*\x20The\x20source\x20backup\x20of\
    \x20the\x20copied\x20backup\x20name\x20contains\x20the\x20string\n\x20\
    \x20\x20\x20\x20\"test\".\n\x20\x20\x20\x20\x20*\x20The\x20operation\x20\
    started\x20before\x202022-01-18T14:50:00Z.\n\x20\x20\x20\x20\x20*\x20The\
    \x20operation\x20resulted\x20in\x20an\x20error.\n\x20\x20\x20*\x20`((met\
    adata.@type=type.googleapis.com/google.spanner.admin.database.v1.CreateB\
    ackupMetadata)\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(metadata.database:te\
    st_db))\x20OR`\x20\\\n\x20\x20\x20\x20\x20`((metadata.@type=type.googlea\
    pis.com/google.spanner.admin.database.v1.CopyBackupMetadata)\n\x20\x20\
    \x20\x20\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(metadata.source_backup:tes\
    t_bkp))\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(error:*)`\x20-\x20Returns\
    \x20operations\x20where:\n\x20\x20\x20\x20\x20*\x20The\x20operation's\
    \x20metadata\x20matches\x20either\x20of\x20criteria:\n\x20\x20\x20\x20\
    \x20\x20\x20*\x20The\x20operation's\x20metadata\x20type\x20is\x20[Create\
    BackupMetadata][google.spanner.admin.database.v1.CreateBackupMetadata]\
    \x20AND\x20the\n\x20\x20\x20\x20\x20\x20\x20database\x20the\x20backup\
    \x20was\x20taken\x20from\x20has\x20name\x20containing\x20string\n\x20\
    \x20\x20\x20\x20\x20\x20\"test_db\"\n\x20\x20\x20\x20\x20\x20\x20*\x20Th\
    e\x20operation's\x20metadata\x20type\x20is\x20[CopyBackupMetadata][googl\
    e.spanner.admin.database.v1.CopyBackupMetadata]\x20AND\x20the\n\x20\x20\
    \x20\x20\x20\x20\x20backup\x20the\x20backup\x20was\x20copied\x20from\x20\
    has\x20name\x20containing\x20string\n\x20\x20\x20\x20\x20\x20\x20\"test_\
    bkp\"\n\x20\x20\x20\x20\x20*\x20The\x20operation\x20resulted\x20in\x20an\
    \x20error.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xde\x03\x02\x08\n\r\n\
    \x05\x04\n\x02\x01\x01\x12\x04\xde\x03\t\x0f\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\xde\x03\x12\x13\n\x87\x01\n\x04\x04\n\x02\x02\x12\x04\xe2\x03\
    \x02\x16\x1ay\x20Number\x20of\x20operations\x20to\x20be\x20returned\x20i\
    n\x20the\x20response.\x20If\x200\x20or\n\x20less,\x20defaults\x20to\x20t\
    he\x20server's\x20maximum\x20allowed\x20page\x20size.\n\n\r\n\x05\x04\n\
    \x02\x02\x05\x12\x04\xe2\x03\x02\x07\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\
    \xe2\x03\x08\x11\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xe2\x03\x14\x15\n\
    \xbf\x02\n\x04\x04\n\x02\x03\x12\x04\xe8\x03\x02\x18\x1a\xb0\x02\x20If\
    \x20non-empty,\x20`page_token`\x20should\x20contain\x20a\n\x20[next_page\
    _token][google.spanner.admin.database.v1.ListBackupOperationsResponse.ne\
    xt_page_token]\n\x20from\x20a\x20previous\x20[ListBackupOperationsRespon\
    se][google.spanner.admin.database.v1.ListBackupOperationsResponse]\x20to\
    \x20the\n\x20same\x20`parent`\x20and\x20with\x20the\x20same\x20`filter`.\
    \n\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xe8\x03\x02\x08\n\r\n\x05\x04\n\
    \x02\x03\x01\x12\x04\xe8\x03\t\x13\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\
    \xe8\x03\x16\x17\n~\n\x02\x04\x0b\x12\x06\xed\x03\0\xfd\x03\x01\x1ap\x20\
    The\x20response\x20for\n\x20[ListBackupOperations][google.spanner.admin.\
    database.v1.DatabaseAdmin.ListBackupOperations].\n\n\x0b\n\x03\x04\x0b\
    \x01\x12\x04\xed\x03\x08$\n\xb5\x04\n\x04\x04\x0b\x02\0\x12\x04\xf7\x03\
    \x027\x1a\xa6\x04\x20The\x20list\x20of\x20matching\x20backup\x20[long-ru\
    nning\n\x20operations][google.longrunning.Operation].\x20Each\x20operati\
    on's\x20name\x20will\x20be\n\x20prefixed\x20by\x20the\x20backup's\x20nam\
    e.\x20The\x20operation's\n\x20[metadata][google.longrunning.Operation.me\
    tadata]\x20field\x20type\n\x20`metadata.type_url`\x20describes\x20the\
    \x20type\x20of\x20the\x20metadata.\x20Operations\x20returned\n\x20includ\
    e\x20those\x20that\x20are\x20pending\x20or\x20have\x20completed/failed/c\
    anceled\x20within\x20the\n\x20last\x207\x20days.\x20Operations\x20return\
    ed\x20are\x20ordered\x20by\n\x20`operation.metadata.value.progress.start\
    _time`\x20in\x20descending\x20order\x20starting\n\x20from\x20the\x20most\
    \x20recently\x20started\x20operation.\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\
    \x04\xf7\x03\x02\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xf7\x03\x0b'\n\r\
    \n\x05\x04\x0b\x02\0\x01\x12\x04\xf7\x03(2\n\r\n\x05\x04\x0b\x02\0\x03\
    \x12\x04\xf7\x0356\n\xc9\x01\n\x04\x04\x0b\x02\x01\x12\x04\xfc\x03\x02\
    \x1d\x1a\xba\x01\x20`next_page_token`\x20can\x20be\x20sent\x20in\x20a\
    \x20subsequent\n\x20[ListBackupOperations][google.spanner.admin.database\
    .v1.DatabaseAdmin.ListBackupOperations]\n\x20call\x20to\x20fetch\x20more\
    \x20of\x20the\x20matching\x20metadata.\n\n\r\n\x05\x04\x0b\x02\x01\x05\
    \x12\x04\xfc\x03\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xfc\x03\t\
    \x18\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xfc\x03\x1b\x1c\n+\n\x02\x04\
    \x0c\x12\x06\x80\x04\0\x95\x04\x01\x1a\x1d\x20Information\x20about\x20a\
    \x20backup.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x80\x04\x08\x12\n%\n\x04\
    \x04\x0c\x02\0\x12\x06\x82\x04\x02\x84\x04\x18\x1a\x15\x20Name\x20of\x20\
    the\x20backup.\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x82\x04\x02\x08\n\r\
    \n\x05\x04\x0c\x02\0\x01\x12\x04\x82\x04\t\x0f\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\x82\x04\x12\x13\n\x0f\n\x05\x04\x0c\x02\0\x08\x12\x06\x82\
    \x04\x14\x84\x04\x17\n\x11\n\x07\x04\x0c\x02\0\x08\x9f\x08\x12\x06\x82\
    \x04\x15\x84\x04\x16\n\xc9\x02\n\x04\x04\x0c\x02\x01\x12\x04\x8b\x04\x02\
    -\x1a\xba\x02\x20The\x20backup\x20contains\x20an\x20externally\x20consis\
    tent\x20copy\x20of\x20`source_database`\x20at\n\x20the\x20timestamp\x20s\
    pecified\x20by\x20`version_time`.\x20If\x20the\n\x20[CreateBackup][googl\
    e.spanner.admin.database.v1.DatabaseAdmin.CreateBackup]\x20request\x20di\
    d\x20not\x20specify\n\x20`version_time`,\x20the\x20`version_time`\x20of\
    \x20the\x20backup\x20is\x20equivalent\x20to\x20the\n\x20`create_time`.\n\
    \n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\x8b\x04\x02\x1b\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\x8b\x04\x1c(\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \x8b\x04+,\n\x7f\n\x04\x04\x0c\x02\x02\x12\x04\x8f\x04\x02,\x1aq\x20The\
    \x20time\x20the\x20[CreateBackup][google.spanner.admin.database.v1.Datab\
    aseAdmin.CreateBackup]\x20request\x20was\n\x20received.\n\n\r\n\x05\x04\
    \x0c\x02\x02\x06\x12\x04\x8f\x04\x02\x1b\n\r\n\x05\x04\x0c\x02\x02\x01\
    \x12\x04\x8f\x04\x1c'\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x8f\x04*+\nC\
    \n\x04\x04\x0c\x02\x03\x12\x06\x92\x04\x02\x94\x04!\x1a3\x20Name\x20of\
    \x20the\x20database\x20the\x20backup\x20was\x20created\x20from.\n\n\r\n\
    \x05\x04\x0c\x02\x03\x05\x12\x04\x92\x04\x02\x08\n\r\n\x05\x04\x0c\x02\
    \x03\x01\x12\x04\x92\x04\t\x18\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\x92\
    \x04\x1b\x1c\n\x0f\n\x05\x04\x0c\x02\x03\x08\x12\x06\x92\x04\x1d\x94\x04\
    \x20\n\x11\n\x07\x04\x0c\x02\x03\x08\x9f\x08\x12\x06\x92\x04\x1e\x94\x04\
    \x1f\nB\n\x02\x04\r\x12\x06\x98\x04\0\xbb\x04\x01\x1a4\x20Encryption\x20\
    configuration\x20for\x20the\x20backup\x20to\x20create.\n\n\x0b\n\x03\x04\
    \r\x01\x12\x04\x98\x04\x08$\n2\n\x04\x04\r\x04\0\x12\x06\x9a\x04\x02\xab\
    \x04\x03\x1a\"\x20Encryption\x20types\x20for\x20the\x20backup.\n\n\r\n\
    \x05\x04\r\x04\0\x01\x12\x04\x9a\x04\x07\x15\n*\n\x06\x04\r\x04\0\x02\0\
    \x12\x04\x9c\x04\x04$\x1a\x1a\x20Unspecified.\x20Do\x20not\x20use.\n\n\
    \x0f\n\x07\x04\r\x04\0\x02\0\x01\x12\x04\x9c\x04\x04\x1f\n\x0f\n\x07\x04\
    \r\x04\0\x02\0\x02\x12\x04\x9c\x04\"#\n\xd0\x02\n\x06\x04\r\x04\0\x02\
    \x01\x12\x04\xa3\x04\x04\x20\x1a\xbf\x02\x20Use\x20the\x20same\x20encryp\
    tion\x20configuration\x20as\x20the\x20database.\x20This\x20is\x20the\n\
    \x20default\x20option\x20when\n\x20[encryption_config][google.spanner.ad\
    min.database.v1.CreateBackupEncryptionConfig]\x20is\x20empty.\n\x20For\
    \x20example,\x20if\x20the\x20database\x20is\x20using\x20`Customer_Manage\
    d_Encryption`,\x20the\n\x20backup\x20will\x20be\x20using\x20the\x20same\
    \x20Cloud\x20KMS\x20key\x20as\x20the\x20database.\n\n\x0f\n\x07\x04\r\
    \x04\0\x02\x01\x01\x12\x04\xa3\x04\x04\x1b\n\x0f\n\x07\x04\r\x04\0\x02\
    \x01\x02\x12\x04\xa3\x04\x1e\x1f\n0\n\x06\x04\r\x04\0\x02\x02\x12\x04\
    \xa6\x04\x04\"\x1a\x20\x20Use\x20Google\x20default\x20encryption.\n\n\
    \x0f\n\x07\x04\r\x04\0\x02\x02\x01\x12\x04\xa6\x04\x04\x1d\n\x0f\n\x07\
    \x04\r\x04\0\x02\x02\x02\x12\x04\xa6\x04\x20!\nt\n\x06\x04\r\x04\0\x02\
    \x03\x12\x04\xaa\x04\x04$\x1ad\x20Use\x20customer\x20managed\x20encrypti\
    on.\x20If\x20specified,\x20`kms_key_name`\n\x20must\x20contain\x20a\x20v\
    alid\x20Cloud\x20KMS\x20key.\n\n\x0f\n\x07\x04\r\x04\0\x02\x03\x01\x12\
    \x04\xaa\x04\x04\x1f\n\x0f\n\x07\x04\r\x04\0\x02\x03\x02\x12\x04\xaa\x04\
    \"#\n<\n\x04\x04\r\x02\0\x12\x04\xae\x04\x02N\x1a.\x20Required.\x20The\
    \x20encryption\x20type\x20of\x20the\x20backup.\n\n\r\n\x05\x04\r\x02\0\
    \x06\x12\x04\xae\x04\x02\x10\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xae\x04\
    \x11\x20\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xae\x04#$\n\r\n\x05\x04\r\x02\
    \0\x08\x12\x04\xae\x04%M\n\x10\n\x08\x04\r\x02\0\x08\x9c\x08\0\x12\x04\
    \xae\x04&L\n\xf1\x02\n\x04\x04\r\x02\x01\x12\x06\xb5\x04\x02\xba\x04\x04\
    \x1a\xe0\x02\x20Optional.\x20The\x20Cloud\x20KMS\x20key\x20that\x20will\
    \x20be\x20used\x20to\x20protect\x20the\x20backup.\n\x20This\x20field\x20\
    should\x20be\x20set\x20only\x20when\n\x20[encryption_type][google.spanne\
    r.admin.database.v1.CreateBackupEncryptionConfig.encryption_type]\x20is\
    \n\x20`CUSTOMER_MANAGED_ENCRYPTION`.\x20Values\x20are\x20of\x20the\x20fo\
    rm\n\x20`projects/<project>/locations/<location>/keyRings/<key_ring>/cry\
    ptoKeys/<kms_key_name>`.\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xb5\x04\
    \x02\x08\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xb5\x04\t\x15\n\r\n\x05\x04\
    \r\x02\x01\x03\x12\x04\xb5\x04\x18\x19\n\x0f\n\x05\x04\r\x02\x01\x08\x12\
    \x06\xb5\x04\x1a\xba\x04\x03\n\x10\n\x08\x04\r\x02\x01\x08\x9c\x08\0\x12\
    \x04\xb6\x04\x04*\n\x11\n\x07\x04\r\x02\x01\x08\x9f\x08\x12\x06\xb7\x04\
    \x04\xb9\x04\x05\n?\n\x02\x04\x0e\x12\x06\xbe\x04\0\xe0\x04\x01\x1a1\x20\
    Encryption\x20configuration\x20for\x20the\x20copied\x20backup.\n\n\x0b\n\
    \x03\x04\x0e\x01\x12\x04\xbe\x04\x08\"\n2\n\x04\x04\x0e\x04\0\x12\x06\
    \xc0\x04\x02\xd0\x04\x03\x1a\"\x20Encryption\x20types\x20for\x20the\x20b\
    ackup.\n\n\r\n\x05\x04\x0e\x04\0\x01\x12\x04\xc0\x04\x07\x15\n*\n\x06\
    \x04\x0e\x04\0\x02\0\x12\x04\xc2\x04\x04$\x1a\x1a\x20Unspecified.\x20Do\
    \x20not\x20use.\n\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\x04\xc2\x04\
    \x04\x1f\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xc2\x04\"#\n\xf4\
    \x02\n\x06\x04\x0e\x04\0\x02\x01\x12\x04\xc8\x04\x040\x1a\xe3\x02\x20Thi\
    s\x20is\x20the\x20default\x20option\x20for\x20[CopyBackup][google.spanne\
    r.admin.database.v1.DatabaseAdmin.CopyBackup]\n\x20when\x20[encryption_c\
    onfig][google.spanner.admin.database.v1.CopyBackupEncryptionConfig]\x20i\
    s\x20not\x20specified.\n\x20For\x20example,\x20if\x20the\x20source\x20ba\
    ckup\x20is\x20using\x20`Customer_Managed_Encryption`,\n\x20the\x20backup\
    \x20will\x20be\x20using\x20the\x20same\x20Cloud\x20KMS\x20key\x20as\x20t\
    he\x20source\x20backup.\n\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\x01\x12\x04\
    \xc8\x04\x04+\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\x02\x12\x04\xc8\x04./\n0\
    \n\x06\x04\x0e\x04\0\x02\x02\x12\x04\xcb\x04\x04\"\x1a\x20\x20Use\x20Goo\
    gle\x20default\x20encryption.\n\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x01\
    \x12\x04\xcb\x04\x04\x1d\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x02\x12\x04\
    \xcb\x04\x20!\nt\n\x06\x04\x0e\x04\0\x02\x03\x12\x04\xcf\x04\x04$\x1ad\
    \x20Use\x20customer\x20managed\x20encryption.\x20If\x20specified,\x20`km\
    s_key_name`\n\x20must\x20contain\x20a\x20valid\x20Cloud\x20KMS\x20key.\n\
    \n\x0f\n\x07\x04\x0e\x04\0\x02\x03\x01\x12\x04\xcf\x04\x04\x1f\n\x0f\n\
    \x07\x04\x0e\x04\0\x02\x03\x02\x12\x04\xcf\x04\"#\n<\n\x04\x04\x0e\x02\0\
    \x12\x04\xd3\x04\x02N\x1a.\x20Required.\x20The\x20encryption\x20type\x20\
    of\x20the\x20backup.\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xd3\x04\x02\
    \x10\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xd3\x04\x11\x20\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\xd3\x04#$\n\r\n\x05\x04\x0e\x02\0\x08\x12\x04\xd3\
    \x04%M\n\x10\n\x08\x04\x0e\x02\0\x08\x9c\x08\0\x12\x04\xd3\x04&L\n\xef\
    \x02\n\x04\x04\x0e\x02\x01\x12\x06\xda\x04\x02\xdf\x04\x04\x1a\xde\x02\
    \x20Optional.\x20The\x20Cloud\x20KMS\x20key\x20that\x20will\x20be\x20use\
    d\x20to\x20protect\x20the\x20backup.\n\x20This\x20field\x20should\x20be\
    \x20set\x20only\x20when\n\x20[encryption_type][google.spanner.admin.data\
    base.v1.CopyBackupEncryptionConfig.encryption_type]\x20is\n\x20`CUSTOMER\
    _MANAGED_ENCRYPTION`.\x20Values\x20are\x20of\x20the\x20form\n\x20`projec\
    ts/<project>/locations/<location>/keyRings/<key_ring>/cryptoKeys/<kms_ke\
    y_name>`.\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xda\x04\x02\x08\n\r\n\
    \x05\x04\x0e\x02\x01\x01\x12\x04\xda\x04\t\x15\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\xda\x04\x18\x19\n\x0f\n\x05\x04\x0e\x02\x01\x08\x12\x06\xda\
    \x04\x1a\xdf\x04\x03\n\x10\n\x08\x04\x0e\x02\x01\x08\x9c\x08\0\x12\x04\
    \xdb\x04\x04*\n\x11\n\x07\x04\x0e\x02\x01\x08\x9f\x08\x12\x06\xdc\x04\
    \x04\xde\x04\x05b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
