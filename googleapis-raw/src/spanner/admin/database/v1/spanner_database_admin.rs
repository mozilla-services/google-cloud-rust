// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/spanner/admin/database/v1/spanner_database_admin.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct RestoreInfo {
    // message fields
    pub source_type: RestoreSourceType,
    // message oneof groups
    pub source_info: ::std::option::Option<RestoreInfo_oneof_source_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreInfo {
    fn default() -> &'a RestoreInfo {
        <RestoreInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RestoreInfo_oneof_source_info {
    backup_info(super::backup::BackupInfo),
}

impl RestoreInfo {
    pub fn new() -> RestoreInfo {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.RestoreSourceType source_type = 1;


    pub fn get_source_type(&self) -> RestoreSourceType {
        self.source_type
    }
    pub fn clear_source_type(&mut self) {
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: RestoreSourceType) {
        self.source_type = v;
    }

    // .google.spanner.admin.database.v1.BackupInfo backup_info = 2;


    pub fn get_backup_info(&self) -> &super::backup::BackupInfo {
        match self.source_info {
            ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(ref v)) => v,
            _ => <super::backup::BackupInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_backup_info(&mut self) {
        self.source_info = ::std::option::Option::None;
    }

    pub fn has_backup_info(&self) -> bool {
        match self.source_info {
            ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backup_info(&mut self, v: super::backup::BackupInfo) {
        self.source_info = ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backup_info(&mut self) -> &mut super::backup::BackupInfo {
        if let ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(_)) = self.source_info {
        } else {
            self.source_info = ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(super::backup::BackupInfo::new()));
        }
        match self.source_info {
            ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backup_info(&mut self) -> super::backup::BackupInfo {
        if self.has_backup_info() {
            match self.source_info.take() {
                ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(v)) => v,
                _ => panic!(),
            }
        } else {
            super::backup::BackupInfo::new()
        }
    }
}

impl ::protobuf::Message for RestoreInfo {
    fn is_initialized(&self) -> bool {
        if let Some(RestoreInfo_oneof_source_info::backup_info(ref v)) = self.source_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source_info = ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.source_type);
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreInfo_oneof_source_info::backup_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.source_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreInfo_oneof_source_info::backup_info(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreInfo {
        RestoreInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestoreSourceType>>(
                "source_type",
                |m: &RestoreInfo| { &m.source_type },
                |m: &mut RestoreInfo| { &mut m.source_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::backup::BackupInfo>(
                "backup_info",
                RestoreInfo::has_backup_info,
                RestoreInfo::get_backup_info,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreInfo>(
                "RestoreInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreInfo {
        static instance: ::protobuf::rt::LazyV2<RestoreInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreInfo::new)
    }
}

impl ::protobuf::Clear for RestoreInfo {
    fn clear(&mut self) {
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
        self.source_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Database {
    // message fields
    pub name: ::std::string::String,
    pub state: Database_State,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub restore_info: ::protobuf::SingularPtrField<RestoreInfo>,
    pub encryption_config: ::protobuf::SingularPtrField<super::common::EncryptionConfig>,
    pub encryption_info: ::protobuf::RepeatedField<super::common::EncryptionInfo>,
    pub version_retention_period: ::std::string::String,
    pub earliest_version_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub default_leader: ::std::string::String,
    pub database_dialect: super::common::DatabaseDialect,
    pub enable_drop_protection: bool,
    pub reconciling: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Database {
    fn default() -> &'a Database {
        <Database as ::protobuf::Message>::default_instance()
    }
}

impl Database {
    pub fn new() -> Database {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.Database.State state = 2;


    pub fn get_state(&self) -> Database_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Database_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Database_State) {
        self.state = v;
    }

    // .google.protobuf.Timestamp create_time = 3;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.spanner.admin.database.v1.RestoreInfo restore_info = 4;


    pub fn get_restore_info(&self) -> &RestoreInfo {
        self.restore_info.as_ref().unwrap_or_else(|| <RestoreInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_restore_info(&mut self) {
        self.restore_info.clear();
    }

    pub fn has_restore_info(&self) -> bool {
        self.restore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restore_info(&mut self, v: RestoreInfo) {
        self.restore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restore_info(&mut self) -> &mut RestoreInfo {
        if self.restore_info.is_none() {
            self.restore_info.set_default();
        }
        self.restore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_restore_info(&mut self) -> RestoreInfo {
        self.restore_info.take().unwrap_or_else(|| RestoreInfo::new())
    }

    // .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 5;


    pub fn get_encryption_config(&self) -> &super::common::EncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <super::common::EncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: super::common::EncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut super::common::EncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> super::common::EncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| super::common::EncryptionConfig::new())
    }

    // repeated .google.spanner.admin.database.v1.EncryptionInfo encryption_info = 8;


    pub fn get_encryption_info(&self) -> &[super::common::EncryptionInfo] {
        &self.encryption_info
    }
    pub fn clear_encryption_info(&mut self) {
        self.encryption_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_info(&mut self, v: ::protobuf::RepeatedField<super::common::EncryptionInfo>) {
        self.encryption_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryption_info(&mut self) -> &mut ::protobuf::RepeatedField<super::common::EncryptionInfo> {
        &mut self.encryption_info
    }

    // Take field
    pub fn take_encryption_info(&mut self) -> ::protobuf::RepeatedField<super::common::EncryptionInfo> {
        ::std::mem::replace(&mut self.encryption_info, ::protobuf::RepeatedField::new())
    }

    // string version_retention_period = 6;


    pub fn get_version_retention_period(&self) -> &str {
        &self.version_retention_period
    }
    pub fn clear_version_retention_period(&mut self) {
        self.version_retention_period.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_retention_period(&mut self, v: ::std::string::String) {
        self.version_retention_period = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_retention_period(&mut self) -> &mut ::std::string::String {
        &mut self.version_retention_period
    }

    // Take field
    pub fn take_version_retention_period(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_retention_period, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp earliest_version_time = 7;


    pub fn get_earliest_version_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.earliest_version_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_earliest_version_time(&mut self) {
        self.earliest_version_time.clear();
    }

    pub fn has_earliest_version_time(&self) -> bool {
        self.earliest_version_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_earliest_version_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.earliest_version_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_earliest_version_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.earliest_version_time.is_none() {
            self.earliest_version_time.set_default();
        }
        self.earliest_version_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_earliest_version_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.earliest_version_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string default_leader = 9;


    pub fn get_default_leader(&self) -> &str {
        &self.default_leader
    }
    pub fn clear_default_leader(&mut self) {
        self.default_leader.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_leader(&mut self, v: ::std::string::String) {
        self.default_leader = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_leader(&mut self) -> &mut ::std::string::String {
        &mut self.default_leader
    }

    // Take field
    pub fn take_default_leader(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_leader, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.DatabaseDialect database_dialect = 10;


    pub fn get_database_dialect(&self) -> super::common::DatabaseDialect {
        self.database_dialect
    }
    pub fn clear_database_dialect(&mut self) {
        self.database_dialect = super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_database_dialect(&mut self, v: super::common::DatabaseDialect) {
        self.database_dialect = v;
    }

    // bool enable_drop_protection = 11;


    pub fn get_enable_drop_protection(&self) -> bool {
        self.enable_drop_protection
    }
    pub fn clear_enable_drop_protection(&mut self) {
        self.enable_drop_protection = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_drop_protection(&mut self, v: bool) {
        self.enable_drop_protection = v;
    }

    // bool reconciling = 12;


    pub fn get_reconciling(&self) -> bool {
        self.reconciling
    }
    pub fn clear_reconciling(&mut self) {
        self.reconciling = false;
    }

    // Param is passed by value, moved
    pub fn set_reconciling(&mut self, v: bool) {
        self.reconciling = v;
    }
}

impl ::protobuf::Message for Database {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.earliest_version_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.restore_info)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryption_info)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_retention_period)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.earliest_version_time)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_leader)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.database_dialect, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_drop_protection = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reconciling = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.state != Database_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.state);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.restore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.encryption_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.version_retention_period.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.version_retention_period);
        }
        if let Some(ref v) = self.earliest_version_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.default_leader.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.default_leader);
        }
        if self.database_dialect != super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(10, self.database_dialect);
        }
        if self.enable_drop_protection != false {
            my_size += 2;
        }
        if self.reconciling != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.state != Database_State::STATE_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.restore_info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.encryption_info {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.version_retention_period.is_empty() {
            os.write_string(6, &self.version_retention_period)?;
        }
        if let Some(ref v) = self.earliest_version_time.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.default_leader.is_empty() {
            os.write_string(9, &self.default_leader)?;
        }
        if self.database_dialect != super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.database_dialect))?;
        }
        if self.enable_drop_protection != false {
            os.write_bool(11, self.enable_drop_protection)?;
        }
        if self.reconciling != false {
            os.write_bool(12, self.reconciling)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Database {
        Database::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Database| { &m.name },
                |m: &mut Database| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Database_State>>(
                "state",
                |m: &Database| { &m.state },
                |m: &mut Database| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &Database| { &m.create_time },
                |m: &mut Database| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreInfo>>(
                "restore_info",
                |m: &Database| { &m.restore_info },
                |m: &mut Database| { &mut m.restore_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionConfig>>(
                "encryption_config",
                |m: &Database| { &m.encryption_config },
                |m: &mut Database| { &mut m.encryption_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionInfo>>(
                "encryption_info",
                |m: &Database| { &m.encryption_info },
                |m: &mut Database| { &mut m.encryption_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_retention_period",
                |m: &Database| { &m.version_retention_period },
                |m: &mut Database| { &mut m.version_retention_period },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "earliest_version_time",
                |m: &Database| { &m.earliest_version_time },
                |m: &mut Database| { &mut m.earliest_version_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_leader",
                |m: &Database| { &m.default_leader },
                |m: &mut Database| { &mut m.default_leader },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::DatabaseDialect>>(
                "database_dialect",
                |m: &Database| { &m.database_dialect },
                |m: &mut Database| { &mut m.database_dialect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_drop_protection",
                |m: &Database| { &m.enable_drop_protection },
                |m: &mut Database| { &mut m.enable_drop_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reconciling",
                |m: &Database| { &m.reconciling },
                |m: &mut Database| { &mut m.reconciling },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Database>(
                "Database",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Database {
        static instance: ::protobuf::rt::LazyV2<Database> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Database::new)
    }
}

impl ::protobuf::Clear for Database {
    fn clear(&mut self) {
        self.name.clear();
        self.state = Database_State::STATE_UNSPECIFIED;
        self.create_time.clear();
        self.restore_info.clear();
        self.encryption_config.clear();
        self.encryption_info.clear();
        self.version_retention_period.clear();
        self.earliest_version_time.clear();
        self.default_leader.clear();
        self.database_dialect = super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED;
        self.enable_drop_protection = false;
        self.reconciling = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Database {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Database {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Database_State {
    STATE_UNSPECIFIED = 0,
    CREATING = 1,
    READY = 2,
    READY_OPTIMIZING = 3,
}

impl ::protobuf::ProtobufEnum for Database_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Database_State> {
        match value {
            0 => ::std::option::Option::Some(Database_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Database_State::CREATING),
            2 => ::std::option::Option::Some(Database_State::READY),
            3 => ::std::option::Option::Some(Database_State::READY_OPTIMIZING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Database_State] = &[
            Database_State::STATE_UNSPECIFIED,
            Database_State::CREATING,
            Database_State::READY,
            Database_State::READY_OPTIMIZING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Database_State>("Database.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Database_State {
}

impl ::std::default::Default for Database_State {
    fn default() -> Self {
        Database_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Database_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabasesRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabasesRequest {
    fn default() -> &'a ListDatabasesRequest {
        <ListDatabasesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabasesRequest {
    pub fn new() -> ListDatabasesRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabasesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabasesRequest {
        ListDatabasesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListDatabasesRequest| { &m.parent },
                |m: &mut ListDatabasesRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListDatabasesRequest| { &m.page_size },
                |m: &mut ListDatabasesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListDatabasesRequest| { &m.page_token },
                |m: &mut ListDatabasesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabasesRequest>(
                "ListDatabasesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabasesRequest {
        static instance: ::protobuf::rt::LazyV2<ListDatabasesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabasesRequest::new)
    }
}

impl ::protobuf::Clear for ListDatabasesRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabasesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabasesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabasesResponse {
    // message fields
    pub databases: ::protobuf::RepeatedField<Database>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabasesResponse {
    fn default() -> &'a ListDatabasesResponse {
        <ListDatabasesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabasesResponse {
    pub fn new() -> ListDatabasesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.spanner.admin.database.v1.Database databases = 1;


    pub fn get_databases(&self) -> &[Database] {
        &self.databases
    }
    pub fn clear_databases(&mut self) {
        self.databases.clear();
    }

    // Param is passed by value, moved
    pub fn set_databases(&mut self, v: ::protobuf::RepeatedField<Database>) {
        self.databases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_databases(&mut self) -> &mut ::protobuf::RepeatedField<Database> {
        &mut self.databases
    }

    // Take field
    pub fn take_databases(&mut self) -> ::protobuf::RepeatedField<Database> {
        ::std::mem::replace(&mut self.databases, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabasesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.databases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.databases)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.databases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.databases {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabasesResponse {
        ListDatabasesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Database>>(
                "databases",
                |m: &ListDatabasesResponse| { &m.databases },
                |m: &mut ListDatabasesResponse| { &mut m.databases },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListDatabasesResponse| { &m.next_page_token },
                |m: &mut ListDatabasesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabasesResponse>(
                "ListDatabasesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabasesResponse {
        static instance: ::protobuf::rt::LazyV2<ListDatabasesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabasesResponse::new)
    }
}

impl ::protobuf::Clear for ListDatabasesResponse {
    fn clear(&mut self) {
        self.databases.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabasesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabasesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateDatabaseRequest {
    // message fields
    pub parent: ::std::string::String,
    pub create_statement: ::std::string::String,
    pub extra_statements: ::protobuf::RepeatedField<::std::string::String>,
    pub encryption_config: ::protobuf::SingularPtrField<super::common::EncryptionConfig>,
    pub database_dialect: super::common::DatabaseDialect,
    pub proto_descriptors: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateDatabaseRequest {
    fn default() -> &'a CreateDatabaseRequest {
        <CreateDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateDatabaseRequest {
    pub fn new() -> CreateDatabaseRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string create_statement = 2;


    pub fn get_create_statement(&self) -> &str {
        &self.create_statement
    }
    pub fn clear_create_statement(&mut self) {
        self.create_statement.clear();
    }

    // Param is passed by value, moved
    pub fn set_create_statement(&mut self, v: ::std::string::String) {
        self.create_statement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_statement(&mut self) -> &mut ::std::string::String {
        &mut self.create_statement
    }

    // Take field
    pub fn take_create_statement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.create_statement, ::std::string::String::new())
    }

    // repeated string extra_statements = 3;


    pub fn get_extra_statements(&self) -> &[::std::string::String] {
        &self.extra_statements
    }
    pub fn clear_extra_statements(&mut self) {
        self.extra_statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.extra_statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.extra_statements
    }

    // Take field
    pub fn take_extra_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.extra_statements, ::protobuf::RepeatedField::new())
    }

    // .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 4;


    pub fn get_encryption_config(&self) -> &super::common::EncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <super::common::EncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: super::common::EncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut super::common::EncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> super::common::EncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| super::common::EncryptionConfig::new())
    }

    // .google.spanner.admin.database.v1.DatabaseDialect database_dialect = 5;


    pub fn get_database_dialect(&self) -> super::common::DatabaseDialect {
        self.database_dialect
    }
    pub fn clear_database_dialect(&mut self) {
        self.database_dialect = super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_database_dialect(&mut self, v: super::common::DatabaseDialect) {
        self.database_dialect = v;
    }

    // bytes proto_descriptors = 6;


    pub fn get_proto_descriptors(&self) -> &[u8] {
        &self.proto_descriptors
    }
    pub fn clear_proto_descriptors(&mut self) {
        self.proto_descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_proto_descriptors(&mut self, v: ::std::vec::Vec<u8>) {
        self.proto_descriptors = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proto_descriptors(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proto_descriptors
    }

    // Take field
    pub fn take_proto_descriptors(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proto_descriptors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CreateDatabaseRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.create_statement)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extra_statements)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.database_dialect, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proto_descriptors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.create_statement.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.create_statement);
        }
        for value in &self.extra_statements {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.database_dialect != super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.database_dialect);
        }
        if !self.proto_descriptors.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.proto_descriptors);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.create_statement.is_empty() {
            os.write_string(2, &self.create_statement)?;
        }
        for v in &self.extra_statements {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.database_dialect != super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.database_dialect))?;
        }
        if !self.proto_descriptors.is_empty() {
            os.write_bytes(6, &self.proto_descriptors)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateDatabaseRequest {
        CreateDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateDatabaseRequest| { &m.parent },
                |m: &mut CreateDatabaseRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "create_statement",
                |m: &CreateDatabaseRequest| { &m.create_statement },
                |m: &mut CreateDatabaseRequest| { &mut m.create_statement },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extra_statements",
                |m: &CreateDatabaseRequest| { &m.extra_statements },
                |m: &mut CreateDatabaseRequest| { &mut m.extra_statements },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionConfig>>(
                "encryption_config",
                |m: &CreateDatabaseRequest| { &m.encryption_config },
                |m: &mut CreateDatabaseRequest| { &mut m.encryption_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::DatabaseDialect>>(
                "database_dialect",
                |m: &CreateDatabaseRequest| { &m.database_dialect },
                |m: &mut CreateDatabaseRequest| { &mut m.database_dialect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proto_descriptors",
                |m: &CreateDatabaseRequest| { &m.proto_descriptors },
                |m: &mut CreateDatabaseRequest| { &mut m.proto_descriptors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateDatabaseRequest>(
                "CreateDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<CreateDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for CreateDatabaseRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.create_statement.clear();
        self.extra_statements.clear();
        self.encryption_config.clear();
        self.database_dialect = super::common::DatabaseDialect::DATABASE_DIALECT_UNSPECIFIED;
        self.proto_descriptors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateDatabaseMetadata {
    // message fields
    pub database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateDatabaseMetadata {
    fn default() -> &'a CreateDatabaseMetadata {
        <CreateDatabaseMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CreateDatabaseMetadata {
    pub fn new() -> CreateDatabaseMetadata {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateDatabaseMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateDatabaseMetadata {
        CreateDatabaseMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &CreateDatabaseMetadata| { &m.database },
                |m: &mut CreateDatabaseMetadata| { &mut m.database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateDatabaseMetadata>(
                "CreateDatabaseMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateDatabaseMetadata {
        static instance: ::protobuf::rt::LazyV2<CreateDatabaseMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateDatabaseMetadata::new)
    }
}

impl ::protobuf::Clear for CreateDatabaseMetadata {
    fn clear(&mut self) {
        self.database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateDatabaseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDatabaseMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatabaseRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatabaseRequest {
    fn default() -> &'a GetDatabaseRequest {
        <GetDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatabaseRequest {
    pub fn new() -> GetDatabaseRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDatabaseRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatabaseRequest {
        GetDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetDatabaseRequest| { &m.name },
                |m: &mut GetDatabaseRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatabaseRequest>(
                "GetDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<GetDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for GetDatabaseRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDatabaseRequest {
    // message fields
    pub database: ::protobuf::SingularPtrField<Database>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDatabaseRequest {
    fn default() -> &'a UpdateDatabaseRequest {
        <UpdateDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDatabaseRequest {
    pub fn new() -> UpdateDatabaseRequest {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.Database database = 1;


    pub fn get_database(&self) -> &Database {
        self.database.as_ref().unwrap_or_else(|| <Database as ::protobuf::Message>::default_instance())
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    pub fn has_database(&self) -> bool {
        self.database.is_some()
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: Database) {
        self.database = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut Database {
        if self.database.is_none() {
            self.database.set_default();
        }
        self.database.as_mut().unwrap()
    }

    // Take field
    pub fn take_database(&mut self) -> Database {
        self.database.take().unwrap_or_else(|| Database::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateDatabaseRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.database {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.database.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.database.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDatabaseRequest {
        UpdateDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Database>>(
                "database",
                |m: &UpdateDatabaseRequest| { &m.database },
                |m: &mut UpdateDatabaseRequest| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateDatabaseRequest| { &m.update_mask },
                |m: &mut UpdateDatabaseRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateDatabaseRequest>(
                "UpdateDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for UpdateDatabaseRequest {
    fn clear(&mut self) {
        self.database.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDatabaseMetadata {
    // message fields
    pub request: ::protobuf::SingularPtrField<UpdateDatabaseRequest>,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDatabaseMetadata {
    fn default() -> &'a UpdateDatabaseMetadata {
        <UpdateDatabaseMetadata as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDatabaseMetadata {
    pub fn new() -> UpdateDatabaseMetadata {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.UpdateDatabaseRequest request = 1;


    pub fn get_request(&self) -> &UpdateDatabaseRequest {
        self.request.as_ref().unwrap_or_else(|| <UpdateDatabaseRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: UpdateDatabaseRequest) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut UpdateDatabaseRequest {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> UpdateDatabaseRequest {
        self.request.take().unwrap_or_else(|| UpdateDatabaseRequest::new())
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 2;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }

    // .google.protobuf.Timestamp cancel_time = 3;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for UpdateDatabaseMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDatabaseMetadata {
        UpdateDatabaseMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateDatabaseRequest>>(
                "request",
                |m: &UpdateDatabaseMetadata| { &m.request },
                |m: &mut UpdateDatabaseMetadata| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &UpdateDatabaseMetadata| { &m.progress },
                |m: &mut UpdateDatabaseMetadata| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "cancel_time",
                |m: &UpdateDatabaseMetadata| { &m.cancel_time },
                |m: &mut UpdateDatabaseMetadata| { &mut m.cancel_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateDatabaseMetadata>(
                "UpdateDatabaseMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateDatabaseMetadata {
        static instance: ::protobuf::rt::LazyV2<UpdateDatabaseMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDatabaseMetadata::new)
    }
}

impl ::protobuf::Clear for UpdateDatabaseMetadata {
    fn clear(&mut self) {
        self.request.clear();
        self.progress.clear();
        self.cancel_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDatabaseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDatabaseMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDatabaseDdlRequest {
    // message fields
    pub database: ::std::string::String,
    pub statements: ::protobuf::RepeatedField<::std::string::String>,
    pub operation_id: ::std::string::String,
    pub proto_descriptors: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDatabaseDdlRequest {
    fn default() -> &'a UpdateDatabaseDdlRequest {
        <UpdateDatabaseDdlRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDatabaseDdlRequest {
    pub fn new() -> UpdateDatabaseDdlRequest {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // repeated string statements = 2;


    pub fn get_statements(&self) -> &[::std::string::String] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }

    // string operation_id = 3;


    pub fn get_operation_id(&self) -> &str {
        &self.operation_id
    }
    pub fn clear_operation_id(&mut self) {
        self.operation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_id(&mut self, v: ::std::string::String) {
        self.operation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_id(&mut self) -> &mut ::std::string::String {
        &mut self.operation_id
    }

    // Take field
    pub fn take_operation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_id, ::std::string::String::new())
    }

    // bytes proto_descriptors = 4;


    pub fn get_proto_descriptors(&self) -> &[u8] {
        &self.proto_descriptors
    }
    pub fn clear_proto_descriptors(&mut self) {
        self.proto_descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_proto_descriptors(&mut self, v: ::std::vec::Vec<u8>) {
        self.proto_descriptors = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proto_descriptors(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proto_descriptors
    }

    // Take field
    pub fn take_proto_descriptors(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proto_descriptors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UpdateDatabaseDdlRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.statements)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proto_descriptors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        for value in &self.statements {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.operation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.operation_id);
        }
        if !self.proto_descriptors.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.proto_descriptors);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        for v in &self.statements {
            os.write_string(2, &v)?;
        };
        if !self.operation_id.is_empty() {
            os.write_string(3, &self.operation_id)?;
        }
        if !self.proto_descriptors.is_empty() {
            os.write_bytes(4, &self.proto_descriptors)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDatabaseDdlRequest {
        UpdateDatabaseDdlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &UpdateDatabaseDdlRequest| { &m.database },
                |m: &mut UpdateDatabaseDdlRequest| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statements",
                |m: &UpdateDatabaseDdlRequest| { &m.statements },
                |m: &mut UpdateDatabaseDdlRequest| { &mut m.statements },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation_id",
                |m: &UpdateDatabaseDdlRequest| { &m.operation_id },
                |m: &mut UpdateDatabaseDdlRequest| { &mut m.operation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proto_descriptors",
                |m: &UpdateDatabaseDdlRequest| { &m.proto_descriptors },
                |m: &mut UpdateDatabaseDdlRequest| { &mut m.proto_descriptors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateDatabaseDdlRequest>(
                "UpdateDatabaseDdlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateDatabaseDdlRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateDatabaseDdlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDatabaseDdlRequest::new)
    }
}

impl ::protobuf::Clear for UpdateDatabaseDdlRequest {
    fn clear(&mut self) {
        self.database.clear();
        self.statements.clear();
        self.operation_id.clear();
        self.proto_descriptors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDatabaseDdlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDatabaseDdlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DdlStatementActionInfo {
    // message fields
    pub action: ::std::string::String,
    pub entity_type: ::std::string::String,
    pub entity_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DdlStatementActionInfo {
    fn default() -> &'a DdlStatementActionInfo {
        <DdlStatementActionInfo as ::protobuf::Message>::default_instance()
    }
}

impl DdlStatementActionInfo {
    pub fn new() -> DdlStatementActionInfo {
        ::std::default::Default::default()
    }

    // string action = 1;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }

    // string entity_type = 2;


    pub fn get_entity_type(&self) -> &str {
        &self.entity_type
    }
    pub fn clear_entity_type(&mut self) {
        self.entity_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_type(&mut self, v: ::std::string::String) {
        self.entity_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_type(&mut self) -> &mut ::std::string::String {
        &mut self.entity_type
    }

    // Take field
    pub fn take_entity_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_type, ::std::string::String::new())
    }

    // repeated string entity_names = 3;


    pub fn get_entity_names(&self) -> &[::std::string::String] {
        &self.entity_names
    }
    pub fn clear_entity_names(&mut self) {
        self.entity_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.entity_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entity_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.entity_names
    }

    // Take field
    pub fn take_entity_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.entity_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DdlStatementActionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_type)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.entity_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.action);
        }
        if !self.entity_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity_type);
        }
        for value in &self.entity_names {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.action.is_empty() {
            os.write_string(1, &self.action)?;
        }
        if !self.entity_type.is_empty() {
            os.write_string(2, &self.entity_type)?;
        }
        for v in &self.entity_names {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DdlStatementActionInfo {
        DdlStatementActionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &DdlStatementActionInfo| { &m.action },
                |m: &mut DdlStatementActionInfo| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_type",
                |m: &DdlStatementActionInfo| { &m.entity_type },
                |m: &mut DdlStatementActionInfo| { &mut m.entity_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_names",
                |m: &DdlStatementActionInfo| { &m.entity_names },
                |m: &mut DdlStatementActionInfo| { &mut m.entity_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DdlStatementActionInfo>(
                "DdlStatementActionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DdlStatementActionInfo {
        static instance: ::protobuf::rt::LazyV2<DdlStatementActionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DdlStatementActionInfo::new)
    }
}

impl ::protobuf::Clear for DdlStatementActionInfo {
    fn clear(&mut self) {
        self.action.clear();
        self.entity_type.clear();
        self.entity_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DdlStatementActionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DdlStatementActionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDatabaseDdlMetadata {
    // message fields
    pub database: ::std::string::String,
    pub statements: ::protobuf::RepeatedField<::std::string::String>,
    pub commit_timestamps: ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp>,
    pub throttled: bool,
    pub progress: ::protobuf::RepeatedField<super::common::OperationProgress>,
    pub actions: ::protobuf::RepeatedField<DdlStatementActionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDatabaseDdlMetadata {
    fn default() -> &'a UpdateDatabaseDdlMetadata {
        <UpdateDatabaseDdlMetadata as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDatabaseDdlMetadata {
    pub fn new() -> UpdateDatabaseDdlMetadata {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // repeated string statements = 2;


    pub fn get_statements(&self) -> &[::std::string::String] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }

    // repeated .google.protobuf.Timestamp commit_timestamps = 3;


    pub fn get_commit_timestamps(&self) -> &[::protobuf::well_known_types::Timestamp] {
        &self.commit_timestamps
    }
    pub fn clear_commit_timestamps(&mut self) {
        self.commit_timestamps.clear();
    }

    // Param is passed by value, moved
    pub fn set_commit_timestamps(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp>) {
        self.commit_timestamps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commit_timestamps(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp> {
        &mut self.commit_timestamps
    }

    // Take field
    pub fn take_commit_timestamps(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp> {
        ::std::mem::replace(&mut self.commit_timestamps, ::protobuf::RepeatedField::new())
    }

    // bool throttled = 4;


    pub fn get_throttled(&self) -> bool {
        self.throttled
    }
    pub fn clear_throttled(&mut self) {
        self.throttled = false;
    }

    // Param is passed by value, moved
    pub fn set_throttled(&mut self, v: bool) {
        self.throttled = v;
    }

    // repeated .google.spanner.admin.database.v1.OperationProgress progress = 5;


    pub fn get_progress(&self) -> &[super::common::OperationProgress] {
        &self.progress
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: ::protobuf::RepeatedField<super::common::OperationProgress>) {
        self.progress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_progress(&mut self) -> &mut ::protobuf::RepeatedField<super::common::OperationProgress> {
        &mut self.progress
    }

    // Take field
    pub fn take_progress(&mut self) -> ::protobuf::RepeatedField<super::common::OperationProgress> {
        ::std::mem::replace(&mut self.progress, ::protobuf::RepeatedField::new())
    }

    // repeated .google.spanner.admin.database.v1.DdlStatementActionInfo actions = 6;


    pub fn get_actions(&self) -> &[DdlStatementActionInfo] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<DdlStatementActionInfo>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<DdlStatementActionInfo> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<DdlStatementActionInfo> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateDatabaseDdlMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.commit_timestamps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.statements)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.commit_timestamps)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.throttled = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.progress)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        for value in &self.statements {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.commit_timestamps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.throttled != false {
            my_size += 2;
        }
        for value in &self.progress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        for v in &self.statements {
            os.write_string(2, &v)?;
        };
        for v in &self.commit_timestamps {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.throttled != false {
            os.write_bool(4, self.throttled)?;
        }
        for v in &self.progress {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.actions {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDatabaseDdlMetadata {
        UpdateDatabaseDdlMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &UpdateDatabaseDdlMetadata| { &m.database },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statements",
                |m: &UpdateDatabaseDdlMetadata| { &m.statements },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.statements },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "commit_timestamps",
                |m: &UpdateDatabaseDdlMetadata| { &m.commit_timestamps },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.commit_timestamps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "throttled",
                |m: &UpdateDatabaseDdlMetadata| { &m.throttled },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.throttled },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &UpdateDatabaseDdlMetadata| { &m.progress },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DdlStatementActionInfo>>(
                "actions",
                |m: &UpdateDatabaseDdlMetadata| { &m.actions },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateDatabaseDdlMetadata>(
                "UpdateDatabaseDdlMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateDatabaseDdlMetadata {
        static instance: ::protobuf::rt::LazyV2<UpdateDatabaseDdlMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDatabaseDdlMetadata::new)
    }
}

impl ::protobuf::Clear for UpdateDatabaseDdlMetadata {
    fn clear(&mut self) {
        self.database.clear();
        self.statements.clear();
        self.commit_timestamps.clear();
        self.throttled = false;
        self.progress.clear();
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDatabaseDdlMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDatabaseDdlMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DropDatabaseRequest {
    // message fields
    pub database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DropDatabaseRequest {
    fn default() -> &'a DropDatabaseRequest {
        <DropDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropDatabaseRequest {
    pub fn new() -> DropDatabaseRequest {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DropDatabaseRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DropDatabaseRequest {
        DropDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &DropDatabaseRequest| { &m.database },
                |m: &mut DropDatabaseRequest| { &mut m.database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DropDatabaseRequest>(
                "DropDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DropDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<DropDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DropDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for DropDatabaseRequest {
    fn clear(&mut self) {
        self.database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DropDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatabaseDdlRequest {
    // message fields
    pub database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatabaseDdlRequest {
    fn default() -> &'a GetDatabaseDdlRequest {
        <GetDatabaseDdlRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatabaseDdlRequest {
    pub fn new() -> GetDatabaseDdlRequest {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDatabaseDdlRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatabaseDdlRequest {
        GetDatabaseDdlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &GetDatabaseDdlRequest| { &m.database },
                |m: &mut GetDatabaseDdlRequest| { &mut m.database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatabaseDdlRequest>(
                "GetDatabaseDdlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatabaseDdlRequest {
        static instance: ::protobuf::rt::LazyV2<GetDatabaseDdlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatabaseDdlRequest::new)
    }
}

impl ::protobuf::Clear for GetDatabaseDdlRequest {
    fn clear(&mut self) {
        self.database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatabaseDdlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatabaseDdlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatabaseDdlResponse {
    // message fields
    pub statements: ::protobuf::RepeatedField<::std::string::String>,
    pub proto_descriptors: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatabaseDdlResponse {
    fn default() -> &'a GetDatabaseDdlResponse {
        <GetDatabaseDdlResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDatabaseDdlResponse {
    pub fn new() -> GetDatabaseDdlResponse {
        ::std::default::Default::default()
    }

    // repeated string statements = 1;


    pub fn get_statements(&self) -> &[::std::string::String] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }

    // bytes proto_descriptors = 2;


    pub fn get_proto_descriptors(&self) -> &[u8] {
        &self.proto_descriptors
    }
    pub fn clear_proto_descriptors(&mut self) {
        self.proto_descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_proto_descriptors(&mut self, v: ::std::vec::Vec<u8>) {
        self.proto_descriptors = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proto_descriptors(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proto_descriptors
    }

    // Take field
    pub fn take_proto_descriptors(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proto_descriptors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetDatabaseDdlResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.statements)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proto_descriptors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statements {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.proto_descriptors.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proto_descriptors);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statements {
            os.write_string(1, &v)?;
        };
        if !self.proto_descriptors.is_empty() {
            os.write_bytes(2, &self.proto_descriptors)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatabaseDdlResponse {
        GetDatabaseDdlResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statements",
                |m: &GetDatabaseDdlResponse| { &m.statements },
                |m: &mut GetDatabaseDdlResponse| { &mut m.statements },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proto_descriptors",
                |m: &GetDatabaseDdlResponse| { &m.proto_descriptors },
                |m: &mut GetDatabaseDdlResponse| { &mut m.proto_descriptors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatabaseDdlResponse>(
                "GetDatabaseDdlResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatabaseDdlResponse {
        static instance: ::protobuf::rt::LazyV2<GetDatabaseDdlResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatabaseDdlResponse::new)
    }
}

impl ::protobuf::Clear for GetDatabaseDdlResponse {
    fn clear(&mut self) {
        self.statements.clear();
        self.proto_descriptors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatabaseDdlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatabaseDdlResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabaseOperationsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabaseOperationsRequest {
    fn default() -> &'a ListDatabaseOperationsRequest {
        <ListDatabaseOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabaseOperationsRequest {
    pub fn new() -> ListDatabaseOperationsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabaseOperationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabaseOperationsRequest {
        ListDatabaseOperationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListDatabaseOperationsRequest| { &m.parent },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListDatabaseOperationsRequest| { &m.filter },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListDatabaseOperationsRequest| { &m.page_size },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListDatabaseOperationsRequest| { &m.page_token },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabaseOperationsRequest>(
                "ListDatabaseOperationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabaseOperationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListDatabaseOperationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabaseOperationsRequest::new)
    }
}

impl ::protobuf::Clear for ListDatabaseOperationsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabaseOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabaseOperationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabaseOperationsResponse {
    // message fields
    pub operations: ::protobuf::RepeatedField<super::operations::Operation>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabaseOperationsResponse {
    fn default() -> &'a ListDatabaseOperationsResponse {
        <ListDatabaseOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabaseOperationsResponse {
    pub fn new() -> ListDatabaseOperationsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.longrunning.Operation operations = 1;


    pub fn get_operations(&self) -> &[super::operations::Operation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<super::operations::Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<super::operations::Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<super::operations::Operation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabaseOperationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.operations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabaseOperationsResponse {
        ListDatabaseOperationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::operations::Operation>>(
                "operations",
                |m: &ListDatabaseOperationsResponse| { &m.operations },
                |m: &mut ListDatabaseOperationsResponse| { &mut m.operations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListDatabaseOperationsResponse| { &m.next_page_token },
                |m: &mut ListDatabaseOperationsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabaseOperationsResponse>(
                "ListDatabaseOperationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabaseOperationsResponse {
        static instance: ::protobuf::rt::LazyV2<ListDatabaseOperationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabaseOperationsResponse::new)
    }
}

impl ::protobuf::Clear for ListDatabaseOperationsResponse {
    fn clear(&mut self) {
        self.operations.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabaseOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabaseOperationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreDatabaseRequest {
    // message fields
    pub parent: ::std::string::String,
    pub database_id: ::std::string::String,
    pub encryption_config: ::protobuf::SingularPtrField<RestoreDatabaseEncryptionConfig>,
    // message oneof groups
    pub source: ::std::option::Option<RestoreDatabaseRequest_oneof_source>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreDatabaseRequest {
    fn default() -> &'a RestoreDatabaseRequest {
        <RestoreDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RestoreDatabaseRequest_oneof_source {
    backup(::std::string::String),
}

impl RestoreDatabaseRequest {
    pub fn new() -> RestoreDatabaseRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string database_id = 2;


    pub fn get_database_id(&self) -> &str {
        &self.database_id
    }
    pub fn clear_database_id(&mut self) {
        self.database_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_database_id(&mut self, v: ::std::string::String) {
        self.database_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database_id(&mut self) -> &mut ::std::string::String {
        &mut self.database_id
    }

    // Take field
    pub fn take_database_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database_id, ::std::string::String::new())
    }

    // string backup = 3;


    pub fn get_backup(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_backup(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_backup(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backup(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backup(&mut self) -> ::std::string::String {
        if self.has_backup() {
            match self.source.take() {
                ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig encryption_config = 4;


    pub fn get_encryption_config(&self) -> &RestoreDatabaseEncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <RestoreDatabaseEncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: RestoreDatabaseEncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut RestoreDatabaseEncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> RestoreDatabaseEncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| RestoreDatabaseEncryptionConfig::new())
    }
}

impl ::protobuf::Message for RestoreDatabaseRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.database_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.database_id);
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &RestoreDatabaseRequest_oneof_source::backup(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.database_id.is_empty() {
            os.write_string(2, &self.database_id)?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &RestoreDatabaseRequest_oneof_source::backup(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreDatabaseRequest {
        RestoreDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &RestoreDatabaseRequest| { &m.parent },
                |m: &mut RestoreDatabaseRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database_id",
                |m: &RestoreDatabaseRequest| { &m.database_id },
                |m: &mut RestoreDatabaseRequest| { &mut m.database_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "backup",
                RestoreDatabaseRequest::has_backup,
                RestoreDatabaseRequest::get_backup,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreDatabaseEncryptionConfig>>(
                "encryption_config",
                |m: &RestoreDatabaseRequest| { &m.encryption_config },
                |m: &mut RestoreDatabaseRequest| { &mut m.encryption_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreDatabaseRequest>(
                "RestoreDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<RestoreDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for RestoreDatabaseRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.database_id.clear();
        self.source = ::std::option::Option::None;
        self.encryption_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreDatabaseEncryptionConfig {
    // message fields
    pub encryption_type: RestoreDatabaseEncryptionConfig_EncryptionType,
    pub kms_key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreDatabaseEncryptionConfig {
    fn default() -> &'a RestoreDatabaseEncryptionConfig {
        <RestoreDatabaseEncryptionConfig as ::protobuf::Message>::default_instance()
    }
}

impl RestoreDatabaseEncryptionConfig {
    pub fn new() -> RestoreDatabaseEncryptionConfig {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.EncryptionType encryption_type = 1;


    pub fn get_encryption_type(&self) -> RestoreDatabaseEncryptionConfig_EncryptionType {
        self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type = RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: RestoreDatabaseEncryptionConfig_EncryptionType) {
        self.encryption_type = v;
    }

    // string kms_key_name = 2;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RestoreDatabaseEncryptionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.encryption_type != RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.encryption_type);
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.encryption_type != RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.encryption_type))?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(2, &self.kms_key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreDatabaseEncryptionConfig {
        RestoreDatabaseEncryptionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestoreDatabaseEncryptionConfig_EncryptionType>>(
                "encryption_type",
                |m: &RestoreDatabaseEncryptionConfig| { &m.encryption_type },
                |m: &mut RestoreDatabaseEncryptionConfig| { &mut m.encryption_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &RestoreDatabaseEncryptionConfig| { &m.kms_key_name },
                |m: &mut RestoreDatabaseEncryptionConfig| { &mut m.kms_key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreDatabaseEncryptionConfig>(
                "RestoreDatabaseEncryptionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreDatabaseEncryptionConfig {
        static instance: ::protobuf::rt::LazyV2<RestoreDatabaseEncryptionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreDatabaseEncryptionConfig::new)
    }
}

impl ::protobuf::Clear for RestoreDatabaseEncryptionConfig {
    fn clear(&mut self) {
        self.encryption_type = RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
        self.kms_key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreDatabaseEncryptionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseEncryptionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RestoreDatabaseEncryptionConfig_EncryptionType {
    ENCRYPTION_TYPE_UNSPECIFIED = 0,
    USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION = 1,
    GOOGLE_DEFAULT_ENCRYPTION = 2,
    CUSTOMER_MANAGED_ENCRYPTION = 3,
}

impl ::protobuf::ProtobufEnum for RestoreDatabaseEncryptionConfig_EncryptionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RestoreDatabaseEncryptionConfig_EncryptionType> {
        match value {
            0 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION),
            2 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION),
            3 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RestoreDatabaseEncryptionConfig_EncryptionType] = &[
            RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED,
            RestoreDatabaseEncryptionConfig_EncryptionType::USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION,
            RestoreDatabaseEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION,
            RestoreDatabaseEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RestoreDatabaseEncryptionConfig_EncryptionType>("RestoreDatabaseEncryptionConfig.EncryptionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RestoreDatabaseEncryptionConfig_EncryptionType {
}

impl ::std::default::Default for RestoreDatabaseEncryptionConfig_EncryptionType {
    fn default() -> Self {
        RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseEncryptionConfig_EncryptionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreDatabaseMetadata {
    // message fields
    pub name: ::std::string::String,
    pub source_type: RestoreSourceType,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub optimize_database_operation_name: ::std::string::String,
    // message oneof groups
    pub source_info: ::std::option::Option<RestoreDatabaseMetadata_oneof_source_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreDatabaseMetadata {
    fn default() -> &'a RestoreDatabaseMetadata {
        <RestoreDatabaseMetadata as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RestoreDatabaseMetadata_oneof_source_info {
    backup_info(super::backup::BackupInfo),
}

impl RestoreDatabaseMetadata {
    pub fn new() -> RestoreDatabaseMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.RestoreSourceType source_type = 2;


    pub fn get_source_type(&self) -> RestoreSourceType {
        self.source_type
    }
    pub fn clear_source_type(&mut self) {
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: RestoreSourceType) {
        self.source_type = v;
    }

    // .google.spanner.admin.database.v1.BackupInfo backup_info = 3;


    pub fn get_backup_info(&self) -> &super::backup::BackupInfo {
        match self.source_info {
            ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v)) => v,
            _ => <super::backup::BackupInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_backup_info(&mut self) {
        self.source_info = ::std::option::Option::None;
    }

    pub fn has_backup_info(&self) -> bool {
        match self.source_info {
            ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backup_info(&mut self, v: super::backup::BackupInfo) {
        self.source_info = ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backup_info(&mut self) -> &mut super::backup::BackupInfo {
        if let ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(_)) = self.source_info {
        } else {
            self.source_info = ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(super::backup::BackupInfo::new()));
        }
        match self.source_info {
            ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backup_info(&mut self) -> super::backup::BackupInfo {
        if self.has_backup_info() {
            match self.source_info.take() {
                ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(v)) => v,
                _ => panic!(),
            }
        } else {
            super::backup::BackupInfo::new()
        }
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 4;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }

    // .google.protobuf.Timestamp cancel_time = 5;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string optimize_database_operation_name = 6;


    pub fn get_optimize_database_operation_name(&self) -> &str {
        &self.optimize_database_operation_name
    }
    pub fn clear_optimize_database_operation_name(&mut self) {
        self.optimize_database_operation_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_optimize_database_operation_name(&mut self, v: ::std::string::String) {
        self.optimize_database_operation_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optimize_database_operation_name(&mut self) -> &mut ::std::string::String {
        &mut self.optimize_database_operation_name
    }

    // Take field
    pub fn take_optimize_database_operation_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.optimize_database_operation_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RestoreDatabaseMetadata {
    fn is_initialized(&self) -> bool {
        if let Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v)) = self.source_info {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source_info = ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.optimize_database_operation_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.source_type);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.optimize_database_operation_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.optimize_database_operation_name);
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.source_type))?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.optimize_database_operation_name.is_empty() {
            os.write_string(6, &self.optimize_database_operation_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreDatabaseMetadata {
        RestoreDatabaseMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RestoreDatabaseMetadata| { &m.name },
                |m: &mut RestoreDatabaseMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestoreSourceType>>(
                "source_type",
                |m: &RestoreDatabaseMetadata| { &m.source_type },
                |m: &mut RestoreDatabaseMetadata| { &mut m.source_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::backup::BackupInfo>(
                "backup_info",
                RestoreDatabaseMetadata::has_backup_info,
                RestoreDatabaseMetadata::get_backup_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &RestoreDatabaseMetadata| { &m.progress },
                |m: &mut RestoreDatabaseMetadata| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "cancel_time",
                |m: &RestoreDatabaseMetadata| { &m.cancel_time },
                |m: &mut RestoreDatabaseMetadata| { &mut m.cancel_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "optimize_database_operation_name",
                |m: &RestoreDatabaseMetadata| { &m.optimize_database_operation_name },
                |m: &mut RestoreDatabaseMetadata| { &mut m.optimize_database_operation_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreDatabaseMetadata>(
                "RestoreDatabaseMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreDatabaseMetadata {
        static instance: ::protobuf::rt::LazyV2<RestoreDatabaseMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreDatabaseMetadata::new)
    }
}

impl ::protobuf::Clear for RestoreDatabaseMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
        self.source_info = ::std::option::Option::None;
        self.progress.clear();
        self.cancel_time.clear();
        self.optimize_database_operation_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreDatabaseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OptimizeRestoredDatabaseMetadata {
    // message fields
    pub name: ::std::string::String,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OptimizeRestoredDatabaseMetadata {
    fn default() -> &'a OptimizeRestoredDatabaseMetadata {
        <OptimizeRestoredDatabaseMetadata as ::protobuf::Message>::default_instance()
    }
}

impl OptimizeRestoredDatabaseMetadata {
    pub fn new() -> OptimizeRestoredDatabaseMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 2;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }
}

impl ::protobuf::Message for OptimizeRestoredDatabaseMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OptimizeRestoredDatabaseMetadata {
        OptimizeRestoredDatabaseMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OptimizeRestoredDatabaseMetadata| { &m.name },
                |m: &mut OptimizeRestoredDatabaseMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &OptimizeRestoredDatabaseMetadata| { &m.progress },
                |m: &mut OptimizeRestoredDatabaseMetadata| { &mut m.progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OptimizeRestoredDatabaseMetadata>(
                "OptimizeRestoredDatabaseMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OptimizeRestoredDatabaseMetadata {
        static instance: ::protobuf::rt::LazyV2<OptimizeRestoredDatabaseMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OptimizeRestoredDatabaseMetadata::new)
    }
}

impl ::protobuf::Clear for OptimizeRestoredDatabaseMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.progress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OptimizeRestoredDatabaseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptimizeRestoredDatabaseMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatabaseRole {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatabaseRole {
    fn default() -> &'a DatabaseRole {
        <DatabaseRole as ::protobuf::Message>::default_instance()
    }
}

impl DatabaseRole {
    pub fn new() -> DatabaseRole {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DatabaseRole {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatabaseRole {
        DatabaseRole::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DatabaseRole| { &m.name },
                |m: &mut DatabaseRole| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatabaseRole>(
                "DatabaseRole",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatabaseRole {
        static instance: ::protobuf::rt::LazyV2<DatabaseRole> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatabaseRole::new)
    }
}

impl ::protobuf::Clear for DatabaseRole {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatabaseRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatabaseRole {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabaseRolesRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabaseRolesRequest {
    fn default() -> &'a ListDatabaseRolesRequest {
        <ListDatabaseRolesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabaseRolesRequest {
    pub fn new() -> ListDatabaseRolesRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabaseRolesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabaseRolesRequest {
        ListDatabaseRolesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListDatabaseRolesRequest| { &m.parent },
                |m: &mut ListDatabaseRolesRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListDatabaseRolesRequest| { &m.page_size },
                |m: &mut ListDatabaseRolesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListDatabaseRolesRequest| { &m.page_token },
                |m: &mut ListDatabaseRolesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabaseRolesRequest>(
                "ListDatabaseRolesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabaseRolesRequest {
        static instance: ::protobuf::rt::LazyV2<ListDatabaseRolesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabaseRolesRequest::new)
    }
}

impl ::protobuf::Clear for ListDatabaseRolesRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabaseRolesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabaseRolesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabaseRolesResponse {
    // message fields
    pub database_roles: ::protobuf::RepeatedField<DatabaseRole>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabaseRolesResponse {
    fn default() -> &'a ListDatabaseRolesResponse {
        <ListDatabaseRolesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabaseRolesResponse {
    pub fn new() -> ListDatabaseRolesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.spanner.admin.database.v1.DatabaseRole database_roles = 1;


    pub fn get_database_roles(&self) -> &[DatabaseRole] {
        &self.database_roles
    }
    pub fn clear_database_roles(&mut self) {
        self.database_roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_database_roles(&mut self, v: ::protobuf::RepeatedField<DatabaseRole>) {
        self.database_roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_database_roles(&mut self) -> &mut ::protobuf::RepeatedField<DatabaseRole> {
        &mut self.database_roles
    }

    // Take field
    pub fn take_database_roles(&mut self) -> ::protobuf::RepeatedField<DatabaseRole> {
        ::std::mem::replace(&mut self.database_roles, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabaseRolesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.database_roles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.database_roles)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.database_roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.database_roles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabaseRolesResponse {
        ListDatabaseRolesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseRole>>(
                "database_roles",
                |m: &ListDatabaseRolesResponse| { &m.database_roles },
                |m: &mut ListDatabaseRolesResponse| { &mut m.database_roles },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListDatabaseRolesResponse| { &m.next_page_token },
                |m: &mut ListDatabaseRolesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabaseRolesResponse>(
                "ListDatabaseRolesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabaseRolesResponse {
        static instance: ::protobuf::rt::LazyV2<ListDatabaseRolesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabaseRolesResponse::new)
    }
}

impl ::protobuf::Clear for ListDatabaseRolesResponse {
    fn clear(&mut self) {
        self.database_roles.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabaseRolesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabaseRolesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RestoreSourceType {
    TYPE_UNSPECIFIED = 0,
    BACKUP = 1,
}

impl ::protobuf::ProtobufEnum for RestoreSourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RestoreSourceType> {
        match value {
            0 => ::std::option::Option::Some(RestoreSourceType::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(RestoreSourceType::BACKUP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RestoreSourceType] = &[
            RestoreSourceType::TYPE_UNSPECIFIED,
            RestoreSourceType::BACKUP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RestoreSourceType>("RestoreSourceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RestoreSourceType {
}

impl ::std::default::Default for RestoreSourceType {
    fn default() -> Self {
        RestoreSourceType::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreSourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n=google/spanner/admin/database/v1/spanner_database_admin.proto\x12\x20\
    google.spanner.admin.database.v1\x1a\x1cgoogle/api/annotations.proto\x1a\
    \x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\
    \x19google/api/resource.proto\x1a\x1egoogle/iam/v1/iam_policy.proto\x1a\
    \x1agoogle/iam/v1/policy.proto\x1a#google/longrunning/operations.proto\
    \x1a\x1bgoogle/protobuf/empty.proto\x1a\x20google/protobuf/field_mask.pr\
    oto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a-google/spanner/admin/data\
    base/v1/backup.proto\x1a-google/spanner/admin/database/v1/common.proto\"\
    \xc3\x01\n\x0bRestoreInfo\x12T\n\x0bsource_type\x18\x01\x20\x01(\x0e23.g\
    oogle.spanner.admin.database.v1.RestoreSourceTypeR\nsourceType\x12O\n\
    \x0bbackup_info\x18\x02\x20\x01(\x0b2,.google.spanner.admin.database.v1.\
    BackupInfoH\0R\nbackupInfoB\r\n\x0bsource_info\"\x82\x08\n\x08Database\
    \x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x03\xe0A\x02\x12K\n\x05s\
    tate\x18\x02\x20\x01(\x0e20.google.spanner.admin.database.v1.Database.St\
    ateR\x05stateB\x03\xe0A\x03\x12@\n\x0bcreate_time\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\ncreateTimeB\x03\xe0A\x03\x12U\n\x0crest\
    ore_info\x18\x04\x20\x01(\x0b2-.google.spanner.admin.database.v1.Restore\
    InfoR\x0brestoreInfoB\x03\xe0A\x03\x12d\n\x11encryption_config\x18\x05\
    \x20\x01(\x0b22.google.spanner.admin.database.v1.EncryptionConfigR\x10en\
    cryptionConfigB\x03\xe0A\x03\x12^\n\x0fencryption_info\x18\x08\x20\x03(\
    \x0b20.google.spanner.admin.database.v1.EncryptionInfoR\x0eencryptionInf\
    oB\x03\xe0A\x03\x12=\n\x18version_retention_period\x18\x06\x20\x01(\tR\
    \x16versionRetentionPeriodB\x03\xe0A\x03\x12S\n\x15earliest_version_time\
    \x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x13earliestVersion\
    TimeB\x03\xe0A\x03\x12*\n\x0edefault_leader\x18\t\x20\x01(\tR\rdefaultLe\
    aderB\x03\xe0A\x03\x12a\n\x10database_dialect\x18\n\x20\x01(\x0e21.googl\
    e.spanner.admin.database.v1.DatabaseDialectR\x0fdatabaseDialectB\x03\xe0\
    A\x03\x124\n\x16enable_drop_protection\x18\x0b\x20\x01(\x08R\x14enableDr\
    opProtection\x12%\n\x0breconciling\x18\x0c\x20\x01(\x08R\x0breconcilingB\
    \x03\xe0A\x03\"M\n\x05State\x12\x15\n\x11STATE_UNSPECIFIED\x10\0\x12\x0c\
    \n\x08CREATING\x10\x01\x12\t\n\x05READY\x10\x02\x12\x14\n\x10READY_OPTIM\
    IZING\x10\x03:b\xeaA_\n\x1fspanner.googleapis.com/Database\x12<projects/\
    {project}/instances/{instance}/databases/{database}\"\x93\x01\n\x14ListD\
    atabasesRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\n\
    \x1fspanner.googleapis.com/Instance\xe0A\x02\x12\x1b\n\tpage_size\x18\
    \x03\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\
    \tpageToken\"\x89\x01\n\x15ListDatabasesResponse\x12H\n\tdatabases\x18\
    \x01\x20\x03(\x0b2*.google.spanner.admin.database.v1.DatabaseR\tdatabase\
    s\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\xb3\x03\
    \n\x15CreateDatabaseRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06pare\
    ntB'\xfaA!\n\x1fspanner.googleapis.com/Instance\xe0A\x02\x12.\n\x10creat\
    e_statement\x18\x02\x20\x01(\tR\x0fcreateStatementB\x03\xe0A\x02\x12.\n\
    \x10extra_statements\x18\x03\x20\x03(\tR\x0fextraStatementsB\x03\xe0A\
    \x01\x12d\n\x11encryption_config\x18\x04\x20\x01(\x0b22.google.spanner.a\
    dmin.database.v1.EncryptionConfigR\x10encryptionConfigB\x03\xe0A\x01\x12\
    a\n\x10database_dialect\x18\x05\x20\x01(\x0e21.google.spanner.admin.data\
    base.v1.DatabaseDialectR\x0fdatabaseDialectB\x03\xe0A\x01\x120\n\x11prot\
    o_descriptors\x18\x06\x20\x01(\x0cR\x10protoDescriptorsB\x03\xe0A\x01\"Z\
    \n\x16CreateDatabaseMetadata\x12@\n\x08database\x18\x01\x20\x01(\tR\x08d\
    atabaseB$\xfaA!\n\x1fspanner.googleapis.com/Database\"Q\n\x12GetDatabase\
    Request\x12;\n\x04name\x18\x01\x20\x01(\tR\x04nameB'\xfaA!\n\x1fspanner.\
    googleapis.com/Database\xe0A\x02\"\xa6\x01\n\x15UpdateDatabaseRequest\
    \x12K\n\x08database\x18\x01\x20\x01(\x0b2*.google.spanner.admin.database\
    .v1.DatabaseR\x08databaseB\x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMaskB\x03\xe0A\x02\
    \"\xf9\x01\n\x16UpdateDatabaseMetadata\x12Q\n\x07request\x18\x01\x20\x01\
    (\x0b27.google.spanner.admin.database.v1.UpdateDatabaseRequestR\x07reque\
    st\x12O\n\x08progress\x18\x02\x20\x01(\x0b23.google.spanner.admin.databa\
    se.v1.OperationProgressR\x08progress\x12;\n\x0bcancel_time\x18\x03\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\ncancelTime\"\xd9\x01\n\x18Upd\
    ateDatabaseDdlRequest\x12C\n\x08database\x18\x01\x20\x01(\tR\x08database\
    B'\xfaA!\n\x1fspanner.googleapis.com/Database\xe0A\x02\x12#\n\nstatement\
    s\x18\x02\x20\x03(\tR\nstatementsB\x03\xe0A\x02\x12!\n\x0coperation_id\
    \x18\x03\x20\x01(\tR\x0boperationId\x120\n\x11proto_descriptors\x18\x04\
    \x20\x01(\x0cR\x10protoDescriptorsB\x03\xe0A\x01\"t\n\x16DdlStatementAct\
    ionInfo\x12\x16\n\x06action\x18\x01\x20\x01(\tR\x06action\x12\x1f\n\x0be\
    ntity_type\x18\x02\x20\x01(\tR\nentityType\x12!\n\x0centity_names\x18\
    \x03\x20\x03(\tR\x0bentityNames\"\x8e\x03\n\x19UpdateDatabaseDdlMetadata\
    \x12@\n\x08database\x18\x01\x20\x01(\tR\x08databaseB$\xfaA!\n\x1fspanner\
    .googleapis.com/Database\x12\x1e\n\nstatements\x18\x02\x20\x03(\tR\nstat\
    ements\x12G\n\x11commit_timestamps\x18\x03\x20\x03(\x0b2\x1a.google.prot\
    obuf.TimestampR\x10commitTimestamps\x12!\n\tthrottled\x18\x04\x20\x01(\
    \x08R\tthrottledB\x03\xe0A\x03\x12O\n\x08progress\x18\x05\x20\x03(\x0b23\
    .google.spanner.admin.database.v1.OperationProgressR\x08progress\x12R\n\
    \x07actions\x18\x06\x20\x03(\x0b28.google.spanner.admin.database.v1.DdlS\
    tatementActionInfoR\x07actions\"Z\n\x13DropDatabaseRequest\x12C\n\x08dat\
    abase\x18\x01\x20\x01(\tR\x08databaseB'\xfaA!\n\x1fspanner.googleapis.co\
    m/Database\xe0A\x02\"\\\n\x15GetDatabaseDdlRequest\x12C\n\x08database\
    \x18\x01\x20\x01(\tR\x08databaseB'\xfaA!\n\x1fspanner.googleapis.com/Dat\
    abase\xe0A\x02\"e\n\x16GetDatabaseDdlResponse\x12\x1e\n\nstatements\x18\
    \x01\x20\x03(\tR\nstatements\x12+\n\x11proto_descriptors\x18\x02\x20\x01\
    (\x0cR\x10protoDescriptors\"\xb4\x01\n\x1dListDatabaseOperationsRequest\
    \x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\n\x1fspanner.goo\
    gleapis.com/Instance\xe0A\x02\x12\x16\n\x06filter\x18\x02\x20\x01(\tR\
    \x06filter\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\x87\x01\n\x1eListDat\
    abaseOperationsResponse\x12=\n\noperations\x18\x01\x20\x03(\x0b2\x1d.goo\
    gle.longrunning.OperationR\noperations\x12&\n\x0fnext_page_token\x18\x02\
    \x20\x01(\tR\rnextPageToken\"\xbc\x02\n\x16RestoreDatabaseRequest\x12?\n\
    \x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\n\x1fspanner.googleapis\
    .com/Instance\xe0A\x02\x12$\n\x0bdatabase_id\x18\x02\x20\x01(\tR\ndataba\
    seIdB\x03\xe0A\x02\x12<\n\x06backup\x18\x03\x20\x01(\tH\0R\x06backupB\"\
    \xfaA\x1f\n\x1dspanner.googleapis.com/Backup\x12s\n\x11encryption_config\
    \x18\x04\x20\x01(\x0b2A.google.spanner.admin.database.v1.RestoreDatabase\
    EncryptionConfigR\x10encryptionConfigB\x03\xe0A\x01B\x08\n\x06source\"\
    \x8f\x03\n\x1fRestoreDatabaseEncryptionConfig\x12~\n\x0fencryption_type\
    \x18\x01\x20\x01(\x0e2P.google.spanner.admin.database.v1.RestoreDatabase\
    EncryptionConfig.EncryptionTypeR\x0eencryptionTypeB\x03\xe0A\x02\x12K\n\
    \x0ckms_key_name\x18\x02\x20\x01(\tR\nkmsKeyNameB)\xfaA#\n!cloudkms.goog\
    leapis.com/CryptoKey\xe0A\x01\"\x9e\x01\n\x0eEncryptionType\x12\x1f\n\
    \x1bENCRYPTION_TYPE_UNSPECIFIED\x10\0\x12+\n'USE_CONFIG_DEFAULT_OR_BACKU\
    P_ENCRYPTION\x10\x01\x12\x1d\n\x19GOOGLE_DEFAULT_ENCRYPTION\x10\x02\x12\
    \x1f\n\x1bCUSTOMER_MANAGED_ENCRYPTION\x10\x03\"\xe0\x03\n\x17RestoreData\
    baseMetadata\x128\n\x04name\x18\x01\x20\x01(\tR\x04nameB$\xfaA!\n\x1fspa\
    nner.googleapis.com/Database\x12T\n\x0bsource_type\x18\x02\x20\x01(\x0e2\
    3.google.spanner.admin.database.v1.RestoreSourceTypeR\nsourceType\x12O\n\
    \x0bbackup_info\x18\x03\x20\x01(\x0b2,.google.spanner.admin.database.v1.\
    BackupInfoH\0R\nbackupInfo\x12O\n\x08progress\x18\x04\x20\x01(\x0b23.goo\
    gle.spanner.admin.database.v1.OperationProgressR\x08progress\x12;\n\x0bc\
    ancel_time\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncancelT\
    ime\x12G\n\x20optimize_database_operation_name\x18\x06\x20\x01(\tR\x1dop\
    timizeDatabaseOperationNameB\r\n\x0bsource_info\"\xad\x01\n\x20OptimizeR\
    estoredDatabaseMetadata\x128\n\x04name\x18\x01\x20\x01(\tR\x04nameB$\xfa\
    A!\n\x1fspanner.googleapis.com/Database\x12O\n\x08progress\x18\x02\x20\
    \x01(\x0b23.google.spanner.admin.database.v1.OperationProgressR\x08progr\
    ess\"\xa4\x01\n\x0cDatabaseRole\x12\x17\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\x03\xe0A\x02:{\xeaAx\n#spanner.googleapis.com/DatabaseRole\x12\
    Qprojects/{project}/instances/{instance}/databases/{database}/databaseRo\
    les/{role}\"\x97\x01\n\x18ListDatabaseRolesRequest\x12?\n\x06parent\x18\
    \x01\x20\x01(\tR\x06parentB'\xfaA!\n\x1fspanner.googleapis.com/Database\
    \xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\
    \n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"\x9a\x01\n\x19ListDatabas\
    eRolesResponse\x12U\n\x0edatabase_roles\x18\x01\x20\x03(\x0b2..google.sp\
    anner.admin.database.v1.DatabaseRoleR\rdatabaseRoles\x12&\n\x0fnext_page\
    _token\x18\x02\x20\x01(\tR\rnextPageToken*5\n\x11RestoreSourceType\x12\
    \x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\n\n\x06BACKUP\x10\x012\xee%\n\rData\
    baseAdmin\x12\xc0\x01\n\rListDatabases\x126.google.spanner.admin.databas\
    e.v1.ListDatabasesRequest\x1a7.google.spanner.admin.database.v1.ListData\
    basesResponse\">\x82\xd3\xe4\x93\x02/\x12-/v1/{parent=projects/*/instanc\
    es/*}/databases\xdaA\x06parent\x12\xa4\x02\n\x0eCreateDatabase\x127.goog\
    le.spanner.admin.database.v1.CreateDatabaseRequest\x1a\x1d.google.longru\
    nning.Operation\"\xb9\x01\xcaAd\n)google.spanner.admin.database.v1.Datab\
    ase\x127google.spanner.admin.database.v1.CreateDatabaseMetadata\x82\xd3\
    \xe4\x93\x022\"-/v1/{parent=projects/*/instances/*}/databases:\x01*\xdaA\
    \x17parent,create_statement\x12\xad\x01\n\x0bGetDatabase\x124.google.spa\
    nner.admin.database.v1.GetDatabaseRequest\x1a*.google.spanner.admin.data\
    base.v1.Database\"<\x82\xd3\xe4\x93\x02/\x12-/v1/{name=projects/*/instan\
    ces/*/databases/*}\xdaA\x04name\x12\xef\x01\n\x0eUpdateDatabase\x127.goo\
    gle.spanner.admin.database.v1.UpdateDatabaseRequest\x1a\x1d.google.longr\
    unning.Operation\"\x84\x01\xcaA\"\n\x08Database\x12\x16UpdateDatabaseMet\
    adata\x82\xd3\xe4\x93\x02B26/v1/{database.name=projects/*/instances/*/da\
    tabases/*}:\x08database\xdaA\x14database,update_mask\x12\x9d\x02\n\x11Up\
    dateDatabaseDdl\x12:.google.spanner.admin.database.v1.UpdateDatabaseDdlR\
    equest\x1a\x1d.google.longrunning.Operation\"\xac\x01\xcaAS\n\x15google.\
    protobuf.Empty\x12:google.spanner.admin.database.v1.UpdateDatabaseDdlMet\
    adata\x82\xd3\xe4\x93\x02:25/v1/{database=projects/*/instances/*/databas\
    es/*}/ddl:\x01*\xdaA\x13database,statements\x12\xa3\x01\n\x0cDropDatabas\
    e\x125.google.spanner.admin.database.v1.DropDatabaseRequest\x1a\x16.goog\
    le.protobuf.Empty\"D\x82\xd3\xe4\x93\x023*1/v1/{database=projects/*/inst\
    ances/*/databases/*}\xdaA\x08database\x12\xcd\x01\n\x0eGetDatabaseDdl\
    \x127.google.spanner.admin.database.v1.GetDatabaseDdlRequest\x1a8.google\
    .spanner.admin.database.v1.GetDatabaseDdlResponse\"H\x82\xd3\xe4\x93\x02\
    7\x125/v1/{database=projects/*/instances/*/databases/*}/ddl\xdaA\x08data\
    base\x12\xeb\x01\n\x0cSetIamPolicy\x12\".google.iam.v1.SetIamPolicyReque\
    st\x1a\x15.google.iam.v1.Policy\"\x9f\x01\x82\xd3\xe4\x93\x02\x86\x01\">\
    /v1/{resource=projects/*/instances/*/databases/*}:setIamPolicy:\x01*ZA\"\
    </v1/{resource=projects/*/instances/*/backups/*}:setIamPolicy:\x01*\xdaA\
    \x0fresource,policy\x12\xe4\x01\n\x0cGetIamPolicy\x12\".google.iam.v1.Ge\
    tIamPolicyRequest\x1a\x15.google.iam.v1.Policy\"\x98\x01\x82\xd3\xe4\x93\
    \x02\x86\x01\">/v1/{resource=projects/*/instances/*/databases/*}:getIamP\
    olicy:\x01*ZA\"</v1/{resource=projects/*/instances/*/backups/*}:getIamPo\
    licy:\x01*\xdaA\x08resource\x12\xf7\x02\n\x12TestIamPermissions\x12(.goo\
    gle.iam.v1.TestIamPermissionsRequest\x1a).google.iam.v1.TestIamPermissio\
    nsResponse\"\x8b\x02\x82\xd3\xe4\x93\x02\xed\x01\"D/v1/{resource=project\
    s/*/instances/*/databases/*}:testIamPermissions:\x01*ZG\"B/v1/{resource=\
    projects/*/instances/*/backups/*}:testIamPermissions:\x01*ZY\"T/v1/{reso\
    urce=projects/*/instances/*/databases/*/databaseRoles/*}:testIamPermissi\
    ons:\x01*\xdaA\x14resource,permissions\x12\x9f\x02\n\x0cCreateBackup\x12\
    5.google.spanner.admin.database.v1.CreateBackupRequest\x1a\x1d.google.lo\
    ngrunning.Operation\"\xb8\x01\xcaA`\n'google.spanner.admin.database.v1.B\
    ackup\x125google.spanner.admin.database.v1.CreateBackupMetadata\x82\xd3\
    \xe4\x93\x025\"+/v1/{parent=projects/*/instances/*}/backups:\x06backup\
    \xdaA\x17parent,backup,backup_id\x12\xac\x02\n\nCopyBackup\x123.google.s\
    panner.admin.database.v1.CopyBackupRequest\x1a\x1d.google.longrunning.Op\
    eration\"\xc9\x01\xcaA^\n'google.spanner.admin.database.v1.Backup\x123go\
    ogle.spanner.admin.database.v1.CopyBackupMetadata\x82\xd3\xe4\x93\x025\"\
    0/v1/{parent=projects/*/instances/*}/backups:copy:\x01*\xdaA*parent,back\
    up_id,source_backup,expire_time\x12\xa5\x01\n\tGetBackup\x122.google.spa\
    nner.admin.database.v1.GetBackupRequest\x1a(.google.spanner.admin.databa\
    se.v1.Backup\":\x82\xd3\xe4\x93\x02-\x12+/v1/{name=projects/*/instances/\
    */backups/*}\xdaA\x04name\x12\xc8\x01\n\x0cUpdateBackup\x125.google.span\
    ner.admin.database.v1.UpdateBackupRequest\x1a(.google.spanner.admin.data\
    base.v1.Backup\"W\x82\xd3\xe4\x93\x02<22/v1/{backup.name=projects/*/inst\
    ances/*/backups/*}:\x06backup\xdaA\x12backup,update_mask\x12\x99\x01\n\
    \x0cDeleteBackup\x125.google.spanner.admin.database.v1.DeleteBackupReque\
    st\x1a\x16.google.protobuf.Empty\":\x82\xd3\xe4\x93\x02-*+/v1/{name=proj\
    ects/*/instances/*/backups/*}\xdaA\x04name\x12\xb8\x01\n\x0bListBackups\
    \x124.google.spanner.admin.database.v1.ListBackupsRequest\x1a5.google.sp\
    anner.admin.database.v1.ListBackupsResponse\"<\x82\xd3\xe4\x93\x02-\x12+\
    /v1/{parent=projects/*/instances/*}/backups\xdaA\x06parent\x12\xb1\x02\n\
    \x0fRestoreDatabase\x128.google.spanner.admin.database.v1.RestoreDatabas\
    eRequest\x1a\x1d.google.longrunning.Operation\"\xc4\x01\xcaAe\n)google.s\
    panner.admin.database.v1.Database\x128google.spanner.admin.database.v1.R\
    estoreDatabaseMetadata\x82\xd3\xe4\x93\x02:\"5/v1/{parent=projects/*/ins\
    tances/*}/databases:restore:\x01*\xdaA\x19parent,database_id,backup\x12\
    \xe4\x01\n\x16ListDatabaseOperations\x12?.google.spanner.admin.database.\
    v1.ListDatabaseOperationsRequest\x1a@.google.spanner.admin.database.v1.L\
    istDatabaseOperationsResponse\"G\x82\xd3\xe4\x93\x028\x126/v1/{parent=pr\
    ojects/*/instances/*}/databaseOperations\xdaA\x06parent\x12\xdc\x01\n\
    \x14ListBackupOperations\x12=.google.spanner.admin.database.v1.ListBacku\
    pOperationsRequest\x1a>.google.spanner.admin.database.v1.ListBackupOpera\
    tionsResponse\"E\x82\xd3\xe4\x93\x026\x124/v1/{parent=projects/*/instanc\
    es/*}/backupOperations\xdaA\x06parent\x12\xdc\x01\n\x11ListDatabaseRoles\
    \x12:.google.spanner.admin.database.v1.ListDatabaseRolesRequest\x1a;.goo\
    gle.spanner.admin.database.v1.ListDatabaseRolesResponse\"N\x82\xd3\xe4\
    \x93\x02?\x12=/v1/{parent=projects/*/instances/*/databases/*}/databaseRo\
    les\xdaA\x06parent\x1ax\xd2A\\https://www.googleapis.com/auth/cloud-plat\
    form,https://www.googleapis.com/auth/spanner.admin\xcaA\x16spanner.googl\
    eapis.comB\xd8\x02\n$com.google.spanner.admin.database.v1B\x19SpannerDat\
    abaseAdminProtoP\x01ZFcloud.google.com/go/spanner/admin/database/apiv1/d\
    atabasepb;databasepb\xaa\x02&Google.Cloud.Spanner.Admin.Database.V1\xca\
    \x02&Google\\Cloud\\Spanner\\Admin\\Database\\V1\xea\x02+Google::Cloud::\
    Spanner::Admin::Database::V1\xeaAJ\n\x1fspanner.googleapis.com/Instance\
    \x12'projects/{project}/instances/{instance}J\xf1\xd0\x02\n\x07\x12\x05\
    \x0e\0\xba\x08\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Cop\
    yright\x202023\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apach\
    e\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\
    \x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20\
    the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20L\
    icense\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICEN\
    SE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agr\
    eed\x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0)\n\t\
    \n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\x03\x13\0!\n\t\n\x02\
    \x03\x02\x12\x03\x14\0)\n\t\n\x02\x03\x03\x12\x03\x15\0#\n\t\n\x02\x03\
    \x04\x12\x03\x16\0(\n\t\n\x02\x03\x05\x12\x03\x17\0$\n\t\n\x02\x03\x06\
    \x12\x03\x18\0-\n\t\n\x02\x03\x07\x12\x03\x19\0%\n\t\n\x02\x03\x08\x12\
    \x03\x1a\0*\n\t\n\x02\x03\t\x12\x03\x1b\0)\n\t\n\x02\x03\n\x12\x03\x1c\0\
    7\n\t\n\x02\x03\x0b\x12\x03\x1d\07\n\x08\n\x01\x08\x12\x03\x1f\0C\n\t\n\
    \x02\x08%\x12\x03\x1f\0C\n\x08\n\x01\x08\x12\x03\x20\0]\n\t\n\x02\x08\
    \x0b\x12\x03\x20\0]\n\x08\n\x01\x08\x12\x03!\0\"\n\t\n\x02\x08\n\x12\x03\
    !\0\"\n\x08\n\x01\x08\x12\x03\"\0:\n\t\n\x02\x08\x08\x12\x03\"\0:\n\x08\
    \n\x01\x08\x12\x03#\0=\n\t\n\x02\x08\x01\x12\x03#\0=\n\x08\n\x01\x08\x12\
    \x03$\0E\n\t\n\x02\x08)\x12\x03$\0E\n\x08\n\x01\x08\x12\x03%\0D\n\t\n\
    \x02\x08-\x12\x03%\0D\n\t\n\x01\x08\x12\x04&\0)\x02\n\x0c\n\x04\x08\x9d\
    \x08\0\x12\x04&\0)\x02\n\xa2\x02\n\x02\x06\0\x12\x052\0\x8e\x03\x01\x1a\
    \x94\x02\x20Cloud\x20Spanner\x20Database\x20Admin\x20API\n\n\x20The\x20C\
    loud\x20Spanner\x20Database\x20Admin\x20API\x20can\x20be\x20used\x20to:\
    \n\x20\x20\x20*\x20create,\x20drop,\x20and\x20list\x20databases\n\x20\
    \x20\x20*\x20update\x20the\x20schema\x20of\x20pre-existing\x20databases\
    \n\x20\x20\x20*\x20create,\x20delete\x20and\x20list\x20backups\x20for\
    \x20a\x20database\n\x20\x20\x20*\x20restore\x20a\x20database\x20from\x20\
    an\x20existing\x20backup\n\n\n\n\x03\x06\0\x01\x12\x032\x08\x15\n\n\n\
    \x03\x06\0\x03\x12\x033\x02>\n\x0c\n\x05\x06\0\x03\x99\x08\x12\x033\x02>\
    \n\x0b\n\x03\x06\0\x03\x12\x044\x0266\n\r\n\x05\x06\0\x03\x9a\x08\x12\
    \x044\x0266\n.\n\x04\x06\0\x02\0\x12\x049\x02>\x03\x1a\x20\x20Lists\x20C\
    loud\x20Spanner\x20databases.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x039\x06\
    \x13\n\x0c\n\x05\x06\0\x02\0\x02\x12\x039\x14(\n\x0c\n\x05\x06\0\x02\0\
    \x03\x12\x0393H\n\r\n\x05\x06\0\x02\0\x04\x12\x04:\x04<\x06\n\x11\n\t\
    \x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04:\x04<\x06\n\x0c\n\x05\x06\0\x02\0\
    \x04\x12\x03=\x044\n\x0f\n\x08\x06\0\x02\0\x04\x9b\x08\0\x12\x03=\x044\n\
    \xc8\x04\n\x04\x06\0\x02\x01\x12\x04H\x02R\x03\x1a\xb9\x04\x20Creates\
    \x20a\x20new\x20Cloud\x20Spanner\x20database\x20and\x20starts\x20to\x20p\
    repare\x20it\x20for\x20serving.\n\x20The\x20returned\x20[long-running\
    \x20operation][google.longrunning.Operation]\x20will\n\x20have\x20a\x20n\
    ame\x20of\x20the\x20format\x20`<database_name>/operations/<operation_id>\
    `\x20and\n\x20can\x20be\x20used\x20to\x20track\x20preparation\x20of\x20t\
    he\x20database.\x20The\n\x20[metadata][google.longrunning.Operation.meta\
    data]\x20field\x20type\x20is\n\x20[CreateDatabaseMetadata][google.spanne\
    r.admin.database.v1.CreateDatabaseMetadata].\x20The\n\x20[response][goog\
    le.longrunning.Operation.response]\x20field\x20type\x20is\n\x20[Database\
    ][google.spanner.admin.database.v1.Database],\x20if\x20successful.\n\n\
    \x0c\n\x05\x06\0\x02\x01\x01\x12\x03H\x06\x14\n\x0c\n\x05\x06\0\x02\x01\
    \x02\x12\x03H\x15*\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03H5Q\n\r\n\x05\
    \x06\0\x02\x01\x04\x12\x04I\x04L\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\
    \xbc\"\x12\x04I\x04L\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03M\x04E\n\
    \x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\x12\x03M\x04E\n\r\n\x05\x06\0\x02\
    \x01\x04\x12\x04N\x04Q\x06\n\x0f\n\x07\x06\0\x02\x01\x04\x99\x08\x12\x04\
    N\x04Q\x06\n;\n\x04\x06\0\x02\x02\x12\x04U\x02Z\x03\x1a-\x20Gets\x20the\
    \x20state\x20of\x20a\x20Cloud\x20Spanner\x20database.\n\n\x0c\n\x05\x06\
    \0\x02\x02\x01\x12\x03U\x06\x11\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03U\
    \x12$\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03U/7\n\r\n\x05\x06\0\x02\x02\
    \x04\x12\x04V\x04X\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04\
    V\x04X\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03Y\x042\n\x0f\n\x08\x06\0\
    \x02\x02\x04\x9b\x08\0\x12\x03Y\x042\n\xa4\r\n\x04\x06\0\x02\x03\x12\x06\
    \x80\x01\x02\x8b\x01\x03\x1a\x93\r\x20Updates\x20a\x20Cloud\x20Spanner\
    \x20database.\x20The\x20returned\n\x20[long-running\x20operation][google\
    .longrunning.Operation]\x20can\x20be\x20used\x20to\x20track\n\x20the\x20\
    progress\x20of\x20updating\x20the\x20database.\x20If\x20the\x20named\x20\
    database\x20does\x20not\n\x20exist,\x20returns\x20`NOT_FOUND`.\n\n\x20Wh\
    ile\x20the\x20operation\x20is\x20pending:\n\n\x20\x20\x20*\x20The\x20dat\
    abase's\n\x20\x20\x20\x20\x20[reconciling][google.spanner.admin.database\
    .v1.Database.reconciling]\n\x20\x20\x20\x20\x20field\x20is\x20set\x20to\
    \x20true.\n\x20\x20\x20*\x20Cancelling\x20the\x20operation\x20is\x20best\
    -effort.\x20If\x20the\x20cancellation\x20succeeds,\n\x20\x20\x20\x20\x20\
    the\x20operation\x20metadata's\n\x20\x20\x20\x20\x20[cancel_time][google\
    .spanner.admin.database.v1.UpdateDatabaseMetadata.cancel_time]\n\x20\x20\
    \x20\x20\x20is\x20set,\x20the\x20updates\x20are\x20reverted,\x20and\x20t\
    he\x20operation\x20terminates\x20with\x20a\n\x20\x20\x20\x20\x20`CANCELL\
    ED`\x20status.\n\x20\x20\x20*\x20New\x20UpdateDatabase\x20requests\x20wi\
    ll\x20return\x20a\x20`FAILED_PRECONDITION`\x20error\n\x20\x20\x20\x20\
    \x20until\x20the\x20pending\x20operation\x20is\x20done\x20(returns\x20su\
    ccessfully\x20or\x20with\n\x20\x20\x20\x20\x20error).\n\x20\x20\x20*\x20\
    Reading\x20the\x20database\x20via\x20the\x20API\x20continues\x20to\x20gi\
    ve\x20the\x20pre-request\n\x20\x20\x20\x20\x20values.\n\n\x20Upon\x20com\
    pletion\x20of\x20the\x20returned\x20operation:\n\n\x20\x20\x20*\x20The\
    \x20new\x20values\x20are\x20in\x20effect\x20and\x20readable\x20via\x20th\
    e\x20API.\n\x20\x20\x20*\x20The\x20database's\n\x20\x20\x20\x20\x20[reco\
    nciling][google.spanner.admin.database.v1.Database.reconciling]\n\x20\
    \x20\x20\x20\x20field\x20becomes\x20false.\n\n\x20The\x20returned\x20[lo\
    ng-running\x20operation][google.longrunning.Operation]\x20will\n\x20have\
    \x20a\x20name\x20of\x20the\x20format\n\x20`projects/<project>/instances/\
    <instance>/databases/<database>/operations/<operation_id>`\n\x20and\x20c\
    an\x20be\x20used\x20to\x20track\x20the\x20database\x20modification.\x20T\
    he\n\x20[metadata][google.longrunning.Operation.metadata]\x20field\x20ty\
    pe\x20is\n\x20[UpdateDatabaseMetadata][google.spanner.admin.database.v1.\
    UpdateDatabaseMetadata].\n\x20The\x20[response][google.longrunning.Opera\
    tion.response]\x20field\x20type\x20is\n\x20[Database][google.spanner.adm\
    in.database.v1.Database],\x20if\x20successful.\n\n\r\n\x05\x06\0\x02\x03\
    \x01\x12\x04\x80\x01\x06\x14\n\r\n\x05\x06\0\x02\x03\x02\x12\x04\x80\x01\
    \x15*\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\x81\x01\x0f+\n\x0f\n\x05\x06\0\
    \x02\x03\x04\x12\x06\x82\x01\x04\x85\x01\x06\n\x13\n\t\x06\0\x02\x03\x04\
    \xb0\xca\xbc\"\x12\x06\x82\x01\x04\x85\x01\x06\n\r\n\x05\x06\0\x02\x03\
    \x04\x12\x04\x86\x01\x04B\n\x10\n\x08\x06\0\x02\x03\x04\x9b\x08\0\x12\
    \x04\x86\x01\x04B\n\x0f\n\x05\x06\0\x02\x03\x04\x12\x06\x87\x01\x04\x8a\
    \x01\x06\n\x11\n\x07\x06\0\x02\x03\x04\x99\x08\x12\x06\x87\x01\x04\x8a\
    \x01\x06\n\x8c\x04\n\x04\x06\0\x02\x04\x12\x06\x94\x01\x02\x9e\x01\x03\
    \x1a\xfb\x03\x20Updates\x20the\x20schema\x20of\x20a\x20Cloud\x20Spanner\
    \x20database\x20by\n\x20creating/altering/dropping\x20tables,\x20columns\
    ,\x20indexes,\x20etc.\x20The\x20returned\n\x20[long-running\x20operation\
    ][google.longrunning.Operation]\x20will\x20have\x20a\x20name\x20of\n\x20\
    the\x20format\x20`<database_name>/operations/<operation_id>`\x20and\x20c\
    an\x20be\x20used\x20to\n\x20track\x20execution\x20of\x20the\x20schema\
    \x20change(s).\x20The\n\x20[metadata][google.longrunning.Operation.metad\
    ata]\x20field\x20type\x20is\n\x20[UpdateDatabaseDdlMetadata][google.span\
    ner.admin.database.v1.UpdateDatabaseDdlMetadata].\x20\x20The\x20operatio\
    n\x20has\x20no\x20response.\n\n\r\n\x05\x06\0\x02\x04\x01\x12\x04\x94\
    \x01\x06\x17\n\r\n\x05\x06\0\x02\x04\x02\x12\x04\x94\x01\x180\n\r\n\x05\
    \x06\0\x02\x04\x03\x12\x04\x94\x01;W\n\x0f\n\x05\x06\0\x02\x04\x04\x12\
    \x06\x95\x01\x04\x98\x01\x06\n\x13\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\
    \x12\x06\x95\x01\x04\x98\x01\x06\n\r\n\x05\x06\0\x02\x04\x04\x12\x04\x99\
    \x01\x04A\n\x10\n\x08\x06\0\x02\x04\x04\x9b\x08\0\x12\x04\x99\x01\x04A\n\
    \x0f\n\x05\x06\0\x02\x04\x04\x12\x06\x9a\x01\x04\x9d\x01\x06\n\x11\n\x07\
    \x06\0\x02\x04\x04\x99\x08\x12\x06\x9a\x01\x04\x9d\x01\x06\n\x87\x02\n\
    \x04\x06\0\x02\x05\x12\x06\xa5\x01\x02\xaa\x01\x03\x1a\xf6\x01\x20Drops\
    \x20(aka\x20deletes)\x20a\x20Cloud\x20Spanner\x20database.\n\x20Complete\
    d\x20backups\x20for\x20the\x20database\x20will\x20be\x20retained\x20acco\
    rding\x20to\x20their\n\x20`expire_time`.\n\x20Note:\x20Cloud\x20Spanner\
    \x20might\x20continue\x20to\x20accept\x20requests\x20for\x20a\x20few\x20\
    seconds\n\x20after\x20the\x20database\x20has\x20been\x20deleted.\n\n\r\n\
    \x05\x06\0\x02\x05\x01\x12\x04\xa5\x01\x06\x12\n\r\n\x05\x06\0\x02\x05\
    \x02\x12\x04\xa5\x01\x13&\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\xa5\x011F\
    \n\x0f\n\x05\x06\0\x02\x05\x04\x12\x06\xa6\x01\x04\xa8\x01\x06\n\x13\n\t\
    \x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x06\xa6\x01\x04\xa8\x01\x06\n\r\n\
    \x05\x06\0\x02\x05\x04\x12\x04\xa9\x01\x046\n\x10\n\x08\x06\0\x02\x05\
    \x04\x9b\x08\0\x12\x04\xa9\x01\x046\n\xec\x01\n\x04\x06\0\x02\x06\x12\
    \x06\xaf\x01\x02\xb4\x01\x03\x1a\xdb\x01\x20Returns\x20the\x20schema\x20\
    of\x20a\x20Cloud\x20Spanner\x20database\x20as\x20a\x20list\x20of\x20form\
    atted\n\x20DDL\x20statements.\x20This\x20method\x20does\x20not\x20show\
    \x20pending\x20schema\x20updates,\x20those\x20may\n\x20be\x20queried\x20\
    using\x20the\x20[Operations][google.longrunning.Operations]\x20API.\n\n\
    \r\n\x05\x06\0\x02\x06\x01\x12\x04\xaf\x01\x06\x14\n\r\n\x05\x06\0\x02\
    \x06\x02\x12\x04\xaf\x01\x15*\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\xaf\
    \x015K\n\x0f\n\x05\x06\0\x02\x06\x04\x12\x06\xb0\x01\x04\xb2\x01\x06\n\
    \x13\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x06\xb0\x01\x04\xb2\x01\x06\
    \n\r\n\x05\x06\0\x02\x06\x04\x12\x04\xb3\x01\x046\n\x10\n\x08\x06\0\x02\
    \x06\x04\x9b\x08\0\x12\x04\xb3\x01\x046\n\xfe\x02\n\x04\x06\0\x02\x07\
    \x12\x06\xbd\x01\x02\xc7\x01\x03\x1a\xed\x02\x20Sets\x20the\x20access\
    \x20control\x20policy\x20on\x20a\x20database\x20or\x20backup\x20resource\
    .\n\x20Replaces\x20any\x20existing\x20policy.\n\n\x20Authorization\x20re\
    quires\x20`spanner.databases.setIamPolicy`\n\x20permission\x20on\x20[res\
    ource][google.iam.v1.SetIamPolicyRequest.resource].\n\x20For\x20backups,\
    \x20authorization\x20requires\x20`spanner.backups.setIamPolicy`\n\x20per\
    mission\x20on\x20[resource][google.iam.v1.SetIamPolicyRequest.resource].\
    \n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\xbd\x01\x06\x12\n\r\n\x05\x06\0\
    \x02\x07\x02\x12\x04\xbd\x01\x134\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\
    \xbd\x01?S\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\xbe\x01\x04\xc5\x01\x06\
    \n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\xbe\x01\x04\xc5\x01\
    \x06\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\xc6\x01\x04=\n\x10\n\x08\x06\0\
    \x02\x07\x04\x9b\x08\0\x12\x04\xc6\x01\x04=\n\xb9\x03\n\x04\x06\0\x02\
    \x08\x12\x06\xd1\x01\x02\xdb\x01\x03\x1a\xa8\x03\x20Gets\x20the\x20acces\
    s\x20control\x20policy\x20for\x20a\x20database\x20or\x20backup\x20resour\
    ce.\n\x20Returns\x20an\x20empty\x20policy\x20if\x20a\x20database\x20or\
    \x20backup\x20exists\x20but\x20does\x20not\x20have\x20a\n\x20policy\x20s\
    et.\n\n\x20Authorization\x20requires\x20`spanner.databases.getIamPolicy`\
    \x20permission\x20on\n\x20[resource][google.iam.v1.GetIamPolicyRequest.r\
    esource].\n\x20For\x20backups,\x20authorization\x20requires\x20`spanner.\
    backups.getIamPolicy`\n\x20permission\x20on\x20[resource][google.iam.v1.\
    GetIamPolicyRequest.resource].\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xd1\
    \x01\x06\x12\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\xd1\x01\x134\n\r\n\x05\
    \x06\0\x02\x08\x03\x12\x04\xd1\x01?S\n\x0f\n\x05\x06\0\x02\x08\x04\x12\
    \x06\xd2\x01\x04\xd9\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\
    \x12\x06\xd2\x01\x04\xd9\x01\x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xda\
    \x01\x046\n\x10\n\x08\x06\0\x02\x08\x04\x9b\x08\0\x12\x04\xda\x01\x046\n\
    \xff\x03\n\x04\x06\0\x02\t\x12\x06\xe7\x01\x02\xf5\x01\x03\x1a\xee\x03\
    \x20Returns\x20permissions\x20that\x20the\x20caller\x20has\x20on\x20the\
    \x20specified\x20database\x20or\x20backup\n\x20resource.\n\n\x20Attempti\
    ng\x20this\x20RPC\x20on\x20a\x20non-existent\x20Cloud\x20Spanner\x20data\
    base\x20will\n\x20result\x20in\x20a\x20NOT_FOUND\x20error\x20if\x20the\
    \x20user\x20has\n\x20`spanner.databases.list`\x20permission\x20on\x20the\
    \x20containing\x20Cloud\n\x20Spanner\x20instance.\x20Otherwise\x20return\
    s\x20an\x20empty\x20set\x20of\x20permissions.\n\x20Calling\x20this\x20me\
    thod\x20on\x20a\x20backup\x20that\x20does\x20not\x20exist\x20will\n\x20r\
    esult\x20in\x20a\x20NOT_FOUND\x20error\x20if\x20the\x20user\x20has\n\x20\
    `spanner.backups.list`\x20permission\x20on\x20the\x20containing\x20insta\
    nce.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xe7\x01\x06\x18\n\r\n\x05\x06\0\
    \x02\t\x02\x12\x04\xe7\x01\x19@\n\r\n\x05\x06\0\x02\t\x03\x12\x04\xe7\
    \x01Ks\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\xe8\x01\x04\xf3\x01\x06\n\x13\
    \n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\xe8\x01\x04\xf3\x01\x06\n\r\n\
    \x05\x06\0\x02\t\x04\x12\x04\xf4\x01\x04B\n\x10\n\x08\x06\0\x02\t\x04\
    \x9b\x08\0\x12\x04\xf4\x01\x04B\n\x9b\x06\n\x04\x06\0\x02\n\x12\x06\x83\
    \x02\x02\x8d\x02\x03\x1a\x8a\x06\x20Starts\x20creating\x20a\x20new\x20Cl\
    oud\x20Spanner\x20Backup.\n\x20The\x20returned\x20backup\x20[long-runnin\
    g\x20operation][google.longrunning.Operation]\n\x20will\x20have\x20a\x20\
    name\x20of\x20the\x20format\n\x20`projects/<project>/instances/<instance\
    >/backups/<backup>/operations/<operation_id>`\n\x20and\x20can\x20be\x20u\
    sed\x20to\x20track\x20creation\x20of\x20the\x20backup.\x20The\n\x20[meta\
    data][google.longrunning.Operation.metadata]\x20field\x20type\x20is\n\
    \x20[CreateBackupMetadata][google.spanner.admin.database.v1.CreateBackup\
    Metadata].\x20The\n\x20[response][google.longrunning.Operation.response]\
    \x20field\x20type\x20is\n\x20[Backup][google.spanner.admin.database.v1.B\
    ackup],\x20if\x20successful.\x20Cancelling\x20the\x20returned\x20operati\
    on\x20will\x20stop\x20the\n\x20creation\x20and\x20delete\x20the\x20backu\
    p.\n\x20There\x20can\x20be\x20only\x20one\x20pending\x20backup\x20creati\
    on\x20per\x20database.\x20Backup\x20creation\n\x20of\x20different\x20dat\
    abases\x20can\x20run\x20concurrently.\n\n\r\n\x05\x06\0\x02\n\x01\x12\
    \x04\x83\x02\x06\x12\n\r\n\x05\x06\0\x02\n\x02\x12\x04\x83\x02\x13&\n\r\
    \n\x05\x06\0\x02\n\x03\x12\x04\x83\x021M\n\x0f\n\x05\x06\0\x02\n\x04\x12\
    \x06\x84\x02\x04\x87\x02\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\
    \x06\x84\x02\x04\x87\x02\x06\n\r\n\x05\x06\0\x02\n\x04\x12\x04\x88\x02\
    \x04E\n\x10\n\x08\x06\0\x02\n\x04\x9b\x08\0\x12\x04\x88\x02\x04E\n\x0f\n\
    \x05\x06\0\x02\n\x04\x12\x06\x89\x02\x04\x8c\x02\x06\n\x11\n\x07\x06\0\
    \x02\n\x04\x99\x08\x12\x06\x89\x02\x04\x8c\x02\x06\n\x92\x06\n\x04\x06\0\
    \x02\x0b\x12\x06\x9b\x02\x02\xa5\x02\x03\x1a\x81\x06\x20Starts\x20copyin\
    g\x20a\x20Cloud\x20Spanner\x20Backup.\n\x20The\x20returned\x20backup\x20\
    [long-running\x20operation][google.longrunning.Operation]\n\x20will\x20h\
    ave\x20a\x20name\x20of\x20the\x20format\n\x20`projects/<project>/instanc\
    es/<instance>/backups/<backup>/operations/<operation_id>`\n\x20and\x20ca\
    n\x20be\x20used\x20to\x20track\x20copying\x20of\x20the\x20backup.\x20The\
    \x20operation\x20is\x20associated\n\x20with\x20the\x20destination\x20bac\
    kup.\n\x20The\x20[metadata][google.longrunning.Operation.metadata]\x20fi\
    eld\x20type\x20is\n\x20[CopyBackupMetadata][google.spanner.admin.databas\
    e.v1.CopyBackupMetadata].\n\x20The\x20[response][google.longrunning.Oper\
    ation.response]\x20field\x20type\x20is\n\x20[Backup][google.spanner.admi\
    n.database.v1.Backup],\x20if\x20successful.\x20Cancelling\x20the\x20retu\
    rned\x20operation\x20will\x20stop\x20the\n\x20copying\x20and\x20delete\
    \x20the\x20backup.\n\x20Concurrent\x20CopyBackup\x20requests\x20can\x20r\
    un\x20on\x20the\x20same\x20source\x20backup.\n\n\r\n\x05\x06\0\x02\x0b\
    \x01\x12\x04\x9b\x02\x06\x10\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\x9b\x02\
    \x11\"\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\x9b\x02-I\n\x0f\n\x05\x06\0\
    \x02\x0b\x04\x12\x06\x9c\x02\x04\x9f\x02\x06\n\x13\n\t\x06\0\x02\x0b\x04\
    \xb0\xca\xbc\"\x12\x06\x9c\x02\x04\x9f\x02\x06\n\r\n\x05\x06\0\x02\x0b\
    \x04\x12\x04\xa0\x02\x04X\n\x10\n\x08\x06\0\x02\x0b\x04\x9b\x08\0\x12\
    \x04\xa0\x02\x04X\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xa1\x02\x04\xa4\
    \x02\x06\n\x11\n\x07\x06\0\x02\x0b\x04\x99\x08\x12\x06\xa1\x02\x04\xa4\
    \x02\x06\nl\n\x04\x06\0\x02\x0c\x12\x06\xa8\x02\x02\xad\x02\x03\x1a\\\
    \x20Gets\x20metadata\x20on\x20a\x20pending\x20or\x20completed\x20[Backup\
    ][google.spanner.admin.database.v1.Backup].\n\n\r\n\x05\x06\0\x02\x0c\
    \x01\x12\x04\xa8\x02\x06\x0f\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xa8\x02\
    \x10\x20\n\r\n\x05\x06\0\x02\x0c\x03\x12\x04\xa8\x02+1\n\x0f\n\x05\x06\0\
    \x02\x0c\x04\x12\x06\xa9\x02\x04\xab\x02\x06\n\x13\n\t\x06\0\x02\x0c\x04\
    \xb0\xca\xbc\"\x12\x06\xa9\x02\x04\xab\x02\x06\n\r\n\x05\x06\0\x02\x0c\
    \x04\x12\x04\xac\x02\x042\n\x10\n\x08\x06\0\x02\x0c\x04\x9b\x08\0\x12\
    \x04\xac\x02\x042\nc\n\x04\x06\0\x02\r\x12\x06\xb0\x02\x02\xb6\x02\x03\
    \x1aS\x20Updates\x20a\x20pending\x20or\x20completed\x20[Backup][google.s\
    panner.admin.database.v1.Backup].\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\
    \xb0\x02\x06\x12\n\r\n\x05\x06\0\x02\r\x02\x12\x04\xb0\x02\x13&\n\r\n\
    \x05\x06\0\x02\r\x03\x12\x04\xb0\x0217\n\x0f\n\x05\x06\0\x02\r\x04\x12\
    \x06\xb1\x02\x04\xb4\x02\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\
    \x06\xb1\x02\x04\xb4\x02\x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\xb5\x02\
    \x04@\n\x10\n\x08\x06\0\x02\r\x04\x9b\x08\0\x12\x04\xb5\x02\x04@\nc\n\
    \x04\x06\0\x02\x0e\x12\x06\xb9\x02\x02\xbe\x02\x03\x1aS\x20Deletes\x20a\
    \x20pending\x20or\x20completed\x20[Backup][google.spanner.admin.database\
    .v1.Backup].\n\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\xb9\x02\x06\x12\n\r\n\
    \x05\x06\0\x02\x0e\x02\x12\x04\xb9\x02\x13&\n\r\n\x05\x06\0\x02\x0e\x03\
    \x12\x04\xb9\x021F\n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\xba\x02\x04\xbc\
    \x02\x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\xba\x02\x04\
    \xbc\x02\x06\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\xbd\x02\x042\n\x10\n\
    \x08\x06\0\x02\x0e\x04\x9b\x08\0\x12\x04\xbd\x02\x042\n\xa9\x01\n\x04\
    \x06\0\x02\x0f\x12\x06\xc3\x02\x02\xc8\x02\x03\x1a\x98\x01\x20Lists\x20c\
    ompleted\x20and\x20pending\x20backups.\n\x20Backups\x20returned\x20are\
    \x20ordered\x20by\x20`create_time`\x20in\x20descending\x20order,\n\x20st\
    arting\x20from\x20the\x20most\x20recent\x20`create_time`.\n\n\r\n\x05\
    \x06\0\x02\x0f\x01\x12\x04\xc3\x02\x06\x11\n\r\n\x05\x06\0\x02\x0f\x02\
    \x12\x04\xc3\x02\x12$\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\xc3\x02/B\n\
    \x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\xc4\x02\x04\xc6\x02\x06\n\x13\n\t\
    \x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\xc4\x02\x04\xc6\x02\x06\n\r\n\
    \x05\x06\0\x02\x0f\x04\x12\x04\xc7\x02\x044\n\x10\n\x08\x06\0\x02\x0f\
    \x04\x9b\x08\0\x12\x04\xc7\x02\x044\n\xd6\x08\n\x04\x06\0\x02\x10\x12\
    \x06\xdb\x02\x02\xe5\x02\x03\x1a\xc5\x08\x20Create\x20a\x20new\x20databa\
    se\x20by\x20restoring\x20from\x20a\x20completed\x20backup.\x20The\x20new\
    \n\x20database\x20must\x20be\x20in\x20the\x20same\x20project\x20and\x20i\
    n\x20an\x20instance\x20with\x20the\x20same\n\x20instance\x20configuratio\
    n\x20as\x20the\x20instance\x20containing\n\x20the\x20backup.\x20The\x20r\
    eturned\x20database\x20[long-running\n\x20operation][google.longrunning.\
    Operation]\x20has\x20a\x20name\x20of\x20the\x20format\n\x20`projects/<pr\
    oject>/instances/<instance>/databases/<database>/operations/<operation_i\
    d>`,\n\x20and\x20can\x20be\x20used\x20to\x20track\x20the\x20progress\x20\
    of\x20the\x20operation,\x20and\x20to\x20cancel\x20it.\n\x20The\x20[metad\
    ata][google.longrunning.Operation.metadata]\x20field\x20type\x20is\n\x20\
    [RestoreDatabaseMetadata][google.spanner.admin.database.v1.RestoreDataba\
    seMetadata].\n\x20The\x20[response][google.longrunning.Operation.respons\
    e]\x20type\n\x20is\x20[Database][google.spanner.admin.database.v1.Databa\
    se],\x20if\n\x20successful.\x20Cancelling\x20the\x20returned\x20operatio\
    n\x20will\x20stop\x20the\x20restore\x20and\n\x20delete\x20the\x20databas\
    e.\n\x20There\x20can\x20be\x20only\x20one\x20database\x20being\x20restor\
    ed\x20into\x20an\x20instance\x20at\x20a\x20time.\n\x20Once\x20the\x20res\
    tore\x20operation\x20completes,\x20a\x20new\x20restore\x20operation\x20c\
    an\x20be\n\x20initiated,\x20without\x20waiting\x20for\x20the\x20optimize\
    \x20operation\x20associated\x20with\x20the\n\x20first\x20restore\x20to\
    \x20complete.\n\n\r\n\x05\x06\0\x02\x10\x01\x12\x04\xdb\x02\x06\x15\n\r\
    \n\x05\x06\0\x02\x10\x02\x12\x04\xdb\x02\x16,\n\r\n\x05\x06\0\x02\x10\
    \x03\x12\x04\xdb\x027S\n\x0f\n\x05\x06\0\x02\x10\x04\x12\x06\xdc\x02\x04\
    \xdf\x02\x06\n\x13\n\t\x06\0\x02\x10\x04\xb0\xca\xbc\"\x12\x06\xdc\x02\
    \x04\xdf\x02\x06\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xe0\x02\x04G\n\x10\
    \n\x08\x06\0\x02\x10\x04\x9b\x08\0\x12\x04\xe0\x02\x04G\n\x0f\n\x05\x06\
    \0\x02\x10\x04\x12\x06\xe1\x02\x04\xe4\x02\x06\n\x11\n\x07\x06\0\x02\x10\
    \x04\x99\x08\x12\x06\xe1\x02\x04\xe4\x02\x06\n\xe9\x03\n\x04\x06\0\x02\
    \x11\x12\x06\xef\x02\x02\xf4\x02\x03\x1a\xd8\x03\x20Lists\x20database\
    \x20[longrunning-operations][google.longrunning.Operation].\n\x20A\x20da\
    tabase\x20operation\x20has\x20a\x20name\x20of\x20the\x20form\n\x20`proje\
    cts/<project>/instances/<instance>/databases/<database>/operations/<oper\
    ation>`.\n\x20The\x20long-running\x20operation\n\x20[metadata][google.lo\
    ngrunning.Operation.metadata]\x20field\x20type\n\x20`metadata.type_url`\
    \x20describes\x20the\x20type\x20of\x20the\x20metadata.\x20Operations\x20\
    returned\n\x20include\x20those\x20that\x20have\x20completed/failed/cance\
    led\x20within\x20the\x20last\x207\x20days,\n\x20and\x20pending\x20operat\
    ions.\n\n\r\n\x05\x06\0\x02\x11\x01\x12\x04\xef\x02\x06\x1c\n\r\n\x05\
    \x06\0\x02\x11\x02\x12\x04\xef\x02\x1d:\n\r\n\x05\x06\0\x02\x11\x03\x12\
    \x04\xef\x02Ec\n\x0f\n\x05\x06\0\x02\x11\x04\x12\x06\xf0\x02\x04\xf2\x02\
    \x06\n\x13\n\t\x06\0\x02\x11\x04\xb0\xca\xbc\"\x12\x06\xf0\x02\x04\xf2\
    \x02\x06\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xf3\x02\x044\n\x10\n\x08\
    \x06\0\x02\x11\x04\x9b\x08\0\x12\x04\xf3\x02\x044\n\x97\x05\n\x04\x06\0\
    \x02\x12\x12\x06\x80\x03\x02\x85\x03\x03\x1a\x86\x05\x20Lists\x20the\x20\
    backup\x20[long-running\x20operations][google.longrunning.Operation]\x20\
    in\n\x20the\x20given\x20instance.\x20A\x20backup\x20operation\x20has\x20\
    a\x20name\x20of\x20the\x20form\n\x20`projects/<project>/instances/<insta\
    nce>/backups/<backup>/operations/<operation>`.\n\x20The\x20long-running\
    \x20operation\n\x20[metadata][google.longrunning.Operation.metadata]\x20\
    field\x20type\n\x20`metadata.type_url`\x20describes\x20the\x20type\x20of\
    \x20the\x20metadata.\x20Operations\x20returned\n\x20include\x20those\x20\
    that\x20have\x20completed/failed/canceled\x20within\x20the\x20last\x207\
    \x20days,\n\x20and\x20pending\x20operations.\x20Operations\x20returned\
    \x20are\x20ordered\x20by\n\x20`operation.metadata.value.progress.start_t\
    ime`\x20in\x20descending\x20order\x20starting\n\x20from\x20the\x20most\
    \x20recently\x20started\x20operation.\n\n\r\n\x05\x06\0\x02\x12\x01\x12\
    \x04\x80\x03\x06\x1a\n\r\n\x05\x06\0\x02\x12\x02\x12\x04\x80\x03\x1b6\n\
    \r\n\x05\x06\0\x02\x12\x03\x12\x04\x80\x03A]\n\x0f\n\x05\x06\0\x02\x12\
    \x04\x12\x06\x81\x03\x04\x83\x03\x06\n\x13\n\t\x06\0\x02\x12\x04\xb0\xca\
    \xbc\"\x12\x06\x81\x03\x04\x83\x03\x06\n\r\n\x05\x06\0\x02\x12\x04\x12\
    \x04\x84\x03\x044\n\x10\n\x08\x06\0\x02\x12\x04\x9b\x08\0\x12\x04\x84\
    \x03\x044\n5\n\x04\x06\0\x02\x13\x12\x06\x88\x03\x02\x8d\x03\x03\x1a%\
    \x20Lists\x20Cloud\x20Spanner\x20database\x20roles.\n\n\r\n\x05\x06\0\
    \x02\x13\x01\x12\x04\x88\x03\x06\x17\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\
    \x88\x03\x180\n\r\n\x05\x06\0\x02\x13\x03\x12\x04\x88\x03;T\n\x0f\n\x05\
    \x06\0\x02\x13\x04\x12\x06\x89\x03\x04\x8b\x03\x06\n\x13\n\t\x06\0\x02\
    \x13\x04\xb0\xca\xbc\"\x12\x06\x89\x03\x04\x8b\x03\x06\n\r\n\x05\x06\0\
    \x02\x13\x04\x12\x04\x8c\x03\x044\n\x10\n\x08\x06\0\x02\x13\x04\x9b\x08\
    \0\x12\x04\x8c\x03\x044\n7\n\x02\x04\0\x12\x06\x91\x03\0\x9b\x03\x01\x1a\
    )\x20Information\x20about\x20the\x20database\x20restore.\n\n\x0b\n\x03\
    \x04\0\x01\x12\x04\x91\x03\x08\x13\n/\n\x04\x04\0\x02\0\x12\x04\x93\x03\
    \x02$\x1a!\x20The\x20type\x20of\x20the\x20restore\x20source.\n\n\r\n\x05\
    \x04\0\x02\0\x06\x12\x04\x93\x03\x02\x13\n\r\n\x05\x04\0\x02\0\x01\x12\
    \x04\x93\x03\x14\x1f\n\r\n\x05\x04\0\x02\0\x03\x12\x04\x93\x03\"#\nL\n\
    \x04\x04\0\x08\0\x12\x06\x96\x03\x02\x9a\x03\x03\x1a<\x20Information\x20\
    about\x20the\x20source\x20used\x20to\x20restore\x20the\x20database.\n\n\
    \r\n\x05\x04\0\x08\0\x01\x12\x04\x96\x03\x08\x13\nk\n\x04\x04\0\x02\x01\
    \x12\x04\x99\x03\x04\x1f\x1a]\x20Information\x20about\x20the\x20backup\
    \x20used\x20to\x20restore\x20the\x20database.\x20The\x20backup\n\x20may\
    \x20no\x20longer\x20exist.\n\n\r\n\x05\x04\0\x02\x01\x06\x12\x04\x99\x03\
    \x04\x0e\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\x99\x03\x0f\x1a\n\r\n\x05\
    \x04\0\x02\x01\x03\x12\x04\x99\x03\x1d\x1e\n)\n\x02\x04\x01\x12\x06\x9e\
    \x03\0\xfd\x03\x01\x1a\x1b\x20A\x20Cloud\x20Spanner\x20database.\n\n\x0b\
    \n\x03\x04\x01\x01\x12\x04\x9e\x03\x08\x10\n\r\n\x03\x04\x01\x07\x12\x06\
    \x9f\x03\x02\xa2\x03\x04\n\x0f\n\x05\x04\x01\x07\x9d\x08\x12\x06\x9f\x03\
    \x02\xa2\x03\x04\n>\n\x04\x04\x01\x04\0\x12\x06\xa5\x03\x02\xb9\x03\x03\
    \x1a.\x20Indicates\x20the\x20current\x20state\x20of\x20the\x20database.\
    \n\n\r\n\x05\x04\x01\x04\0\x01\x12\x04\xa5\x03\x07\x0c\n\x20\n\x06\x04\
    \x01\x04\0\x02\0\x12\x04\xa7\x03\x04\x1a\x1a\x10\x20Not\x20specified.\n\
    \n\x0f\n\x07\x04\x01\x04\0\x02\0\x01\x12\x04\xa7\x03\x04\x15\n\x0f\n\x07\
    \x04\x01\x04\0\x02\0\x02\x12\x04\xa7\x03\x18\x19\n\x85\x01\n\x06\x04\x01\
    \x04\0\x02\x01\x12\x04\xab\x03\x04\x11\x1au\x20The\x20database\x20is\x20\
    still\x20being\x20created.\x20Operations\x20on\x20the\x20database\x20may\
    \x20fail\n\x20with\x20`FAILED_PRECONDITION`\x20in\x20this\x20state.\n\n\
    \x0f\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x04\xab\x03\x04\x0c\n\x0f\n\x07\
    \x04\x01\x04\0\x02\x01\x02\x12\x04\xab\x03\x0f\x10\nB\n\x06\x04\x01\x04\
    \0\x02\x02\x12\x04\xae\x03\x04\x0e\x1a2\x20The\x20database\x20is\x20full\
    y\x20created\x20and\x20ready\x20for\x20use.\n\n\x0f\n\x07\x04\x01\x04\0\
    \x02\x02\x01\x12\x04\xae\x03\x04\t\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x02\
    \x12\x04\xae\x03\x0c\r\n\x96\x03\n\x06\x04\x01\x04\0\x02\x03\x12\x04\xb8\
    \x03\x04\x19\x1a\x85\x03\x20The\x20database\x20is\x20fully\x20created\
    \x20and\x20ready\x20for\x20use,\x20but\x20is\x20still\n\x20being\x20opti\
    mized\x20for\x20performance\x20and\x20cannot\x20handle\x20full\x20load.\
    \n\n\x20In\x20this\x20state,\x20the\x20database\x20still\x20references\
    \x20the\x20backup\n\x20it\x20was\x20restore\x20from,\x20preventing\x20th\
    e\x20backup\n\x20from\x20being\x20deleted.\x20When\x20optimizations\x20a\
    re\x20complete,\x20the\x20full\x20performance\n\x20of\x20the\x20database\
    \x20will\x20be\x20restored,\x20and\x20the\x20database\x20will\x20transit\
    ion\x20to\n\x20`READY`\x20state.\n\n\x0f\n\x07\x04\x01\x04\0\x02\x03\x01\
    \x12\x04\xb8\x03\x04\x14\n\x0f\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x04\
    \xb8\x03\x17\x18\n\x9d\x02\n\x04\x04\x01\x02\0\x12\x04\xc0\x03\x02;\x1a\
    \x8e\x02\x20Required.\x20The\x20name\x20of\x20the\x20database.\x20Values\
    \x20are\x20of\x20the\x20form\n\x20`projects/<project>/instances/<instanc\
    e>/databases/<database>`,\n\x20where\x20`<database>`\x20is\x20as\x20spec\
    ified\x20in\x20the\x20`CREATE\x20DATABASE`\n\x20statement.\x20This\x20na\
    me\x20can\x20be\x20passed\x20to\x20other\x20API\x20methods\x20to\n\x20id\
    entify\x20the\x20database.\n\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xc0\x03\
    \x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xc0\x03\t\r\n\r\n\x05\x04\
    \x01\x02\0\x03\x12\x04\xc0\x03\x10\x11\n\r\n\x05\x04\x01\x02\0\x08\x12\
    \x04\xc0\x03\x12:\n\x10\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\x04\xc0\
    \x03\x139\n8\n\x04\x04\x01\x02\x01\x12\x04\xc3\x03\x02>\x1a*\x20Output\
    \x20only.\x20The\x20current\x20database\x20state.\n\n\r\n\x05\x04\x01\
    \x02\x01\x06\x12\x04\xc3\x03\x02\x07\n\r\n\x05\x04\x01\x02\x01\x01\x12\
    \x04\xc3\x03\x08\r\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xc3\x03\x10\x11\
    \n\r\n\x05\x04\x01\x02\x01\x08\x12\x04\xc3\x03\x12=\n\x10\n\x08\x04\x01\
    \x02\x01\x08\x9c\x08\0\x12\x04\xc3\x03\x13<\nX\n\x04\x04\x01\x02\x02\x12\
    \x04\xc6\x03\x02X\x1aJ\x20Output\x20only.\x20If\x20exists,\x20the\x20tim\
    e\x20at\x20which\x20the\x20database\x20creation\x20started.\n\n\r\n\x05\
    \x04\x01\x02\x02\x06\x12\x04\xc6\x03\x02\x1b\n\r\n\x05\x04\x01\x02\x02\
    \x01\x12\x04\xc6\x03\x1c'\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xc6\x03*\
    +\n\r\n\x05\x04\x01\x02\x02\x08\x12\x04\xc6\x03,W\n\x10\n\x08\x04\x01\
    \x02\x02\x08\x9c\x08\0\x12\x04\xc6\x03-V\nt\n\x04\x04\x01\x02\x03\x12\
    \x04\xca\x03\x02K\x1af\x20Output\x20only.\x20Applicable\x20only\x20for\
    \x20restored\x20databases.\x20Contains\x20information\n\x20about\x20the\
    \x20restore\x20source.\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\xca\x03\
    \x02\r\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\xca\x03\x0e\x1a\n\r\n\x05\
    \x04\x01\x02\x03\x03\x12\x04\xca\x03\x1d\x1e\n\r\n\x05\x04\x01\x02\x03\
    \x08\x12\x04\xca\x03\x1fJ\n\x10\n\x08\x04\x01\x02\x03\x08\x9c\x08\0\x12\
    \x04\xca\x03\x20I\n\xfc\x01\n\x04\x04\x01\x02\x04\x12\x04\xd0\x03\x02U\
    \x1a\xed\x01\x20Output\x20only.\x20For\x20databases\x20that\x20are\x20us\
    ing\x20customer\x20managed\x20encryption,\x20this\n\x20field\x20contains\
    \x20the\x20encryption\x20configuration\x20for\x20the\x20database.\n\x20F\
    or\x20databases\x20that\x20are\x20using\x20Google\x20default\x20or\x20ot\
    her\x20types\x20of\x20encryption,\n\x20this\x20field\x20is\x20empty.\n\n\
    \r\n\x05\x04\x01\x02\x04\x06\x12\x04\xd0\x03\x02\x12\n\r\n\x05\x04\x01\
    \x02\x04\x01\x12\x04\xd0\x03\x13$\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\
    \xd0\x03'(\n\r\n\x05\x04\x01\x02\x04\x08\x12\x04\xd0\x03)T\n\x10\n\x08\
    \x04\x01\x02\x04\x08\x9c\x08\0\x12\x04\xd0\x03*S\n\xda\x03\n\x04\x04\x01\
    \x02\x05\x12\x04\xdb\x03\x02Z\x1a\xcb\x03\x20Output\x20only.\x20For\x20d\
    atabases\x20that\x20are\x20using\x20customer\x20managed\x20encryption,\
    \x20this\n\x20field\x20contains\x20the\x20encryption\x20information\x20f\
    or\x20the\x20database,\x20such\x20as\n\x20encryption\x20state\x20and\x20\
    the\x20Cloud\x20KMS\x20key\x20versions\x20that\x20are\x20in\x20use.\n\n\
    \x20For\x20databases\x20that\x20are\x20using\x20Google\x20default\x20or\
    \x20other\x20types\x20of\x20encryption,\n\x20this\x20field\x20is\x20empt\
    y.\n\n\x20This\x20field\x20is\x20propagated\x20lazily\x20from\x20the\x20\
    backend.\x20There\x20might\x20be\x20a\x20delay\n\x20from\x20when\x20a\
    \x20key\x20version\x20is\x20being\x20used\x20and\x20when\x20it\x20appear\
    s\x20in\x20this\x20field.\n\n\r\n\x05\x04\x01\x02\x05\x04\x12\x04\xdb\
    \x03\x02\n\n\r\n\x05\x04\x01\x02\x05\x06\x12\x04\xdb\x03\x0b\x19\n\r\n\
    \x05\x04\x01\x02\x05\x01\x12\x04\xdb\x03\x1a)\n\r\n\x05\x04\x01\x02\x05\
    \x03\x12\x04\xdb\x03,-\n\r\n\x05\x04\x01\x02\x05\x08\x12\x04\xdb\x03.Y\n\
    \x10\n\x08\x04\x01\x02\x05\x08\x9c\x08\0\x12\x04\xdb\x03/X\n\xbd\x02\n\
    \x04\x04\x01\x02\x06\x12\x04\xe2\x03\x02R\x1a\xae\x02\x20Output\x20only.\
    \x20The\x20period\x20in\x20which\x20Cloud\x20Spanner\x20retains\x20all\
    \x20versions\x20of\x20data\n\x20for\x20the\x20database.\x20This\x20is\
    \x20the\x20same\x20as\x20the\x20value\x20of\x20version_retention_period\
    \n\x20database\x20option\x20set\x20using\n\x20[UpdateDatabaseDdl][google\
    .spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl].\x20Defaults\
    \x20to\x201\x20hour,\n\x20if\x20not\x20set.\n\n\r\n\x05\x04\x01\x02\x06\
    \x05\x12\x04\xe2\x03\x02\x08\n\r\n\x05\x04\x01\x02\x06\x01\x12\x04\xe2\
    \x03\t!\n\r\n\x05\x04\x01\x02\x06\x03\x12\x04\xe2\x03$%\n\r\n\x05\x04\
    \x01\x02\x06\x08\x12\x04\xe2\x03&Q\n\x10\n\x08\x04\x01\x02\x06\x08\x9c\
    \x08\0\x12\x04\xe2\x03'P\n\xec\x02\n\x04\x04\x01\x02\x07\x12\x04\xe9\x03\
    \x02b\x1a\xdd\x02\x20Output\x20only.\x20Earliest\x20timestamp\x20at\x20w\
    hich\x20older\x20versions\x20of\x20the\x20data\x20can\x20be\n\x20read.\
    \x20This\x20value\x20is\x20continuously\x20updated\x20by\x20Cloud\x20Spa\
    nner\x20and\x20becomes\x20stale\n\x20the\x20moment\x20it\x20is\x20querie\
    d.\x20If\x20you\x20are\x20using\x20this\x20value\x20to\x20recover\x20dat\
    a,\x20make\n\x20sure\x20to\x20account\x20for\x20the\x20time\x20from\x20t\
    he\x20moment\x20when\x20the\x20value\x20is\x20queried\x20to\n\x20the\x20\
    moment\x20when\x20you\x20initiate\x20the\x20recovery.\n\n\r\n\x05\x04\
    \x01\x02\x07\x06\x12\x04\xe9\x03\x02\x1b\n\r\n\x05\x04\x01\x02\x07\x01\
    \x12\x04\xe9\x03\x1c1\n\r\n\x05\x04\x01\x02\x07\x03\x12\x04\xe9\x0345\n\
    \r\n\x05\x04\x01\x02\x07\x08\x12\x04\xe9\x036a\n\x10\n\x08\x04\x01\x02\
    \x07\x08\x9c\x08\0\x12\x04\xe9\x037`\n\x98\x02\n\x04\x04\x01\x02\x08\x12\
    \x04\xf1\x03\x02H\x1a\x89\x02\x20Output\x20only.\x20The\x20read-write\
    \x20region\x20which\x20contains\x20the\x20database's\x20leader\n\x20repl\
    icas.\n\n\x20This\x20is\x20the\x20same\x20as\x20the\x20value\x20of\x20de\
    fault_leader\n\x20database\x20option\x20set\x20using\x20DatabaseAdmin.Cr\
    eateDatabase\x20or\n\x20DatabaseAdmin.UpdateDatabaseDdl.\x20If\x20not\
    \x20explicitly\x20set,\x20this\x20is\x20empty.\n\n\r\n\x05\x04\x01\x02\
    \x08\x05\x12\x04\xf1\x03\x02\x08\n\r\n\x05\x04\x01\x02\x08\x01\x12\x04\
    \xf1\x03\t\x17\n\r\n\x05\x04\x01\x02\x08\x03\x12\x04\xf1\x03\x1a\x1b\n\r\
    \n\x05\x04\x01\x02\x08\x08\x12\x04\xf1\x03\x1cG\n\x10\n\x08\x04\x01\x02\
    \x08\x08\x9c\x08\0\x12\x04\xf1\x03\x1dF\nG\n\x04\x04\x01\x02\t\x12\x04\
    \xf4\x03\x02T\x1a9\x20Output\x20only.\x20The\x20dialect\x20of\x20the\x20\
    Cloud\x20Spanner\x20Database.\n\n\r\n\x05\x04\x01\x02\t\x06\x12\x04\xf4\
    \x03\x02\x11\n\r\n\x05\x04\x01\x02\t\x01\x12\x04\xf4\x03\x12\"\n\r\n\x05\
    \x04\x01\x02\t\x03\x12\x04\xf4\x03%'\n\r\n\x05\x04\x01\x02\t\x08\x12\x04\
    \xf4\x03(S\n\x10\n\x08\x04\x01\x02\t\x08\x9c\x08\0\x12\x04\xf4\x03)R\ne\
    \n\x04\x04\x01\x02\n\x12\x04\xf8\x03\x02#\x1aW\x20Whether\x20drop\x20pro\
    tection\x20is\x20enabled\x20for\x20this\x20database.\x20Defaults\x20to\
    \x20false,\n\x20if\x20not\x20set.\n\n\r\n\x05\x04\x01\x02\n\x05\x12\x04\
    \xf8\x03\x02\x06\n\r\n\x05\x04\x01\x02\n\x01\x12\x04\xf8\x03\x07\x1d\n\r\
    \n\x05\x04\x01\x02\n\x03\x12\x04\xf8\x03\x20\"\n\x88\x01\n\x04\x04\x01\
    \x02\x0b\x12\x04\xfc\x03\x02D\x1az\x20Output\x20only.\x20If\x20true,\x20\
    the\x20database\x20is\x20being\x20updated.\x20If\x20false,\x20there\x20a\
    re\x20no\n\x20ongoing\x20update\x20operations\x20for\x20the\x20database.\
    \n\n\r\n\x05\x04\x01\x02\x0b\x05\x12\x04\xfc\x03\x02\x06\n\r\n\x05\x04\
    \x01\x02\x0b\x01\x12\x04\xfc\x03\x07\x12\n\r\n\x05\x04\x01\x02\x0b\x03\
    \x12\x04\xfc\x03\x15\x17\n\r\n\x05\x04\x01\x02\x0b\x08\x12\x04\xfc\x03\
    \x18C\n\x10\n\x08\x04\x01\x02\x0b\x08\x9c\x08\0\x12\x04\xfc\x03\x19B\nn\
    \n\x02\x04\x02\x12\x06\x80\x04\0\x92\x04\x01\x1a`\x20The\x20request\x20f\
    or\x20[ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.Lis\
    tDatabases].\n\n\x0b\n\x03\x04\x02\x01\x12\x04\x80\x04\x08\x1c\n\x8d\x01\
    \n\x04\x04\x02\x02\0\x12\x06\x83\x04\x02\x88\x04\x04\x1a}\x20Required.\
    \x20The\x20instance\x20whose\x20databases\x20should\x20be\x20listed.\n\
    \x20Values\x20are\x20of\x20the\x20form\x20`projects/<project>/instances/\
    <instance>`.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x83\x04\x02\x08\n\r\n\
    \x05\x04\x02\x02\0\x01\x12\x04\x83\x04\t\x0f\n\r\n\x05\x04\x02\x02\0\x03\
    \x12\x04\x83\x04\x12\x13\n\x0f\n\x05\x04\x02\x02\0\x08\x12\x06\x83\x04\
    \x14\x88\x04\x03\n\x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\x84\x04\
    \x04*\n\x11\n\x07\x04\x02\x02\0\x08\x9f\x08\x12\x06\x85\x04\x04\x87\x04\
    \x05\n\x86\x01\n\x04\x04\x02\x02\x01\x12\x04\x8c\x04\x02\x16\x1ax\x20Num\
    ber\x20of\x20databases\x20to\x20be\x20returned\x20in\x20the\x20response.\
    \x20If\x200\x20or\x20less,\n\x20defaults\x20to\x20the\x20server's\x20max\
    imum\x20allowed\x20page\x20size.\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\
    \x8c\x04\x02\x07\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x8c\x04\x08\x11\n\
    \r\n\x05\x04\x02\x02\x01\x03\x12\x04\x8c\x04\x14\x15\n\xf9\x01\n\x04\x04\
    \x02\x02\x02\x12\x04\x91\x04\x02\x18\x1a\xea\x01\x20If\x20non-empty,\x20\
    `page_token`\x20should\x20contain\x20a\n\x20[next_page_token][google.spa\
    nner.admin.database.v1.ListDatabasesResponse.next_page_token]\x20from\
    \x20a\n\x20previous\x20[ListDatabasesResponse][google.spanner.admin.data\
    base.v1.ListDatabasesResponse].\n\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\
    \x91\x04\x02\x08\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x91\x04\t\x13\n\r\
    \n\x05\x04\x02\x02\x02\x03\x12\x04\x91\x04\x16\x17\no\n\x02\x04\x03\x12\
    \x06\x95\x04\0\x9d\x04\x01\x1aa\x20The\x20response\x20for\x20[ListDataba\
    ses][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases].\n\n\
    \x0b\n\x03\x04\x03\x01\x12\x04\x95\x04\x08\x1d\n3\n\x04\x04\x03\x02\0\
    \x12\x04\x97\x04\x02\"\x1a%\x20Databases\x20that\x20matched\x20the\x20re\
    quest.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x97\x04\x02\n\n\r\n\x05\x04\
    \x03\x02\0\x06\x12\x04\x97\x04\x0b\x13\n\r\n\x05\x04\x03\x02\0\x01\x12\
    \x04\x97\x04\x14\x1d\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x97\x04\x20!\n\
    \xbc\x01\n\x04\x04\x03\x02\x01\x12\x04\x9c\x04\x02\x1d\x1a\xad\x01\x20`n\
    ext_page_token`\x20can\x20be\x20sent\x20in\x20a\x20subsequent\n\x20[List\
    Databases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases]\
    \x20call\x20to\x20fetch\x20more\n\x20of\x20the\x20matching\x20databases.\
    \n\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\x9c\x04\x02\x08\n\r\n\x05\x04\
    \x03\x02\x01\x01\x12\x04\x9c\x04\t\x18\n\r\n\x05\x04\x03\x02\x01\x03\x12\
    \x04\x9c\x04\x1b\x1c\np\n\x02\x04\x04\x12\x06\xa0\x04\0\xcf\x04\x01\x1ab\
    \x20The\x20request\x20for\x20[CreateDatabase][google.spanner.admin.datab\
    ase.v1.DatabaseAdmin.CreateDatabase].\n\n\x0b\n\x03\x04\x04\x01\x12\x04\
    \xa0\x04\x08\x1d\n\x9a\x01\n\x04\x04\x04\x02\0\x12\x06\xa3\x04\x02\xa8\
    \x04\x04\x1a\x89\x01\x20Required.\x20The\x20name\x20of\x20the\x20instanc\
    e\x20that\x20will\x20serve\x20the\x20new\x20database.\n\x20Values\x20are\
    \x20of\x20the\x20form\x20`projects/<project>/instances/<instance>`.\n\n\
    \r\n\x05\x04\x04\x02\0\x05\x12\x04\xa3\x04\x02\x08\n\r\n\x05\x04\x04\x02\
    \0\x01\x12\x04\xa3\x04\t\x0f\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xa3\x04\
    \x12\x13\n\x0f\n\x05\x04\x04\x02\0\x08\x12\x06\xa3\x04\x14\xa8\x04\x03\n\
    \x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\xa4\x04\x04*\n\x11\n\x07\
    \x04\x04\x02\0\x08\x9f\x08\x12\x06\xa5\x04\x04\xa7\x04\x05\n\xe6\x02\n\
    \x04\x04\x04\x02\x01\x12\x04\xaf\x04\x02G\x1a\xd7\x02\x20Required.\x20A\
    \x20`CREATE\x20DATABASE`\x20statement,\x20which\x20specifies\x20the\x20I\
    D\x20of\x20the\n\x20new\x20database.\x20\x20The\x20database\x20ID\x20mus\
    t\x20conform\x20to\x20the\x20regular\x20expression\n\x20`[a-z][a-z0-9_\\\
    -]*[a-z0-9]`\x20and\x20be\x20between\x202\x20and\x2030\x20characters\x20\
    in\x20length.\n\x20If\x20the\x20database\x20ID\x20is\x20a\x20reserved\
    \x20word\x20or\x20if\x20it\x20contains\x20a\x20hyphen,\x20the\n\x20datab\
    ase\x20ID\x20must\x20be\x20enclosed\x20in\x20backticks\x20(``\x20`\x20``\
    ).\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xaf\x04\x02\x08\n\r\n\x05\x04\
    \x04\x02\x01\x01\x12\x04\xaf\x04\t\x19\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\xaf\x04\x1c\x1d\n\r\n\x05\x04\x04\x02\x01\x08\x12\x04\xaf\x04\x1eF\
    \n\x10\n\x08\x04\x04\x02\x01\x08\x9c\x08\0\x12\x04\xaf\x04\x1fE\n\x97\
    \x02\n\x04\x04\x04\x02\x02\x12\x04\xb5\x04\x02P\x1a\x88\x02\x20Optional.\
    \x20A\x20list\x20of\x20DDL\x20statements\x20to\x20run\x20inside\x20the\
    \x20newly\x20created\n\x20database.\x20Statements\x20can\x20create\x20ta\
    bles,\x20indexes,\x20etc.\x20These\n\x20statements\x20execute\x20atomica\
    lly\x20with\x20the\x20creation\x20of\x20the\x20database:\n\x20if\x20ther\
    e\x20is\x20an\x20error\x20in\x20any\x20statement,\x20the\x20database\x20\
    is\x20not\x20created.\n\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xb5\x04\
    \x02\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xb5\x04\x0b\x11\n\r\n\x05\
    \x04\x04\x02\x02\x01\x12\x04\xb5\x04\x12\"\n\r\n\x05\x04\x04\x02\x02\x03\
    \x12\x04\xb5\x04%&\n\r\n\x05\x04\x04\x02\x02\x08\x12\x04\xb5\x04'O\n\x10\
    \n\x08\x04\x04\x02\x02\x08\x9c\x08\0\x12\x04\xb5\x04(N\n\xc0\x01\n\x04\
    \x04\x04\x02\x03\x12\x04\xba\x04\x02R\x1a\xb1\x01\x20Optional.\x20The\
    \x20encryption\x20configuration\x20for\x20the\x20database.\x20If\x20this\
    \x20field\x20is\x20not\n\x20specified,\x20Cloud\x20Spanner\x20will\x20en\
    crypt/decrypt\x20all\x20data\x20at\x20rest\x20using\n\x20Google\x20defau\
    lt\x20encryption.\n\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\xba\x04\x02\
    \x12\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xba\x04\x13$\n\r\n\x05\x04\
    \x04\x02\x03\x03\x12\x04\xba\x04'(\n\r\n\x05\x04\x04\x02\x03\x08\x12\x04\
    \xba\x04)Q\n\x10\n\x08\x04\x04\x02\x03\x08\x9c\x08\0\x12\x04\xba\x04*P\n\
    D\n\x04\x04\x04\x02\x04\x12\x04\xbd\x04\x02P\x1a6\x20Optional.\x20The\
    \x20dialect\x20of\x20the\x20Cloud\x20Spanner\x20Database.\n\n\r\n\x05\
    \x04\x04\x02\x04\x06\x12\x04\xbd\x04\x02\x11\n\r\n\x05\x04\x04\x02\x04\
    \x01\x12\x04\xbd\x04\x12\"\n\r\n\x05\x04\x04\x02\x04\x03\x12\x04\xbd\x04\
    %&\n\r\n\x05\x04\x04\x02\x04\x08\x12\x04\xbd\x04'O\n\x10\n\x08\x04\x04\
    \x02\x04\x08\x9c\x08\0\x12\x04\xbd\x04(N\n\x94\x06\n\x04\x04\x04\x02\x05\
    \x12\x04\xce\x04\x02G\x1a\x85\x06\x20Optional.\x20Proto\x20descriptors\
    \x20used\x20by\x20CREATE/ALTER\x20PROTO\x20BUNDLE\x20statements\x20in\n\
    \x20'extra_statements'\x20above.\n\x20Contains\x20a\x20protobuf-serializ\
    ed\n\x20[google.protobuf.FileDescriptorSet](https://github.com/protocolb\
    uffers/protobuf/blob/main/src/google/protobuf/descriptor.proto).\n\x20To\
    \x20generate\x20it,\x20[install](https://grpc.io/docs/protoc-installatio\
    n/)\x20and\n\x20run\x20`protoc`\x20with\x20--include_imports\x20and\x20-\
    -descriptor_set_out.\x20For\x20example,\n\x20to\x20generate\x20for\x20mo\
    on/shot/app.proto,\x20run\n\x20```\n\x20$protoc\x20\x20--proto_path=/app\
    _path\x20--proto_path=/lib_path\x20\\\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20--include_imports\x20\\\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20--descriptor_set_out=descriptors.data\x20\\\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20moon/shot/app.proto\n\x20```\n\x20For\x20more\x20det\
    ails,\x20see\x20protobuffer\x20[self\n\x20description](https://developer\
    s.google.com/protocol-buffers/docs/techniques#self-description).\n\n\r\n\
    \x05\x04\x04\x02\x05\x05\x12\x04\xce\x04\x02\x07\n\r\n\x05\x04\x04\x02\
    \x05\x01\x12\x04\xce\x04\x08\x19\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\
    \xce\x04\x1c\x1d\n\r\n\x05\x04\x04\x02\x05\x08\x12\x04\xce\x04\x1eF\n\
    \x10\n\x08\x04\x04\x02\x05\x08\x9c\x08\0\x12\x04\xce\x04\x1fE\n\x8d\x01\
    \n\x02\x04\x05\x12\x06\xd3\x04\0\xd8\x04\x01\x1a\x7f\x20Metadata\x20type\
    \x20for\x20the\x20operation\x20returned\x20by\n\x20[CreateDatabase][goog\
    le.spanner.admin.database.v1.DatabaseAdmin.CreateDatabase].\n\n\x0b\n\
    \x03\x04\x05\x01\x12\x04\xd3\x04\x08\x1e\n-\n\x04\x04\x05\x02\0\x12\x06\
    \xd5\x04\x02\xd7\x04\x1a\x1a\x1d\x20The\x20database\x20being\x20created.\
    \n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xd5\x04\x02\x08\n\r\n\x05\x04\x05\
    \x02\0\x01\x12\x04\xd5\x04\t\x11\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xd5\
    \x04\x14\x15\n\x0f\n\x05\x04\x05\x02\0\x08\x12\x06\xd5\x04\x16\xd7\x04\
    \x19\n\x11\n\x07\x04\x05\x02\0\x08\x9f\x08\x12\x06\xd5\x04\x17\xd7\x04\
    \x18\nj\n\x02\x04\x06\x12\x06\xdb\x04\0\xe4\x04\x01\x1a\\\x20The\x20requ\
    est\x20for\x20[GetDatabase][google.spanner.admin.database.v1.DatabaseAdm\
    in.GetDatabase].\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xdb\x04\x08\x1a\n\x98\
    \x01\n\x04\x04\x06\x02\0\x12\x06\xde\x04\x02\xe3\x04\x04\x1a\x87\x01\x20\
    Required.\x20The\x20name\x20of\x20the\x20requested\x20database.\x20Value\
    s\x20are\x20of\x20the\x20form\n\x20`projects/<project>/instances/<instan\
    ce>/databases/<database>`.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xde\x04\
    \x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xde\x04\t\r\n\r\n\x05\x04\
    \x06\x02\0\x03\x12\x04\xde\x04\x10\x11\n\x0f\n\x05\x04\x06\x02\0\x08\x12\
    \x06\xde\x04\x12\xe3\x04\x03\n\x10\n\x08\x04\x06\x02\0\x08\x9c\x08\0\x12\
    \x04\xdf\x04\x04*\n\x11\n\x07\x04\x06\x02\0\x08\x9f\x08\x12\x06\xe0\x04\
    \x04\xe2\x04\x05\nq\n\x02\x04\x07\x12\x06\xe8\x04\0\xf2\x04\x01\x1ac\x20\
    The\x20request\x20for\n\x20[UpdateDatabase][google.spanner.admin.databas\
    e.v1.DatabaseAdmin.UpdateDatabase].\n\n\x0b\n\x03\x04\x07\x01\x12\x04\
    \xe8\x04\x08\x1d\n\xa4\x01\n\x04\x04\x07\x02\0\x12\x04\xec\x04\x02A\x1a\
    \x95\x01\x20Required.\x20The\x20database\x20to\x20update.\n\x20The\x20`n\
    ame`\x20field\x20of\x20the\x20database\x20is\x20of\x20the\x20form\n\x20`\
    projects/<project>/instances/<instance>/databases/<database>`.\n\n\r\n\
    \x05\x04\x07\x02\0\x06\x12\x04\xec\x04\x02\n\n\r\n\x05\x04\x07\x02\0\x01\
    \x12\x04\xec\x04\x0b\x13\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xec\x04\x16\
    \x17\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\xec\x04\x18@\n\x10\n\x08\x04\
    \x07\x02\0\x08\x9c\x08\0\x12\x04\xec\x04\x19?\ny\n\x04\x04\x07\x02\x01\
    \x12\x06\xf0\x04\x02\xf1\x04/\x1ai\x20Required.\x20The\x20list\x20of\x20\
    fields\x20to\x20update.\x20Currently,\x20only\n\x20`enable_drop_protecti\
    on`\x20field\x20can\x20be\x20updated.\n\n\r\n\x05\x04\x07\x02\x01\x06\
    \x12\x04\xf0\x04\x02\x1b\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xf0\x04\
    \x1c'\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xf0\x04*+\n\r\n\x05\x04\x07\
    \x02\x01\x08\x12\x04\xf1\x04\x06.\n\x10\n\x08\x04\x07\x02\x01\x08\x9c\
    \x08\0\x12\x04\xf1\x04\x07-\n\x8d\x01\n\x02\x04\x08\x12\x06\xf6\x04\0\
    \x83\x05\x01\x1a\x7f\x20Metadata\x20type\x20for\x20the\x20operation\x20r\
    eturned\x20by\n\x20[UpdateDatabase][google.spanner.admin.database.v1.Dat\
    abaseAdmin.UpdateDatabase].\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xf6\x04\
    \x08\x1e\nq\n\x04\x04\x08\x02\0\x12\x04\xf9\x04\x02$\x1ac\x20The\x20requ\
    est\x20for\n\x20[UpdateDatabase][google.spanner.admin.database.v1.Databa\
    seAdmin.UpdateDatabase].\n\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xf9\x04\
    \x02\x17\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xf9\x04\x18\x1f\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xf9\x04\"#\n\x80\x01\n\x04\x04\x08\x02\x01\
    \x12\x04\xfe\x04\x02!\x1ar\x20The\x20progress\x20of\x20the\n\x20[UpdateD\
    atabase][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabase]\
    \n\x20operation.\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xfe\x04\x02\x13\
    \n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xfe\x04\x14\x1c\n\r\n\x05\x04\x08\
    \x02\x01\x03\x12\x04\xfe\x04\x1f\x20\n\x94\x01\n\x04\x04\x08\x02\x02\x12\
    \x04\x82\x05\x02,\x1a\x85\x01\x20The\x20time\x20at\x20which\x20this\x20o\
    peration\x20was\x20cancelled.\x20If\x20set,\x20this\x20operation\x20is\n\
    \x20in\x20the\x20process\x20of\x20undoing\x20itself\x20(which\x20is\x20b\
    est-effort).\n\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\x82\x05\x02\x1b\n\r\
    \n\x05\x04\x08\x02\x02\x01\x12\x04\x82\x05\x1c'\n\r\n\x05\x04\x08\x02\
    \x02\x03\x12\x04\x82\x05*+\n\x99\x07\n\x02\x04\t\x12\x06\x95\x05\0\xc5\
    \x05\x01\x1a\x8a\x07\x20Enqueues\x20the\x20given\x20DDL\x20statements\
    \x20to\x20be\x20applied,\x20in\x20order\x20but\x20not\n\x20necessarily\
    \x20all\x20at\x20once,\x20to\x20the\x20database\x20schema\x20at\x20some\
    \x20point\x20(or\n\x20points)\x20in\x20the\x20future.\x20The\x20server\
    \x20checks\x20that\x20the\x20statements\n\x20are\x20executable\x20(synta\
    ctically\x20valid,\x20name\x20tables\x20that\x20exist,\x20etc.)\n\x20bef\
    ore\x20enqueueing\x20them,\x20but\x20they\x20may\x20still\x20fail\x20upo\
    n\n\x20later\x20execution\x20(e.g.,\x20if\x20a\x20statement\x20from\x20a\
    nother\x20batch\x20of\n\x20statements\x20is\x20applied\x20first\x20and\
    \x20it\x20conflicts\x20in\x20some\x20way,\x20or\x20if\n\x20there\x20is\
    \x20some\x20data-related\x20problem\x20like\x20a\x20`NULL`\x20value\x20i\
    n\x20a\x20column\x20to\n\x20which\x20`NOT\x20NULL`\x20would\x20be\x20add\
    ed).\x20If\x20a\x20statement\x20fails,\x20all\n\x20subsequent\x20stateme\
    nts\x20in\x20the\x20batch\x20are\x20automatically\x20cancelled.\n\n\x20E\
    ach\x20batch\x20of\x20statements\x20is\x20assigned\x20a\x20name\x20which\
    \x20can\x20be\x20used\x20with\n\x20the\x20[Operations][google.longrunnin\
    g.Operations]\x20API\x20to\x20monitor\n\x20progress.\x20See\x20the\n\x20\
    [operation_id][google.spanner.admin.database.v1.UpdateDatabaseDdlRequest\
    .operation_id]\x20field\x20for\x20more\n\x20details.\n\n\x0b\n\x03\x04\t\
    \x01\x12\x04\x95\x05\x08\x20\n3\n\x04\x04\t\x02\0\x12\x06\x97\x05\x02\
    \x9c\x05\x04\x1a#\x20Required.\x20The\x20database\x20to\x20update.\n\n\r\
    \n\x05\x04\t\x02\0\x05\x12\x04\x97\x05\x02\x08\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\x97\x05\t\x11\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x97\x05\x14\x15\
    \n\x0f\n\x05\x04\t\x02\0\x08\x12\x06\x97\x05\x16\x9c\x05\x03\n\x10\n\x08\
    \x04\t\x02\0\x08\x9c\x08\0\x12\x04\x98\x05\x04*\n\x11\n\x07\x04\t\x02\0\
    \x08\x9f\x08\x12\x06\x99\x05\x04\x9b\x05\x05\nG\n\x04\x04\t\x02\x01\x12\
    \x04\x9f\x05\x02J\x1a9\x20Required.\x20DDL\x20statements\x20to\x20be\x20\
    applied\x20to\x20the\x20database.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\
    \x9f\x05\x02\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x9f\x05\x0b\x11\n\r\n\
    \x05\x04\t\x02\x01\x01\x12\x04\x9f\x05\x12\x1c\n\r\n\x05\x04\t\x02\x01\
    \x03\x12\x04\x9f\x05\x1f\x20\n\r\n\x05\x04\t\x02\x01\x08\x12\x04\x9f\x05\
    !I\n\x10\n\x08\x04\t\x02\x01\x08\x9c\x08\0\x12\x04\x9f\x05\"H\n\xe4\x08\
    \n\x04\x04\t\x02\x02\x12\x04\xb4\x05\x02\x1a\x1a\xd5\x08\x20If\x20empty,\
    \x20the\x20new\x20update\x20request\x20is\x20assigned\x20an\n\x20automat\
    ically-generated\x20operation\x20ID.\x20Otherwise,\x20`operation_id`\n\
    \x20is\x20used\x20to\x20construct\x20the\x20name\x20of\x20the\x20resulti\
    ng\n\x20[Operation][google.longrunning.Operation].\n\n\x20Specifying\x20\
    an\x20explicit\x20operation\x20ID\x20simplifies\x20determining\n\x20whet\
    her\x20the\x20statements\x20were\x20executed\x20in\x20the\x20event\x20th\
    at\x20the\n\x20[UpdateDatabaseDdl][google.spanner.admin.database.v1.Data\
    baseAdmin.UpdateDatabaseDdl]\x20call\x20is\x20replayed,\n\x20or\x20the\
    \x20return\x20value\x20is\x20otherwise\x20lost:\x20the\x20[database][goo\
    gle.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database]\x20and\
    \n\x20`operation_id`\x20fields\x20can\x20be\x20combined\x20to\x20form\
    \x20the\n\x20[name][google.longrunning.Operation.name]\x20of\x20the\x20r\
    esulting\n\x20[longrunning.Operation][google.longrunning.Operation]:\x20\
    `<database>/operations/<operation_id>`.\n\n\x20`operation_id`\x20should\
    \x20be\x20unique\x20within\x20the\x20database,\x20and\x20must\x20be\n\
    \x20a\x20valid\x20identifier:\x20`[a-z][a-z0-9_]*`.\x20Note\x20that\n\
    \x20automatically-generated\x20operation\x20IDs\x20always\x20begin\x20wi\
    th\x20an\n\x20underscore.\x20If\x20the\x20named\x20operation\x20already\
    \x20exists,\n\x20[UpdateDatabaseDdl][google.spanner.admin.database.v1.Da\
    tabaseAdmin.UpdateDatabaseDdl]\x20returns\n\x20`ALREADY_EXISTS`.\n\n\r\n\
    \x05\x04\t\x02\x02\x05\x12\x04\xb4\x05\x02\x08\n\r\n\x05\x04\t\x02\x02\
    \x01\x12\x04\xb4\x05\t\x15\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xb4\x05\
    \x18\x19\n\xf7\x05\n\x04\x04\t\x02\x03\x12\x04\xc4\x05\x02G\x1a\xe8\x05\
    \x20Optional.\x20Proto\x20descriptors\x20used\x20by\x20CREATE/ALTER\x20P\
    ROTO\x20BUNDLE\x20statements.\n\x20Contains\x20a\x20protobuf-serialized\
    \n\x20[google.protobuf.FileDescriptorSet](https://github.com/protocolbuf\
    fers/protobuf/blob/main/src/google/protobuf/descriptor.proto).\n\x20To\
    \x20generate\x20it,\x20[install](https://grpc.io/docs/protoc-installatio\
    n/)\x20and\n\x20run\x20`protoc`\x20with\x20--include_imports\x20and\x20-\
    -descriptor_set_out.\x20For\x20example,\n\x20to\x20generate\x20for\x20mo\
    on/shot/app.proto,\x20run\n\x20```\n\x20$protoc\x20\x20--proto_path=/app\
    _path\x20--proto_path=/lib_path\x20\\\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20--include_imports\x20\\\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20--descriptor_set_out=descriptors.data\x20\\\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20moon/shot/app.proto\n\x20```\n\x20For\x20more\x20det\
    ails,\x20see\x20protobuffer\x20[self\n\x20description](https://developer\
    s.google.com/protocol-buffers/docs/techniques#self-description).\n\n\r\n\
    \x05\x04\t\x02\x03\x05\x12\x04\xc4\x05\x02\x07\n\r\n\x05\x04\t\x02\x03\
    \x01\x12\x04\xc4\x05\x08\x19\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xc4\x05\
    \x1c\x1d\n\r\n\x05\x04\t\x02\x03\x08\x12\x04\xc4\x05\x1eF\n\x10\n\x08\
    \x04\t\x02\x03\x08\x9c\x08\0\x12\x04\xc4\x05\x1fE\n\xf0\x01\n\x02\x04\n\
    \x12\x06\xca\x05\0\xda\x05\x01\x1a\xe1\x01\x20Action\x20information\x20e\
    xtracted\x20from\x20a\x20DDL\x20statement.\x20This\x20proto\x20is\x20use\
    d\x20to\n\x20display\x20the\x20brief\x20info\x20of\x20the\x20DDL\x20stat\
    ement\x20for\x20the\x20operation\n\x20[UpdateDatabaseDdl][google.spanner\
    .admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl].\n\n\x0b\n\x03\x04\n\
    \x01\x12\x04\xca\x05\x08\x1e\nz\n\x04\x04\n\x02\0\x12\x04\xcd\x05\x02\
    \x14\x1al\x20The\x20action\x20for\x20the\x20DDL\x20statement,\x20e.g.\
    \x20CREATE,\x20ALTER,\x20DROP,\x20GRANT,\x20etc.\n\x20This\x20field\x20i\
    s\x20a\x20non-empty\x20string.\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xcd\
    \x05\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xcd\x05\t\x0f\n\r\n\x05\
    \x04\n\x02\0\x03\x12\x04\xcd\x05\x12\x13\n\xc0\x01\n\x04\x04\n\x02\x01\
    \x12\x04\xd2\x05\x02\x19\x1a\xb1\x01\x20The\x20entity\x20type\x20for\x20\
    the\x20DDL\x20statement,\x20e.g.\x20TABLE,\x20INDEX,\x20VIEW,\x20etc.\n\
    \x20This\x20field\x20can\x20be\x20empty\x20string\x20for\x20some\x20DDL\
    \x20statement,\n\x20e.g.\x20for\x20statement\x20\"ANALYZE\",\x20`entity_\
    type`\x20=\x20\"\".\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xd2\x05\x02\
    \x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xd2\x05\t\x14\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\xd2\x05\x17\x18\n\x8d\x02\n\x04\x04\n\x02\x02\x12\
    \x04\xd9\x05\x02#\x1a\xfe\x01\x20The\x20entity\x20name(s)\x20being\x20op\
    erated\x20on\x20the\x20DDL\x20statement.\n\x20E.g.\n\x201.\x20For\x20sta\
    tement\x20\"CREATE\x20TABLE\x20t1(...)\",\x20`entity_names`\x20=\x20[\"t\
    1\"].\n\x202.\x20For\x20statement\x20\"GRANT\x20ROLE\x20r1,\x20r2\x20...\
    \",\x20`entity_names`\x20=\x20[\"r1\",\x20\"r2\"].\n\x203.\x20For\x20sta\
    tement\x20\"ANALYZE\",\x20`entity_names`\x20=\x20[].\n\n\r\n\x05\x04\n\
    \x02\x02\x04\x12\x04\xd9\x05\x02\n\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\
    \xd9\x05\x0b\x11\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xd9\x05\x12\x1e\n\r\
    \n\x05\x04\n\x02\x02\x03\x12\x04\xd9\x05!\"\n\x94\x01\n\x02\x04\x0b\x12\
    \x06\xde\x05\0\xfe\x05\x01\x1a\x85\x01\x20Metadata\x20type\x20for\x20the\
    \x20operation\x20returned\x20by\n\x20[UpdateDatabaseDdl][google.spanner.\
    admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl].\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xde\x05\x08!\n.\n\x04\x04\x0b\x02\0\x12\x06\xe0\x05\x02\
    \xe2\x05\x1a\x1a\x1e\x20The\x20database\x20being\x20modified.\n\n\r\n\
    \x05\x04\x0b\x02\0\x05\x12\x04\xe0\x05\x02\x08\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\xe0\x05\t\x11\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xe0\x05\
    \x14\x15\n\x0f\n\x05\x04\x0b\x02\0\x08\x12\x06\xe0\x05\x16\xe2\x05\x19\n\
    \x11\n\x07\x04\x0b\x02\0\x08\x9f\x08\x12\x06\xe0\x05\x17\xe2\x05\x18\n\
    \x8a\x01\n\x04\x04\x0b\x02\x01\x12\x04\xe6\x05\x02!\x1a|\x20For\x20an\
    \x20update\x20this\x20list\x20contains\x20all\x20the\x20statements.\x20F\
    or\x20an\n\x20individual\x20statement,\x20this\x20list\x20contains\x20on\
    ly\x20that\x20statement.\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xe6\x05\
    \x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xe6\x05\x0b\x11\n\r\n\x05\
    \x04\x0b\x02\x01\x01\x12\x04\xe6\x05\x12\x1c\n\r\n\x05\x04\x0b\x02\x01\
    \x03\x12\x04\xe6\x05\x1f\x20\n\xb6\x01\n\x04\x04\x0b\x02\x02\x12\x04\xeb\
    \x05\x02;\x1a\xa7\x01\x20Reports\x20the\x20commit\x20timestamps\x20of\
    \x20all\x20statements\x20that\x20have\n\x20succeeded\x20so\x20far,\x20wh\
    ere\x20`commit_timestamps[i]`\x20is\x20the\x20commit\n\x20timestamp\x20f\
    or\x20the\x20statement\x20`statements[i]`.\n\n\r\n\x05\x04\x0b\x02\x02\
    \x04\x12\x04\xeb\x05\x02\n\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xeb\x05\
    \x0b$\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xeb\x05%6\n\r\n\x05\x04\x0b\
    \x02\x02\x03\x12\x04\xeb\x059:\n\xd4\x01\n\x04\x04\x0b\x02\x03\x12\x04\
    \xf0\x05\x02A\x1a\xc5\x01\x20Output\x20only.\x20When\x20true,\x20indicat\
    es\x20that\x20the\x20operation\x20is\x20throttled\x20e.g.\n\x20due\x20to\
    \x20resource\x20constraints.\x20When\x20resources\x20become\x20available\
    \x20the\x20operation\n\x20will\x20resume\x20and\x20this\x20field\x20will\
    \x20be\x20false\x20again.\n\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xf0\
    \x05\x02\x06\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xf0\x05\x07\x10\n\r\n\
    \x05\x04\x0b\x02\x03\x03\x12\x04\xf0\x05\x13\x14\n\r\n\x05\x04\x0b\x02\
    \x03\x08\x12\x04\xf0\x05\x15@\n\x10\n\x08\x04\x0b\x02\x03\x08\x9c\x08\0\
    \x12\x04\xf0\x05\x16?\n\xae\x03\n\x04\x04\x0b\x02\x04\x12\x04\xf9\x05\
    \x02*\x1a\x9f\x03\x20The\x20progress\x20of\x20the\n\x20[UpdateDatabaseDd\
    l][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl]\n\
    \x20operations.\x20All\x20DDL\x20statements\x20will\x20have\x20continuou\
    sly\x20updating\x20progress,\n\x20and\x20`progress[i]`\x20is\x20the\x20o\
    peration\x20progress\x20for\x20`statements[i]`.\x20Also,\n\x20`progress[\
    i]`\x20will\x20have\x20start\x20time\x20and\x20end\x20time\x20populated\
    \x20with\x20commit\n\x20timestamp\x20of\x20operation,\x20as\x20well\x20a\
    s\x20a\x20progress\x20of\x20100%\x20once\x20the\x20operation\n\x20has\
    \x20completed.\n\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\xf9\x05\x02\n\n\r\
    \n\x05\x04\x0b\x02\x04\x06\x12\x04\xf9\x05\x0b\x1c\n\r\n\x05\x04\x0b\x02\
    \x04\x01\x12\x04\xf9\x05\x1d%\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xf9\
    \x05()\nr\n\x04\x04\x0b\x02\x05\x12\x04\xfd\x05\x02.\x1ad\x20The\x20brie\
    f\x20action\x20info\x20for\x20the\x20DDL\x20statements.\n\x20`actions[i]\
    `\x20is\x20the\x20brief\x20info\x20for\x20`statements[i]`.\n\n\r\n\x05\
    \x04\x0b\x02\x05\x04\x12\x04\xfd\x05\x02\n\n\r\n\x05\x04\x0b\x02\x05\x06\
    \x12\x04\xfd\x05\x0b!\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xfd\x05\")\n\
    \r\n\x05\x04\x0b\x02\x05\x03\x12\x04\xfd\x05,-\nl\n\x02\x04\x0c\x12\x06\
    \x81\x06\0\x89\x06\x01\x1a^\x20The\x20request\x20for\x20[DropDatabase][g\
    oogle.spanner.admin.database.v1.DatabaseAdmin.DropDatabase].\n\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\x81\x06\x08\x1b\n7\n\x04\x04\x0c\x02\0\x12\x06\
    \x83\x06\x02\x88\x06\x04\x1a'\x20Required.\x20The\x20database\x20to\x20b\
    e\x20dropped.\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x83\x06\x02\x08\n\r\
    \n\x05\x04\x0c\x02\0\x01\x12\x04\x83\x06\t\x11\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\x83\x06\x14\x15\n\x0f\n\x05\x04\x0c\x02\0\x08\x12\x06\x83\
    \x06\x16\x88\x06\x03\n\x10\n\x08\x04\x0c\x02\0\x08\x9c\x08\0\x12\x04\x84\
    \x06\x04*\n\x11\n\x07\x04\x0c\x02\0\x08\x9f\x08\x12\x06\x85\x06\x04\x87\
    \x06\x05\np\n\x02\x04\r\x12\x06\x8c\x06\0\x96\x06\x01\x1ab\x20The\x20req\
    uest\x20for\x20[GetDatabaseDdl][google.spanner.admin.database.v1.Databas\
    eAdmin.GetDatabaseDdl].\n\n\x0b\n\x03\x04\r\x01\x12\x04\x8c\x06\x08\x1d\
    \n\x9e\x01\n\x04\x04\r\x02\0\x12\x06\x90\x06\x02\x95\x06\x04\x1a\x8d\x01\
    \x20Required.\x20The\x20database\x20whose\x20schema\x20we\x20wish\x20to\
    \x20get.\n\x20Values\x20are\x20of\x20the\x20form\n\x20`projects/<project\
    >/instances/<instance>/databases/<database>`\n\n\r\n\x05\x04\r\x02\0\x05\
    \x12\x04\x90\x06\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x90\x06\t\x11\
    \n\r\n\x05\x04\r\x02\0\x03\x12\x04\x90\x06\x14\x15\n\x0f\n\x05\x04\r\x02\
    \0\x08\x12\x06\x90\x06\x16\x95\x06\x03\n\x10\n\x08\x04\r\x02\0\x08\x9c\
    \x08\0\x12\x04\x91\x06\x04*\n\x11\n\x07\x04\r\x02\0\x08\x9f\x08\x12\x06\
    \x92\x06\x04\x94\x06\x05\nq\n\x02\x04\x0e\x12\x06\x99\x06\0\xa4\x06\x01\
    \x1ac\x20The\x20response\x20for\x20[GetDatabaseDdl][google.spanner.admin\
    .database.v1.DatabaseAdmin.GetDatabaseDdl].\n\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\x99\x06\x08\x1e\nq\n\x04\x04\x0e\x02\0\x12\x04\x9c\x06\x02!\x1a\
    c\x20A\x20list\x20of\x20formatted\x20DDL\x20statements\x20defining\x20th\
    e\x20schema\x20of\x20the\x20database\n\x20specified\x20in\x20the\x20requ\
    est.\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x9c\x06\x02\n\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\x9c\x06\x0b\x11\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x9c\x06\x12\x1c\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9c\x06\x1f\x20\
    \n\xe5\x02\n\x04\x04\x0e\x02\x01\x12\x04\xa3\x06\x02\x1e\x1a\xd6\x02\x20\
    Proto\x20descriptors\x20stored\x20in\x20the\x20database.\n\x20Contains\
    \x20a\x20protobuf-serialized\n\x20[google.protobuf.FileDescriptorSet](ht\
    tps://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/\
    descriptor.proto).\n\x20For\x20more\x20details,\x20see\x20protobuffer\
    \x20[self\n\x20description](https://developers.google.com/protocol-buffe\
    rs/docs/techniques#self-description).\n\n\r\n\x05\x04\x0e\x02\x01\x05\
    \x12\x04\xa3\x06\x02\x07\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xa3\x06\
    \x08\x19\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa3\x06\x1c\x1d\n\x81\x01\
    \n\x02\x04\x0f\x12\x06\xa8\x06\0\xe7\x06\x01\x1as\x20The\x20request\x20f\
    or\n\x20[ListDatabaseOperations][google.spanner.admin.database.v1.Databa\
    seAdmin.ListDatabaseOperations].\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa8\
    \x06\x08%\n\x87\x01\n\x04\x04\x0f\x02\0\x12\x06\xab\x06\x02\xb0\x06\x04\
    \x1aw\x20Required.\x20The\x20instance\x20of\x20the\x20database\x20operat\
    ions.\n\x20Values\x20are\x20of\x20the\x20form\x20`projects/<project>/ins\
    tances/<instance>`.\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xab\x06\x02\
    \x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xab\x06\t\x0f\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xab\x06\x12\x13\n\x0f\n\x05\x04\x0f\x02\0\x08\x12\x06\
    \xab\x06\x14\xb0\x06\x03\n\x10\n\x08\x04\x0f\x02\0\x08\x9c\x08\0\x12\x04\
    \xac\x06\x04*\n\x11\n\x07\x04\x0f\x02\0\x08\x9f\x08\x12\x06\xad\x06\x04\
    \xaf\x06\x05\n\x95\x11\n\x04\x04\x0f\x02\x01\x12\x04\xdc\x06\x02\x14\x1a\
    \x86\x11\x20An\x20expression\x20that\x20filters\x20the\x20list\x20of\x20\
    returned\x20operations.\n\n\x20A\x20filter\x20expression\x20consists\x20\
    of\x20a\x20field\x20name,\x20a\n\x20comparison\x20operator,\x20and\x20a\
    \x20value\x20for\x20filtering.\n\x20The\x20value\x20must\x20be\x20a\x20s\
    tring,\x20a\x20number,\x20or\x20a\x20boolean.\x20The\x20comparison\x20op\
    erator\n\x20must\x20be\x20one\x20of:\x20`<`,\x20`>`,\x20`<=`,\x20`>=`,\
    \x20`!=`,\x20`=`,\x20or\x20`:`.\n\x20Colon\x20`:`\x20is\x20the\x20contai\
    ns\x20operator.\x20Filter\x20rules\x20are\x20not\x20case\x20sensitive.\n\
    \n\x20The\x20following\x20fields\x20in\x20the\x20[Operation][google.long\
    running.Operation]\n\x20are\x20eligible\x20for\x20filtering:\n\n\x20\x20\
    \x20*\x20`name`\x20-\x20The\x20name\x20of\x20the\x20long-running\x20oper\
    ation\n\x20\x20\x20*\x20`done`\x20-\x20False\x20if\x20the\x20operation\
    \x20is\x20in\x20progress,\x20else\x20true.\n\x20\x20\x20*\x20`metadata.@\
    type`\x20-\x20the\x20type\x20of\x20metadata.\x20For\x20example,\x20the\
    \x20type\x20string\n\x20\x20\x20\x20\x20\x20for\x20[RestoreDatabaseMetad\
    ata][google.spanner.admin.database.v1.RestoreDatabaseMetadata]\x20is\n\
    \x20\x20\x20\x20\x20\x20`type.googleapis.com/google.spanner.admin.databa\
    se.v1.RestoreDatabaseMetadata`.\n\x20\x20\x20*\x20`metadata.<field_name>\
    `\x20-\x20any\x20field\x20in\x20metadata.value.\n\x20\x20\x20\x20\x20\
    \x20`metadata.@type`\x20must\x20be\x20specified\x20first,\x20if\x20filte\
    ring\x20on\x20metadata\n\x20\x20\x20\x20\x20\x20fields.\n\x20\x20\x20*\
    \x20`error`\x20-\x20Error\x20associated\x20with\x20the\x20long-running\
    \x20operation.\n\x20\x20\x20*\x20`response.@type`\x20-\x20the\x20type\
    \x20of\x20response.\n\x20\x20\x20*\x20`response.<field_name>`\x20-\x20an\
    y\x20field\x20in\x20response.value.\n\n\x20You\x20can\x20combine\x20mult\
    iple\x20expressions\x20by\x20enclosing\x20each\x20expression\x20in\n\x20\
    parentheses.\x20By\x20default,\x20expressions\x20are\x20combined\x20with\
    \x20AND\x20logic.\x20However,\n\x20you\x20can\x20specify\x20AND,\x20OR,\
    \x20and\x20NOT\x20logic\x20explicitly.\n\n\x20Here\x20are\x20a\x20few\
    \x20examples:\n\n\x20\x20\x20*\x20`done:true`\x20-\x20The\x20operation\
    \x20is\x20complete.\n\x20\x20\x20*\x20`(metadata.@type=type.googleapis.c\
    om/google.spanner.admin.database.v1.RestoreDatabaseMetadata)\x20AND`\x20\
    \\\n\x20\x20\x20\x20\x20`(metadata.source_type:BACKUP)\x20AND`\x20\\\n\
    \x20\x20\x20\x20\x20`(metadata.backup_info.backup:backup_howl)\x20AND`\
    \x20\\\n\x20\x20\x20\x20\x20`(metadata.name:restored_howl)\x20AND`\x20\\\
    \n\x20\x20\x20\x20\x20`(metadata.progress.start_time\x20<\x20\\\"2018-03\
    -28T14:50:00Z\\\")\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(error:*)`\x20-\
    \x20Return\x20operations\x20where:\n\x20\x20\x20\x20\x20*\x20The\x20oper\
    ation's\x20metadata\x20type\x20is\x20[RestoreDatabaseMetadata][google.sp\
    anner.admin.database.v1.RestoreDatabaseMetadata].\n\x20\x20\x20\x20\x20*\
    \x20The\x20database\x20is\x20restored\x20from\x20a\x20backup.\n\x20\x20\
    \x20\x20\x20*\x20The\x20backup\x20name\x20contains\x20\"backup_howl\".\n\
    \x20\x20\x20\x20\x20*\x20The\x20restored\x20database's\x20name\x20contai\
    ns\x20\"restored_howl\".\n\x20\x20\x20\x20\x20*\x20The\x20operation\x20s\
    tarted\x20before\x202018-03-28T14:50:00Z.\n\x20\x20\x20\x20\x20*\x20The\
    \x20operation\x20resulted\x20in\x20an\x20error.\n\n\r\n\x05\x04\x0f\x02\
    \x01\x05\x12\x04\xdc\x06\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\
    \xdc\x06\t\x0f\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xdc\x06\x12\x13\n\
    \x87\x01\n\x04\x04\x0f\x02\x02\x12\x04\xe0\x06\x02\x16\x1ay\x20Number\
    \x20of\x20operations\x20to\x20be\x20returned\x20in\x20the\x20response.\
    \x20If\x200\x20or\n\x20less,\x20defaults\x20to\x20the\x20server's\x20max\
    imum\x20allowed\x20page\x20size.\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\
    \xe0\x06\x02\x07\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xe0\x06\x08\x11\n\
    \r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xe0\x06\x14\x15\n\xc5\x02\n\x04\x04\
    \x0f\x02\x03\x12\x04\xe6\x06\x02\x18\x1a\xb6\x02\x20If\x20non-empty,\x20\
    `page_token`\x20should\x20contain\x20a\n\x20[next_page_token][google.spa\
    nner.admin.database.v1.ListDatabaseOperationsResponse.next_page_token]\n\
    \x20from\x20a\x20previous\x20[ListDatabaseOperationsResponse][google.spa\
    nner.admin.database.v1.ListDatabaseOperationsResponse]\x20to\x20the\n\
    \x20same\x20`parent`\x20and\x20with\x20the\x20same\x20`filter`.\n\n\r\n\
    \x05\x04\x0f\x02\x03\x05\x12\x04\xe6\x06\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x03\x01\x12\x04\xe6\x06\t\x13\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xe6\
    \x06\x16\x17\n\x82\x01\n\x02\x04\x10\x12\x06\xeb\x06\0\xf7\x06\x01\x1at\
    \x20The\x20response\x20for\n\x20[ListDatabaseOperations][google.spanner.\
    admin.database.v1.DatabaseAdmin.ListDatabaseOperations].\n\n\x0b\n\x03\
    \x04\x10\x01\x12\x04\xeb\x06\x08&\n\xaf\x02\n\x04\x04\x10\x02\0\x12\x04\
    \xf1\x06\x027\x1a\xa0\x02\x20The\x20list\x20of\x20matching\x20database\
    \x20[long-running\n\x20operations][google.longrunning.Operation].\x20Eac\
    h\x20operation's\x20name\x20will\x20be\n\x20prefixed\x20by\x20the\x20dat\
    abase's\x20name.\x20The\x20operation's\n\x20[metadata][google.longrunnin\
    g.Operation.metadata]\x20field\x20type\n\x20`metadata.type_url`\x20descr\
    ibes\x20the\x20type\x20of\x20the\x20metadata.\n\n\r\n\x05\x04\x10\x02\0\
    \x04\x12\x04\xf1\x06\x02\n\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xf1\x06\
    \x0b'\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xf1\x06(2\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xf1\x0656\n\xcd\x01\n\x04\x04\x10\x02\x01\x12\x04\xf6\
    \x06\x02\x1d\x1a\xbe\x01\x20`next_page_token`\x20can\x20be\x20sent\x20in\
    \x20a\x20subsequent\n\x20[ListDatabaseOperations][google.spanner.admin.d\
    atabase.v1.DatabaseAdmin.ListDatabaseOperations]\n\x20call\x20to\x20fetc\
    h\x20more\x20of\x20the\x20matching\x20metadata.\n\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\xf6\x06\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xf6\x06\t\x18\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xf6\x06\x1b\x1c\ns\
    \n\x02\x04\x11\x12\x06\xfb\x06\0\x9e\x07\x01\x1ae\x20The\x20request\x20f\
    or\n\x20[RestoreDatabase][google.spanner.admin.database.v1.DatabaseAdmin\
    .RestoreDatabase].\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xfb\x06\x08\x1e\n\
    \xa6\x02\n\x04\x04\x11\x02\0\x12\x06\x81\x07\x02\x86\x07\x04\x1a\x95\x02\
    \x20Required.\x20The\x20name\x20of\x20the\x20instance\x20in\x20which\x20\
    to\x20create\x20the\n\x20restored\x20database.\x20This\x20instance\x20mu\
    st\x20be\x20in\x20the\x20same\x20project\x20and\n\x20have\x20the\x20same\
    \x20instance\x20configuration\x20as\x20the\x20instance\x20containing\n\
    \x20the\x20source\x20backup.\x20Values\x20are\x20of\x20the\x20form\n\x20\
    `projects/<project>/instances/<instance>`.\n\n\r\n\x05\x04\x11\x02\0\x05\
    \x12\x04\x81\x07\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x81\x07\t\
    \x0f\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x81\x07\x12\x13\n\x0f\n\x05\x04\
    \x11\x02\0\x08\x12\x06\x81\x07\x14\x86\x07\x03\n\x10\n\x08\x04\x11\x02\0\
    \x08\x9c\x08\0\x12\x04\x82\x07\x04*\n\x11\n\x07\x04\x11\x02\0\x08\x9f\
    \x08\x12\x06\x83\x07\x04\x85\x07\x05\n\x87\x02\n\x04\x04\x11\x02\x01\x12\
    \x04\x8c\x07\x02B\x1a\xf8\x01\x20Required.\x20The\x20id\x20of\x20the\x20\
    database\x20to\x20create\x20and\x20restore\x20to.\x20This\n\x20database\
    \x20must\x20not\x20already\x20exist.\x20The\x20`database_id`\x20appended\
    \x20to\n\x20`parent`\x20forms\x20the\x20full\x20database\x20name\x20of\
    \x20the\x20form\n\x20`projects/<project>/instances/<instance>/databases/\
    <database_id>`.\n\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\x8c\x07\x02\x08\
    \n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x8c\x07\t\x14\n\r\n\x05\x04\x11\
    \x02\x01\x03\x12\x04\x8c\x07\x17\x18\n\r\n\x05\x04\x11\x02\x01\x08\x12\
    \x04\x8c\x07\x19A\n\x10\n\x08\x04\x11\x02\x01\x08\x9c\x08\0\x12\x04\x8c\
    \x07\x1a@\n=\n\x04\x04\x11\x08\0\x12\x06\x8f\x07\x02\x95\x07\x03\x1a-\
    \x20Required.\x20The\x20source\x20from\x20which\x20to\x20restore.\n\n\r\
    \n\x05\x04\x11\x08\0\x01\x12\x04\x8f\x07\x08\x0e\n\x91\x01\n\x04\x04\x11\
    \x02\x02\x12\x06\x92\x07\x04\x94\x07\x1a\x1a\x80\x01\x20Name\x20of\x20th\
    e\x20backup\x20from\x20which\x20to\x20restore.\x20\x20Values\x20are\x20o\
    f\x20the\x20form\n\x20`projects/<project>/instances/<instance>/backups/<\
    backup>`.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\x92\x07\x04\n\n\r\n\
    \x05\x04\x11\x02\x02\x01\x12\x04\x92\x07\x0b\x11\n\r\n\x05\x04\x11\x02\
    \x02\x03\x12\x04\x92\x07\x14\x15\n\x0f\n\x05\x04\x11\x02\x02\x08\x12\x06\
    \x92\x07\x16\x94\x07\x19\n\x11\n\x07\x04\x11\x02\x02\x08\x9f\x08\x12\x06\
    \x92\x07\x17\x94\x07\x18\n\xc0\x03\n\x04\x04\x11\x02\x03\x12\x04\x9d\x07\
    \x02a\x1a\xb1\x03\x20Optional.\x20An\x20encryption\x20configuration\x20d\
    escribing\x20the\x20encryption\x20type\x20and\x20key\n\x20resources\x20i\
    n\x20Cloud\x20KMS\x20used\x20to\x20encrypt/decrypt\x20the\x20database\
    \x20to\x20restore\x20to.\n\x20If\x20this\x20field\x20is\x20not\x20specif\
    ied,\x20the\x20restored\x20database\x20will\x20use\n\x20the\x20same\x20e\
    ncryption\x20configuration\x20as\x20the\x20backup\x20by\x20default,\x20n\
    amely\n\x20[encryption_type][google.spanner.admin.database.v1.RestoreDat\
    abaseEncryptionConfig.encryption_type]\x20=\n\x20`USE_CONFIG_DEFAULT_OR_\
    BACKUP_ENCRYPTION`.\n\n\r\n\x05\x04\x11\x02\x03\x06\x12\x04\x9d\x07\x02!\
    \n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\x9d\x07\"3\n\r\n\x05\x04\x11\x02\
    \x03\x03\x12\x04\x9d\x0767\n\r\n\x05\x04\x11\x02\x03\x08\x12\x04\x9d\x07\
    8`\n\x10\n\x08\x04\x11\x02\x03\x08\x9c\x08\0\x12\x04\x9d\x079_\nC\n\x02\
    \x04\x12\x12\x06\xa1\x07\0\xc1\x07\x01\x1a5\x20Encryption\x20configurati\
    on\x20for\x20the\x20restored\x20database.\n\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xa1\x07\x08'\nC\n\x04\x04\x12\x04\0\x12\x06\xa3\x07\x02\xb1\x07\x03\
    \x1a3\x20Encryption\x20types\x20for\x20the\x20database\x20to\x20be\x20re\
    stored.\n\n\r\n\x05\x04\x12\x04\0\x01\x12\x04\xa3\x07\x07\x15\n*\n\x06\
    \x04\x12\x04\0\x02\0\x12\x04\xa5\x07\x04$\x1a\x1a\x20Unspecified.\x20Do\
    \x20not\x20use.\n\n\x0f\n\x07\x04\x12\x04\0\x02\0\x01\x12\x04\xa5\x07\
    \x04\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\0\x02\x12\x04\xa5\x07\"#\n\x9b\
    \x01\n\x06\x04\x12\x04\0\x02\x01\x12\x04\xa9\x07\x040\x1a\x8a\x01\x20Thi\
    s\x20is\x20the\x20default\x20option\x20when\n\x20[encryption_config][goo\
    gle.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig]\x20is\x20\
    not\x20specified.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x01\x01\x12\x04\xa9\
    \x07\x04+\n\x0f\n\x07\x04\x12\x04\0\x02\x01\x02\x12\x04\xa9\x07./\n0\n\
    \x06\x04\x12\x04\0\x02\x02\x12\x04\xac\x07\x04\"\x1a\x20\x20Use\x20Googl\
    e\x20default\x20encryption.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x01\x12\
    \x04\xac\x07\x04\x1d\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x02\x12\x04\xac\
    \x07\x20!\ny\n\x06\x04\x12\x04\0\x02\x03\x12\x04\xb0\x07\x04$\x1ai\x20Us\
    e\x20customer\x20managed\x20encryption.\x20If\x20specified,\x20`kms_key_\
    name`\x20must\n\x20must\x20contain\x20a\x20valid\x20Cloud\x20KMS\x20key.\
    \n\n\x0f\n\x07\x04\x12\x04\0\x02\x03\x01\x12\x04\xb0\x07\x04\x1f\n\x0f\n\
    \x07\x04\x12\x04\0\x02\x03\x02\x12\x04\xb0\x07\"#\nG\n\x04\x04\x12\x02\0\
    \x12\x04\xb4\x07\x02N\x1a9\x20Required.\x20The\x20encryption\x20type\x20\
    of\x20the\x20restored\x20database.\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\
    \xb4\x07\x02\x10\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xb4\x07\x11\x20\n\r\
    \n\x05\x04\x12\x02\0\x03\x12\x04\xb4\x07#$\n\r\n\x05\x04\x12\x02\0\x08\
    \x12\x04\xb4\x07%M\n\x10\n\x08\x04\x12\x02\0\x08\x9c\x08\0\x12\x04\xb4\
    \x07&L\n\x87\x03\n\x04\x04\x12\x02\x01\x12\x06\xbb\x07\x02\xc0\x07\x04\
    \x1a\xf6\x02\x20Optional.\x20The\x20Cloud\x20KMS\x20key\x20that\x20will\
    \x20be\x20used\x20to\x20encrypt/decrypt\x20the\x20restored\n\x20database\
    .\x20This\x20field\x20should\x20be\x20set\x20only\x20when\n\x20[encrypti\
    on_type][google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfi\
    g.encryption_type]\x20is\n\x20`CUSTOMER_MANAGED_ENCRYPTION`.\x20Values\
    \x20are\x20of\x20the\x20form\n\x20`projects/<project>/locations/<locatio\
    n>/keyRings/<key_ring>/cryptoKeys/<kms_key_name>`.\n\n\r\n\x05\x04\x12\
    \x02\x01\x05\x12\x04\xbb\x07\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\
    \x04\xbb\x07\t\x15\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xbb\x07\x18\x19\
    \n\x0f\n\x05\x04\x12\x02\x01\x08\x12\x06\xbb\x07\x1a\xc0\x07\x03\n\x10\n\
    \x08\x04\x12\x02\x01\x08\x9c\x08\0\x12\x04\xbc\x07\x04*\n\x11\n\x07\x04\
    \x12\x02\x01\x08\x9f\x08\x12\x06\xbd\x07\x04\xbf\x07\x05\n\x9d\x01\n\x02\
    \x04\x13\x12\x06\xc5\x07\0\xf3\x07\x01\x1a\x8e\x01\x20Metadata\x20type\
    \x20for\x20the\x20long-running\x20operation\x20returned\x20by\n\x20[Rest\
    oreDatabase][google.spanner.admin.database.v1.DatabaseAdmin.RestoreDatab\
    ase].\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xc5\x07\x08\x1f\nE\n\x04\x04\x13\
    \x02\0\x12\x06\xc7\x07\x02\xc9\x07\x16\x1a5\x20Name\x20of\x20the\x20data\
    base\x20being\x20created\x20and\x20restored\x20to.\n\n\r\n\x05\x04\x13\
    \x02\0\x05\x12\x04\xc7\x07\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \xc7\x07\t\r\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xc7\x07\x10\x11\n\x0f\n\
    \x05\x04\x13\x02\0\x08\x12\x06\xc7\x07\x12\xc9\x07\x15\n\x11\n\x07\x04\
    \x13\x02\0\x08\x9f\x08\x12\x06\xc7\x07\x13\xc9\x07\x14\n/\n\x04\x04\x13\
    \x02\x01\x12\x04\xcc\x07\x02$\x1a!\x20The\x20type\x20of\x20the\x20restor\
    e\x20source.\n\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\xcc\x07\x02\x13\n\r\
    \n\x05\x04\x13\x02\x01\x01\x12\x04\xcc\x07\x14\x1f\n\r\n\x05\x04\x13\x02\
    \x01\x03\x12\x04\xcc\x07\"#\n\xbd\x01\n\x04\x04\x13\x08\0\x12\x06\xd0\
    \x07\x02\xd3\x07\x03\x1a\xac\x01\x20Information\x20about\x20the\x20sourc\
    e\x20used\x20to\x20restore\x20the\x20database,\x20as\x20specified\x20by\
    \n\x20`source`\x20in\x20[RestoreDatabaseRequest][google.spanner.admin.da\
    tabase.v1.RestoreDatabaseRequest].\n\n\r\n\x05\x04\x13\x08\0\x01\x12\x04\
    \xd0\x07\x08\x13\nJ\n\x04\x04\x13\x02\x02\x12\x04\xd2\x07\x04\x1f\x1a<\
    \x20Information\x20about\x20the\x20backup\x20used\x20to\x20restore\x20th\
    e\x20database.\n\n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\xd2\x07\x04\x0e\n\
    \r\n\x05\x04\x13\x02\x02\x01\x12\x04\xd2\x07\x0f\x1a\n\r\n\x05\x04\x13\
    \x02\x02\x03\x12\x04\xd2\x07\x1d\x1e\n\x82\x01\n\x04\x04\x13\x02\x03\x12\
    \x04\xd8\x07\x02!\x1at\x20The\x20progress\x20of\x20the\n\x20[RestoreData\
    base][google.spanner.admin.database.v1.DatabaseAdmin.RestoreDatabase]\n\
    \x20operation.\n\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\xd8\x07\x02\x13\n\
    \r\n\x05\x04\x13\x02\x03\x01\x12\x04\xd8\x07\x14\x1c\n\r\n\x05\x04\x13\
    \x02\x03\x03\x12\x04\xd8\x07\x1f\x20\n\x86\x06\n\x04\x04\x13\x02\x04\x12\
    \x04\xe5\x07\x02,\x1a\xf7\x05\x20The\x20time\x20at\x20which\x20cancellat\
    ion\x20of\x20this\x20operation\x20was\x20received.\n\x20[Operations.Canc\
    elOperation][google.longrunning.Operations.CancelOperation]\n\x20starts\
    \x20asynchronous\x20cancellation\x20on\x20a\x20long-running\x20operation\
    .\x20The\x20server\n\x20makes\x20a\x20best\x20effort\x20to\x20cancel\x20\
    the\x20operation,\x20but\x20success\x20is\x20not\x20guaranteed.\n\x20Cli\
    ents\x20can\x20use\n\x20[Operations.GetOperation][google.longrunning.Ope\
    rations.GetOperation]\x20or\n\x20other\x20methods\x20to\x20check\x20whet\
    her\x20the\x20cancellation\x20succeeded\x20or\x20whether\x20the\n\x20ope\
    ration\x20completed\x20despite\x20cancellation.\x20On\x20successful\x20c\
    ancellation,\n\x20the\x20operation\x20is\x20not\x20deleted;\x20instead,\
    \x20it\x20becomes\x20an\x20operation\x20with\n\x20an\x20[Operation.error\
    ][google.longrunning.Operation.error]\x20value\x20with\x20a\n\x20[google\
    .rpc.Status.code][google.rpc.Status.code]\x20of\x201,\x20corresponding\
    \x20to\x20`Code.CANCELLED`.\n\n\r\n\x05\x04\x13\x02\x04\x06\x12\x04\xe5\
    \x07\x02\x1b\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xe5\x07\x1c'\n\r\n\
    \x05\x04\x13\x02\x04\x03\x12\x04\xe5\x07*+\n\xa0\x06\n\x04\x04\x13\x02\
    \x05\x12\x04\xf2\x07\x02.\x1a\x91\x06\x20If\x20exists,\x20the\x20name\
    \x20of\x20the\x20long-running\x20operation\x20that\x20will\x20be\x20used\
    \x20to\n\x20track\x20the\x20post-restore\x20optimization\x20process\x20t\
    o\x20optimize\x20the\x20performance\x20of\n\x20the\x20restored\x20databa\
    se,\x20and\x20remove\x20the\x20dependency\x20on\x20the\x20restore\x20sou\
    rce.\n\x20The\x20name\x20is\x20of\x20the\x20form\n\x20`projects/<project\
    >/instances/<instance>/databases/<database>/operations/<operation>`\n\
    \x20where\x20the\x20<database>\x20is\x20the\x20name\x20of\x20database\
    \x20being\x20created\x20and\x20restored\x20to.\n\x20The\x20metadata\x20t\
    ype\x20of\x20the\x20\x20long-running\x20operation\x20is\n\x20[OptimizeRe\
    storedDatabaseMetadata][google.spanner.admin.database.v1.OptimizeRestore\
    dDatabaseMetadata].\x20This\x20long-running\x20operation\x20will\x20be\n\
    \x20automatically\x20created\x20by\x20the\x20system\x20after\x20the\x20R\
    estoreDatabase\x20long-running\n\x20operation\x20completes\x20successful\
    ly.\x20This\x20operation\x20will\x20not\x20be\x20created\x20if\x20the\n\
    \x20restore\x20was\x20not\x20successful.\n\n\r\n\x05\x04\x13\x02\x05\x05\
    \x12\x04\xf2\x07\x02\x08\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xf2\x07\t\
    )\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xf2\x07,-\n\xa7\x02\n\x02\x04\
    \x14\x12\x06\xf9\x07\0\x81\x08\x01\x1a\x98\x02\x20Metadata\x20type\x20fo\
    r\x20the\x20long-running\x20operation\x20used\x20to\x20track\x20the\x20p\
    rogress\n\x20of\x20optimizations\x20performed\x20on\x20a\x20newly\x20res\
    tored\x20database.\x20This\x20long-running\n\x20operation\x20is\x20autom\
    atically\x20created\x20by\x20the\x20system\x20after\x20the\x20successful\
    \n\x20completion\x20of\x20a\x20database\x20restore,\x20and\x20cannot\x20\
    be\x20cancelled.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xf9\x07\x08(\n@\n\x04\
    \x04\x14\x02\0\x12\x06\xfb\x07\x02\xfd\x07\x16\x1a0\x20Name\x20of\x20the\
    \x20restored\x20database\x20being\x20optimized.\n\n\r\n\x05\x04\x14\x02\
    \0\x05\x12\x04\xfb\x07\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xfb\
    \x07\t\r\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xfb\x07\x10\x11\n\x0f\n\x05\
    \x04\x14\x02\0\x08\x12\x06\xfb\x07\x12\xfd\x07\x15\n\x11\n\x07\x04\x14\
    \x02\0\x08\x9f\x08\x12\x06\xfb\x07\x13\xfd\x07\x14\n?\n\x04\x04\x14\x02\
    \x01\x12\x04\x80\x08\x02!\x1a1\x20The\x20progress\x20of\x20the\x20post-r\
    estore\x20optimizations.\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\x80\x08\
    \x02\x13\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x80\x08\x14\x1c\n\r\n\x05\
    \x04\x14\x02\x01\x03\x12\x04\x80\x08\x1f\x20\n9\n\x02\x05\0\x12\x06\x84\
    \x08\0\x8a\x08\x01\x1a+\x20Indicates\x20the\x20type\x20of\x20the\x20rest\
    ore\x20source.\n\n\x0b\n\x03\x05\0\x01\x12\x04\x84\x08\x05\x16\n&\n\x04\
    \x05\0\x02\0\x12\x04\x86\x08\x02\x17\x1a\x18\x20No\x20restore\x20associa\
    ted.\n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\x86\x08\x02\x12\n\r\n\x05\x05\0\
    \x02\0\x02\x12\x04\x86\x08\x15\x16\n?\n\x04\x05\0\x02\x01\x12\x04\x89\
    \x08\x02\r\x1a1\x20A\x20backup\x20was\x20used\x20as\x20the\x20source\x20\
    of\x20the\x20restore.\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\x89\x08\x02\
    \x08\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x89\x08\x0b\x0c\n.\n\x02\x04\
    \x15\x12\x06\x8d\x08\0\x99\x08\x01\x1a\x20\x20A\x20Cloud\x20Spanner\x20d\
    atabase\x20role.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\x8d\x08\x08\x14\n\r\n\
    \x03\x04\x15\x07\x12\x06\x8e\x08\x02\x91\x08\x04\n\x0f\n\x05\x04\x15\x07\
    \x9d\x08\x12\x06\x8e\x08\x02\x91\x08\x04\n\xc1\x02\n\x04\x04\x15\x02\0\
    \x12\x04\x98\x08\x02;\x1a\xb2\x02\x20Required.\x20The\x20name\x20of\x20t\
    he\x20database\x20role.\x20Values\x20are\x20of\x20the\x20form\n\x20`proj\
    ects/<project>/instances/<instance>/databases/<database>/databaseRoles/\
    \n\x20{role}`,\x20where\x20`<role>`\x20is\x20as\x20specified\x20in\x20th\
    e\x20`CREATE\x20ROLE`\n\x20DDL\x20statement.\x20This\x20name\x20can\x20b\
    e\x20passed\x20to\x20Get/Set\x20IAMPolicy\x20methods\x20to\n\x20identify\
    \x20the\x20database\x20role.\n\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x98\
    \x08\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x98\x08\t\r\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\x98\x08\x10\x11\n\r\n\x05\x04\x15\x02\0\x08\
    \x12\x04\x98\x08\x12:\n\x10\n\x08\x04\x15\x02\0\x08\x9c\x08\0\x12\x04\
    \x98\x08\x139\nv\n\x02\x04\x16\x12\x06\x9c\x08\0\xaf\x08\x01\x1ah\x20The\
    \x20request\x20for\x20[ListDatabaseRoles][google.spanner.admin.database.\
    v1.DatabaseAdmin.ListDatabaseRoles].\n\n\x0b\n\x03\x04\x16\x01\x12\x04\
    \x9c\x08\x08\x20\n\xae\x01\n\x04\x04\x16\x02\0\x12\x06\xa0\x08\x02\xa5\
    \x08\x04\x1a\x9d\x01\x20Required.\x20The\x20database\x20whose\x20roles\
    \x20should\x20be\x20listed.\n\x20Values\x20are\x20of\x20the\x20form\n\
    \x20`projects/<project>/instances/<instance>/databases/<database>/databa\
    seRoles`.\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xa0\x08\x02\x08\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\xa0\x08\t\x0f\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xa0\x08\x12\x13\n\x0f\n\x05\x04\x16\x02\0\x08\x12\x06\xa0\x08\
    \x14\xa5\x08\x03\n\x10\n\x08\x04\x16\x02\0\x08\x9c\x08\0\x12\x04\xa1\x08\
    \x04*\n\x11\n\x07\x04\x16\x02\0\x08\x9f\x08\x12\x06\xa2\x08\x04\xa4\x08\
    \x05\n\x8b\x01\n\x04\x04\x16\x02\x01\x12\x04\xa9\x08\x02\x16\x1a}\x20Num\
    ber\x20of\x20database\x20roles\x20to\x20be\x20returned\x20in\x20the\x20r\
    esponse.\x20If\x200\x20or\x20less,\n\x20defaults\x20to\x20the\x20server'\
    s\x20maximum\x20allowed\x20page\x20size.\n\n\r\n\x05\x04\x16\x02\x01\x05\
    \x12\x04\xa9\x08\x02\x07\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xa9\x08\
    \x08\x11\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xa9\x08\x14\x15\n\x85\x02\
    \n\x04\x04\x16\x02\x02\x12\x04\xae\x08\x02\x18\x1a\xf6\x01\x20If\x20non-\
    empty,\x20`page_token`\x20should\x20contain\x20a\n\x20[next_page_token][\
    google.spanner.admin.database.v1.ListDatabaseRolesResponse.next_page_tok\
    en]\x20from\x20a\n\x20previous\x20[ListDatabaseRolesResponse][google.spa\
    nner.admin.database.v1.ListDatabaseRolesResponse].\n\n\r\n\x05\x04\x16\
    \x02\x02\x05\x12\x04\xae\x08\x02\x08\n\r\n\x05\x04\x16\x02\x02\x01\x12\
    \x04\xae\x08\t\x13\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xae\x08\x16\x17\
    \nw\n\x02\x04\x17\x12\x06\xb2\x08\0\xba\x08\x01\x1ai\x20The\x20response\
    \x20for\x20[ListDatabaseRoles][google.spanner.admin.database.v1.Database\
    Admin.ListDatabaseRoles].\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xb2\x08\x08!\
    \n8\n\x04\x04\x17\x02\0\x12\x04\xb4\x08\x02+\x1a*\x20Database\x20roles\
    \x20that\x20matched\x20the\x20request.\n\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xb4\x08\x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xb4\x08\x0b\x17\n\
    \r\n\x05\x04\x17\x02\0\x01\x12\x04\xb4\x08\x18&\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\xb4\x08)*\n\xc0\x01\n\x04\x04\x17\x02\x01\x12\x04\xb9\x08\
    \x02\x1d\x1a\xb1\x01\x20`next_page_token`\x20can\x20be\x20sent\x20in\x20\
    a\x20subsequent\n\x20[ListDatabaseRoles][google.spanner.admin.database.v\
    1.DatabaseAdmin.ListDatabaseRoles]\n\x20call\x20to\x20fetch\x20more\x20o\
    f\x20the\x20matching\x20roles.\n\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\
    \xb9\x08\x02\x08\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xb9\x08\t\x18\n\r\
    \n\x05\x04\x17\x02\x01\x03\x12\x04\xb9\x08\x1b\x1cb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
