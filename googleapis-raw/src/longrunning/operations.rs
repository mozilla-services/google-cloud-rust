// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/longrunning/operations.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

///  This resource represents a long-running operation that is the result of a
///  network API call.
// @@protoc_insertion_point(message:google.longrunning.Operation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Operation {
    // message fields
    ///  The server-assigned name, which is only unique within the same service that
    ///  originally returns it. If you use the default HTTP mapping, the
    ///  `name` should have the format of `operations/some/unique/name`.
    // @@protoc_insertion_point(field:google.longrunning.Operation.name)
    pub name: ::std::string::String,
    ///  Service-specific metadata associated with the operation.  It typically
    ///  contains progress information and common metadata such as create time.
    ///  Some services might not provide such metadata.  Any method that returns a
    ///  long-running operation should document the metadata type, if any.
    // @@protoc_insertion_point(field:google.longrunning.Operation.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    ///  If the value is `false`, it means the operation is still in progress.
    ///  If `true`, the operation is completed, and either `error` or `response` is
    ///  available.
    // @@protoc_insertion_point(field:google.longrunning.Operation.done)
    pub done: bool,
    // message oneof groups
    pub result: ::std::option::Option<operation::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.Operation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Operation {
    fn default() -> &'a Operation {
        <Operation as ::protobuf::Message>::default_instance()
    }
}

impl Operation {
    pub fn new() -> Operation {
        ::std::default::Default::default()
    }

    // .google.rpc.Status error = 4;

    pub fn error(&self) -> &super::status::Status {
        match self.result {
            ::std::option::Option::Some(operation::Result::Error(ref v)) => v,
            _ => <super::status::Status as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(operation::Result::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::status::Status) {
        self.result = ::std::option::Option::Some(operation::Result::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut super::status::Status {
        if let ::std::option::Option::Some(operation::Result::Error(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(operation::Result::Error(super::status::Status::new()));
        }
        match self.result {
            ::std::option::Option::Some(operation::Result::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> super::status::Status {
        if self.has_error() {
            match self.result.take() {
                ::std::option::Option::Some(operation::Result::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            super::status::Status::new()
        }
    }

    // .google.protobuf.Any response = 5;

    pub fn response(&self) -> &::protobuf::well_known_types::any::Any {
        match self.result {
            ::std::option::Option::Some(operation::Result::Response(ref v)) => v,
            _ => <::protobuf::well_known_types::any::Any as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_response(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(operation::Result::Response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::protobuf::well_known_types::any::Any) {
        self.result = ::std::option::Option::Some(operation::Result::Response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response(&mut self) -> &mut ::protobuf::well_known_types::any::Any {
        if let ::std::option::Option::Some(operation::Result::Response(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(operation::Result::Response(::protobuf::well_known_types::any::Any::new()));
        }
        match self.result {
            ::std::option::Option::Some(operation::Result::Response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response(&mut self) -> ::protobuf::well_known_types::any::Any {
        if self.has_response() {
            match self.result.take() {
                ::std::option::Option::Some(operation::Result::Response(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::any::Any::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Operation| { &m.name },
            |m: &mut Operation| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "metadata",
            |m: &Operation| { &m.metadata },
            |m: &mut Operation| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "done",
            |m: &Operation| { &m.done },
            |m: &mut Operation| { &mut m.done },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::status::Status>(
            "error",
            Operation::has_error,
            Operation::error,
            Operation::mut_error,
            Operation::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "response",
            Operation::has_response,
            Operation::response,
            Operation::mut_response,
            Operation::set_response,
        ));
        oneofs.push(operation::Result::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Operation>(
            "Operation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Operation {
    const NAME: &'static str = "Operation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                24 => {
                    self.done = is.read_bool()?;
                },
                34 => {
                    self.result = ::std::option::Option::Some(operation::Result::Error(is.read_message()?));
                },
                42 => {
                    self.result = ::std::option::Option::Some(operation::Result::Response(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.done != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &operation::Result::Error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Result::Response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.done != false {
            os.write_bool(3, self.done)?;
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &operation::Result::Error(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &operation::Result::Response(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Operation {
        Operation::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.metadata.clear();
        self.done = false;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Operation {
        static instance: Operation = Operation {
            name: ::std::string::String::new(),
            metadata: ::protobuf::MessageField::none(),
            done: false,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Operation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Operation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Operation`
pub mod operation {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.longrunning.Operation.result)
    pub enum Result {
        // @@protoc_insertion_point(oneof_field:google.longrunning.Operation.error)
        Error(super::super::status::Status),
        // @@protoc_insertion_point(oneof_field:google.longrunning.Operation.response)
        Response(::protobuf::well_known_types::any::Any),
    }

    impl ::protobuf::Oneof for Result {
    }

    impl ::protobuf::OneofFull for Result {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Operation as ::protobuf::MessageFull>::descriptor().oneof_by_name("result").unwrap()).clone()
        }
    }

    impl Result {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Result>("result")
        }
    }
}

///  The request message for [Operations.GetOperation][google.longrunning.Operations.GetOperation].
// @@protoc_insertion_point(message:google.longrunning.GetOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetOperationRequest {
    // message fields
    ///  The name of the operation resource.
    // @@protoc_insertion_point(field:google.longrunning.GetOperationRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.GetOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetOperationRequest {
    fn default() -> &'a GetOperationRequest {
        <GetOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetOperationRequest {
    pub fn new() -> GetOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GetOperationRequest| { &m.name },
            |m: &mut GetOperationRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetOperationRequest>(
            "GetOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetOperationRequest {
    const NAME: &'static str = "GetOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetOperationRequest {
        GetOperationRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetOperationRequest {
        static instance: GetOperationRequest = GetOperationRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request message for [Operations.ListOperations][google.longrunning.Operations.ListOperations].
// @@protoc_insertion_point(message:google.longrunning.ListOperationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListOperationsRequest {
    // message fields
    ///  The name of the operation's parent resource.
    // @@protoc_insertion_point(field:google.longrunning.ListOperationsRequest.name)
    pub name: ::std::string::String,
    ///  The standard list filter.
    // @@protoc_insertion_point(field:google.longrunning.ListOperationsRequest.filter)
    pub filter: ::std::string::String,
    ///  The standard list page size.
    // @@protoc_insertion_point(field:google.longrunning.ListOperationsRequest.page_size)
    pub page_size: i32,
    ///  The standard list page token.
    // @@protoc_insertion_point(field:google.longrunning.ListOperationsRequest.page_token)
    pub page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.ListOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOperationsRequest {
    fn default() -> &'a ListOperationsRequest {
        <ListOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOperationsRequest {
    pub fn new() -> ListOperationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListOperationsRequest| { &m.name },
            |m: &mut ListOperationsRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filter",
            |m: &ListOperationsRequest| { &m.filter },
            |m: &mut ListOperationsRequest| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &ListOperationsRequest| { &m.page_size },
            |m: &mut ListOperationsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_token",
            |m: &ListOperationsRequest| { &m.page_token },
            |m: &mut ListOperationsRequest| { &mut m.page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOperationsRequest>(
            "ListOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOperationsRequest {
    const NAME: &'static str = "ListOperationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.name = is.read_string()?;
                },
                10 => {
                    self.filter = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_int32()?;
                },
                26 => {
                    self.page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page_size);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.filter.is_empty() {
            os.write_string(1, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOperationsRequest {
        ListOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOperationsRequest {
        static instance: ListOperationsRequest = ListOperationsRequest {
            name: ::std::string::String::new(),
            filter: ::std::string::String::new(),
            page_size: 0,
            page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The response message for [Operations.ListOperations][google.longrunning.Operations.ListOperations].
// @@protoc_insertion_point(message:google.longrunning.ListOperationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListOperationsResponse {
    // message fields
    ///  A list of operations that matches the specified filter in the request.
    // @@protoc_insertion_point(field:google.longrunning.ListOperationsResponse.operations)
    pub operations: ::std::vec::Vec<Operation>,
    ///  The standard List next-page token.
    // @@protoc_insertion_point(field:google.longrunning.ListOperationsResponse.next_page_token)
    pub next_page_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.ListOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOperationsResponse {
    fn default() -> &'a ListOperationsResponse {
        <ListOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOperationsResponse {
    pub fn new() -> ListOperationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operations",
            |m: &ListOperationsResponse| { &m.operations },
            |m: &mut ListOperationsResponse| { &mut m.operations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_page_token",
            |m: &ListOperationsResponse| { &m.next_page_token },
            |m: &mut ListOperationsResponse| { &mut m.next_page_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOperationsResponse>(
            "ListOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOperationsResponse {
    const NAME: &'static str = "ListOperationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operations.push(is.read_message()?);
                },
                18 => {
                    self.next_page_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.operations {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOperationsResponse {
        ListOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.operations.clear();
        self.next_page_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOperationsResponse {
        static instance: ListOperationsResponse = ListOperationsResponse {
            operations: ::std::vec::Vec::new(),
            next_page_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request message for [Operations.CancelOperation][google.longrunning.Operations.CancelOperation].
// @@protoc_insertion_point(message:google.longrunning.CancelOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelOperationRequest {
    // message fields
    ///  The name of the operation resource to be cancelled.
    // @@protoc_insertion_point(field:google.longrunning.CancelOperationRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.CancelOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelOperationRequest {
    fn default() -> &'a CancelOperationRequest {
        <CancelOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelOperationRequest {
    pub fn new() -> CancelOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CancelOperationRequest| { &m.name },
            |m: &mut CancelOperationRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelOperationRequest>(
            "CancelOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelOperationRequest {
    const NAME: &'static str = "CancelOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelOperationRequest {
        CancelOperationRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelOperationRequest {
        static instance: CancelOperationRequest = CancelOperationRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request message for [Operations.DeleteOperation][google.longrunning.Operations.DeleteOperation].
// @@protoc_insertion_point(message:google.longrunning.DeleteOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteOperationRequest {
    // message fields
    ///  The name of the operation resource to be deleted.
    // @@protoc_insertion_point(field:google.longrunning.DeleteOperationRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.DeleteOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteOperationRequest {
    fn default() -> &'a DeleteOperationRequest {
        <DeleteOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOperationRequest {
    pub fn new() -> DeleteOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeleteOperationRequest| { &m.name },
            |m: &mut DeleteOperationRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteOperationRequest>(
            "DeleteOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteOperationRequest {
    const NAME: &'static str = "DeleteOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteOperationRequest {
        DeleteOperationRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteOperationRequest {
        static instance: DeleteOperationRequest = DeleteOperationRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The request message for [Operations.WaitOperation][google.longrunning.Operations.WaitOperation].
// @@protoc_insertion_point(message:google.longrunning.WaitOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WaitOperationRequest {
    // message fields
    ///  The name of the operation resource to wait on.
    // @@protoc_insertion_point(field:google.longrunning.WaitOperationRequest.name)
    pub name: ::std::string::String,
    ///  The maximum duration to wait before timing out. If left blank, the wait
    ///  will be at most the time permitted by the underlying HTTP/RPC protocol.
    ///  If RPC context deadline is also specified, the shorter one will be used.
    // @@protoc_insertion_point(field:google.longrunning.WaitOperationRequest.timeout)
    pub timeout: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.WaitOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WaitOperationRequest {
    fn default() -> &'a WaitOperationRequest {
        <WaitOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitOperationRequest {
    pub fn new() -> WaitOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &WaitOperationRequest| { &m.name },
            |m: &mut WaitOperationRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "timeout",
            |m: &WaitOperationRequest| { &m.timeout },
            |m: &mut WaitOperationRequest| { &mut m.timeout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WaitOperationRequest>(
            "WaitOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WaitOperationRequest {
    const NAME: &'static str = "WaitOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeout)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.timeout.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WaitOperationRequest {
        WaitOperationRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.timeout.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WaitOperationRequest {
        static instance: WaitOperationRequest = WaitOperationRequest {
            name: ::std::string::String::new(),
            timeout: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WaitOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WaitOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WaitOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.longrunning.OperationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OperationInfo {
    // message fields
    ///  Required. The message name of the primary return type for this
    ///  long-running operation.
    ///  This type will be used to deserialize the LRO's response.
    ///
    ///  If the response is in a different package from the rpc, a fully-qualified
    ///  message name must be used (e.g. `google.protobuf.Struct`).
    ///
    ///  Note: Altering this value constitutes a breaking change.
    // @@protoc_insertion_point(field:google.longrunning.OperationInfo.response_type)
    pub response_type: ::std::string::String,
    ///  Required. The message name of the metadata type for this long-running
    ///  operation.
    ///
    ///  If the response is in a different package from the rpc, a fully-qualified
    ///  message name must be used (e.g. `google.protobuf.Struct`).
    ///
    ///  Note: Altering this value constitutes a breaking change.
    // @@protoc_insertion_point(field:google.longrunning.OperationInfo.metadata_type)
    pub metadata_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.longrunning.OperationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationInfo {
    fn default() -> &'a OperationInfo {
        <OperationInfo as ::protobuf::Message>::default_instance()
    }
}

impl OperationInfo {
    pub fn new() -> OperationInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_type",
            |m: &OperationInfo| { &m.response_type },
            |m: &mut OperationInfo| { &mut m.response_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metadata_type",
            |m: &OperationInfo| { &m.metadata_type },
            |m: &mut OperationInfo| { &mut m.metadata_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationInfo>(
            "OperationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationInfo {
    const NAME: &'static str = "OperationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response_type = is.read_string()?;
                },
                18 => {
                    self.metadata_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.response_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.response_type);
        }
        if !self.metadata_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.metadata_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.response_type.is_empty() {
            os.write_string(1, &self.response_type)?;
        }
        if !self.metadata_type.is_empty() {
            os.write_string(2, &self.metadata_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationInfo {
        OperationInfo::new()
    }

    fn clear(&mut self) {
        self.response_type.clear();
        self.metadata_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationInfo {
        static instance: OperationInfo = OperationInfo {
            response_type: ::std::string::String::new(),
            metadata_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Extension fields
pub mod exts {

    pub const operation_info: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::MethodOptions, super::OperationInfo> = ::protobuf::ext::ExtFieldOptional::new(1049, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#google/longrunning/operations.proto\x12\x12google.longrunning\x1a\x1c\
    google/api/annotations.proto\x1a\x19google/protobuf/any.proto\x1a\x1egoo\
    gle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x17go\
    ogle/rpc/status.proto\x1a\x20google/protobuf/descriptor.proto\"\xcf\x01\
    \n\tOperation\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x120\n\x08me\
    tadata\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x08metadata\x12\
    \x12\n\x04done\x18\x03\x20\x01(\x08R\x04done\x12*\n\x05error\x18\x04\x20\
    \x01(\x0b2\x12.google.rpc.StatusH\0R\x05error\x122\n\x08response\x18\x05\
    \x20\x01(\x0b2\x14.google.protobuf.AnyH\0R\x08responseB\x08\n\x06result\
    \")\n\x13GetOperationRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\"\x7f\n\x15ListOperationsRequest\x12\x12\n\x04name\x18\x04\x20\x01(\t\
    R\x04name\x12\x16\n\x06filter\x18\x01\x20\x01(\tR\x06filter\x12\x1b\n\tp\
    age_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03\
    \x20\x01(\tR\tpageToken\"\x7f\n\x16ListOperationsResponse\x12=\n\noperat\
    ions\x18\x01\x20\x03(\x0b2\x1d.google.longrunning.OperationR\noperations\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\",\n\x16Ca\
    ncelOperationRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\",\n\
    \x16DeleteOperationRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \"_\n\x14WaitOperationRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x123\n\x07timeout\x18\x02\x20\x01(\x0b2\x19.google.protobuf.Duration\
    R\x07timeout\"Y\n\rOperationInfo\x12#\n\rresponse_type\x18\x01\x20\x01(\
    \tR\x0cresponseType\x12#\n\rmetadata_type\x18\x02\x20\x01(\tR\x0cmetadat\
    aType2\xe8\x04\n\nOperations\x12\x86\x01\n\x0eListOperations\x12).google\
    .longrunning.ListOperationsRequest\x1a*.google.longrunning.ListOperation\
    sResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\x12\x15/v1/{name=operations}\x12\
    x\n\x0cGetOperation\x12'.google.longrunning.GetOperationRequest\x1a\x1d.\
    google.longrunning.Operation\"\x20\x82\xd3\xe4\x93\x02\x1a\x12\x18/v1/{n\
    ame=operations/**}\x12w\n\x0fDeleteOperation\x12*.google.longrunning.Del\
    eteOperationRequest\x1a\x16.google.protobuf.Empty\"\x20\x82\xd3\xe4\x93\
    \x02\x1a*\x18/v1/{name=operations/**}\x12\x81\x01\n\x0fCancelOperation\
    \x12*.google.longrunning.CancelOperationRequest\x1a\x16.google.protobuf.\
    Empty\"*\x82\xd3\xe4\x93\x02$\"\x1f/v1/{name=operations/**}:cancel:\x01*\
    \x12Z\n\rWaitOperation\x12(.google.longrunning.WaitOperationRequest\x1a\
    \x1d.google.longrunning.Operation\"\0:i\n\x0eoperation_info\x18\x99\x08\
    \x20\x01(\x0b2!.google.longrunning.OperationInfo\x12\x1e.google.protobuf\
    .MethodOptionsR\roperationInfoB\x97\x01\n\x16com.google.longrunningB\x0f\
    OperationsProtoP\x01Z=google.golang.org/genproto/googleapis/longrunning;\
    longrunning\xf8\x01\x01\xaa\x02\x12Google.LongRunning\xca\x02\x12Google\
    \\LongRunningJ\xc3K\n\x07\x12\x05\x0f\0\xf0\x01\x01\n\xbe\x04\n\x01\x0c\
    \x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20LLC.\n\n\
    \x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20\
    (the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20e\
    xcept\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20\
    obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\
    \x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\
    \x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20s\
    oftware\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\
    \x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\
    \x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20impli\
    ed.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20\
    governing\x20permissions\x20and\n\x20limitations\x20under\x20the\x20Lice\
    nse.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1b\n\t\n\x02\x03\0\x12\x03\x13\0\
    &\n\t\n\x02\x03\x01\x12\x03\x14\0#\n\t\n\x02\x03\x02\x12\x03\x15\0(\n\t\
    \n\x02\x03\x03\x12\x03\x16\0%\n\t\n\x02\x03\x04\x12\x03\x17\0!\n\t\n\x02\
    \x03\x05\x12\x03\x18\0*\n\x08\n\x01\x08\x12\x03\x1a\0\x1f\n\t\n\x02\x08\
    \x1f\x12\x03\x1a\0\x1f\n\x08\n\x01\x08\x12\x03\x1b\0/\n\t\n\x02\x08%\x12\
    \x03\x1b\0/\n\x08\n\x01\x08\x12\x03\x1c\0T\n\t\n\x02\x08\x0b\x12\x03\x1c\
    \0T\n\x08\n\x01\x08\x12\x03\x1d\0\"\n\t\n\x02\x08\n\x12\x03\x1d\0\"\n\
    \x08\n\x01\x08\x12\x03\x1e\00\n\t\n\x02\x08\x08\x12\x03\x1e\00\n\x08\n\
    \x01\x08\x12\x03\x1f\0/\n\t\n\x02\x08\x01\x12\x03\x1f\0/\n\x08\n\x01\x08\
    \x12\x03\x20\0-\n\t\n\x02\x08)\x12\x03\x20\0-\n\t\n\x01\x07\x12\x04\"\0*\
    \x01\n\xf8\x01\n\x02\x07\0\x12\x03)\x029\x1a\xec\x01\x20Additional\x20in\
    formation\x20regarding\x20long-running\x20operations.\n\x20In\x20particu\
    lar,\x20this\x20specifies\x20the\x20types\x20that\x20are\x20returned\x20\
    from\n\x20long-running\x20operations.\n\n\x20Required\x20for\x20methods\
    \x20that\x20return\x20`google.longrunning.Operation`;\x20invalid\n\x20ot\
    herwise.\n\n\n\n\x03\x07\0\x02\x12\x03\"\x07$\n\n\n\x03\x07\0\x06\x12\
    \x03)\x02\"\n\n\n\x03\x07\0\x01\x12\x03)#1\n\n\n\x03\x07\0\x03\x12\x03)4\
    8\n\xd2\x04\n\x02\x06\0\x12\x045\0u\x01\x1a\xc5\x04\x20Manages\x20long-r\
    unning\x20operations\x20with\x20an\x20API\x20service.\n\n\x20When\x20an\
    \x20API\x20method\x20normally\x20takes\x20long\x20time\x20to\x20complete\
    ,\x20it\x20can\x20be\x20designed\n\x20to\x20return\x20[Operation][google\
    .longrunning.Operation]\x20to\x20the\x20client,\x20and\x20the\x20client\
    \x20can\x20use\x20this\n\x20interface\x20to\x20receive\x20the\x20real\
    \x20response\x20asynchronously\x20by\x20polling\x20the\n\x20operation\
    \x20resource,\x20or\x20pass\x20the\x20operation\x20resource\x20to\x20ano\
    ther\x20API\x20(such\x20as\n\x20Google\x20Cloud\x20Pub/Sub\x20API)\x20to\
    \x20receive\x20the\x20response.\x20\x20Any\x20API\x20service\x20that\n\
    \x20returns\x20long-running\x20operations\x20should\x20implement\x20the\
    \x20`Operations`\x20interface\n\x20so\x20developers\x20can\x20have\x20a\
    \x20consistent\x20client\x20experience.\n\n\n\n\x03\x06\0\x01\x12\x035\
    \x08\x12\n\xf7\x04\n\x04\x06\0\x02\0\x12\x04@\x02D\x03\x1a\xe8\x04\x20Li\
    sts\x20operations\x20that\x20match\x20the\x20specified\x20filter\x20in\
    \x20the\x20request.\x20If\x20the\n\x20server\x20doesn't\x20support\x20th\
    is\x20method,\x20it\x20returns\x20`UNIMPLEMENTED`.\n\n\x20NOTE:\x20the\
    \x20`name`\x20binding\x20allows\x20API\x20services\x20to\x20override\x20\
    the\x20binding\n\x20to\x20use\x20different\x20resource\x20name\x20scheme\
    s,\x20such\x20as\x20`users/*/operations`.\x20To\n\x20override\x20the\x20\
    binding,\x20API\x20services\x20can\x20add\x20a\x20binding\x20such\x20as\
    \n\x20`\"/v1/{name=users/*}/operations\"`\x20to\x20their\x20service\x20c\
    onfiguration.\n\x20For\x20backwards\x20compatibility,\x20the\x20default\
    \x20name\x20includes\x20the\x20operations\n\x20collection\x20id,\x20howe\
    ver\x20overriding\x20users\x20must\x20ensure\x20the\x20name\x20binding\n\
    \x20is\x20the\x20parent\x20resource,\x20without\x20the\x20operations\x20\
    collection\x20id.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03@\x06\x14\n\x0c\n\
    \x05\x06\0\x02\0\x02\x12\x03@\x15*\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03@5\
    K\n\r\n\x05\x06\0\x02\0\x04\x12\x04A\x04C\x06\n\x11\n\t\x06\0\x02\0\x04\
    \xb0\xca\xbc\"\x12\x04A\x04C\x06\n\xaf\x01\n\x04\x06\0\x02\x01\x12\x04I\
    \x02M\x03\x1a\xa0\x01\x20Gets\x20the\x20latest\x20state\x20of\x20a\x20lo\
    ng-running\x20operation.\x20\x20Clients\x20can\x20use\x20this\n\x20metho\
    d\x20to\x20poll\x20the\x20operation\x20result\x20at\x20intervals\x20as\
    \x20recommended\x20by\x20the\x20API\n\x20service.\n\n\x0c\n\x05\x06\0\
    \x02\x01\x01\x12\x03I\x06\x12\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03I\x13\
    &\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03I1:\n\r\n\x05\x06\0\x02\x01\x04\
    \x12\x04J\x04L\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04J\
    \x04L\x06\n\x85\x02\n\x04\x06\0\x02\x02\x12\x04S\x02W\x03\x1a\xf6\x01\
    \x20Deletes\x20a\x20long-running\x20operation.\x20This\x20method\x20indi\
    cates\x20that\x20the\x20client\x20is\n\x20no\x20longer\x20interested\x20\
    in\x20the\x20operation\x20result.\x20It\x20does\x20not\x20cancel\x20the\
    \n\x20operation.\x20If\x20the\x20server\x20doesn't\x20support\x20this\
    \x20method,\x20it\x20returns\n\x20`google.rpc.Code.UNIMPLEMENTED`.\n\n\
    \x0c\n\x05\x06\0\x02\x02\x01\x12\x03S\x06\x15\n\x0c\n\x05\x06\0\x02\x02\
    \x02\x12\x03S\x16,\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03S7L\n\r\n\x05\
    \x06\0\x02\x02\x04\x12\x04T\x04V\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\
    \xbc\"\x12\x04T\x04V\x06\n\xd4\x05\n\x04\x06\0\x02\x03\x12\x04c\x02h\x03\
    \x1a\xc5\x05\x20Starts\x20asynchronous\x20cancellation\x20on\x20a\x20lon\
    g-running\x20operation.\x20\x20The\x20server\n\x20makes\x20a\x20best\x20\
    effort\x20to\x20cancel\x20the\x20operation,\x20but\x20success\x20is\x20n\
    ot\n\x20guaranteed.\x20\x20If\x20the\x20server\x20doesn't\x20support\x20\
    this\x20method,\x20it\x20returns\n\x20`google.rpc.Code.UNIMPLEMENTED`.\
    \x20\x20Clients\x20can\x20use\n\x20[Operations.GetOperation][google.long\
    running.Operations.GetOperation]\x20or\n\x20other\x20methods\x20to\x20ch\
    eck\x20whether\x20the\x20cancellation\x20succeeded\x20or\x20whether\x20t\
    he\n\x20operation\x20completed\x20despite\x20cancellation.\x20On\x20succ\
    essful\x20cancellation,\n\x20the\x20operation\x20is\x20not\x20deleted;\
    \x20instead,\x20it\x20becomes\x20an\x20operation\x20with\n\x20an\x20[Ope\
    ration.error][google.longrunning.Operation.error]\x20value\x20with\x20a\
    \x20[google.rpc.Status.code][google.rpc.Status.code]\x20of\x201,\n\x20co\
    rresponding\x20to\x20`Code.CANCELLED`.\n\n\x0c\n\x05\x06\0\x02\x03\x01\
    \x12\x03c\x06\x15\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03c\x16,\n\x0c\n\
    \x05\x06\0\x02\x03\x03\x12\x03c7L\n\r\n\x05\x06\0\x02\x03\x04\x12\x04d\
    \x04g\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04d\x04g\x06\n\
    \xfe\x04\n\x04\x06\0\x02\x04\x12\x04s\x02t\x03\x1a\xef\x04\x20Waits\x20f\
    or\x20the\x20specified\x20long-running\x20operation\x20until\x20it\x20is\
    \x20done\x20or\x20reaches\n\x20at\x20most\x20a\x20specified\x20timeout,\
    \x20returning\x20the\x20latest\x20state.\x20\x20If\x20the\x20operation\n\
    \x20is\x20already\x20done,\x20the\x20latest\x20state\x20is\x20immediatel\
    y\x20returned.\x20\x20If\x20the\x20timeout\n\x20specified\x20is\x20great\
    er\x20than\x20the\x20default\x20HTTP/RPC\x20timeout,\x20the\x20HTTP/RPC\
    \n\x20timeout\x20is\x20used.\x20\x20If\x20the\x20server\x20does\x20not\
    \x20support\x20this\x20method,\x20it\x20returns\n\x20`google.rpc.Code.UN\
    IMPLEMENTED`.\n\x20Note\x20that\x20this\x20method\x20is\x20on\x20a\x20be\
    st-effort\x20basis.\x20\x20It\x20may\x20return\x20the\x20latest\n\x20sta\
    te\x20before\x20the\x20specified\x20timeout\x20(including\x20immediately\
    ),\x20meaning\x20even\x20an\n\x20immediate\x20response\x20is\x20no\x20gu\
    arantee\x20that\x20the\x20operation\x20is\x20done.\n\n\x0c\n\x05\x06\0\
    \x02\x04\x01\x12\x03s\x06\x13\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03s\x14\
    (\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03s3<\nk\n\x02\x04\0\x12\x05y\0\x9b\
    \x01\x01\x1a^\x20This\x20resource\x20represents\x20a\x20long-running\x20\
    operation\x20that\x20is\x20the\x20result\x20of\x20a\n\x20network\x20API\
    \x20call.\n\n\n\n\x03\x04\0\x01\x12\x03y\x08\x11\n\xdd\x01\n\x04\x04\0\
    \x02\0\x12\x03}\x02\x12\x1a\xcf\x01\x20The\x20server-assigned\x20name,\
    \x20which\x20is\x20only\x20unique\x20within\x20the\x20same\x20service\
    \x20that\n\x20originally\x20returns\x20it.\x20If\x20you\x20use\x20the\
    \x20default\x20HTTP\x20mapping,\x20the\n\x20`name`\x20should\x20have\x20\
    the\x20format\x20of\x20`operations/some/unique/name`.\n\n\x0c\n\x05\x04\
    \0\x02\0\x05\x12\x03}\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03}\t\r\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03}\x10\x11\n\xad\x02\n\x04\x04\0\x02\
    \x01\x12\x04\x83\x01\x02#\x1a\x9e\x02\x20Service-specific\x20metadata\
    \x20associated\x20with\x20the\x20operation.\x20\x20It\x20typically\n\x20\
    contains\x20progress\x20information\x20and\x20common\x20metadata\x20such\
    \x20as\x20create\x20time.\n\x20Some\x20services\x20might\x20not\x20provi\
    de\x20such\x20metadata.\x20\x20Any\x20method\x20that\x20returns\x20a\n\
    \x20long-running\x20operation\x20should\x20document\x20the\x20metadata\
    \x20type,\x20if\x20any.\n\n\r\n\x05\x04\0\x02\x01\x06\x12\x04\x83\x01\
    \x02\x15\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\x83\x01\x16\x1e\n\r\n\x05\
    \x04\0\x02\x01\x03\x12\x04\x83\x01!\"\n\xae\x01\n\x04\x04\0\x02\x02\x12\
    \x04\x88\x01\x02\x10\x1a\x9f\x01\x20If\x20the\x20value\x20is\x20`false`,\
    \x20it\x20means\x20the\x20operation\x20is\x20still\x20in\x20progress.\n\
    \x20If\x20`true`,\x20the\x20operation\x20is\x20completed,\x20and\x20eith\
    er\x20`error`\x20or\x20`response`\x20is\n\x20available.\n\n\r\n\x05\x04\
    \0\x02\x02\x05\x12\x04\x88\x01\x02\x06\n\r\n\x05\x04\0\x02\x02\x01\x12\
    \x04\x88\x01\x07\x0b\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\x88\x01\x0e\x0f\
    \n\xdf\x01\n\x04\x04\0\x08\0\x12\x06\x8d\x01\x02\x9a\x01\x03\x1a\xce\x01\
    \x20The\x20operation\x20result,\x20which\x20can\x20be\x20either\x20an\
    \x20`error`\x20or\x20a\x20valid\x20`response`.\n\x20If\x20`done`\x20==\
    \x20`false`,\x20neither\x20`error`\x20nor\x20`response`\x20is\x20set.\n\
    \x20If\x20`done`\x20==\x20`true`,\x20exactly\x20one\x20of\x20`error`\x20\
    or\x20`response`\x20is\x20set.\n\n\r\n\x05\x04\0\x08\0\x01\x12\x04\x8d\
    \x01\x08\x0e\nU\n\x04\x04\0\x02\x03\x12\x04\x8f\x01\x04\x20\x1aG\x20The\
    \x20error\x20result\x20of\x20the\x20operation\x20in\x20case\x20of\x20fai\
    lure\x20or\x20cancellation.\n\n\r\n\x05\x04\0\x02\x03\x06\x12\x04\x8f\
    \x01\x04\x15\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\x8f\x01\x16\x1b\n\r\n\
    \x05\x04\0\x02\x03\x03\x12\x04\x8f\x01\x1e\x1f\n\x84\x04\n\x04\x04\0\x02\
    \x04\x12\x04\x99\x01\x04%\x1a\xf5\x03\x20The\x20normal\x20response\x20of\
    \x20the\x20operation\x20in\x20case\x20of\x20success.\x20\x20If\x20the\
    \x20original\n\x20method\x20returns\x20no\x20data\x20on\x20success,\x20s\
    uch\x20as\x20`Delete`,\x20the\x20response\x20is\n\x20`google.protobuf.Em\
    pty`.\x20\x20If\x20the\x20original\x20method\x20is\x20standard\n\x20`Get\
    `/`Create`/`Update`,\x20the\x20response\x20should\x20be\x20the\x20resour\
    ce.\x20\x20For\x20other\n\x20methods,\x20the\x20response\x20should\x20ha\
    ve\x20the\x20type\x20`XxxResponse`,\x20where\x20`Xxx`\n\x20is\x20the\x20\
    original\x20method\x20name.\x20\x20For\x20example,\x20if\x20the\x20origi\
    nal\x20method\x20name\n\x20is\x20`TakeSnapshot()`,\x20the\x20inferred\
    \x20response\x20type\x20is\n\x20`TakeSnapshotResponse`.\n\n\r\n\x05\x04\
    \0\x02\x04\x06\x12\x04\x99\x01\x04\x17\n\r\n\x05\x04\0\x02\x04\x01\x12\
    \x04\x99\x01\x18\x20\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\x99\x01#$\nn\n\
    \x02\x04\x01\x12\x06\x9e\x01\0\xa1\x01\x01\x1a`\x20The\x20request\x20mes\
    sage\x20for\x20[Operations.GetOperation][google.longrunning.Operations.G\
    etOperation].\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x9e\x01\x08\x1b\n3\n\x04\
    \x04\x01\x02\0\x12\x04\xa0\x01\x02\x12\x1a%\x20The\x20name\x20of\x20the\
    \x20operation\x20resource.\n\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xa0\x01\
    \x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xa0\x01\t\r\n\r\n\x05\x04\
    \x01\x02\0\x03\x12\x04\xa0\x01\x10\x11\nr\n\x02\x04\x02\x12\x06\xa4\x01\
    \0\xb0\x01\x01\x1ad\x20The\x20request\x20message\x20for\x20[Operations.L\
    istOperations][google.longrunning.Operations.ListOperations].\n\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\xa4\x01\x08\x1d\n<\n\x04\x04\x02\x02\0\x12\x04\
    \xa6\x01\x02\x12\x1a.\x20The\x20name\x20of\x20the\x20operation's\x20pare\
    nt\x20resource.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xa6\x01\x02\x08\n\
    \r\n\x05\x04\x02\x02\0\x01\x12\x04\xa6\x01\t\r\n\r\n\x05\x04\x02\x02\0\
    \x03\x12\x04\xa6\x01\x10\x11\n)\n\x04\x04\x02\x02\x01\x12\x04\xa9\x01\
    \x02\x14\x1a\x1b\x20The\x20standard\x20list\x20filter.\n\n\r\n\x05\x04\
    \x02\x02\x01\x05\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\
    \x12\x04\xa9\x01\t\x0f\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xa9\x01\x12\
    \x13\n,\n\x04\x04\x02\x02\x02\x12\x04\xac\x01\x02\x16\x1a\x1e\x20The\x20\
    standard\x20list\x20page\x20size.\n\n\r\n\x05\x04\x02\x02\x02\x05\x12\
    \x04\xac\x01\x02\x07\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xac\x01\x08\
    \x11\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xac\x01\x14\x15\n-\n\x04\x04\
    \x02\x02\x03\x12\x04\xaf\x01\x02\x18\x1a\x1f\x20The\x20standard\x20list\
    \x20page\x20token.\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\xaf\x01\x02\
    \x08\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xaf\x01\t\x13\n\r\n\x05\x04\
    \x02\x02\x03\x03\x12\x04\xaf\x01\x16\x17\ns\n\x02\x04\x03\x12\x06\xb3\
    \x01\0\xb9\x01\x01\x1ae\x20The\x20response\x20message\x20for\x20[Operati\
    ons.ListOperations][google.longrunning.Operations.ListOperations].\n\n\
    \x0b\n\x03\x04\x03\x01\x12\x04\xb3\x01\x08\x1e\nV\n\x04\x04\x03\x02\0\
    \x12\x04\xb5\x01\x02$\x1aH\x20A\x20list\x20of\x20operations\x20that\x20m\
    atches\x20the\x20specified\x20filter\x20in\x20the\x20request.\n\n\r\n\
    \x05\x04\x03\x02\0\x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x03\x02\0\x06\
    \x12\x04\xb5\x01\x0b\x14\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xb5\x01\x15\
    \x1f\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xb5\x01\"#\n2\n\x04\x04\x03\x02\
    \x01\x12\x04\xb8\x01\x02\x1d\x1a$\x20The\x20standard\x20List\x20next-pag\
    e\x20token.\n\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xb8\x01\x02\x08\n\r\
    \n\x05\x04\x03\x02\x01\x01\x12\x04\xb8\x01\t\x18\n\r\n\x05\x04\x03\x02\
    \x01\x03\x12\x04\xb8\x01\x1b\x1c\nt\n\x02\x04\x04\x12\x06\xbc\x01\0\xbf\
    \x01\x01\x1af\x20The\x20request\x20message\x20for\x20[Operations.CancelO\
    peration][google.longrunning.Operations.CancelOperation].\n\n\x0b\n\x03\
    \x04\x04\x01\x12\x04\xbc\x01\x08\x1e\nC\n\x04\x04\x04\x02\0\x12\x04\xbe\
    \x01\x02\x12\x1a5\x20The\x20name\x20of\x20the\x20operation\x20resource\
    \x20to\x20be\x20cancelled.\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xbe\x01\
    \x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xbe\x01\t\r\n\r\n\x05\x04\
    \x04\x02\0\x03\x12\x04\xbe\x01\x10\x11\nt\n\x02\x04\x05\x12\x06\xc2\x01\
    \0\xc5\x01\x01\x1af\x20The\x20request\x20message\x20for\x20[Operations.D\
    eleteOperation][google.longrunning.Operations.DeleteOperation].\n\n\x0b\
    \n\x03\x04\x05\x01\x12\x04\xc2\x01\x08\x1e\nA\n\x04\x04\x05\x02\0\x12\
    \x04\xc4\x01\x02\x12\x1a3\x20The\x20name\x20of\x20the\x20operation\x20re\
    source\x20to\x20be\x20deleted.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xc4\
    \x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xc4\x01\t\r\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xc4\x01\x10\x11\np\n\x02\x04\x06\x12\x06\xc8\
    \x01\0\xd0\x01\x01\x1ab\x20The\x20request\x20message\x20for\x20[Operatio\
    ns.WaitOperation][google.longrunning.Operations.WaitOperation].\n\n\x0b\
    \n\x03\x04\x06\x01\x12\x04\xc8\x01\x08\x1c\n>\n\x04\x04\x06\x02\0\x12\
    \x04\xca\x01\x02\x12\x1a0\x20The\x20name\x20of\x20the\x20operation\x20re\
    source\x20to\x20wait\x20on.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xca\
    \x01\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xca\x01\t\r\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\xca\x01\x10\x11\n\xeb\x01\n\x04\x04\x06\x02\
    \x01\x12\x04\xcf\x01\x02'\x1a\xdc\x01\x20The\x20maximum\x20duration\x20t\
    o\x20wait\x20before\x20timing\x20out.\x20If\x20left\x20blank,\x20the\x20\
    wait\n\x20will\x20be\x20at\x20most\x20the\x20time\x20permitted\x20by\x20\
    the\x20underlying\x20HTTP/RPC\x20protocol.\n\x20If\x20RPC\x20context\x20\
    deadline\x20is\x20also\x20specified,\x20the\x20shorter\x20one\x20will\
    \x20be\x20used.\n\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xcf\x01\x02\x1a\
    \n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xcf\x01\x1b\"\n\r\n\x05\x04\x06\
    \x02\x01\x03\x12\x04\xcf\x01%&\n\xfb\x02\n\x02\x04\x07\x12\x06\xdd\x01\0\
    \xf0\x01\x01\x1a\xec\x02\x20A\x20message\x20representing\x20the\x20messa\
    ge\x20types\x20used\x20by\x20a\x20long-running\x20operation.\n\n\x20Exam\
    ple:\n\n\x20\x20\x20rpc\x20LongRunningRecognize(LongRunningRecognizeRequ\
    est)\n\x20\x20\x20\x20\x20\x20\x20returns\x20(google.longrunning.Operati\
    on)\x20{\n\x20\x20\x20\x20\x20option\x20(google.longrunning.operation_in\
    fo)\x20=\x20{\n\x20\x20\x20\x20\x20\x20\x20response_type:\x20\"LongRunni\
    ngRecognizeResponse\"\n\x20\x20\x20\x20\x20\x20\x20metadata_type:\x20\"L\
    ongRunningRecognizeMetadata\"\n\x20\x20\x20\x20\x20};\n\x20\x20\x20}\n\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\xdd\x01\x08\x15\n\xe6\x02\n\x04\x04\x07\
    \x02\0\x12\x04\xe6\x01\x02\x1b\x1a\xd7\x02\x20Required.\x20The\x20messag\
    e\x20name\x20of\x20the\x20primary\x20return\x20type\x20for\x20this\n\x20\
    long-running\x20operation.\n\x20This\x20type\x20will\x20be\x20used\x20to\
    \x20deserialize\x20the\x20LRO's\x20response.\n\n\x20If\x20the\x20respons\
    e\x20is\x20in\x20a\x20different\x20package\x20from\x20the\x20rpc,\x20a\
    \x20fully-qualified\n\x20message\x20name\x20must\x20be\x20used\x20(e.g.\
    \x20`google.protobuf.Struct`).\n\n\x20Note:\x20Altering\x20this\x20value\
    \x20constitutes\x20a\x20breaking\x20change.\n\n\r\n\x05\x04\x07\x02\0\
    \x05\x12\x04\xe6\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xe6\x01\
    \t\x16\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xe6\x01\x19\x1a\n\xa5\x02\n\
    \x04\x04\x07\x02\x01\x12\x04\xef\x01\x02\x1b\x1a\x96\x02\x20Required.\
    \x20The\x20message\x20name\x20of\x20the\x20metadata\x20type\x20for\x20th\
    is\x20long-running\n\x20operation.\n\n\x20If\x20the\x20response\x20is\
    \x20in\x20a\x20different\x20package\x20from\x20the\x20rpc,\x20a\x20fully\
    -qualified\n\x20message\x20name\x20must\x20be\x20used\x20(e.g.\x20`googl\
    e.protobuf.Struct`).\n\n\x20Note:\x20Altering\x20this\x20value\x20consti\
    tutes\x20a\x20breaking\x20change.\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\
    \x04\xef\x01\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xef\x01\t\x16\
    \n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xef\x01\x19\x1ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            deps.push(super::status::file_descriptor().clone());
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(Operation::generated_message_descriptor_data());
            messages.push(GetOperationRequest::generated_message_descriptor_data());
            messages.push(ListOperationsRequest::generated_message_descriptor_data());
            messages.push(ListOperationsResponse::generated_message_descriptor_data());
            messages.push(CancelOperationRequest::generated_message_descriptor_data());
            messages.push(DeleteOperationRequest::generated_message_descriptor_data());
            messages.push(WaitOperationRequest::generated_message_descriptor_data());
            messages.push(OperationInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
