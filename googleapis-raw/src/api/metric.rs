// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/api/metric.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

///  Defines a metric type and its schema. Once a metric descriptor is created,
///  deleting or altering it stops data collection and makes the metric type's
///  existing data unusable.
// @@protoc_insertion_point(message:google.api.MetricDescriptor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MetricDescriptor {
    // message fields
    ///  The resource name of the metric descriptor.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.type)
    pub type_: ::std::string::String,
    ///  The set of labels that can be used to describe a specific
    ///  instance of this metric type. For example, the
    ///  `appengine.googleapis.com/http/server/response_latencies` metric
    ///  type has a label for the HTTP response code, `response_code`, so
    ///  you can look at latencies for successful responses or just
    ///  for responses that failed.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.labels)
    pub labels: ::std::vec::Vec<super::label::LabelDescriptor>,
    ///  Whether the metric records instantaneous values, changes to a value, etc.
    ///  Some combinations of `metric_kind` and `value_type` might not be supported.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.metric_kind)
    pub metric_kind: ::protobuf::EnumOrUnknown<metric_descriptor::MetricKind>,
    ///  Whether the measurement is an integer, a floating-point number, etc.
    ///  Some combinations of `metric_kind` and `value_type` might not be supported.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.value_type)
    pub value_type: ::protobuf::EnumOrUnknown<metric_descriptor::ValueType>,
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.unit)
    pub unit: ::std::string::String,
    ///  A detailed description of the metric, which can be used in documentation.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.description)
    pub description: ::std::string::String,
    ///  A concise name for the metric, which can be displayed in user interfaces.
    ///  Use sentence case without an ending period, for example "Request count".
    ///  This field is optional but it is recommended to be set for any metrics
    ///  associated with user-visible concepts, such as Quota.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.display_name)
    pub display_name: ::std::string::String,
    ///  Optional. Metadata which can be used to guide usage of the metric.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.metadata)
    pub metadata: ::protobuf::MessageField<metric_descriptor::MetricDescriptorMetadata>,
    ///  Optional. The launch stage of the metric definition.
    // @@protoc_insertion_point(field:google.api.MetricDescriptor.launch_stage)
    pub launch_stage: ::protobuf::EnumOrUnknown<super::launch_stage::LaunchStage>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.MetricDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricDescriptor {
    fn default() -> &'a MetricDescriptor {
        <MetricDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl MetricDescriptor {
    pub fn new() -> MetricDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MetricDescriptor| { &m.name },
            |m: &mut MetricDescriptor| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MetricDescriptor| { &m.type_ },
            |m: &mut MetricDescriptor| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &MetricDescriptor| { &m.labels },
            |m: &mut MetricDescriptor| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metric_kind",
            |m: &MetricDescriptor| { &m.metric_kind },
            |m: &mut MetricDescriptor| { &mut m.metric_kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value_type",
            |m: &MetricDescriptor| { &m.value_type },
            |m: &mut MetricDescriptor| { &mut m.value_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit",
            |m: &MetricDescriptor| { &m.unit },
            |m: &mut MetricDescriptor| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &MetricDescriptor| { &m.description },
            |m: &mut MetricDescriptor| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display_name",
            |m: &MetricDescriptor| { &m.display_name },
            |m: &mut MetricDescriptor| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, metric_descriptor::MetricDescriptorMetadata>(
            "metadata",
            |m: &MetricDescriptor| { &m.metadata },
            |m: &mut MetricDescriptor| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "launch_stage",
            |m: &MetricDescriptor| { &m.launch_stage },
            |m: &mut MetricDescriptor| { &mut m.launch_stage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricDescriptor>(
            "MetricDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricDescriptor {
    const NAME: &'static str = "MetricDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                66 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.labels.push(is.read_message()?);
                },
                24 => {
                    self.metric_kind = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.value_type = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.unit = is.read_string()?;
                },
                50 => {
                    self.description = is.read_string()?;
                },
                58 => {
                    self.display_name = is.read_string()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                96 => {
                    self.launch_stage = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.type_);
        }
        for value in &self.labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.metric_kind != ::protobuf::EnumOrUnknown::new(metric_descriptor::MetricKind::METRIC_KIND_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(3, self.metric_kind.value());
        }
        if self.value_type != ::protobuf::EnumOrUnknown::new(metric_descriptor::ValueType::VALUE_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.value_type.value());
        }
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.unit);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.display_name);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.launch_stage != ::protobuf::EnumOrUnknown::new(super::launch_stage::LaunchStage::LAUNCH_STAGE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(12, self.launch_stage.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.type_.is_empty() {
            os.write_string(8, &self.type_)?;
        }
        for v in &self.labels {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.metric_kind != ::protobuf::EnumOrUnknown::new(metric_descriptor::MetricKind::METRIC_KIND_UNSPECIFIED) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.metric_kind))?;
        }
        if self.value_type != ::protobuf::EnumOrUnknown::new(metric_descriptor::ValueType::VALUE_TYPE_UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.value_type))?;
        }
        if !self.unit.is_empty() {
            os.write_string(5, &self.unit)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(7, &self.display_name)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.launch_stage != ::protobuf::EnumOrUnknown::new(super::launch_stage::LaunchStage::LAUNCH_STAGE_UNSPECIFIED) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.launch_stage))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricDescriptor {
        MetricDescriptor::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_.clear();
        self.labels.clear();
        self.metric_kind = ::protobuf::EnumOrUnknown::new(metric_descriptor::MetricKind::METRIC_KIND_UNSPECIFIED);
        self.value_type = ::protobuf::EnumOrUnknown::new(metric_descriptor::ValueType::VALUE_TYPE_UNSPECIFIED);
        self.unit.clear();
        self.description.clear();
        self.display_name.clear();
        self.metadata.clear();
        self.launch_stage = ::protobuf::EnumOrUnknown::new(super::launch_stage::LaunchStage::LAUNCH_STAGE_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricDescriptor {
        static instance: MetricDescriptor = MetricDescriptor {
            name: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            labels: ::std::vec::Vec::new(),
            metric_kind: ::protobuf::EnumOrUnknown::from_i32(0),
            value_type: ::protobuf::EnumOrUnknown::from_i32(0),
            unit: ::std::string::String::new(),
            description: ::std::string::String::new(),
            display_name: ::std::string::String::new(),
            metadata: ::protobuf::MessageField::none(),
            launch_stage: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetricDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MetricDescriptor`
pub mod metric_descriptor {
    ///  Additional annotations that can be used to guide the usage of a metric.
    // @@protoc_insertion_point(message:google.api.MetricDescriptor.MetricDescriptorMetadata)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MetricDescriptorMetadata {
        // message fields
        ///  Deprecated. Please use the MetricDescriptor.launch_stage instead.
        ///  The launch stage of the metric definition.
        // @@protoc_insertion_point(field:google.api.MetricDescriptor.MetricDescriptorMetadata.launch_stage)
        pub launch_stage: ::protobuf::EnumOrUnknown<super::super::launch_stage::LaunchStage>,
        ///  The sampling period of metric data points. For metrics which are written
        ///  periodically, consecutive data points are stored at this time interval,
        ///  excluding data loss due to errors. Metrics with a higher granularity have
        ///  a smaller sampling period.
        // @@protoc_insertion_point(field:google.api.MetricDescriptor.MetricDescriptorMetadata.sample_period)
        pub sample_period: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
        ///  The delay of data points caused by ingestion. Data points older than this
        ///  age are guaranteed to be ingested and available to be read, excluding
        ///  data loss due to errors.
        // @@protoc_insertion_point(field:google.api.MetricDescriptor.MetricDescriptorMetadata.ingest_delay)
        pub ingest_delay: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
        // special fields
        // @@protoc_insertion_point(special_field:google.api.MetricDescriptor.MetricDescriptorMetadata.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MetricDescriptorMetadata {
        fn default() -> &'a MetricDescriptorMetadata {
            <MetricDescriptorMetadata as ::protobuf::Message>::default_instance()
        }
    }

    impl MetricDescriptorMetadata {
        pub fn new() -> MetricDescriptorMetadata {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "launch_stage",
                |m: &MetricDescriptorMetadata| { &m.launch_stage },
                |m: &mut MetricDescriptorMetadata| { &mut m.launch_stage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
                "sample_period",
                |m: &MetricDescriptorMetadata| { &m.sample_period },
                |m: &mut MetricDescriptorMetadata| { &mut m.sample_period },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
                "ingest_delay",
                |m: &MetricDescriptorMetadata| { &m.ingest_delay },
                |m: &mut MetricDescriptorMetadata| { &mut m.ingest_delay },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricDescriptorMetadata>(
                "MetricDescriptor.MetricDescriptorMetadata",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MetricDescriptorMetadata {
        const NAME: &'static str = "MetricDescriptorMetadata";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.launch_stage = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.sample_period)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ingest_delay)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.launch_stage != ::protobuf::EnumOrUnknown::new(super::super::launch_stage::LaunchStage::LAUNCH_STAGE_UNSPECIFIED) {
                my_size += ::protobuf::rt::int32_size(1, self.launch_stage.value());
            }
            if let Some(v) = self.sample_period.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.ingest_delay.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.launch_stage != ::protobuf::EnumOrUnknown::new(super::super::launch_stage::LaunchStage::LAUNCH_STAGE_UNSPECIFIED) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.launch_stage))?;
            }
            if let Some(v) = self.sample_period.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.ingest_delay.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MetricDescriptorMetadata {
            MetricDescriptorMetadata::new()
        }

        fn clear(&mut self) {
            self.launch_stage = ::protobuf::EnumOrUnknown::new(super::super::launch_stage::LaunchStage::LAUNCH_STAGE_UNSPECIFIED);
            self.sample_period.clear();
            self.ingest_delay.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MetricDescriptorMetadata {
            static instance: MetricDescriptorMetadata = MetricDescriptorMetadata {
                launch_stage: ::protobuf::EnumOrUnknown::from_i32(0),
                sample_period: ::protobuf::MessageField::none(),
                ingest_delay: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MetricDescriptorMetadata {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MetricDescriptor.MetricDescriptorMetadata").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MetricDescriptorMetadata {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MetricDescriptorMetadata {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  The kind of measurement. It describes how the data is reported.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.MetricDescriptor.MetricKind)
    pub enum MetricKind {
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.MetricKind.METRIC_KIND_UNSPECIFIED)
        METRIC_KIND_UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.MetricKind.GAUGE)
        GAUGE = 1,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.MetricKind.DELTA)
        DELTA = 2,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.MetricKind.CUMULATIVE)
        CUMULATIVE = 3,
    }

    impl ::protobuf::Enum for MetricKind {
        const NAME: &'static str = "MetricKind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MetricKind> {
            match value {
                0 => ::std::option::Option::Some(MetricKind::METRIC_KIND_UNSPECIFIED),
                1 => ::std::option::Option::Some(MetricKind::GAUGE),
                2 => ::std::option::Option::Some(MetricKind::DELTA),
                3 => ::std::option::Option::Some(MetricKind::CUMULATIVE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<MetricKind> {
            match str {
                "METRIC_KIND_UNSPECIFIED" => ::std::option::Option::Some(MetricKind::METRIC_KIND_UNSPECIFIED),
                "GAUGE" => ::std::option::Option::Some(MetricKind::GAUGE),
                "DELTA" => ::std::option::Option::Some(MetricKind::DELTA),
                "CUMULATIVE" => ::std::option::Option::Some(MetricKind::CUMULATIVE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MetricKind] = &[
            MetricKind::METRIC_KIND_UNSPECIFIED,
            MetricKind::GAUGE,
            MetricKind::DELTA,
            MetricKind::CUMULATIVE,
        ];
    }

    impl ::protobuf::EnumFull for MetricKind {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MetricDescriptor.MetricKind").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MetricKind {
        fn default() -> Self {
            MetricKind::METRIC_KIND_UNSPECIFIED
        }
    }

    impl MetricKind {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MetricKind>("MetricDescriptor.MetricKind")
        }
    }

    ///  The value type of a metric.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.MetricDescriptor.ValueType)
    pub enum ValueType {
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.ValueType.VALUE_TYPE_UNSPECIFIED)
        VALUE_TYPE_UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.ValueType.BOOL)
        BOOL = 1,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.ValueType.INT64)
        INT64 = 2,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.ValueType.DOUBLE)
        DOUBLE = 3,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.ValueType.STRING)
        STRING = 4,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.ValueType.DISTRIBUTION)
        DISTRIBUTION = 5,
        // @@protoc_insertion_point(enum_value:google.api.MetricDescriptor.ValueType.MONEY)
        MONEY = 6,
    }

    impl ::protobuf::Enum for ValueType {
        const NAME: &'static str = "ValueType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ValueType> {
            match value {
                0 => ::std::option::Option::Some(ValueType::VALUE_TYPE_UNSPECIFIED),
                1 => ::std::option::Option::Some(ValueType::BOOL),
                2 => ::std::option::Option::Some(ValueType::INT64),
                3 => ::std::option::Option::Some(ValueType::DOUBLE),
                4 => ::std::option::Option::Some(ValueType::STRING),
                5 => ::std::option::Option::Some(ValueType::DISTRIBUTION),
                6 => ::std::option::Option::Some(ValueType::MONEY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ValueType> {
            match str {
                "VALUE_TYPE_UNSPECIFIED" => ::std::option::Option::Some(ValueType::VALUE_TYPE_UNSPECIFIED),
                "BOOL" => ::std::option::Option::Some(ValueType::BOOL),
                "INT64" => ::std::option::Option::Some(ValueType::INT64),
                "DOUBLE" => ::std::option::Option::Some(ValueType::DOUBLE),
                "STRING" => ::std::option::Option::Some(ValueType::STRING),
                "DISTRIBUTION" => ::std::option::Option::Some(ValueType::DISTRIBUTION),
                "MONEY" => ::std::option::Option::Some(ValueType::MONEY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ValueType] = &[
            ValueType::VALUE_TYPE_UNSPECIFIED,
            ValueType::BOOL,
            ValueType::INT64,
            ValueType::DOUBLE,
            ValueType::STRING,
            ValueType::DISTRIBUTION,
            ValueType::MONEY,
        ];
    }

    impl ::protobuf::EnumFull for ValueType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MetricDescriptor.ValueType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ValueType {
        fn default() -> Self {
            ValueType::VALUE_TYPE_UNSPECIFIED
        }
    }

    impl ValueType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValueType>("MetricDescriptor.ValueType")
        }
    }
}

///  A specific metric, identified by specifying values for all of the
///  labels of a [`MetricDescriptor`][google.api.MetricDescriptor].
// @@protoc_insertion_point(message:google.api.Metric)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Metric {
    // message fields
    ///  An existing metric type, see [google.api.MetricDescriptor][google.api.MetricDescriptor].
    ///  For example, `custom.googleapis.com/invoice/paid/amount`.
    // @@protoc_insertion_point(field:google.api.Metric.type)
    pub type_: ::std::string::String,
    ///  The set of label values that uniquely identify this metric. All
    ///  labels listed in the `MetricDescriptor` must be assigned values.
    // @@protoc_insertion_point(field:google.api.Metric.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.Metric.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metric {
    fn default() -> &'a Metric {
        <Metric as ::protobuf::Message>::default_instance()
    }
}

impl Metric {
    pub fn new() -> Metric {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Metric| { &m.type_ },
            |m: &mut Metric| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &Metric| { &m.labels },
            |m: &mut Metric| { &mut m.labels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metric>(
            "Metric",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metric {
    const NAME: &'static str = "Metric";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.type_);
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(3, &self.type_)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metric {
        Metric::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.labels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metric {
        static instance: ::protobuf::rt::Lazy<Metric> = ::protobuf::rt::Lazy::new();
        instance.get(Metric::new)
    }
}

impl ::protobuf::MessageFull for Metric {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metric").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metric {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17google/api/metric.proto\x12\ngoogle.api\x1a\x16google/api/label.pr\
    oto\x1a\x1dgoogle/api/launch_stage.proto\x1a\x1egoogle/protobuf/duration\
    .proto\"\x87\x07\n\x10MetricDescriptor\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x12\x12\n\x04type\x18\x08\x20\x01(\tR\x04type\x123\n\x06lab\
    els\x18\x02\x20\x03(\x0b2\x1b.google.api.LabelDescriptorR\x06labels\x12H\
    \n\x0bmetric_kind\x18\x03\x20\x01(\x0e2'.google.api.MetricDescriptor.Met\
    ricKindR\nmetricKind\x12E\n\nvalue_type\x18\x04\x20\x01(\x0e2&.google.ap\
    i.MetricDescriptor.ValueTypeR\tvalueType\x12\x12\n\x04unit\x18\x05\x20\
    \x01(\tR\x04unit\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescrip\
    tion\x12!\n\x0cdisplay_name\x18\x07\x20\x01(\tR\x0bdisplayName\x12Q\n\
    \x08metadata\x18\n\x20\x01(\x0b25.google.api.MetricDescriptor.MetricDesc\
    riptorMetadataR\x08metadata\x12:\n\x0claunch_stage\x18\x0c\x20\x01(\x0e2\
    \x17.google.api.LaunchStageR\x0blaunchStage\x1a\xd8\x01\n\x18MetricDescr\
    iptorMetadata\x12>\n\x0claunch_stage\x18\x01\x20\x01(\x0e2\x17.google.ap\
    i.LaunchStageR\x0blaunchStageB\x02\x18\x01\x12>\n\rsample_period\x18\x02\
    \x20\x01(\x0b2\x19.google.protobuf.DurationR\x0csamplePeriod\x12<\n\x0ci\
    ngest_delay\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0binges\
    tDelay\"O\n\nMetricKind\x12\x1b\n\x17METRIC_KIND_UNSPECIFIED\x10\0\x12\t\
    \n\x05GAUGE\x10\x01\x12\t\n\x05DELTA\x10\x02\x12\x0e\n\nCUMULATIVE\x10\
    \x03\"q\n\tValueType\x12\x1a\n\x16VALUE_TYPE_UNSPECIFIED\x10\0\x12\x08\n\
    \x04BOOL\x10\x01\x12\t\n\x05INT64\x10\x02\x12\n\n\x06DOUBLE\x10\x03\x12\
    \n\n\x06STRING\x10\x04\x12\x10\n\x0cDISTRIBUTION\x10\x05\x12\t\n\x05MONE\
    Y\x10\x06\"\x8f\x01\n\x06Metric\x12\x12\n\x04type\x18\x03\x20\x01(\tR\
    \x04type\x126\n\x06labels\x18\x02\x20\x03(\x0b2\x1e.google.api.Metric.La\
    belsEntryR\x06labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01B_\n\x0ecom.google.apiB\x0bMetricProtoP\x01Z7google.golang.org/genpr\
    oto/googleapis/api/metric;metric\xa2\x02\x04GAPIJ\x99M\n\x07\x12\x05\x0f\
    \0\xff\x01\x01\n\xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyrig\
    ht\x202019\x20Google\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\
    \x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\
    \x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20\
    the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20L\
    icense\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICEN\
    SE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agr\
    eed\x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\
    \x13\n\t\n\x02\x03\0\x12\x03\x13\0\x20\n\t\n\x02\x03\x01\x12\x03\x14\0'\
    \n\t\n\x02\x03\x02\x12\x03\x15\0(\n\x08\n\x01\x08\x12\x03\x17\0N\n\t\n\
    \x02\x08\x0b\x12\x03\x17\0N\n\x08\n\x01\x08\x12\x03\x18\0\"\n\t\n\x02\
    \x08\n\x12\x03\x18\0\"\n\x08\n\x01\x08\x12\x03\x19\0,\n\t\n\x02\x08\x08\
    \x12\x03\x19\0,\n\x08\n\x01\x08\x12\x03\x1a\0'\n\t\n\x02\x08\x01\x12\x03\
    \x1a\0'\n\x08\n\x01\x08\x12\x03\x1b\0\"\n\t\n\x02\x08$\x12\x03\x1b\0\"\n\
    \xbe\x01\n\x02\x04\0\x12\x05\x20\0\xf3\x01\x01\x1a\xb0\x01\x20Defines\
    \x20a\x20metric\x20type\x20and\x20its\x20schema.\x20Once\x20a\x20metric\
    \x20descriptor\x20is\x20created,\n\x20deleting\x20or\x20altering\x20it\
    \x20stops\x20data\x20collection\x20and\x20makes\x20the\x20metric\x20type\
    's\n\x20existing\x20data\x20unusable.\n\n\n\n\x03\x04\0\x01\x12\x03\x20\
    \x08\x18\nW\n\x04\x04\0\x03\0\x12\x04\"\x021\x03\x1aI\x20Additional\x20a\
    nnotations\x20that\x20can\x20be\x20used\x20to\x20guide\x20the\x20usage\
    \x20of\x20a\x20metric.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\"\n\"\n~\n\
    \x06\x04\0\x03\0\x02\0\x12\x03%\x045\x1ao\x20Deprecated.\x20Please\x20us\
    e\x20the\x20MetricDescriptor.launch_stage\x20instead.\n\x20The\x20launch\
    \x20stage\x20of\x20the\x20metric\x20definition.\n\n\x0e\n\x07\x04\0\x03\
    \0\x02\0\x06\x12\x03%\x04\x0f\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03%\
    \x10\x1c\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03%\x1f\x20\n\x0e\n\x07\
    \x04\0\x03\0\x02\0\x08\x12\x03%!4\n\x0f\n\x08\x04\0\x03\0\x02\0\x08\x03\
    \x12\x03%\"3\n\x8a\x02\n\x06\x04\0\x03\0\x02\x01\x12\x03+\x04/\x1a\xfa\
    \x01\x20The\x20sampling\x20period\x20of\x20metric\x20data\x20points.\x20\
    For\x20metrics\x20which\x20are\x20written\n\x20periodically,\x20consecut\
    ive\x20data\x20points\x20are\x20stored\x20at\x20this\x20time\x20interval\
    ,\n\x20excluding\x20data\x20loss\x20due\x20to\x20errors.\x20Metrics\x20w\
    ith\x20a\x20higher\x20granularity\x20have\n\x20a\x20smaller\x20sampling\
    \x20period.\n\n\x0e\n\x07\x04\0\x03\0\x02\x01\x06\x12\x03+\x04\x1c\n\x0e\
    \n\x07\x04\0\x03\0\x02\x01\x01\x12\x03+\x1d*\n\x0e\n\x07\x04\0\x03\0\x02\
    \x01\x03\x12\x03+-.\n\xbc\x01\n\x06\x04\0\x03\0\x02\x02\x12\x030\x04.\
    \x1a\xac\x01\x20The\x20delay\x20of\x20data\x20points\x20caused\x20by\x20\
    ingestion.\x20Data\x20points\x20older\x20than\x20this\n\x20age\x20are\
    \x20guaranteed\x20to\x20be\x20ingested\x20and\x20available\x20to\x20be\
    \x20read,\x20excluding\n\x20data\x20loss\x20due\x20to\x20errors.\n\n\x0e\
    \n\x07\x04\0\x03\0\x02\x02\x06\x12\x030\x04\x1c\n\x0e\n\x07\x04\0\x03\0\
    \x02\x02\x01\x12\x030\x1d)\n\x0e\n\x07\x04\0\x03\0\x02\x02\x03\x12\x030,\
    -\nO\n\x04\x04\0\x04\0\x12\x044\x02D\x03\x1aA\x20The\x20kind\x20of\x20me\
    asurement.\x20It\x20describes\x20how\x20the\x20data\x20is\x20reported.\n\
    \n\x0c\n\x05\x04\0\x04\0\x01\x12\x034\x07\x11\n/\n\x06\x04\0\x04\0\x02\0\
    \x12\x036\x04\x20\x1a\x20\x20Do\x20not\x20use\x20this\x20default\x20valu\
    e.\n\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x036\x04\x1b\n\x0e\n\x07\x04\
    \0\x04\0\x02\0\x02\x12\x036\x1e\x1f\n9\n\x06\x04\0\x04\0\x02\x01\x12\x03\
    9\x04\x0e\x1a*\x20An\x20instantaneous\x20measurement\x20of\x20a\x20value\
    .\n\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x039\x04\t\n\x0e\n\x07\x04\0\
    \x04\0\x02\x01\x02\x12\x039\x0c\r\n>\n\x06\x04\0\x04\0\x02\x02\x12\x03<\
    \x04\x0e\x1a/\x20The\x20change\x20in\x20a\x20value\x20during\x20a\x20tim\
    e\x20interval.\n\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03<\x04\t\n\
    \x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03<\x0c\r\n\x8a\x02\n\x06\x04\0\
    \x04\0\x02\x03\x12\x03C\x04\x13\x1a\xfa\x01\x20A\x20value\x20accumulated\
    \x20over\x20a\x20time\x20interval.\x20\x20Cumulative\n\x20measurements\
    \x20in\x20a\x20time\x20series\x20should\x20have\x20the\x20same\x20start\
    \x20time\n\x20and\x20increasing\x20end\x20times,\x20until\x20an\x20event\
    \x20resets\x20the\x20cumulative\n\x20value\x20to\x20zero\x20and\x20sets\
    \x20a\x20new\x20start\x20time\x20for\x20the\x20following\n\x20points.\n\
    \n\x0e\n\x07\x04\0\x04\0\x02\x03\x01\x12\x03C\x04\x0e\n\x0e\n\x07\x04\0\
    \x04\0\x02\x03\x02\x12\x03C\x11\x12\n+\n\x04\x04\0\x04\x01\x12\x04G\x02^\
    \x03\x1a\x1d\x20The\x20value\x20type\x20of\x20a\x20metric.\n\n\x0c\n\x05\
    \x04\0\x04\x01\x01\x12\x03G\x07\x10\n/\n\x06\x04\0\x04\x01\x02\0\x12\x03\
    I\x04\x1f\x1a\x20\x20Do\x20not\x20use\x20this\x20default\x20value.\n\n\
    \x0e\n\x07\x04\0\x04\x01\x02\0\x01\x12\x03I\x04\x1a\n\x0e\n\x07\x04\0\
    \x04\x01\x02\0\x02\x12\x03I\x1d\x1e\ni\n\x06\x04\0\x04\x01\x02\x01\x12\
    \x03M\x04\r\x1aZ\x20The\x20value\x20is\x20a\x20boolean.\n\x20This\x20val\
    ue\x20type\x20can\x20be\x20used\x20only\x20if\x20the\x20metric\x20kind\
    \x20is\x20`GAUGE`.\n\n\x0e\n\x07\x04\0\x04\x01\x02\x01\x01\x12\x03M\x04\
    \x08\n\x0e\n\x07\x04\0\x04\x01\x02\x01\x02\x12\x03M\x0b\x0c\n6\n\x06\x04\
    \0\x04\x01\x02\x02\x12\x03P\x04\x0e\x1a'\x20The\x20value\x20is\x20a\x20s\
    igned\x2064-bit\x20integer.\n\n\x0e\n\x07\x04\0\x04\x01\x02\x02\x01\x12\
    \x03P\x04\t\n\x0e\n\x07\x04\0\x04\x01\x02\x02\x02\x12\x03P\x0c\r\nG\n\
    \x06\x04\0\x04\x01\x02\x03\x12\x03S\x04\x0f\x1a8\x20The\x20value\x20is\
    \x20a\x20double\x20precision\x20floating\x20point\x20number.\n\n\x0e\n\
    \x07\x04\0\x04\x01\x02\x03\x01\x12\x03S\x04\n\n\x0e\n\x07\x04\0\x04\x01\
    \x02\x03\x02\x12\x03S\r\x0e\nm\n\x06\x04\0\x04\x01\x02\x04\x12\x03W\x04\
    \x0f\x1a^\x20The\x20value\x20is\x20a\x20text\x20string.\n\x20This\x20val\
    ue\x20type\x20can\x20be\x20used\x20only\x20if\x20the\x20metric\x20kind\
    \x20is\x20`GAUGE`.\n\n\x0e\n\x07\x04\0\x04\x01\x02\x04\x01\x12\x03W\x04\
    \n\n\x0e\n\x07\x04\0\x04\x01\x02\x04\x02\x12\x03W\r\x0e\nJ\n\x06\x04\0\
    \x04\x01\x02\x05\x12\x03Z\x04\x15\x1a;\x20The\x20value\x20is\x20a\x20[`D\
    istribution`][google.api.Distribution].\n\n\x0e\n\x07\x04\0\x04\x01\x02\
    \x05\x01\x12\x03Z\x04\x10\n\x0e\n\x07\x04\0\x04\x01\x02\x05\x02\x12\x03Z\
    \x13\x14\n$\n\x06\x04\0\x04\x01\x02\x06\x12\x03]\x04\x0e\x1a\x15\x20The\
    \x20value\x20is\x20money.\n\n\x0e\n\x07\x04\0\x04\x01\x02\x06\x01\x12\
    \x03]\x04\t\n\x0e\n\x07\x04\0\x04\x01\x02\x06\x02\x12\x03]\x0c\r\n:\n\
    \x04\x04\0\x02\0\x12\x03a\x02\x12\x1a-\x20The\x20resource\x20name\x20of\
    \x20the\x20metric\x20descriptor.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03a\
    \x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03a\t\r\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03a\x10\x11\n\xab\x03\n\x04\x04\0\x02\x01\x12\x03k\x02\x12\
    \x1a\x9d\x03\x20The\x20metric\x20type,\x20including\x20its\x20DNS\x20nam\
    e\x20prefix.\x20The\x20type\x20is\x20not\n\x20URL-encoded.\x20\x20All\
    \x20user-defined\x20metric\x20types\x20have\x20the\x20DNS\x20name\n\x20`\
    custom.googleapis.com`\x20or\x20`external.googleapis.com`.\x20\x20Metric\
    \x20types\x20should\n\x20use\x20a\x20natural\x20hierarchical\x20grouping\
    .\x20For\x20example:\n\n\x20\x20\x20\x20\x20\"custom.googleapis.com/invo\
    ice/paid/amount\"\n\x20\x20\x20\x20\x20\"external.googleapis.com/prometh\
    eus/up\"\n\x20\x20\x20\x20\x20\"appengine.googleapis.com/http/server/res\
    ponse_latencies\"\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03k\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03k\t\r\n\x0c\n\x05\x04\0\x02\x01\x03\x12\
    \x03k\x10\x11\n\xd5\x02\n\x04\x04\0\x02\x02\x12\x03s\x02&\x1a\xc7\x02\
    \x20The\x20set\x20of\x20labels\x20that\x20can\x20be\x20used\x20to\x20des\
    cribe\x20a\x20specific\n\x20instance\x20of\x20this\x20metric\x20type.\
    \x20For\x20example,\x20the\n\x20`appengine.googleapis.com/http/server/re\
    sponse_latencies`\x20metric\n\x20type\x20has\x20a\x20label\x20for\x20the\
    \x20HTTP\x20response\x20code,\x20`response_code`,\x20so\n\x20you\x20can\
    \x20look\x20at\x20latencies\x20for\x20successful\x20responses\x20or\x20j\
    ust\n\x20for\x20responses\x20that\x20failed.\n\n\x0c\n\x05\x04\0\x02\x02\
    \x04\x12\x03s\x02\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03s\x0b\x1a\n\x0c\
    \n\x05\x04\0\x02\x02\x01\x12\x03s\x1b!\n\x0c\n\x05\x04\0\x02\x02\x03\x12\
    \x03s$%\n\xa6\x01\n\x04\x04\0\x02\x03\x12\x03w\x02\x1d\x1a\x98\x01\x20Wh\
    ether\x20the\x20metric\x20records\x20instantaneous\x20values,\x20changes\
    \x20to\x20a\x20value,\x20etc.\n\x20Some\x20combinations\x20of\x20`metric\
    _kind`\x20and\x20`value_type`\x20might\x20not\x20be\x20supported.\n\n\
    \x0c\n\x05\x04\0\x02\x03\x06\x12\x03w\x02\x0c\n\x0c\n\x05\x04\0\x02\x03\
    \x01\x12\x03w\r\x18\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03w\x1b\x1c\n\xa1\
    \x01\n\x04\x04\0\x02\x04\x12\x03{\x02\x1b\x1a\x93\x01\x20Whether\x20the\
    \x20measurement\x20is\x20an\x20integer,\x20a\x20floating-point\x20number\
    ,\x20etc.\n\x20Some\x20combinations\x20of\x20`metric_kind`\x20and\x20`va\
    lue_type`\x20might\x20not\x20be\x20supported.\n\n\x0c\n\x05\x04\0\x02\
    \x04\x06\x12\x03{\x02\x0b\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03{\x0c\x16\
    \n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03{\x19\x1a\n\xb3\x1e\n\x04\x04\0\
    \x02\x05\x12\x04\xe3\x01\x02\x12\x1a\xa4\x10\x20*\x20`Ki`\x20\x20\x20\
    \x20kibi\x20\x20\x20\x20(2^10)\n\x20*\x20`Mi`\x20\x20\x20\x20mebi\x20\
    \x20\x20\x20(2^20)\n\x20*\x20`Gi`\x20\x20\x20\x20gibi\x20\x20\x20\x20(2^\
    30)\n\x20*\x20`Ti`\x20\x20\x20\x20tebi\x20\x20\x20\x20(2^40)\n\x20*\x20`\
    Pi`\x20\x20\x20\x20pebi\x20\x20\x20\x20(2^50)\n\n\x20**Grammar**\n\n\x20\
    The\x20grammar\x20also\x20includes\x20these\x20connectors:\n\n\x20*\x20`\
    /`\x20\x20\x20\x20division\x20or\x20ratio\x20(as\x20an\x20infix\x20opera\
    tor).\x20For\x20examples,\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`kBy/\
    {email}`\x20or\x20`MiBy/10ms`\x20(although\x20you\x20should\x20almost\
    \x20never\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20have\x20`/s`\x20in\
    \x20a\x20metric\x20`unit`;\x20rates\x20should\x20always\x20be\x20compute\
    d\x20at\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20query\x20time\x20from\
    \x20the\x20underlying\x20cumulative\x20or\x20delta\x20value).\n\x20*\x20\
    `.`\x20\x20\x20\x20multiplication\x20or\x20composition\x20(as\x20an\x20i\
    nfix\x20operator).\x20For\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20examp\
    les,\x20`GBy.d`\x20or\x20`k{watt}.h`.\n\n\x20The\x20grammar\x20for\x20a\
    \x20unit\x20is\x20as\x20follows:\n\n\x20\x20\x20\x20\x20Expression\x20=\
    \x20Component\x20{\x20\".\"\x20Component\x20}\x20{\x20\"/\"\x20Component\
    \x20}\x20;\n\n\x20\x20\x20\x20\x20Component\x20=\x20(\x20[\x20PREFIX\x20\
    ]\x20UNIT\x20|\x20\"%\"\x20)\x20[\x20Annotation\x20]\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20Annotation\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\"1\"\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20;\n\n\x20\x20\x20\
    \x20\x20Annotation\x20=\x20\"{\"\x20NAME\x20\"}\"\x20;\n\n\x20Notes:\n\n\
    \x20*\x20`Annotation`\x20is\x20just\x20a\x20comment\x20if\x20it\x20follo\
    ws\x20a\x20`UNIT`.\x20If\x20the\x20annotation\n\x20\x20\x20\x20is\x20use\
    d\x20alone,\x20then\x20the\x20unit\x20is\x20equivalent\x20to\x20`1`.\x20\
    For\x20examples,\n\x20\x20\x20\x20`{request}/s\x20==\x201/s`,\x20`By{tra\
    nsmitted}/s\x20==\x20By/s`.\n\x20*\x20`NAME`\x20is\x20a\x20sequence\x20o\
    f\x20non-blank\x20printable\x20ASCII\x20characters\x20not\n\x20\x20\x20\
    \x20containing\x20`{`\x20or\x20`}`.\n\x20*\x20`1`\x20represents\x20a\x20\
    unitary\x20[dimensionless\n\x20\x20\x20\x20unit](https://en.wikipedia.or\
    g/wiki/Dimensionless_quantity)\x20of\x201,\x20such\n\x20\x20\x20\x20as\
    \x20in\x20`1/s`.\x20It\x20is\x20typically\x20used\x20when\x20none\x20of\
    \x20the\x20basic\x20units\x20are\n\x20\x20\x20\x20appropriate.\x20For\
    \x20example,\x20\"new\x20users\x20per\x20day\"\x20can\x20be\x20represent\
    ed\x20as\n\x20\x20\x20\x20`1/d`\x20or\x20`{new-users}/d`\x20(and\x20a\
    \x20metric\x20value\x20`5`\x20would\x20mean\x20\"5\x20new\n\x20\x20\x20\
    \x20users).\x20Alternatively,\x20\"thousands\x20of\x20page\x20views\x20p\
    er\x20day\"\x20would\x20be\n\x20\x20\x20\x20represented\x20as\x20`1000/d\
    `\x20or\x20`k1/d`\x20or\x20`k{page_views}/d`\x20(and\x20a\x20metric\n\
    \x20\x20\x20\x20value\x20of\x20`5.3`\x20would\x20mean\x20\"5300\x20page\
    \x20views\x20per\x20day\").\n\x20*\x20`%`\x20represents\x20dimensionless\
    \x20value\x20of\x201/100,\x20and\x20annotates\x20values\x20giving\n\x20\
    \x20\x20\x20a\x20percentage\x20(so\x20the\x20metric\x20values\x20are\x20\
    typically\x20in\x20the\x20range\x20of\x200..100,\n\x20\x20\x20\x20and\
    \x20a\x20metric\x20value\x20`3`\x20means\x20\"3\x20percent\").\n\x20*\
    \x20`10^2.%`\x20indicates\x20a\x20metric\x20contains\x20a\x20ratio,\x20t\
    ypically\x20in\x20the\x20range\n\x20\x20\x20\x200..1,\x20that\x20will\
    \x20be\x20multiplied\x20by\x20100\x20and\x20displayed\x20as\x20a\x20perc\
    entage\n\x20\x20\x20\x20(so\x20a\x20metric\x20value\x20`0.03`\x20means\
    \x20\"3\x20percent\").\n\n2\x9d\x0c\x20The\x20units\x20in\x20which\x20th\
    e\x20metric\x20value\x20is\x20reported.\x20It\x20is\x20only\x20applicabl\
    e\n\x20if\x20the\x20`value_type`\x20is\x20`INT64`,\x20`DOUBLE`,\x20or\
    \x20`DISTRIBUTION`.\x20The\x20`unit`\n\x20defines\x20the\x20representati\
    on\x20of\x20the\x20stored\x20metric\x20values.\n\n\x20Different\x20syste\
    ms\x20may\x20scale\x20the\x20values\x20to\x20be\x20more\x20easily\x20dis\
    played\x20(so\x20a\n\x20value\x20of\x20`0.02KBy`\x20_might_\x20be\x20dis\
    played\x20as\x20`20By`,\x20and\x20a\x20value\x20of\n\x20`3523KBy`\x20_mi\
    ght_\x20be\x20displayed\x20as\x20`3.5MBy`).\x20However,\x20if\x20the\x20\
    `unit`\x20is\n\x20`KBy`,\x20then\x20the\x20value\x20of\x20the\x20metric\
    \x20is\x20always\x20in\x20thousands\x20of\x20bytes,\x20no\n\x20matter\
    \x20how\x20it\x20may\x20be\x20displayed..\n\n\x20If\x20you\x20want\x20a\
    \x20custom\x20metric\x20to\x20record\x20the\x20exact\x20number\x20of\x20\
    CPU-seconds\x20used\n\x20by\x20a\x20job,\x20you\x20can\x20create\x20an\
    \x20`INT64\x20CUMULATIVE`\x20metric\x20whose\x20`unit`\x20is\n\x20`s{CPU\
    }`\x20(or\x20equivalently\x20`1s{CPU}`\x20or\x20just\x20`s`).\x20If\x20t\
    he\x20job\x20uses\x2012,005\n\x20CPU-seconds,\x20then\x20the\x20value\
    \x20is\x20written\x20as\x20`12005`.\n\n\x20Alternatively,\x20if\x20you\
    \x20want\x20a\x20custome\x20metric\x20to\x20record\x20data\x20in\x20a\
    \x20more\n\x20granular\x20way,\x20you\x20can\x20create\x20a\x20`DOUBLE\
    \x20CUMULATIVE`\x20metric\x20whose\x20`unit`\x20is\n\x20`ks{CPU}`,\x20an\
    d\x20then\x20write\x20the\x20value\x20`12.005`\x20(which\x20is\x20`12005\
    /1000`),\n\x20or\x20use\x20`Kis{CPU}`\x20and\x20write\x20`11.723`\x20(wh\
    ich\x20is\x20`12005/1024`).\n\n\x20The\x20supported\x20units\x20are\x20a\
    \x20subset\x20of\x20[The\x20Unified\x20Code\x20for\x20Units\x20of\n\x20M\
    easure](http://unitsofmeasure.org/ucum.html)\x20standard:\n\n\x20**Basic\
    \x20units\x20(UNIT)**\n\n\x20*\x20`bit`\x20\x20\x20bit\n\x20*\x20`By`\
    \x20\x20\x20\x20byte\n\x20*\x20`s`\x20\x20\x20\x20\x20second\n\x20*\x20`\
    min`\x20\x20\x20minute\n\x20*\x20`h`\x20\x20\x20\x20\x20hour\n\x20*\x20`\
    d`\x20\x20\x20\x20\x20day\n\n\x20**Prefixes\x20(PREFIX)**\n\n\x20*\x20`k\
    `\x20\x20\x20\x20\x20kilo\x20\x20\x20\x20(10^3)\n\x20*\x20`M`\x20\x20\
    \x20\x20\x20mega\x20\x20\x20\x20(10^6)\n\x20*\x20`G`\x20\x20\x20\x20\x20\
    giga\x20\x20\x20\x20(10^9)\n\x20*\x20`T`\x20\x20\x20\x20\x20tera\x20\x20\
    \x20\x20(10^12)\n\x20*\x20`P`\x20\x20\x20\x20\x20peta\x20\x20\x20\x20(10\
    ^15)\n\x20*\x20`E`\x20\x20\x20\x20\x20exa\x20\x20\x20\x20\x20(10^18)\n\
    \x20*\x20`Z`\x20\x20\x20\x20\x20zetta\x20\x20\x20(10^21)\n\x20*\x20`Y`\
    \x20\x20\x20\x20\x20yotta\x20\x20\x20(10^24)\n2\xdd\x01\x20*\x20`m`\x20\
    \x20\x20\x20\x20milli\x20\x20\x20(10^-3)\n\x20*\x20`u`\x20\x20\x20\x20\
    \x20micro\x20\x20\x20(10^-6)\n\x20*\x20`n`\x20\x20\x20\x20\x20nano\x20\
    \x20\x20\x20(10^-9)\n\x20*\x20`p`\x20\x20\x20\x20\x20pico\x20\x20\x20\
    \x20(10^-12)\n\x20*\x20`f`\x20\x20\x20\x20\x20femto\x20\x20\x20(10^-15)\
    \n\x20*\x20`a`\x20\x20\x20\x20\x20atto\x20\x20\x20\x20(10^-18)\n\x20*\
    \x20`z`\x20\x20\x20\x20\x20zepto\x20\x20\x20(10^-21)\n\x20*\x20`y`\x20\
    \x20\x20\x20\x20yocto\x20\x20\x20(10^-24)\n\n\r\n\x05\x04\0\x02\x05\x05\
    \x12\x04\xe3\x01\x02\x08\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xe3\x01\t\r\
    \n\r\n\x05\x04\0\x02\x05\x03\x12\x04\xe3\x01\x10\x11\nY\n\x04\x04\0\x02\
    \x06\x12\x04\xe6\x01\x02\x19\x1aK\x20A\x20detailed\x20description\x20of\
    \x20the\x20metric,\x20which\x20can\x20be\x20used\x20in\x20documentation.\
    \n\n\r\n\x05\x04\0\x02\x06\x05\x12\x04\xe6\x01\x02\x08\n\r\n\x05\x04\0\
    \x02\x06\x01\x12\x04\xe6\x01\t\x14\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\
    \xe6\x01\x17\x18\n\xa3\x02\n\x04\x04\0\x02\x07\x12\x04\xec\x01\x02\x1a\
    \x1a\x94\x02\x20A\x20concise\x20name\x20for\x20the\x20metric,\x20which\
    \x20can\x20be\x20displayed\x20in\x20user\x20interfaces.\n\x20Use\x20sent\
    ence\x20case\x20without\x20an\x20ending\x20period,\x20for\x20example\x20\
    \"Request\x20count\".\n\x20This\x20field\x20is\x20optional\x20but\x20it\
    \x20is\x20recommended\x20to\x20be\x20set\x20for\x20any\x20metrics\n\x20a\
    ssociated\x20with\x20user-visible\x20concepts,\x20such\x20as\x20Quota.\n\
    \n\r\n\x05\x04\0\x02\x07\x05\x12\x04\xec\x01\x02\x08\n\r\n\x05\x04\0\x02\
    \x07\x01\x12\x04\xec\x01\t\x15\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\xec\
    \x01\x18\x19\nR\n\x04\x04\0\x02\x08\x12\x04\xef\x01\x02)\x1aD\x20Optiona\
    l.\x20Metadata\x20which\x20can\x20be\x20used\x20to\x20guide\x20usage\x20\
    of\x20the\x20metric.\n\n\r\n\x05\x04\0\x02\x08\x06\x12\x04\xef\x01\x02\
    \x1a\n\r\n\x05\x04\0\x02\x08\x01\x12\x04\xef\x01\x1b#\n\r\n\x05\x04\0\
    \x02\x08\x03\x12\x04\xef\x01&(\nD\n\x04\x04\0\x02\t\x12\x04\xf2\x01\x02\
    \x20\x1a6\x20Optional.\x20The\x20launch\x20stage\x20of\x20the\x20metric\
    \x20definition.\n\n\r\n\x05\x04\0\x02\t\x06\x12\x04\xf2\x01\x02\r\n\r\n\
    \x05\x04\0\x02\t\x01\x12\x04\xf2\x01\x0e\x1a\n\r\n\x05\x04\0\x02\t\x03\
    \x12\x04\xf2\x01\x1d\x1f\n\x92\x01\n\x02\x04\x01\x12\x06\xf7\x01\0\xff\
    \x01\x01\x1a\x83\x01\x20A\x20specific\x20metric,\x20identified\x20by\x20\
    specifying\x20values\x20for\x20all\x20of\x20the\n\x20labels\x20of\x20a\
    \x20[`MetricDescriptor`][google.api.MetricDescriptor].\n\n\x0b\n\x03\x04\
    \x01\x01\x12\x04\xf7\x01\x08\x0e\n\xa4\x01\n\x04\x04\x01\x02\0\x12\x04\
    \xfa\x01\x02\x12\x1a\x95\x01\x20An\x20existing\x20metric\x20type,\x20see\
    \x20[google.api.MetricDescriptor][google.api.MetricDescriptor].\n\x20For\
    \x20example,\x20`custom.googleapis.com/invoice/paid/amount`.\n\n\r\n\x05\
    \x04\x01\x02\0\x05\x12\x04\xfa\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\xfa\x01\t\r\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xfa\x01\x10\x11\
    \n\x92\x01\n\x04\x04\x01\x02\x01\x12\x04\xfe\x01\x02!\x1a\x83\x01\x20The\
    \x20set\x20of\x20label\x20values\x20that\x20uniquely\x20identify\x20this\
    \x20metric.\x20All\n\x20labels\x20listed\x20in\x20the\x20`MetricDescript\
    or`\x20must\x20be\x20assigned\x20values.\n\n\r\n\x05\x04\x01\x02\x01\x06\
    \x12\x04\xfe\x01\x02\x15\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xfe\x01\
    \x16\x1c\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xfe\x01\x1f\x20b\x06proto\
    3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::label::file_descriptor().clone());
            deps.push(super::launch_stage::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(3);
            messages.push(MetricDescriptor::generated_message_descriptor_data());
            messages.push(Metric::generated_message_descriptor_data());
            messages.push(metric_descriptor::MetricDescriptorMetadata::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(metric_descriptor::MetricKind::generated_enum_descriptor_data());
            enums.push(metric_descriptor::ValueType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
