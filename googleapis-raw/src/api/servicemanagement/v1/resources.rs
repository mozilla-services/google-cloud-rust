// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/api/servicemanagement/v1/resources.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  The full representation of a Service that is managed by
///  Google Service Management.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.ManagedService)
pub struct ManagedService {
    // message fields
    ///  The name of the service. See the [overview](/service-management/overview)
    ///  for naming requirements.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ManagedService.service_name)
    pub service_name: ::std::string::String,
    ///  ID of the project that produces and owns this service.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ManagedService.producer_project_id)
    pub producer_project_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.ManagedService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ManagedService {
    fn default() -> &'a ManagedService {
        <ManagedService as ::protobuf::Message>::default_instance()
    }
}

impl ManagedService {
    pub fn new() -> ManagedService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_name",
            |m: &ManagedService| { &m.service_name },
            |m: &mut ManagedService| { &mut m.service_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "producer_project_id",
            |m: &ManagedService| { &m.producer_project_id },
            |m: &mut ManagedService| { &mut m.producer_project_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ManagedService>(
            "ManagedService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ManagedService {
    const NAME: &'static str = "ManagedService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.service_name = is.read_string()?;
                },
                26 => {
                    self.producer_project_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service_name);
        }
        if !self.producer_project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.producer_project_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.service_name.is_empty() {
            os.write_string(2, &self.service_name)?;
        }
        if !self.producer_project_id.is_empty() {
            os.write_string(3, &self.producer_project_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ManagedService {
        ManagedService::new()
    }

    fn clear(&mut self) {
        self.service_name.clear();
        self.producer_project_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ManagedService {
        static instance: ManagedService = ManagedService {
            service_name: ::std::string::String::new(),
            producer_project_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ManagedService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ManagedService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ManagedService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManagedService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The metadata associated with a long running operation resource.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.OperationMetadata)
pub struct OperationMetadata {
    // message fields
    ///  The full name of the resources that this operation is directly
    ///  associated with.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.OperationMetadata.resource_names)
    pub resource_names: ::std::vec::Vec<::std::string::String>,
    ///  Detailed status information for each step. The order is undetermined.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.OperationMetadata.steps)
    pub steps: ::std::vec::Vec<operation_metadata::Step>,
    ///  Percentage of completion of this operation, ranging from 0 to 100.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.OperationMetadata.progress_percentage)
    pub progress_percentage: i32,
    ///  The start time of the operation.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.OperationMetadata.start_time)
    pub start_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.OperationMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationMetadata {
    fn default() -> &'a OperationMetadata {
        <OperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl OperationMetadata {
    pub fn new() -> OperationMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resource_names",
            |m: &OperationMetadata| { &m.resource_names },
            |m: &mut OperationMetadata| { &mut m.resource_names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &OperationMetadata| { &m.steps },
            |m: &mut OperationMetadata| { &mut m.steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "progress_percentage",
            |m: &OperationMetadata| { &m.progress_percentage },
            |m: &mut OperationMetadata| { &mut m.progress_percentage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "start_time",
            |m: &OperationMetadata| { &m.start_time },
            |m: &mut OperationMetadata| { &mut m.start_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationMetadata>(
            "OperationMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationMetadata {
    const NAME: &'static str = "OperationMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resource_names.push(is.read_string()?);
                },
                18 => {
                    self.steps.push(is.read_message()?);
                },
                24 => {
                    self.progress_percentage = is.read_int32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resource_names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.progress_percentage != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.progress_percentage);
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resource_names {
            os.write_string(1, &v)?;
        };
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.progress_percentage != 0 {
            os.write_int32(3, self.progress_percentage)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationMetadata {
        OperationMetadata::new()
    }

    fn clear(&mut self) {
        self.resource_names.clear();
        self.steps.clear();
        self.progress_percentage = 0;
        self.start_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationMetadata {
        static instance: OperationMetadata = OperationMetadata {
            resource_names: ::std::vec::Vec::new(),
            steps: ::std::vec::Vec::new(),
            progress_percentage: 0,
            start_time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OperationMetadata`
pub mod operation_metadata {
    ///  Represents the status of one operation step.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.api.servicemanagement.v1.OperationMetadata.Step)
    pub struct Step {
        // message fields
        ///  The short description of the step.
        // @@protoc_insertion_point(field:google.api.servicemanagement.v1.OperationMetadata.Step.description)
        pub description: ::std::string::String,
        ///  The status code.
        // @@protoc_insertion_point(field:google.api.servicemanagement.v1.OperationMetadata.Step.status)
        pub status: ::protobuf::EnumOrUnknown<Status>,
        // special fields
        // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.OperationMetadata.Step.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Step {
        fn default() -> &'a Step {
            <Step as ::protobuf::Message>::default_instance()
        }
    }

    impl Step {
        pub fn new() -> Step {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "description",
                |m: &Step| { &m.description },
                |m: &mut Step| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "status",
                |m: &Step| { &m.status },
                |m: &mut Step| { &mut m.status },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Step>(
                "OperationMetadata.Step",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Step {
        const NAME: &'static str = "Step";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.description = is.read_string()?;
                    },
                    32 => {
                        self.status = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.description.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.description);
            }
            if self.status != ::protobuf::EnumOrUnknown::new(Status::STATUS_UNSPECIFIED) {
                my_size += ::protobuf::rt::int32_size(4, self.status.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.description.is_empty() {
                os.write_string(2, &self.description)?;
            }
            if self.status != ::protobuf::EnumOrUnknown::new(Status::STATUS_UNSPECIFIED) {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Step {
            Step::new()
        }

        fn clear(&mut self) {
            self.description.clear();
            self.status = ::protobuf::EnumOrUnknown::new(Status::STATUS_UNSPECIFIED);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Step {
            static instance: Step = Step {
                description: ::std::string::String::new(),
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Step {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("OperationMetadata.Step").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Step {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Step {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Code describes the status of the operation (or one of its steps).
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.servicemanagement.v1.OperationMetadata.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.OperationMetadata.Status.STATUS_UNSPECIFIED)
        STATUS_UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.OperationMetadata.Status.DONE)
        DONE = 1,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.OperationMetadata.Status.NOT_STARTED)
        NOT_STARTED = 2,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.OperationMetadata.Status.IN_PROGRESS)
        IN_PROGRESS = 3,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.OperationMetadata.Status.FAILED)
        FAILED = 4,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.OperationMetadata.Status.CANCELLED)
        CANCELLED = 5,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::STATUS_UNSPECIFIED),
                1 => ::std::option::Option::Some(Status::DONE),
                2 => ::std::option::Option::Some(Status::NOT_STARTED),
                3 => ::std::option::Option::Some(Status::IN_PROGRESS),
                4 => ::std::option::Option::Some(Status::FAILED),
                5 => ::std::option::Option::Some(Status::CANCELLED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::STATUS_UNSPECIFIED,
            Status::DONE,
            Status::NOT_STARTED,
            Status::IN_PROGRESS,
            Status::FAILED,
            Status::CANCELLED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OperationMetadata.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::STATUS_UNSPECIFIED
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("OperationMetadata.Status")
        }
    }
}

///  Represents a diagnostic message (error or warning)
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.Diagnostic)
pub struct Diagnostic {
    // message fields
    ///  File name and line number of the error or warning.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Diagnostic.location)
    pub location: ::std::string::String,
    ///  The kind of diagnostic information provided.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Diagnostic.kind)
    pub kind: ::protobuf::EnumOrUnknown<diagnostic::Kind>,
    ///  Message describing the error or warning.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Diagnostic.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.Diagnostic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Diagnostic {
    fn default() -> &'a Diagnostic {
        <Diagnostic as ::protobuf::Message>::default_instance()
    }
}

impl Diagnostic {
    pub fn new() -> Diagnostic {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "location",
            |m: &Diagnostic| { &m.location },
            |m: &mut Diagnostic| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kind",
            |m: &Diagnostic| { &m.kind },
            |m: &mut Diagnostic| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &Diagnostic| { &m.message },
            |m: &mut Diagnostic| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Diagnostic>(
            "Diagnostic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Diagnostic {
    const NAME: &'static str = "Diagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.location = is.read_string()?;
                },
                16 => {
                    self.kind = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.location);
        }
        if self.kind != ::protobuf::EnumOrUnknown::new(diagnostic::Kind::WARNING) {
            my_size += ::protobuf::rt::int32_size(2, self.kind.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.location.is_empty() {
            os.write_string(1, &self.location)?;
        }
        if self.kind != ::protobuf::EnumOrUnknown::new(diagnostic::Kind::WARNING) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.kind))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Diagnostic {
        Diagnostic::new()
    }

    fn clear(&mut self) {
        self.location.clear();
        self.kind = ::protobuf::EnumOrUnknown::new(diagnostic::Kind::WARNING);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Diagnostic {
        static instance: Diagnostic = Diagnostic {
            location: ::std::string::String::new(),
            kind: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Diagnostic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Diagnostic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Diagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Diagnostic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Diagnostic`
pub mod diagnostic {
    ///  The kind of diagnostic information possible.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.servicemanagement.v1.Diagnostic.Kind)
    pub enum Kind {
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Diagnostic.Kind.WARNING)
        WARNING = 0,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Diagnostic.Kind.ERROR)
        ERROR = 1,
    }

    impl ::protobuf::Enum for Kind {
        const NAME: &'static str = "Kind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::WARNING),
                1 => ::std::option::Option::Some(Kind::ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Kind] = &[
            Kind::WARNING,
            Kind::ERROR,
        ];
    }

    impl ::protobuf::EnumFull for Kind {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Diagnostic.Kind").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::WARNING
        }
    }

    impl Kind {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Kind>("Diagnostic.Kind")
        }
    }
}

///  Represents a source file which is used to generate the service configuration
///  defined by `google.api.Service`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.ConfigSource)
pub struct ConfigSource {
    // message fields
    ///  A unique ID for a specific instance of this message, typically assigned
    ///  by the client for tracking purpose. If empty, the server may choose to
    ///  generate one instead.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ConfigSource.id)
    pub id: ::std::string::String,
    ///  Set of source configuration files that are used to generate a service
    ///  configuration (`google.api.Service`).
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ConfigSource.files)
    pub files: ::std::vec::Vec<ConfigFile>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.ConfigSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigSource {
    fn default() -> &'a ConfigSource {
        <ConfigSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigSource {
    pub fn new() -> ConfigSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ConfigSource| { &m.id },
            |m: &mut ConfigSource| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &ConfigSource| { &m.files },
            |m: &mut ConfigSource| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigSource>(
            "ConfigSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigSource {
    const NAME: &'static str = "ConfigSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.files.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.id);
        }
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(5, &self.id)?;
        }
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigSource {
        ConfigSource::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigSource {
        static instance: ConfigSource = ConfigSource {
            id: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Generic specification of a source configuration file
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.ConfigFile)
pub struct ConfigFile {
    // message fields
    ///  The file name of the configuration file (full or relative path).
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ConfigFile.file_path)
    pub file_path: ::std::string::String,
    ///  The bytes that constitute the file.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ConfigFile.file_contents)
    pub file_contents: ::std::vec::Vec<u8>,
    ///  The type of configuration file this represents.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ConfigFile.file_type)
    pub file_type: ::protobuf::EnumOrUnknown<config_file::FileType>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.ConfigFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigFile {
    fn default() -> &'a ConfigFile {
        <ConfigFile as ::protobuf::Message>::default_instance()
    }
}

impl ConfigFile {
    pub fn new() -> ConfigFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_path",
            |m: &ConfigFile| { &m.file_path },
            |m: &mut ConfigFile| { &mut m.file_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_contents",
            |m: &ConfigFile| { &m.file_contents },
            |m: &mut ConfigFile| { &mut m.file_contents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_type",
            |m: &ConfigFile| { &m.file_type },
            |m: &mut ConfigFile| { &mut m.file_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigFile>(
            "ConfigFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigFile {
    const NAME: &'static str = "ConfigFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_path = is.read_string()?;
                },
                26 => {
                    self.file_contents = is.read_bytes()?;
                },
                32 => {
                    self.file_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_path);
        }
        if !self.file_contents.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.file_contents);
        }
        if self.file_type != ::protobuf::EnumOrUnknown::new(config_file::FileType::FILE_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.file_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file_path.is_empty() {
            os.write_string(1, &self.file_path)?;
        }
        if !self.file_contents.is_empty() {
            os.write_bytes(3, &self.file_contents)?;
        }
        if self.file_type != ::protobuf::EnumOrUnknown::new(config_file::FileType::FILE_TYPE_UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.file_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigFile {
        ConfigFile::new()
    }

    fn clear(&mut self) {
        self.file_path.clear();
        self.file_contents.clear();
        self.file_type = ::protobuf::EnumOrUnknown::new(config_file::FileType::FILE_TYPE_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigFile {
        static instance: ConfigFile = ConfigFile {
            file_path: ::std::string::String::new(),
            file_contents: ::std::vec::Vec::new(),
            file_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConfigFile`
pub mod config_file {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.servicemanagement.v1.ConfigFile.FileType)
    pub enum FileType {
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.ConfigFile.FileType.FILE_TYPE_UNSPECIFIED)
        FILE_TYPE_UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.ConfigFile.FileType.SERVICE_CONFIG_YAML)
        SERVICE_CONFIG_YAML = 1,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.ConfigFile.FileType.OPEN_API_JSON)
        OPEN_API_JSON = 2,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.ConfigFile.FileType.OPEN_API_YAML)
        OPEN_API_YAML = 3,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.ConfigFile.FileType.FILE_DESCRIPTOR_SET_PROTO)
        FILE_DESCRIPTOR_SET_PROTO = 4,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.ConfigFile.FileType.PROTO_FILE)
        PROTO_FILE = 6,
    }

    impl ::protobuf::Enum for FileType {
        const NAME: &'static str = "FileType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<FileType> {
            match value {
                0 => ::std::option::Option::Some(FileType::FILE_TYPE_UNSPECIFIED),
                1 => ::std::option::Option::Some(FileType::SERVICE_CONFIG_YAML),
                2 => ::std::option::Option::Some(FileType::OPEN_API_JSON),
                3 => ::std::option::Option::Some(FileType::OPEN_API_YAML),
                4 => ::std::option::Option::Some(FileType::FILE_DESCRIPTOR_SET_PROTO),
                6 => ::std::option::Option::Some(FileType::PROTO_FILE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [FileType] = &[
            FileType::FILE_TYPE_UNSPECIFIED,
            FileType::SERVICE_CONFIG_YAML,
            FileType::OPEN_API_JSON,
            FileType::OPEN_API_YAML,
            FileType::FILE_DESCRIPTOR_SET_PROTO,
            FileType::PROTO_FILE,
        ];
    }

    impl ::protobuf::EnumFull for FileType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ConfigFile.FileType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                FileType::FILE_TYPE_UNSPECIFIED => 0,
                FileType::SERVICE_CONFIG_YAML => 1,
                FileType::OPEN_API_JSON => 2,
                FileType::OPEN_API_YAML => 3,
                FileType::FILE_DESCRIPTOR_SET_PROTO => 4,
                FileType::PROTO_FILE => 5,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for FileType {
        fn default() -> Self {
            FileType::FILE_TYPE_UNSPECIFIED
        }
    }

    impl FileType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FileType>("ConfigFile.FileType")
        }
    }
}

///  Represents a service configuration with its name and id.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.ConfigRef)
pub struct ConfigRef {
    // message fields
    ///  Resource name of a service config. It must have the following
    ///  format: "services/{service name}/configs/{config id}".
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ConfigRef.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.ConfigRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigRef {
    fn default() -> &'a ConfigRef {
        <ConfigRef as ::protobuf::Message>::default_instance()
    }
}

impl ConfigRef {
    pub fn new() -> ConfigRef {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ConfigRef| { &m.name },
            |m: &mut ConfigRef| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigRef>(
            "ConfigRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigRef {
    const NAME: &'static str = "ConfigRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigRef {
        ConfigRef::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigRef {
        static instance: ConfigRef = ConfigRef {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Change report associated with a particular service configuration.
///
///  It contains a list of ConfigChanges based on the comparison between
///  two service configurations.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.ChangeReport)
pub struct ChangeReport {
    // message fields
    ///  List of changes between two service configurations.
    ///  The changes will be alphabetically sorted based on the identifier
    ///  of each change.
    ///  A ConfigChange identifier is a dot separated path to the configuration.
    ///  Example: visibility.rules[selector='LibraryService.CreateBook'].restriction
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.ChangeReport.config_changes)
    pub config_changes: ::std::vec::Vec<super::config_change::ConfigChange>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.ChangeReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChangeReport {
    fn default() -> &'a ChangeReport {
        <ChangeReport as ::protobuf::Message>::default_instance()
    }
}

impl ChangeReport {
    pub fn new() -> ChangeReport {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config_changes",
            |m: &ChangeReport| { &m.config_changes },
            |m: &mut ChangeReport| { &mut m.config_changes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangeReport>(
            "ChangeReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChangeReport {
    const NAME: &'static str = "ChangeReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.config_changes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.config_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.config_changes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChangeReport {
        ChangeReport::new()
    }

    fn clear(&mut self) {
        self.config_changes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChangeReport {
        static instance: ChangeReport = ChangeReport {
            config_changes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChangeReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChangeReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChangeReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A rollout resource that defines how service configuration versions are pushed
///  to control plane systems. Typically, you create a new version of the
///  service config, and then create a Rollout to push the service config.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.servicemanagement.v1.Rollout)
pub struct Rollout {
    // message fields
    ///  Optional unique identifier of this Rollout. Only lower case letters, digits
    ///   and '-' are allowed.
    ///
    ///  If not specified by client, the server will generate one. The generated id
    ///  will have the form of <date><revision number>, where "date" is the create
    ///  date in ISO 8601 format.  "revision number" is a monotonically increasing
    ///  positive number that is reset every day for each service.
    ///  An example of the generated rollout_id is '2016-02-16r1'
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Rollout.rollout_id)
    pub rollout_id: ::std::string::String,
    ///  Creation time of the rollout. Readonly.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Rollout.create_time)
    pub create_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The user who created the Rollout. Readonly.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Rollout.created_by)
    pub created_by: ::std::string::String,
    ///  The status of this rollout. Readonly. In case of a failed rollout,
    ///  the system will automatically rollback to the current Rollout
    ///  version. Readonly.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Rollout.status)
    pub status: ::protobuf::EnumOrUnknown<rollout::RolloutStatus>,
    ///  The name of the service associated with this Rollout.
    // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Rollout.service_name)
    pub service_name: ::std::string::String,
    // message oneof groups
    pub strategy: ::std::option::Option<rollout::Strategy>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.Rollout.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rollout {
    fn default() -> &'a Rollout {
        <Rollout as ::protobuf::Message>::default_instance()
    }
}

impl Rollout {
    pub fn new() -> Rollout {
        ::std::default::Default::default()
    }

    // .google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy traffic_percent_strategy = 5;

    pub fn traffic_percent_strategy(&self) -> &rollout::TrafficPercentStrategy {
        match self.strategy {
            ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(ref v)) => v,
            _ => <rollout::TrafficPercentStrategy as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_traffic_percent_strategy(&mut self) {
        self.strategy = ::std::option::Option::None;
    }

    pub fn has_traffic_percent_strategy(&self) -> bool {
        match self.strategy {
            ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_traffic_percent_strategy(&mut self, v: rollout::TrafficPercentStrategy) {
        self.strategy = ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_traffic_percent_strategy(&mut self) -> &mut rollout::TrafficPercentStrategy {
        if let ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(_)) = self.strategy {
        } else {
            self.strategy = ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(rollout::TrafficPercentStrategy::new()));
        }
        match self.strategy {
            ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_traffic_percent_strategy(&mut self) -> rollout::TrafficPercentStrategy {
        if self.has_traffic_percent_strategy() {
            match self.strategy.take() {
                ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(v)) => v,
                _ => panic!(),
            }
        } else {
            rollout::TrafficPercentStrategy::new()
        }
    }

    // .google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy delete_service_strategy = 200;

    pub fn delete_service_strategy(&self) -> &rollout::DeleteServiceStrategy {
        match self.strategy {
            ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(ref v)) => v,
            _ => <rollout::DeleteServiceStrategy as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_service_strategy(&mut self) {
        self.strategy = ::std::option::Option::None;
    }

    pub fn has_delete_service_strategy(&self) -> bool {
        match self.strategy {
            ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_service_strategy(&mut self, v: rollout::DeleteServiceStrategy) {
        self.strategy = ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_service_strategy(&mut self) -> &mut rollout::DeleteServiceStrategy {
        if let ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(_)) = self.strategy {
        } else {
            self.strategy = ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(rollout::DeleteServiceStrategy::new()));
        }
        match self.strategy {
            ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_service_strategy(&mut self) -> rollout::DeleteServiceStrategy {
        if self.has_delete_service_strategy() {
            match self.strategy.take() {
                ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(v)) => v,
                _ => panic!(),
            }
        } else {
            rollout::DeleteServiceStrategy::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rollout_id",
            |m: &Rollout| { &m.rollout_id },
            |m: &mut Rollout| { &mut m.rollout_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "create_time",
            |m: &Rollout| { &m.create_time },
            |m: &mut Rollout| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_by",
            |m: &Rollout| { &m.created_by },
            |m: &mut Rollout| { &mut m.created_by },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &Rollout| { &m.status },
            |m: &mut Rollout| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, rollout::TrafficPercentStrategy>(
            "traffic_percent_strategy",
            Rollout::has_traffic_percent_strategy,
            Rollout::traffic_percent_strategy,
            Rollout::mut_traffic_percent_strategy,
            Rollout::set_traffic_percent_strategy,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, rollout::DeleteServiceStrategy>(
            "delete_service_strategy",
            Rollout::has_delete_service_strategy,
            Rollout::delete_service_strategy,
            Rollout::mut_delete_service_strategy,
            Rollout::set_delete_service_strategy,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_name",
            |m: &Rollout| { &m.service_name },
            |m: &mut Rollout| { &mut m.service_name },
        ));
        oneofs.push(rollout::Strategy::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rollout>(
            "Rollout",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rollout {
    const NAME: &'static str = "Rollout";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rollout_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.create_time)?;
                },
                26 => {
                    self.created_by = is.read_string()?;
                },
                32 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.strategy = ::std::option::Option::Some(rollout::Strategy::TrafficPercentStrategy(is.read_message()?));
                },
                1602 => {
                    self.strategy = ::std::option::Option::Some(rollout::Strategy::DeleteServiceStrategy(is.read_message()?));
                },
                66 => {
                    self.service_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.rollout_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rollout_id);
        }
        if let Some(v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.created_by.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.created_by);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(rollout::RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.status.value());
        }
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.service_name);
        }
        if let ::std::option::Option::Some(ref v) = self.strategy {
            match v {
                &rollout::Strategy::TrafficPercentStrategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &rollout::Strategy::DeleteServiceStrategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.rollout_id.is_empty() {
            os.write_string(1, &self.rollout_id)?;
        }
        if let Some(v) = self.create_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.created_by.is_empty() {
            os.write_string(3, &self.created_by)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(rollout::RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.service_name.is_empty() {
            os.write_string(8, &self.service_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.strategy {
            match v {
                &rollout::Strategy::TrafficPercentStrategy(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &rollout::Strategy::DeleteServiceStrategy(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(200, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rollout {
        Rollout::new()
    }

    fn clear(&mut self) {
        self.rollout_id.clear();
        self.create_time.clear();
        self.created_by.clear();
        self.status = ::protobuf::EnumOrUnknown::new(rollout::RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED);
        self.strategy = ::std::option::Option::None;
        self.strategy = ::std::option::Option::None;
        self.service_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rollout {
        static instance: Rollout = Rollout {
            rollout_id: ::std::string::String::new(),
            create_time: ::protobuf::MessageField::none(),
            created_by: ::std::string::String::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            service_name: ::std::string::String::new(),
            strategy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rollout {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rollout").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rollout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rollout {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Rollout`
pub mod rollout {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.api.servicemanagement.v1.Rollout.strategy)
    pub enum Strategy {
        // @@protoc_insertion_point(oneof_field:google.api.servicemanagement.v1.Rollout.traffic_percent_strategy)
        TrafficPercentStrategy(TrafficPercentStrategy),
        // @@protoc_insertion_point(oneof_field:google.api.servicemanagement.v1.Rollout.delete_service_strategy)
        DeleteServiceStrategy(DeleteServiceStrategy),
    }

    impl ::protobuf::Oneof for Strategy {
    }

    impl ::protobuf::OneofFull for Strategy {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Rollout as ::protobuf::MessageFull>::descriptor().oneof_by_name("strategy").unwrap()).clone()
        }
    }

    impl Strategy {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Strategy>("strategy")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy)
    pub struct TrafficPercentStrategy {
        // message fields
        ///  Maps service configuration IDs to their corresponding traffic percentage.
        ///  Key is the service configuration ID, Value is the traffic percentage
        ///  which must be greater than 0.0 and the sum must equal to 100.0.
        // @@protoc_insertion_point(field:google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.percentages)
        pub percentages: ::std::collections::HashMap<::std::string::String, f64>,
        // special fields
        // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TrafficPercentStrategy {
        fn default() -> &'a TrafficPercentStrategy {
            <TrafficPercentStrategy as ::protobuf::Message>::default_instance()
        }
    }

    impl TrafficPercentStrategy {
        pub fn new() -> TrafficPercentStrategy {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
                "percentages",
                |m: &TrafficPercentStrategy| { &m.percentages },
                |m: &mut TrafficPercentStrategy| { &mut m.percentages },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrafficPercentStrategy>(
                "Rollout.TrafficPercentStrategy",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TrafficPercentStrategy {
        const NAME: &'static str = "TrafficPercentStrategy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                17 => value = is.read_double()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.percentages.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for (k, v) in &self.percentages {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for (k, v) in &self.percentages {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                os.write_raw_varint32(10)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_double(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TrafficPercentStrategy {
            TrafficPercentStrategy::new()
        }

        fn clear(&mut self) {
            self.percentages.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TrafficPercentStrategy {
            static instance: ::protobuf::rt::Lazy<TrafficPercentStrategy> = ::protobuf::rt::Lazy::new();
            instance.get(TrafficPercentStrategy::new)
        }
    }

    impl ::protobuf::MessageFull for TrafficPercentStrategy {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Rollout.TrafficPercentStrategy").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TrafficPercentStrategy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TrafficPercentStrategy {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Strategy used to delete a service. This strategy is a placeholder only
    ///  used by the system generated rollout to delete a service.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy)
    pub struct DeleteServiceStrategy {
        // special fields
        // @@protoc_insertion_point(special_field:google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeleteServiceStrategy {
        fn default() -> &'a DeleteServiceStrategy {
            <DeleteServiceStrategy as ::protobuf::Message>::default_instance()
        }
    }

    impl DeleteServiceStrategy {
        pub fn new() -> DeleteServiceStrategy {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteServiceStrategy>(
                "Rollout.DeleteServiceStrategy",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeleteServiceStrategy {
        const NAME: &'static str = "DeleteServiceStrategy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeleteServiceStrategy {
            DeleteServiceStrategy::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeleteServiceStrategy {
            static instance: DeleteServiceStrategy = DeleteServiceStrategy {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeleteServiceStrategy {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Rollout.DeleteServiceStrategy").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeleteServiceStrategy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeleteServiceStrategy {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Status of a Rollout.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.servicemanagement.v1.Rollout.RolloutStatus)
    pub enum RolloutStatus {
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Rollout.RolloutStatus.ROLLOUT_STATUS_UNSPECIFIED)
        ROLLOUT_STATUS_UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Rollout.RolloutStatus.IN_PROGRESS)
        IN_PROGRESS = 1,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Rollout.RolloutStatus.SUCCESS)
        SUCCESS = 2,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Rollout.RolloutStatus.CANCELLED)
        CANCELLED = 3,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Rollout.RolloutStatus.FAILED)
        FAILED = 4,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Rollout.RolloutStatus.PENDING)
        PENDING = 5,
        // @@protoc_insertion_point(enum_value:google.api.servicemanagement.v1.Rollout.RolloutStatus.FAILED_ROLLED_BACK)
        FAILED_ROLLED_BACK = 6,
    }

    impl ::protobuf::Enum for RolloutStatus {
        const NAME: &'static str = "RolloutStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<RolloutStatus> {
            match value {
                0 => ::std::option::Option::Some(RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED),
                1 => ::std::option::Option::Some(RolloutStatus::IN_PROGRESS),
                2 => ::std::option::Option::Some(RolloutStatus::SUCCESS),
                3 => ::std::option::Option::Some(RolloutStatus::CANCELLED),
                4 => ::std::option::Option::Some(RolloutStatus::FAILED),
                5 => ::std::option::Option::Some(RolloutStatus::PENDING),
                6 => ::std::option::Option::Some(RolloutStatus::FAILED_ROLLED_BACK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [RolloutStatus] = &[
            RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED,
            RolloutStatus::IN_PROGRESS,
            RolloutStatus::SUCCESS,
            RolloutStatus::CANCELLED,
            RolloutStatus::FAILED,
            RolloutStatus::PENDING,
            RolloutStatus::FAILED_ROLLED_BACK,
        ];
    }

    impl ::protobuf::EnumFull for RolloutStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Rollout.RolloutStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for RolloutStatus {
        fn default() -> Self {
            RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED
        }
    }

    impl RolloutStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RolloutStatus>("Rollout.RolloutStatus")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n/google/api/servicemanagement/v1/resources.proto\x12\x1fgoogle.api.ser\
    vicemanagement.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x1egoogle/api/\
    config_change.proto\x1a\x17google/api/metric.proto\x1a\x18google/api/ser\
    vice.proto\x1a#google/longrunning/operations.proto\x1a\x19google/protobu\
    f/any.proto\x1a\x20google/protobuf/field_mask.proto\x1a\x1cgoogle/protob\
    uf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x17google/rpc\
    /status.proto\"c\n\x0eManagedService\x12!\n\x0cservice_name\x18\x02\x20\
    \x01(\tR\x0bserviceName\x12.\n\x13producer_project_id\x18\x03\x20\x01(\t\
    R\x11producerProjectId\"\xdb\x03\n\x11OperationMetadata\x12%\n\x0eresour\
    ce_names\x18\x01\x20\x03(\tR\rresourceNames\x12M\n\x05steps\x18\x02\x20\
    \x03(\x0b27.google.api.servicemanagement.v1.OperationMetadata.StepR\x05s\
    teps\x12/\n\x13progress_percentage\x18\x03\x20\x01(\x05R\x12progressPerc\
    entage\x129\n\nstart_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.Time\
    stampR\tstartTime\x1a{\n\x04Step\x12\x20\n\x0bdescription\x18\x02\x20\
    \x01(\tR\x0bdescription\x12Q\n\x06status\x18\x04\x20\x01(\x0e29.google.a\
    pi.servicemanagement.v1.OperationMetadata.StatusR\x06status\"g\n\x06Stat\
    us\x12\x16\n\x12STATUS_UNSPECIFIED\x10\0\x12\x08\n\x04DONE\x10\x01\x12\
    \x0f\n\x0bNOT_STARTED\x10\x02\x12\x0f\n\x0bIN_PROGRESS\x10\x03\x12\n\n\
    \x06FAILED\x10\x04\x12\r\n\tCANCELLED\x10\x05\"\xa8\x01\n\nDiagnostic\
    \x12\x1a\n\x08location\x18\x01\x20\x01(\tR\x08location\x12D\n\x04kind\
    \x18\x02\x20\x01(\x0e20.google.api.servicemanagement.v1.Diagnostic.KindR\
    \x04kind\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\"\x1e\n\x04\
    Kind\x12\x0b\n\x07WARNING\x10\0\x12\t\n\x05ERROR\x10\x01\"a\n\x0cConfigS\
    ource\x12\x0e\n\x02id\x18\x05\x20\x01(\tR\x02id\x12A\n\x05files\x18\x02\
    \x20\x03(\x0b2+.google.api.servicemanagement.v1.ConfigFileR\x05files\"\
    \xb7\x02\n\nConfigFile\x12\x1b\n\tfile_path\x18\x01\x20\x01(\tR\x08fileP\
    ath\x12#\n\rfile_contents\x18\x03\x20\x01(\x0cR\x0cfileContents\x12Q\n\t\
    file_type\x18\x04\x20\x01(\x0e24.google.api.servicemanagement.v1.ConfigF\
    ile.FileTypeR\x08fileType\"\x93\x01\n\x08FileType\x12\x19\n\x15FILE_TYPE\
    _UNSPECIFIED\x10\0\x12\x17\n\x13SERVICE_CONFIG_YAML\x10\x01\x12\x11\n\rO\
    PEN_API_JSON\x10\x02\x12\x11\n\rOPEN_API_YAML\x10\x03\x12\x1d\n\x19FILE_\
    DESCRIPTOR_SET_PROTO\x10\x04\x12\x0e\n\nPROTO_FILE\x10\x06\"\x1f\n\tConf\
    igRef\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"O\n\x0cChangeReport\
    \x12?\n\x0econfig_changes\x18\x01\x20\x03(\x0b2\x18.google.api.ConfigCha\
    ngeR\rconfigChanges\"\xf3\x06\n\x07Rollout\x12\x1d\n\nrollout_id\x18\x01\
    \x20\x01(\tR\trolloutId\x12;\n\x0bcreate_time\x18\x02\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\ncreateTime\x12\x1d\n\ncreated_by\x18\x03\x20\
    \x01(\tR\tcreatedBy\x12N\n\x06status\x18\x04\x20\x01(\x0e26.google.api.s\
    ervicemanagement.v1.Rollout.RolloutStatusR\x06status\x12{\n\x18traffic_p\
    ercent_strategy\x18\x05\x20\x01(\x0b2?.google.api.servicemanagement.v1.R\
    ollout.TrafficPercentStrategyH\0R\x16trafficPercentStrategy\x12y\n\x17de\
    lete_service_strategy\x18\xc8\x01\x20\x01(\x0b2>.google.api.servicemanag\
    ement.v1.Rollout.DeleteServiceStrategyH\0R\x15deleteServiceStrategy\x12!\
    \n\x0cservice_name\x18\x08\x20\x01(\tR\x0bserviceName\x1a\xcc\x01\n\x16T\
    rafficPercentStrategy\x12r\n\x0bpercentages\x18\x01\x20\x03(\x0b2P.googl\
    e.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.PercentagesEnt\
    ryR\x0bpercentages\x1a>\n\x10PercentagesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05value:\
    \x028\x01\x1a\x17\n\x15DeleteServiceStrategy\"\x8d\x01\n\rRolloutStatus\
    \x12\x1e\n\x1aROLLOUT_STATUS_UNSPECIFIED\x10\0\x12\x0f\n\x0bIN_PROGRESS\
    \x10\x01\x12\x0b\n\x07SUCCESS\x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\n\n\
    \x06FAILED\x10\x04\x12\x0b\n\x07PENDING\x10\x05\x12\x16\n\x12FAILED_ROLL\
    ED_BACK\x10\x06B\n\n\x08strategyB\xd8\x01\n#com.google.api.servicemanage\
    ment.v1B\x0eResourcesProtoP\x01ZPgoogle.golang.org/genproto/googleapis/a\
    pi/servicemanagement/v1;servicemanagement\xa2\x02\x04GASM\xaa\x02!Google\
    .Cloud.ServiceManagement.V1\xca\x02!Google\\Cloud\\ServiceManagement\\V1\
    J\xcaO\n\x07\x12\x05\x0e\0\xaa\x02\x01\n\xbd\x04\n\x01\x0c\x12\x03\x0e\0\
    \x122\xb2\x04\x20Copyright\x202018\x20Google\x20Inc.\n\n\x20Licensed\x20\
    under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"Licens\
    e\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20c\
    ompliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20c\
    opy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apac\
    he.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicabl\
    e\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distri\
    buted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"A\
    S\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\
    \x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\
    \x02\x12\x03\x10\0(\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\
    \x03\x13\0(\n\t\n\x02\x03\x02\x12\x03\x14\0!\n\t\n\x02\x03\x03\x12\x03\
    \x15\0\"\n\t\n\x02\x03\x04\x12\x03\x16\0-\n\t\n\x02\x03\x05\x12\x03\x17\
    \0#\n\t\n\x02\x03\x06\x12\x03\x18\0*\n\t\n\x02\x03\x07\x12\x03\x19\0&\n\
    \t\n\x02\x03\x08\x12\x03\x1a\0)\n\t\n\x02\x03\t\x12\x03\x1b\0!\n\x08\n\
    \x01\x08\x12\x03\x1d\0>\n\t\n\x02\x08%\x12\x03\x1d\0>\n\x08\n\x01\x08\
    \x12\x03\x1e\0g\n\t\n\x02\x08\x0b\x12\x03\x1e\0g\n\x08\n\x01\x08\x12\x03\
    \x1f\0\"\n\t\n\x02\x08\n\x12\x03\x1f\0\"\n\x08\n\x01\x08\x12\x03\x20\0/\
    \n\t\n\x02\x08\x08\x12\x03\x20\0/\n\x08\n\x01\x08\x12\x03!\0<\n\t\n\x02\
    \x08\x01\x12\x03!\0<\n\x08\n\x01\x08\x12\x03\"\0\"\n\t\n\x02\x08$\x12\
    \x03\"\0\"\n\x08\n\x01\x08\x12\x03#\0>\n\t\n\x02\x08)\x12\x03#\0>\na\n\
    \x02\x04\0\x12\x04'\0.\x01\x1aU\x20The\x20full\x20representation\x20of\
    \x20a\x20Service\x20that\x20is\x20managed\x20by\n\x20Google\x20Service\
    \x20Management.\n\n\n\n\x03\x04\0\x01\x12\x03'\x08\x16\nr\n\x04\x04\0\
    \x02\0\x12\x03*\x02\x1a\x1ae\x20The\x20name\x20of\x20the\x20service.\x20\
    See\x20the\x20[overview](/service-management/overview)\n\x20for\x20namin\
    g\x20requirements.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03*\x02\x08\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03*\t\x15\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03*\x18\x19\nE\n\x04\x04\0\x02\x01\x12\x03-\x02!\x1a8\x20ID\x20of\x20t\
    he\x20project\x20that\x20produces\x20and\x20owns\x20this\x20service.\n\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03-\x02\x08\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03-\t\x1c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03-\x1f\x20\nM\n\
    \x02\x04\x01\x12\x041\0]\x01\x1aA\x20The\x20metadata\x20associated\x20wi\
    th\x20a\x20long\x20running\x20operation\x20resource.\n\n\n\n\x03\x04\x01\
    \x01\x12\x031\x08\x19\n<\n\x04\x04\x01\x03\0\x12\x043\x029\x03\x1a.\x20R\
    epresents\x20the\x20status\x20of\x20one\x20operation\x20step.\n\n\x0c\n\
    \x05\x04\x01\x03\0\x01\x12\x033\n\x0e\n3\n\x06\x04\x01\x03\0\x02\0\x12\
    \x035\x04\x1b\x1a$\x20The\x20short\x20description\x20of\x20the\x20step.\
    \n\n\x0e\n\x07\x04\x01\x03\0\x02\0\x05\x12\x035\x04\n\n\x0e\n\x07\x04\
    \x01\x03\0\x02\0\x01\x12\x035\x0b\x16\n\x0e\n\x07\x04\x01\x03\0\x02\0\
    \x03\x12\x035\x19\x1a\n!\n\x06\x04\x01\x03\0\x02\x01\x12\x038\x04\x16\
    \x1a\x12\x20The\x20status\x20code.\n\n\x0e\n\x07\x04\x01\x03\0\x02\x01\
    \x06\x12\x038\x04\n\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x038\x0b\
    \x11\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x03\x12\x038\x14\x15\nQ\n\x04\x04\
    \x01\x04\0\x12\x04<\x02O\x03\x1aC\x20Code\x20describes\x20the\x20status\
    \x20of\x20the\x20operation\x20(or\x20one\x20of\x20its\x20steps).\n\n\x0c\
    \n\x05\x04\x01\x04\0\x01\x12\x03<\x07\r\n!\n\x06\x04\x01\x04\0\x02\0\x12\
    \x03>\x04\x1b\x1a\x12\x20Unspecifed\x20code.\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\0\x01\x12\x03>\x04\x16\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03>\
    \x19\x1a\nD\n\x06\x04\x01\x04\0\x02\x01\x12\x03A\x04\r\x1a5\x20The\x20op\
    eration\x20or\x20step\x20has\x20completed\x20without\x20errors.\n\n\x0e\
    \n\x07\x04\x01\x04\0\x02\x01\x01\x12\x03A\x04\x08\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x01\x02\x12\x03A\x0b\x0c\n;\n\x06\x04\x01\x04\0\x02\x02\x12\
    \x03D\x04\x14\x1a,\x20The\x20operation\x20or\x20step\x20has\x20not\x20st\
    arted\x20yet.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x03D\x04\x0f\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x03D\x12\x13\n6\n\x06\x04\x01\
    \x04\0\x02\x03\x12\x03G\x04\x14\x1a'\x20The\x20operation\x20or\x20step\
    \x20is\x20in\x20progress.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\
    \x03G\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x03G\x12\x13\n\
    \x8c\x01\n\x06\x04\x01\x04\0\x02\x04\x12\x03K\x04\x0f\x1a}\x20The\x20ope\
    ration\x20or\x20step\x20has\x20completed\x20with\x20errors.\x20If\x20the\
    \x20operation\x20is\n\x20rollbackable,\x20the\x20rollback\x20completed\
    \x20with\x20errors\x20too.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x01\x12\
    \x03K\x04\n\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x02\x12\x03K\r\x0e\nG\n\
    \x06\x04\x01\x04\0\x02\x05\x12\x03N\x04\x12\x1a8\x20The\x20operation\x20\
    or\x20step\x20has\x20completed\x20with\x20cancellation.\n\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x05\x01\x12\x03N\x04\r\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x05\x02\x12\x03N\x10\x11\n_\n\x04\x04\x01\x02\0\x12\x03S\x02%\x1aR\x20T\
    he\x20full\x20name\x20of\x20the\x20resources\x20that\x20this\x20operatio\
    n\x20is\x20directly\n\x20associated\x20with.\n\n\x0c\n\x05\x04\x01\x02\0\
    \x04\x12\x03S\x02\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03S\x0b\x11\n\x0c\
    \n\x05\x04\x01\x02\0\x01\x12\x03S\x12\x20\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03S#$\nT\n\x04\x04\x01\x02\x01\x12\x03V\x02\x1a\x1aG\x20Detailed\
    \x20status\x20information\x20for\x20each\x20step.\x20The\x20order\x20is\
    \x20undetermined.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03V\x02\n\n\x0c\
    \n\x05\x04\x01\x02\x01\x06\x12\x03V\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03V\x10\x15\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03V\x18\x19\n\
    Q\n\x04\x04\x01\x02\x02\x12\x03Y\x02\x20\x1aD\x20Percentage\x20of\x20com\
    pletion\x20of\x20this\x20operation,\x20ranging\x20from\x200\x20to\x20100\
    .\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03Y\x02\x07\n\x0c\n\x05\x04\x01\
    \x02\x02\x01\x12\x03Y\x08\x1b\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03Y\
    \x1e\x1f\n/\n\x04\x04\x01\x02\x03\x12\x03\\\x02+\x1a\"\x20The\x20start\
    \x20time\x20of\x20the\x20operation.\n\n\x0c\n\x05\x04\x01\x02\x03\x06\
    \x12\x03\\\x02\x1b\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\\\x1c&\n\x0c\
    \n\x05\x04\x01\x02\x03\x03\x12\x03\\)*\n@\n\x02\x04\x02\x12\x04`\0r\x01\
    \x1a4\x20Represents\x20a\x20diagnostic\x20message\x20(error\x20or\x20war\
    ning)\n\n\n\n\x03\x04\x02\x01\x12\x03`\x08\x12\n<\n\x04\x04\x02\x04\0\
    \x12\x04b\x02h\x03\x1a.\x20The\x20kind\x20of\x20diagnostic\x20informatio\
    n\x20possible.\n\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03b\x07\x0b\n$\n\x06\
    \x04\x02\x04\0\x02\0\x12\x03d\x04\x10\x1a\x15\x20Warnings\x20and\x20erro\
    rs\n\n\x0e\n\x07\x04\x02\x04\0\x02\0\x01\x12\x03d\x04\x0b\n\x0e\n\x07\
    \x04\x02\x04\0\x02\0\x02\x12\x03d\x0e\x0f\n\x1c\n\x06\x04\x02\x04\0\x02\
    \x01\x12\x03g\x04\x0e\x1a\r\x20Only\x20errors\n\n\x0e\n\x07\x04\x02\x04\
    \0\x02\x01\x01\x12\x03g\x04\t\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x02\x12\
    \x03g\x0c\r\nA\n\x04\x04\x02\x02\0\x12\x03k\x02\x16\x1a4\x20File\x20name\
    \x20and\x20line\x20number\x20of\x20the\x20error\x20or\x20warning.\n\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03k\x02\x08\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03k\t\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03k\x14\x15\n;\n\
    \x04\x04\x02\x02\x01\x12\x03n\x02\x10\x1a.\x20The\x20kind\x20of\x20diagn\
    ostic\x20information\x20provided.\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\
    \x03n\x02\x06\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03n\x07\x0b\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03n\x0e\x0f\n7\n\x04\x04\x02\x02\x02\x12\
    \x03q\x02\x15\x1a*\x20Message\x20describing\x20the\x20error\x20or\x20war\
    ning.\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03q\x02\x08\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x03q\t\x10\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03q\
    \x13\x14\n|\n\x02\x04\x03\x12\x04v\0\x7f\x01\x1ap\x20Represents\x20a\x20\
    source\x20file\x20which\x20is\x20used\x20to\x20generate\x20the\x20servic\
    e\x20configuration\n\x20defined\x20by\x20`google.api.Service`.\n\n\n\n\
    \x03\x04\x03\x01\x12\x03v\x08\x14\n\xb6\x01\n\x04\x04\x03\x02\0\x12\x03z\
    \x02\x10\x1a\xa8\x01\x20A\x20unique\x20ID\x20for\x20a\x20specific\x20ins\
    tance\x20of\x20this\x20message,\x20typically\x20assigned\n\x20by\x20the\
    \x20client\x20for\x20tracking\x20purpose.\x20If\x20empty,\x20the\x20serv\
    er\x20may\x20choose\x20to\n\x20generate\x20one\x20instead.\n\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x03z\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03z\t\x0b\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03z\x0e\x0f\n{\n\x04\x04\
    \x03\x02\x01\x12\x03~\x02\x20\x1an\x20Set\x20of\x20source\x20configurati\
    on\x20files\x20that\x20are\x20used\x20to\x20generate\x20a\x20service\n\
    \x20configuration\x20(`google.api.Service`).\n\n\x0c\n\x05\x04\x03\x02\
    \x01\x04\x12\x03~\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03~\x0b\x15\
    \n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03~\x16\x1b\n\x0c\n\x05\x04\x03\
    \x02\x01\x03\x12\x03~\x1e\x1f\nD\n\x02\x04\x04\x12\x06\x82\x01\0\xa9\x01\
    \x01\x1a6\x20Generic\x20specification\x20of\x20a\x20source\x20configurat\
    ion\x20file\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x82\x01\x08\x12\n\x0e\n\
    \x04\x04\x04\x04\0\x12\x06\x83\x01\x02\x9f\x01\x03\n\r\n\x05\x04\x04\x04\
    \0\x01\x12\x04\x83\x01\x07\x0f\n$\n\x06\x04\x04\x04\0\x02\0\x12\x04\x85\
    \x01\x04\x1e\x1a\x14\x20Unknown\x20file\x20type.\n\n\x0f\n\x07\x04\x04\
    \x04\0\x02\0\x01\x12\x04\x85\x01\x04\x19\n\x0f\n\x07\x04\x04\x04\0\x02\0\
    \x02\x12\x04\x85\x01\x1c\x1d\n0\n\x06\x04\x04\x04\0\x02\x01\x12\x04\x88\
    \x01\x04\x1c\x1a\x20\x20YAML-specification\x20of\x20service.\n\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x01\x01\x12\x04\x88\x01\x04\x17\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x01\x02\x12\x04\x88\x01\x1a\x1b\n<\n\x06\x04\x04\x04\0\
    \x02\x02\x12\x04\x8b\x01\x04\x16\x1a,\x20OpenAPI\x20specification,\x20se\
    rialized\x20in\x20JSON.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x04\
    \x8b\x01\x04\x11\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x02\x12\x04\x8b\x01\
    \x14\x15\n<\n\x06\x04\x04\x04\0\x02\x03\x12\x04\x8e\x01\x04\x16\x1a,\x20\
    OpenAPI\x20specification,\x20serialized\x20in\x20YAML.\n\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x03\x01\x12\x04\x8e\x01\x04\x11\n\x0f\n\x07\x04\x04\x04\0\
    \x02\x03\x02\x12\x04\x8e\x01\x14\x15\n\xaa\x02\n\x06\x04\x04\x04\0\x02\
    \x04\x12\x04\x97\x01\x04\"\x1a\x99\x02\x20FileDescriptorSet,\x20generate\
    d\x20by\x20protoc.\n\n\x20To\x20generate,\x20use\x20protoc\x20with\x20im\
    ports\x20and\x20source\x20info\x20included.\n\x20For\x20an\x20example\
    \x20test.proto\x20file,\x20the\x20following\x20command\x20would\x20put\
    \x20the\x20value\n\x20in\x20a\x20new\x20file\x20named\x20out.pb.\n\n\x20\
    $protoc\x20--include_imports\x20--include_source_info\x20test.proto\x20-\
    o\x20out.pb\n\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x01\x12\x04\x97\x01\x04\
    \x1d\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x02\x12\x04\x97\x01\x20!\n\xd3\
    \x02\n\x06\x04\x04\x04\0\x02\x05\x12\x04\x9e\x01\x04\x13\x1a\xc2\x02\x20\
    Uncompiled\x20Proto\x20file.\x20Used\x20for\x20storage\x20and\x20display\
    \x20purposes\x20only,\n\x20currently\x20server-side\x20compilation\x20is\
    \x20not\x20supported.\x20Should\x20match\x20the\n\x20inputs\x20to\x20'pr\
    otoc'\x20command\x20used\x20to\x20generated\x20FILE_DESCRIPTOR_SET_PROTO\
    .\x20A\n\x20file\x20of\x20this\x20type\x20can\x20only\x20be\x20included\
    \x20if\x20at\x20least\x20one\x20file\x20of\x20type\n\x20FILE_DESCRIPTOR_\
    SET_PROTO\x20is\x20included.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x05\x01\x12\
    \x04\x9e\x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\x05\x02\x12\x04\x9e\
    \x01\x11\x12\nP\n\x04\x04\x04\x02\0\x12\x04\xa2\x01\x02\x17\x1aB\x20The\
    \x20file\x20name\x20of\x20the\x20configuration\x20file\x20(full\x20or\
    \x20relative\x20path).\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xa2\x01\x02\
    \x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xa2\x01\t\x12\n\r\n\x05\x04\x04\
    \x02\0\x03\x12\x04\xa2\x01\x15\x16\n3\n\x04\x04\x04\x02\x01\x12\x04\xa5\
    \x01\x02\x1a\x1a%\x20The\x20bytes\x20that\x20constitute\x20the\x20file.\
    \n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xa5\x01\x02\x07\n\r\n\x05\x04\
    \x04\x02\x01\x01\x12\x04\xa5\x01\x08\x15\n\r\n\x05\x04\x04\x02\x01\x03\
    \x12\x04\xa5\x01\x18\x19\n?\n\x04\x04\x04\x02\x02\x12\x04\xa8\x01\x02\
    \x19\x1a1\x20The\x20type\x20of\x20configuration\x20file\x20this\x20repre\
    sents.\n\n\r\n\x05\x04\x04\x02\x02\x06\x12\x04\xa8\x01\x02\n\n\r\n\x05\
    \x04\x04\x02\x02\x01\x12\x04\xa8\x01\x0b\x14\n\r\n\x05\x04\x04\x02\x02\
    \x03\x12\x04\xa8\x01\x17\x18\nH\n\x02\x04\x05\x12\x06\xac\x01\0\xb0\x01\
    \x01\x1a:\x20Represents\x20a\x20service\x20configuration\x20with\x20its\
    \x20name\x20and\x20id.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xac\x01\x08\x11\
    \n\x85\x01\n\x04\x04\x05\x02\0\x12\x04\xaf\x01\x02\x12\x1aw\x20Resource\
    \x20name\x20of\x20a\x20service\x20config.\x20It\x20must\x20have\x20the\
    \x20following\n\x20format:\x20\"services/{service\x20name}/configs/{conf\
    ig\x20id}\".\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xaf\x01\x02\x08\n\r\n\
    \x05\x04\x05\x02\0\x01\x12\x04\xaf\x01\t\r\n\r\n\x05\x04\x05\x02\0\x03\
    \x12\x04\xaf\x01\x10\x11\n\xb5\x01\n\x02\x04\x06\x12\x06\xb6\x01\0\xbd\
    \x01\x01\x1a\xa6\x01\x20Change\x20report\x20associated\x20with\x20a\x20p\
    articular\x20service\x20configuration.\n\n\x20It\x20contains\x20a\x20lis\
    t\x20of\x20ConfigChanges\x20based\x20on\x20the\x20comparison\x20between\
    \n\x20two\x20service\x20configurations.\n\n\x0b\n\x03\x04\x06\x01\x12\
    \x04\xb6\x01\x08\x14\n\xae\x02\n\x04\x04\x06\x02\0\x12\x04\xbc\x01\x026\
    \x1a\x9f\x02\x20List\x20of\x20changes\x20between\x20two\x20service\x20co\
    nfigurations.\n\x20The\x20changes\x20will\x20be\x20alphabetically\x20sor\
    ted\x20based\x20on\x20the\x20identifier\n\x20of\x20each\x20change.\n\x20\
    A\x20ConfigChange\x20identifier\x20is\x20a\x20dot\x20separated\x20path\
    \x20to\x20the\x20configuration.\n\x20Example:\x20visibility.rules[select\
    or='LibraryService.CreateBook'].restriction\n\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04\xbc\x01\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xbc\x01\
    \x0b\"\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xbc\x01#1\n\r\n\x05\x04\x06\
    \x02\0\x03\x12\x04\xbc\x0145\n\xeb\x01\n\x02\x04\x07\x12\x06\xc2\x01\0\
    \xaa\x02\x01\x1a\xdc\x01\x20A\x20rollout\x20resource\x20that\x20defines\
    \x20how\x20service\x20configuration\x20versions\x20are\x20pushed\n\x20to\
    \x20control\x20plane\x20systems.\x20Typically,\x20you\x20create\x20a\x20\
    new\x20version\x20of\x20the\n\x20service\x20config,\x20and\x20then\x20cr\
    eate\x20a\x20Rollout\x20to\x20push\x20the\x20service\x20config.\n\n\x0b\
    \n\x03\x04\x07\x01\x12\x04\xc2\x01\x08\x0f\n\xbd\x06\n\x04\x04\x07\x03\0\
    \x12\x06\xe1\x01\x02\xe6\x01\x03\x1a\xac\x06\x20Strategy\x20that\x20spec\
    ifies\x20how\x20clients\x20of\x20Google\x20Service\x20Controller\x20want\
    \x20to\n\x20send\x20traffic\x20to\x20use\x20different\x20config\x20versi\
    ons.\x20This\x20is\x20generally\n\x20used\x20by\x20API\x20proxy\x20to\
    \x20split\x20traffic\x20based\x20on\x20your\x20configured\x20precentage\
    \x20for\n\x20each\x20config\x20version.\n\n\x20One\x20example\x20of\x20h\
    ow\x20to\x20gradually\x20rollout\x20a\x20new\x20service\x20configuration\
    \x20using\n\x20this\n\x20strategy:\n\x20Day\x201\n\n\x20\x20\x20\x20\x20\
    Rollout\x20{\n\x20\x20\x20\x20\x20\x20\x20id:\x20\"example.googleapis.co\
    m/rollout_20160206\"\n\x20\x20\x20\x20\x20\x20\x20traffic_percent_strate\
    gy\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20percentages:\x20{\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\"example.googleapis.com/20160201\":\
    \x2070.00\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\"example.googlea\
    pis.com/20160206\":\x2030.00\n\x20\x20\x20\x20\x20\x20\x20\x20\x20}\n\
    \x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20}\n\n\x20Day\x202\n\n\
    \x20\x20\x20\x20\x20Rollout\x20{\n\x20\x20\x20\x20\x20\x20\x20id:\x20\"e\
    xample.googleapis.com/rollout_20160207\"\n\x20\x20\x20\x20\x20\x20\x20tr\
    affic_percent_strategy:\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20percen\
    tages:\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\"example.googl\
    eapis.com/20160206\":\x20100.00\n\x20\x20\x20\x20\x20\x20\x20\x20\x20}\n\
    \x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20}\n\n\r\n\x05\x04\x07\
    \x03\0\x01\x12\x04\xe1\x01\n\x20\n\xe3\x01\n\x06\x04\x07\x03\0\x02\0\x12\
    \x04\xe5\x01\x04(\x1a\xd2\x01\x20Maps\x20service\x20configuration\x20IDs\
    \x20to\x20their\x20corresponding\x20traffic\x20percentage.\n\x20Key\x20i\
    s\x20the\x20service\x20configuration\x20ID,\x20Value\x20is\x20the\x20tra\
    ffic\x20percentage\n\x20which\x20must\x20be\x20greater\x20than\x200.0\
    \x20and\x20the\x20sum\x20must\x20equal\x20to\x20100.0.\n\n\x0f\n\x07\x04\
    \x07\x03\0\x02\0\x06\x12\x04\xe5\x01\x04\x17\n\x0f\n\x07\x04\x07\x03\0\
    \x02\0\x01\x12\x04\xe5\x01\x18#\n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\x12\
    \x04\xe5\x01&'\n\x92\x01\n\x04\x04\x07\x03\x01\x12\x04\xea\x01\x02\"\x1a\
    \x83\x01\x20Strategy\x20used\x20to\x20delete\x20a\x20service.\x20This\
    \x20strategy\x20is\x20a\x20placeholder\x20only\n\x20used\x20by\x20the\
    \x20system\x20generated\x20rollout\x20to\x20delete\x20a\x20service.\n\n\
    \r\n\x05\x04\x07\x03\x01\x01\x12\x04\xea\x01\n\x1f\n&\n\x04\x04\x07\x04\
    \0\x12\x06\xed\x01\x02\x84\x02\x03\x1a\x16\x20Status\x20of\x20a\x20Rollo\
    ut.\n\n\r\n\x05\x04\x07\x04\0\x01\x12\x04\xed\x01\x07\x14\n&\n\x06\x04\
    \x07\x04\0\x02\0\x12\x04\xef\x01\x04#\x1a\x16\x20No\x20status\x20specifi\
    ed.\n\n\x0f\n\x07\x04\x07\x04\0\x02\0\x01\x12\x04\xef\x01\x04\x1e\n\x0f\
    \n\x07\x04\x07\x04\0\x02\0\x02\x12\x04\xef\x01!\"\n-\n\x06\x04\x07\x04\0\
    \x02\x01\x12\x04\xf2\x01\x04\x14\x1a\x1d\x20The\x20Rollout\x20is\x20in\
    \x20progress.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x01\x01\x12\x04\xf2\x01\
    \x04\x0f\n\x0f\n\x07\x04\x07\x04\0\x02\x01\x02\x12\x04\xf2\x01\x12\x13\n\
    9\n\x06\x04\x07\x04\0\x02\x02\x12\x04\xf5\x01\x04\x10\x1a)\x20The\x20Rol\
    lout\x20has\x20completed\x20successfully.\n\n\x0f\n\x07\x04\x07\x04\0\
    \x02\x02\x01\x12\x04\xf5\x01\x04\x0b\n\x0f\n\x07\x04\x07\x04\0\x02\x02\
    \x02\x12\x04\xf5\x01\x0e\x0f\n\x94\x01\n\x06\x04\x07\x04\0\x02\x03\x12\
    \x04\xf9\x01\x04\x12\x1a\x83\x01\x20The\x20Rollout\x20has\x20been\x20can\
    celled.\x20This\x20can\x20happen\x20if\x20you\x20have\x20overlapping\n\
    \x20Rollout\x20pushes,\x20and\x20the\x20previous\x20ones\x20will\x20be\
    \x20cancelled.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x03\x01\x12\x04\xf9\x01\
    \x04\r\n\x0f\n\x07\x04\x07\x04\0\x02\x03\x02\x12\x04\xf9\x01\x10\x11\nQ\
    \n\x06\x04\x07\x04\0\x02\x04\x12\x04\xfc\x01\x04\x0f\x1aA\x20The\x20Roll\
    out\x20has\x20failed\x20and\x20the\x20rollback\x20attempt\x20has\x20fail\
    ed\x20too.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x04\x01\x12\x04\xfc\x01\x04\n\
    \n\x0f\n\x07\x04\x07\x04\0\x02\x04\x02\x12\x04\xfc\x01\r\x0e\nO\n\x06\
    \x04\x07\x04\0\x02\x05\x12\x04\xff\x01\x04\x10\x1a?\x20The\x20Rollout\
    \x20has\x20not\x20started\x20yet\x20and\x20is\x20pending\x20for\x20execu\
    tion.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x05\x01\x12\x04\xff\x01\x04\x0b\n\
    \x0f\n\x07\x04\x07\x04\0\x02\x05\x02\x12\x04\xff\x01\x0e\x0f\n]\n\x06\
    \x04\x07\x04\0\x02\x06\x12\x04\x83\x02\x04\x1b\x1aM\x20The\x20Rollout\
    \x20has\x20failed\x20and\x20rolled\x20back\x20to\x20the\x20previous\x20s\
    uccessful\n\x20Rollout.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x06\x01\x12\x04\
    \x83\x02\x04\x16\n\x0f\n\x07\x04\x07\x04\0\x02\x06\x02\x12\x04\x83\x02\
    \x19\x1a\n\xcb\x03\n\x04\x04\x07\x02\0\x12\x04\x8e\x02\x02\x18\x1a\xbc\
    \x03\x20Optional\x20unique\x20identifier\x20of\x20this\x20Rollout.\x20On\
    ly\x20lower\x20case\x20letters,\x20digits\n\x20\x20and\x20'-'\x20are\x20\
    allowed.\n\n\x20If\x20not\x20specified\x20by\x20client,\x20the\x20server\
    \x20will\x20generate\x20one.\x20The\x20generated\x20id\n\x20will\x20have\
    \x20the\x20form\x20of\x20<date><revision\x20number>,\x20where\x20\"date\
    \"\x20is\x20the\x20create\n\x20date\x20in\x20ISO\x208601\x20format.\x20\
    \x20\"revision\x20number\"\x20is\x20a\x20monotonically\x20increasing\n\
    \x20positive\x20number\x20that\x20is\x20reset\x20every\x20day\x20for\x20\
    each\x20service.\n\x20An\x20example\x20of\x20the\x20generated\x20rollout\
    _id\x20is\x20'2016-02-16r1'\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x8e\
    \x02\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x8e\x02\t\x13\n\r\n\x05\
    \x04\x07\x02\0\x03\x12\x04\x8e\x02\x16\x17\n7\n\x04\x04\x07\x02\x01\x12\
    \x04\x91\x02\x02,\x1a)\x20Creation\x20time\x20of\x20the\x20rollout.\x20R\
    eadonly.\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\x91\x02\x02\x1b\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\x91\x02\x1c'\n\r\n\x05\x04\x07\x02\x01\
    \x03\x12\x04\x91\x02*+\n;\n\x04\x04\x07\x02\x02\x12\x04\x94\x02\x02\x18\
    \x1a-\x20The\x20user\x20who\x20created\x20the\x20Rollout.\x20Readonly.\n\
    \n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\x94\x02\x02\x08\n\r\n\x05\x04\x07\
    \x02\x02\x01\x12\x04\x94\x02\t\x13\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\
    \x94\x02\x16\x17\n\xa6\x01\n\x04\x04\x07\x02\x03\x12\x04\x99\x02\x02\x1b\
    \x1a\x97\x01\x20The\x20status\x20of\x20this\x20rollout.\x20Readonly.\x20\
    In\x20case\x20of\x20a\x20failed\x20rollout,\n\x20the\x20system\x20will\
    \x20automatically\x20rollback\x20to\x20the\x20current\x20Rollout\n\x20ve\
    rsion.\x20Readonly.\n\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\x99\x02\x02\
    \x0f\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\x99\x02\x10\x16\n\r\n\x05\x04\
    \x07\x02\x03\x03\x12\x04\x99\x02\x19\x1a\n\x8b\x01\n\x04\x04\x07\x08\0\
    \x12\x06\x9e\x02\x02\xa6\x02\x03\x1a{\x20Strategy\x20that\x20defines\x20\
    which\x20versions\x20of\x20service\x20configurations\x20should\x20be\n\
    \x20pushed\n\x20and\x20how\x20they\x20should\x20be\x20used\x20at\x20runt\
    ime.\n\n\r\n\x05\x04\x07\x08\0\x01\x12\x04\x9e\x02\x08\x10\nc\n\x04\x04\
    \x07\x02\x04\x12\x04\xa1\x02\x048\x1aU\x20Google\x20Service\x20Control\
    \x20selects\x20service\x20configurations\x20based\x20on\n\x20traffic\x20\
    percentage.\n\n\r\n\x05\x04\x07\x02\x04\x06\x12\x04\xa1\x02\x04\x1a\n\r\
    \n\x05\x04\x07\x02\x04\x01\x12\x04\xa1\x02\x1b3\n\r\n\x05\x04\x07\x02\
    \x04\x03\x12\x04\xa1\x0267\n_\n\x04\x04\x07\x02\x05\x12\x04\xa5\x02\x048\
    \x1aQ\x20The\x20strategy\x20associated\x20with\x20a\x20rollout\x20to\x20\
    delete\x20a\x20`ManagedService`.\n\x20Readonly.\n\n\r\n\x05\x04\x07\x02\
    \x05\x06\x12\x04\xa5\x02\x04\x19\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\
    \xa5\x02\x1a1\n\r\n\x05\x04\x07\x02\x05\x03\x12\x04\xa5\x0247\nE\n\x04\
    \x04\x07\x02\x06\x12\x04\xa9\x02\x02\x1a\x1a7\x20The\x20name\x20of\x20th\
    e\x20service\x20associated\x20with\x20this\x20Rollout.\n\n\r\n\x05\x04\
    \x07\x02\x06\x05\x12\x04\xa9\x02\x02\x08\n\r\n\x05\x04\x07\x02\x06\x01\
    \x12\x04\xa9\x02\t\x15\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\xa9\x02\x18\
    \x19b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(10);
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::config_change::file_descriptor().clone());
            deps.push(super::metric::file_descriptor().clone());
            deps.push(super::service::file_descriptor().clone());
            deps.push(super::operations::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::field_mask::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::struct_::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::status::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(11);
            messages.push(ManagedService::generated_message_descriptor_data());
            messages.push(OperationMetadata::generated_message_descriptor_data());
            messages.push(Diagnostic::generated_message_descriptor_data());
            messages.push(ConfigSource::generated_message_descriptor_data());
            messages.push(ConfigFile::generated_message_descriptor_data());
            messages.push(ConfigRef::generated_message_descriptor_data());
            messages.push(ChangeReport::generated_message_descriptor_data());
            messages.push(Rollout::generated_message_descriptor_data());
            messages.push(operation_metadata::Step::generated_message_descriptor_data());
            messages.push(rollout::TrafficPercentStrategy::generated_message_descriptor_data());
            messages.push(rollout::DeleteServiceStrategy::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(operation_metadata::Status::generated_enum_descriptor_data());
            enums.push(diagnostic::Kind::generated_enum_descriptor_data());
            enums.push(config_file::FileType::generated_enum_descriptor_data());
            enums.push(rollout::RolloutStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
