// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/api/quota.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:google.api.Quota)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Quota {
    // message fields
    ///  List of `QuotaLimit` definitions for the service.
    // @@protoc_insertion_point(field:google.api.Quota.limits)
    pub limits: ::std::vec::Vec<QuotaLimit>,
    ///  List of `MetricRule` definitions, each one mapping a selected method to one
    ///  or more metrics.
    // @@protoc_insertion_point(field:google.api.Quota.metric_rules)
    pub metric_rules: ::std::vec::Vec<MetricRule>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.Quota.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Quota {
    fn default() -> &'a Quota {
        <Quota as ::protobuf::Message>::default_instance()
    }
}

impl Quota {
    pub fn new() -> Quota {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "limits",
            |m: &Quota| { &m.limits },
            |m: &mut Quota| { &mut m.limits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metric_rules",
            |m: &Quota| { &m.metric_rules },
            |m: &mut Quota| { &mut m.metric_rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Quota>(
            "Quota",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Quota {
    const NAME: &'static str = "Quota";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.limits.push(is.read_message()?);
                },
                34 => {
                    self.metric_rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.metric_rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.limits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.metric_rules {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Quota {
        Quota::new()
    }

    fn clear(&mut self) {
        self.limits.clear();
        self.metric_rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Quota {
        static instance: Quota = Quota {
            limits: ::std::vec::Vec::new(),
            metric_rules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Quota {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Quota").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Quota {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Quota {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Bind API methods to metrics. Binding a method to a metric causes that
///  metric's configured quota behaviors to apply to the method call.
// @@protoc_insertion_point(message:google.api.MetricRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MetricRule {
    // message fields
    ///  Selects the methods to which this rule applies.
    ///
    ///  Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
    // @@protoc_insertion_point(field:google.api.MetricRule.selector)
    pub selector: ::std::string::String,
    ///  Metrics to update when the selected methods are called, and the associated
    ///  cost applied to each metric.
    ///
    ///  The key of the map is the metric name, and the values are the amount
    ///  increased for the metric against which the quota limits are defined.
    ///  The value must not be negative.
    // @@protoc_insertion_point(field:google.api.MetricRule.metric_costs)
    pub metric_costs: ::std::collections::HashMap<::std::string::String, i64>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.MetricRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricRule {
    fn default() -> &'a MetricRule {
        <MetricRule as ::protobuf::Message>::default_instance()
    }
}

impl MetricRule {
    pub fn new() -> MetricRule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "selector",
            |m: &MetricRule| { &m.selector },
            |m: &mut MetricRule| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metric_costs",
            |m: &MetricRule| { &m.metric_costs },
            |m: &mut MetricRule| { &mut m.metric_costs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricRule>(
            "MetricRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricRule {
    const NAME: &'static str = "MetricRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selector = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metric_costs.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.selector.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.selector);
        }
        for (k, v) in &self.metric_costs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.selector.is_empty() {
            os.write_string(1, &self.selector)?;
        }
        for (k, v) in &self.metric_costs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricRule {
        MetricRule::new()
    }

    fn clear(&mut self) {
        self.selector.clear();
        self.metric_costs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricRule {
        static instance: ::protobuf::rt::Lazy<MetricRule> = ::protobuf::rt::Lazy::new();
        instance.get(MetricRule::new)
    }
}

impl ::protobuf::MessageFull for MetricRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `QuotaLimit` defines a specific limit that applies over a specified duration
///  for a limit type. There can be at most one limit for a duration and limit
///  type combination defined within a `QuotaGroup`.
// @@protoc_insertion_point(message:google.api.QuotaLimit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuotaLimit {
    // message fields
    ///  Name of the quota limit.
    ///
    ///  The name must be provided, and it must be unique within the service. The
    ///  name can only include alphanumeric characters as well as '-'.
    ///
    ///  The maximum length of the limit name is 64 characters.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.name)
    pub name: ::std::string::String,
    ///  Optional. User-visible, extended description for this quota limit.
    ///  Should be used only when more context is needed to understand this limit
    ///  than provided by the limit's display name (see: `display_name`).
    // @@protoc_insertion_point(field:google.api.QuotaLimit.description)
    pub description: ::std::string::String,
    ///  Default number of tokens that can be consumed during the specified
    ///  duration. This is the number of tokens assigned when a client
    ///  application developer activates the service for his/her project.
    ///
    ///  Specifying a value of 0 will block all requests. This can be used if you
    ///  are provisioning quota to selected consumers and blocking others.
    ///  Similarly, a value of -1 will indicate an unlimited quota. No other
    ///  negative values are allowed.
    ///
    ///  Used by group-based quotas only.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.default_limit)
    pub default_limit: i64,
    ///  Maximum number of tokens that can be consumed during the specified
    ///  duration. Client application developers can override the default limit up
    ///  to this maximum. If specified, this value cannot be set to a value less
    ///  than the default limit. If not specified, it is set to the default limit.
    ///
    ///  To allow clients to apply overrides with no upper bound, set this to -1,
    ///  indicating unlimited maximum quota.
    ///
    ///  Used by group-based quotas only.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.max_limit)
    pub max_limit: i64,
    ///  Free tier value displayed in the Developers Console for this limit.
    ///  The free tier is the number of tokens that will be subtracted from the
    ///  billed amount when billing is enabled.
    ///  This field can only be set on a limit with duration "1d", in a billable
    ///  group; it is invalid on any other limit. If this field is not set, it
    ///  defaults to 0, indicating that there is no free tier for this service.
    ///
    ///  Used by group-based quotas only.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.free_tier)
    pub free_tier: i64,
    ///  Duration of this limit in textual notation. Example: "100s", "24h", "1d".
    ///  For duration longer than a day, only multiple of days is supported. We
    ///  support only "100s" and "1d" for now. Additional support will be added in
    ///  the future. "0" indicates indefinite duration.
    ///
    ///  Used by group-based quotas only.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.duration)
    pub duration: ::std::string::String,
    ///  The name of the metric this quota limit applies to. The quota limits with
    ///  the same metric will be checked together during runtime. The metric must be
    ///  defined within the service config.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.metric)
    pub metric: ::std::string::String,
    ///  Specify the unit of the quota limit. It uses the same syntax as
    ///  [Metric.unit][]. The supported unit kinds are determined by the quota
    ///  backend system.
    ///
    ///  Here are some examples:
    ///  * "1/min/{project}" for quota per minute per project.
    ///
    ///  Note: the order of unit components is insignificant.
    ///  The "1" at the beginning is required to follow the metric unit syntax.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.unit)
    pub unit: ::std::string::String,
    ///  Tiered limit values. You must specify this as a key:value pair, with an
    ///  integer value that is the maximum number of requests allowed for the
    ///  specified unit. Currently only STANDARD is supported.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.values)
    pub values: ::std::collections::HashMap<::std::string::String, i64>,
    ///  User-visible display name for this limit.
    ///  Optional. If not set, the UI will provide a default display name based on
    ///  the quota configuration. This field can be used to override the default
    ///  display name generated from the configuration.
    // @@protoc_insertion_point(field:google.api.QuotaLimit.display_name)
    pub display_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.QuotaLimit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuotaLimit {
    fn default() -> &'a QuotaLimit {
        <QuotaLimit as ::protobuf::Message>::default_instance()
    }
}

impl QuotaLimit {
    pub fn new() -> QuotaLimit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &QuotaLimit| { &m.name },
            |m: &mut QuotaLimit| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &QuotaLimit| { &m.description },
            |m: &mut QuotaLimit| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "default_limit",
            |m: &QuotaLimit| { &m.default_limit },
            |m: &mut QuotaLimit| { &mut m.default_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_limit",
            |m: &QuotaLimit| { &m.max_limit },
            |m: &mut QuotaLimit| { &mut m.max_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "free_tier",
            |m: &QuotaLimit| { &m.free_tier },
            |m: &mut QuotaLimit| { &mut m.free_tier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &QuotaLimit| { &m.duration },
            |m: &mut QuotaLimit| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metric",
            |m: &QuotaLimit| { &m.metric },
            |m: &mut QuotaLimit| { &mut m.metric },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit",
            |m: &QuotaLimit| { &m.unit },
            |m: &mut QuotaLimit| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "values",
            |m: &QuotaLimit| { &m.values },
            |m: &mut QuotaLimit| { &mut m.values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display_name",
            |m: &QuotaLimit| { &m.display_name },
            |m: &mut QuotaLimit| { &mut m.display_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuotaLimit>(
            "QuotaLimit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuotaLimit {
    const NAME: &'static str = "QuotaLimit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                24 => {
                    self.default_limit = is.read_int64()?;
                },
                32 => {
                    self.max_limit = is.read_int64()?;
                },
                56 => {
                    self.free_tier = is.read_int64()?;
                },
                42 => {
                    self.duration = is.read_string()?;
                },
                66 => {
                    self.metric = is.read_string()?;
                },
                74 => {
                    self.unit = is.read_string()?;
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.values.insert(key, value);
                },
                98 => {
                    self.display_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.default_limit != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.default_limit);
        }
        if self.max_limit != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.max_limit);
        }
        if self.free_tier != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.free_tier);
        }
        if !self.duration.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.duration);
        }
        if !self.metric.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.metric);
        }
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.unit);
        }
        for (k, v) in &self.values {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.display_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.default_limit != 0 {
            os.write_int64(3, self.default_limit)?;
        }
        if self.max_limit != 0 {
            os.write_int64(4, self.max_limit)?;
        }
        if self.free_tier != 0 {
            os.write_int64(7, self.free_tier)?;
        }
        if !self.duration.is_empty() {
            os.write_string(5, &self.duration)?;
        }
        if !self.metric.is_empty() {
            os.write_string(8, &self.metric)?;
        }
        if !self.unit.is_empty() {
            os.write_string(9, &self.unit)?;
        }
        for (k, v) in &self.values {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        if !self.display_name.is_empty() {
            os.write_string(12, &self.display_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuotaLimit {
        QuotaLimit::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.default_limit = 0;
        self.max_limit = 0;
        self.free_tier = 0;
        self.duration.clear();
        self.metric.clear();
        self.unit.clear();
        self.values.clear();
        self.display_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuotaLimit {
        static instance: ::protobuf::rt::Lazy<QuotaLimit> = ::protobuf::rt::Lazy::new();
        instance.get(QuotaLimit::new)
    }
}

impl ::protobuf::MessageFull for QuotaLimit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuotaLimit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuotaLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuotaLimit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16google/api/quota.proto\x12\ngoogle.api\"r\n\x05Quota\x12.\n\x06lim\
    its\x18\x03\x20\x03(\x0b2\x16.google.api.QuotaLimitR\x06limits\x129\n\
    \x0cmetric_rules\x18\x04\x20\x03(\x0b2\x16.google.api.MetricRuleR\x0bmet\
    ricRules\"\xb4\x01\n\nMetricRule\x12\x1a\n\x08selector\x18\x01\x20\x01(\
    \tR\x08selector\x12J\n\x0cmetric_costs\x18\x02\x20\x03(\x0b2'.google.api\
    .MetricRule.MetricCostsEntryR\x0bmetricCosts\x1a>\n\x10MetricCostsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x03R\x05value:\x028\x01\"\x83\x03\n\nQuotaLimit\x12\x12\n\x04n\
    ame\x18\x06\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01\
    (\tR\x0bdescription\x12#\n\rdefault_limit\x18\x03\x20\x01(\x03R\x0cdefau\
    ltLimit\x12\x1b\n\tmax_limit\x18\x04\x20\x01(\x03R\x08maxLimit\x12\x1b\n\
    \tfree_tier\x18\x07\x20\x01(\x03R\x08freeTier\x12\x1a\n\x08duration\x18\
    \x05\x20\x01(\tR\x08duration\x12\x16\n\x06metric\x18\x08\x20\x01(\tR\x06\
    metric\x12\x12\n\x04unit\x18\t\x20\x01(\tR\x04unit\x12:\n\x06values\x18\
    \n\x20\x03(\x0b2\".google.api.QuotaLimit.ValuesEntryR\x06values\x12!\n\
    \x0cdisplay_name\x18\x0c\x20\x01(\tR\x0bdisplayName\x1a9\n\x0bValuesEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x03R\x05value:\x028\x01Bl\n\x0ecom.google.apiB\nQuotaProtoP\
    \x01ZEgoogle.golang.org/genproto/googleapis/api/serviceconfig;servicecon\
    fig\xa2\x02\x04GAPIJ\xf48\n\x07\x12\x05\x0f\0\xba\x01\x01\n\xbe\x04\n\
    \x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20LL\
    C.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202\
    .0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20fil\
    e\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20m\
    ay\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x13\n\x08\n\x01\x08\x12\
    \x03\x13\0\\\n\t\n\x02\x08\x0b\x12\x03\x13\0\\\n\x08\n\x01\x08\x12\x03\
    \x14\0\"\n\t\n\x02\x08\n\x12\x03\x14\0\"\n\x08\n\x01\x08\x12\x03\x15\0+\
    \n\t\n\x02\x08\x08\x12\x03\x15\0+\n\x08\n\x01\x08\x12\x03\x16\0'\n\t\n\
    \x02\x08\x01\x12\x03\x16\0'\n\x08\n\x01\x08\x12\x03\x17\0\"\n\t\n\x02\
    \x08$\x12\x03\x17\0\"\n\x87\r\n\x02\x04\0\x12\x04L\0S\x01\x1a\xfa\x0c\
    \x20Quota\x20configuration\x20helps\x20to\x20achieve\x20fairness\x20and\
    \x20budgeting\x20in\x20service\n\x20usage.\n\n\x20The\x20metric\x20based\
    \x20quota\x20configuration\x20works\x20this\x20way:\n\x20-\x20The\x20ser\
    vice\x20configuration\x20defines\x20a\x20set\x20of\x20metrics.\n\x20-\
    \x20For\x20API\x20calls,\x20the\x20quota.metric_rules\x20maps\x20methods\
    \x20to\x20metrics\x20with\n\x20\x20\x20corresponding\x20costs.\n\x20-\
    \x20The\x20quota.limits\x20defines\x20limits\x20on\x20the\x20metrics,\
    \x20which\x20will\x20be\x20used\x20for\n\x20\x20\x20quota\x20checks\x20a\
    t\x20runtime.\n\n\x20An\x20example\x20quota\x20configuration\x20in\x20ya\
    ml\x20format:\n\n\x20\x20\x20\x20quota:\n\x20\x20\x20\x20\x20\x20limits:\
    \n\n\x20\x20\x20\x20\x20\x20-\x20name:\x20apiWriteQpsPerProject\n\x20\
    \x20\x20\x20\x20\x20\x20\x20metric:\x20library.googleapis.com/write_call\
    s\n\x20\x20\x20\x20\x20\x20\x20\x20unit:\x20\"1/min/{project}\"\x20\x20#\
    \x20rate\x20limit\x20for\x20consumer\x20projects\n\x20\x20\x20\x20\x20\
    \x20\x20\x20values:\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20STANDARD:\
    \x2010000\n\n\n\x20\x20\x20\x20\x20\x20#\x20The\x20metric\x20rules\x20bi\
    nd\x20all\x20methods\x20to\x20the\x20read_calls\x20metric,\n\x20\x20\x20\
    \x20\x20\x20#\x20except\x20for\x20the\x20UpdateBook\x20and\x20DeleteBook\
    \x20methods.\x20These\x20two\x20methods\n\x20\x20\x20\x20\x20\x20#\x20ar\
    e\x20mapped\x20to\x20the\x20write_calls\x20metric,\x20with\x20the\x20Upd\
    ateBook\x20method\n\x20\x20\x20\x20\x20\x20#\x20consuming\x20at\x20twice\
    \x20rate\x20as\x20the\x20DeleteBook\x20method.\n\x20\x20\x20\x20\x20\x20\
    metric_rules:\n\x20\x20\x20\x20\x20\x20-\x20selector:\x20\"*\"\n\x20\x20\
    \x20\x20\x20\x20\x20\x20metric_costs:\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20library.googleapis.com/read_calls:\x201\n\x20\x20\x20\x20\x20\
    \x20-\x20selector:\x20google.example.library.v1.LibraryService.UpdateBoo\
    k\n\x20\x20\x20\x20\x20\x20\x20\x20metric_costs:\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20library.googleapis.com/write_calls:\x202\n\x20\x20\
    \x20\x20\x20\x20-\x20selector:\x20google.example.library.v1.LibraryServi\
    ce.DeleteBook\n\x20\x20\x20\x20\x20\x20\x20\x20metric_costs:\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20library.googleapis.com/write_calls:\x201\
    \n\n\x20\x20Corresponding\x20Metric\x20definition:\n\n\x20\x20\x20\x20\
    \x20\x20metrics:\n\x20\x20\x20\x20\x20\x20-\x20name:\x20library.googleap\
    is.com/read_calls\n\x20\x20\x20\x20\x20\x20\x20\x20display_name:\x20Read\
    \x20requests\n\x20\x20\x20\x20\x20\x20\x20\x20metric_kind:\x20DELTA\n\
    \x20\x20\x20\x20\x20\x20\x20\x20value_type:\x20INT64\n\n\x20\x20\x20\x20\
    \x20\x20-\x20name:\x20library.googleapis.com/write_calls\n\x20\x20\x20\
    \x20\x20\x20\x20\x20display_name:\x20Write\x20requests\n\x20\x20\x20\x20\
    \x20\x20\x20\x20metric_kind:\x20DELTA\n\x20\x20\x20\x20\x20\x20\x20\x20v\
    alue_type:\x20INT64\n\n\n\n\n\n\x03\x04\0\x01\x12\x03L\x08\r\n@\n\x04\
    \x04\0\x02\0\x12\x03N\x02!\x1a3\x20List\x20of\x20`QuotaLimit`\x20definit\
    ions\x20for\x20the\x20service.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03N\
    \x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03N\x0b\x15\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03N\x16\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03N\x1f\x20\
    \nl\n\x04\x04\0\x02\x01\x12\x03R\x02'\x1a_\x20List\x20of\x20`MetricRule`\
    \x20definitions,\x20each\x20one\x20mapping\x20a\x20selected\x20method\
    \x20to\x20one\n\x20or\x20more\x20metrics.\n\n\x0c\n\x05\x04\0\x02\x01\
    \x04\x12\x03R\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03R\x0b\x15\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03R\x16\"\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03R%&\n\x96\x01\n\x02\x04\x01\x12\x04W\0d\x01\x1a\x89\x01\x20Bind\
    \x20API\x20methods\x20to\x20metrics.\x20Binding\x20a\x20method\x20to\x20\
    a\x20metric\x20causes\x20that\n\x20metric's\x20configured\x20quota\x20be\
    haviors\x20to\x20apply\x20to\x20the\x20method\x20call.\n\n\n\n\x03\x04\
    \x01\x01\x12\x03W\x08\x12\n\x90\x01\n\x04\x04\x01\x02\0\x12\x03[\x02\x16\
    \x1a\x82\x01\x20Selects\x20the\x20methods\x20to\x20which\x20this\x20rule\
    \x20applies.\n\n\x20Refer\x20to\x20[selector][google.api.DocumentationRu\
    le.selector]\x20for\x20syntax\x20details.\n\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03[\t\x11\n\x0c\
    \n\x05\x04\x01\x02\0\x03\x12\x03[\x14\x15\n\xa6\x02\n\x04\x04\x01\x02\
    \x01\x12\x03c\x02&\x1a\x98\x02\x20Metrics\x20to\x20update\x20when\x20the\
    \x20selected\x20methods\x20are\x20called,\x20and\x20the\x20associated\n\
    \x20cost\x20applied\x20to\x20each\x20metric.\n\n\x20The\x20key\x20of\x20\
    the\x20map\x20is\x20the\x20metric\x20name,\x20and\x20the\x20values\x20ar\
    e\x20the\x20amount\n\x20increased\x20for\x20the\x20metric\x20against\x20\
    which\x20the\x20quota\x20limits\x20are\x20defined.\n\x20The\x20value\x20\
    must\x20not\x20be\x20negative.\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\
    c\x02\x14\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03c\x15!\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x03c$%\n\xd8\x01\n\x02\x04\x02\x12\x05i\0\xba\x01\
    \x01\x1a\xca\x01\x20`QuotaLimit`\x20defines\x20a\x20specific\x20limit\
    \x20that\x20applies\x20over\x20a\x20specified\x20duration\n\x20for\x20a\
    \x20limit\x20type.\x20There\x20can\x20be\x20at\x20most\x20one\x20limit\
    \x20for\x20a\x20duration\x20and\x20limit\n\x20type\x20combination\x20def\
    ined\x20within\x20a\x20`QuotaGroup`.\n\n\n\n\x03\x04\x02\x01\x12\x03i\
    \x08\x12\n\xeb\x01\n\x04\x04\x02\x02\0\x12\x03p\x02\x12\x1a\xdd\x01\x20N\
    ame\x20of\x20the\x20quota\x20limit.\n\n\x20The\x20name\x20must\x20be\x20\
    provided,\x20and\x20it\x20must\x20be\x20unique\x20within\x20the\x20servi\
    ce.\x20The\n\x20name\x20can\x20only\x20include\x20alphanumeric\x20charac\
    ters\x20as\x20well\x20as\x20'-'.\n\n\x20The\x20maximum\x20length\x20of\
    \x20the\x20limit\x20name\x20is\x2064\x20characters.\n\n\x0c\n\x05\x04\
    \x02\x02\0\x05\x12\x03p\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03p\t\
    \r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03p\x10\x11\n\xde\x01\n\x04\x04\
    \x02\x02\x01\x12\x03u\x02\x19\x1a\xd0\x01\x20Optional.\x20User-visible,\
    \x20extended\x20description\x20for\x20this\x20quota\x20limit.\n\x20Shoul\
    d\x20be\x20used\x20only\x20when\x20more\x20context\x20is\x20needed\x20to\
    \x20understand\x20this\x20limit\n\x20than\x20provided\x20by\x20the\x20li\
    mit's\x20display\x20name\x20(see:\x20`display_name`).\n\n\x0c\n\x05\x04\
    \x02\x02\x01\x05\x12\x03u\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x03u\t\x14\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03u\x17\x18\n\xe8\x03\n\
    \x04\x04\x02\x02\x02\x12\x04\x81\x01\x02\x1a\x1a\xd9\x03\x20Default\x20n\
    umber\x20of\x20tokens\x20that\x20can\x20be\x20consumed\x20during\x20the\
    \x20specified\n\x20duration.\x20This\x20is\x20the\x20number\x20of\x20tok\
    ens\x20assigned\x20when\x20a\x20client\n\x20application\x20developer\x20\
    activates\x20the\x20service\x20for\x20his/her\x20project.\n\n\x20Specify\
    ing\x20a\x20value\x20of\x200\x20will\x20block\x20all\x20requests.\x20Thi\
    s\x20can\x20be\x20used\x20if\x20you\n\x20are\x20provisioning\x20quota\
    \x20to\x20selected\x20consumers\x20and\x20blocking\x20others.\n\x20Simil\
    arly,\x20a\x20value\x20of\x20-1\x20will\x20indicate\x20an\x20unlimited\
    \x20quota.\x20No\x20other\n\x20negative\x20values\x20are\x20allowed.\n\n\
    \x20Used\x20by\x20group-based\x20quotas\x20only.\n\n\r\n\x05\x04\x02\x02\
    \x02\x05\x12\x04\x81\x01\x02\x07\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\
    \x81\x01\x08\x15\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\x81\x01\x18\x19\n\
    \xc5\x03\n\x04\x04\x02\x02\x03\x12\x04\x8c\x01\x02\x16\x1a\xb6\x03\x20Ma\
    ximum\x20number\x20of\x20tokens\x20that\x20can\x20be\x20consumed\x20duri\
    ng\x20the\x20specified\n\x20duration.\x20Client\x20application\x20develo\
    pers\x20can\x20override\x20the\x20default\x20limit\x20up\n\x20to\x20this\
    \x20maximum.\x20If\x20specified,\x20this\x20value\x20cannot\x20be\x20set\
    \x20to\x20a\x20value\x20less\n\x20than\x20the\x20default\x20limit.\x20If\
    \x20not\x20specified,\x20it\x20is\x20set\x20to\x20the\x20default\x20limi\
    t.\n\n\x20To\x20allow\x20clients\x20to\x20apply\x20overrides\x20with\x20\
    no\x20upper\x20bound,\x20set\x20this\x20to\x20-1,\n\x20indicating\x20unl\
    imited\x20maximum\x20quota.\n\n\x20Used\x20by\x20group-based\x20quotas\
    \x20only.\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\x8c\x01\x02\x07\n\r\n\
    \x05\x04\x02\x02\x03\x01\x12\x04\x8c\x01\x08\x11\n\r\n\x05\x04\x02\x02\
    \x03\x03\x12\x04\x8c\x01\x14\x15\n\xbf\x03\n\x04\x04\x02\x02\x04\x12\x04\
    \x96\x01\x02\x16\x1a\xb0\x03\x20Free\x20tier\x20value\x20displayed\x20in\
    \x20the\x20Developers\x20Console\x20for\x20this\x20limit.\n\x20The\x20fr\
    ee\x20tier\x20is\x20the\x20number\x20of\x20tokens\x20that\x20will\x20be\
    \x20subtracted\x20from\x20the\n\x20billed\x20amount\x20when\x20billing\
    \x20is\x20enabled.\n\x20This\x20field\x20can\x20only\x20be\x20set\x20on\
    \x20a\x20limit\x20with\x20duration\x20\"1d\",\x20in\x20a\x20billable\n\
    \x20group;\x20it\x20is\x20invalid\x20on\x20any\x20other\x20limit.\x20If\
    \x20this\x20field\x20is\x20not\x20set,\x20it\n\x20defaults\x20to\x200,\
    \x20indicating\x20that\x20there\x20is\x20no\x20free\x20tier\x20for\x20th\
    is\x20service.\n\n\x20Used\x20by\x20group-based\x20quotas\x20only.\n\n\r\
    \n\x05\x04\x02\x02\x04\x05\x12\x04\x96\x01\x02\x07\n\r\n\x05\x04\x02\x02\
    \x04\x01\x12\x04\x96\x01\x08\x11\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\
    \x96\x01\x14\x15\n\xc0\x02\n\x04\x04\x02\x02\x05\x12\x04\x9e\x01\x02\x16\
    \x1a\xb1\x02\x20Duration\x20of\x20this\x20limit\x20in\x20textual\x20nota\
    tion.\x20Example:\x20\"100s\",\x20\"24h\",\x20\"1d\".\n\x20For\x20durati\
    on\x20longer\x20than\x20a\x20day,\x20only\x20multiple\x20of\x20days\x20i\
    s\x20supported.\x20We\n\x20support\x20only\x20\"100s\"\x20and\x20\"1d\"\
    \x20for\x20now.\x20Additional\x20support\x20will\x20be\x20added\x20in\n\
    \x20the\x20future.\x20\"0\"\x20indicates\x20indefinite\x20duration.\n\n\
    \x20Used\x20by\x20group-based\x20quotas\x20only.\n\n\r\n\x05\x04\x02\x02\
    \x05\x05\x12\x04\x9e\x01\x02\x08\n\r\n\x05\x04\x02\x02\x05\x01\x12\x04\
    \x9e\x01\t\x11\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\x9e\x01\x14\x15\n\
    \xcb\x01\n\x04\x04\x02\x02\x06\x12\x04\xa3\x01\x02\x14\x1a\xbc\x01\x20Th\
    e\x20name\x20of\x20the\x20metric\x20this\x20quota\x20limit\x20applies\
    \x20to.\x20The\x20quota\x20limits\x20with\n\x20the\x20same\x20metric\x20\
    will\x20be\x20checked\x20together\x20during\x20runtime.\x20The\x20metric\
    \x20must\x20be\n\x20defined\x20within\x20the\x20service\x20config.\n\n\r\
    \n\x05\x04\x02\x02\x06\x05\x12\x04\xa3\x01\x02\x08\n\r\n\x05\x04\x02\x02\
    \x06\x01\x12\x04\xa3\x01\t\x0f\n\r\n\x05\x04\x02\x02\x06\x03\x12\x04\xa3\
    \x01\x12\x13\n\xf8\x02\n\x04\x04\x02\x02\x07\x12\x04\xae\x01\x02\x12\x1a\
    \xe9\x02\x20Specify\x20the\x20unit\x20of\x20the\x20quota\x20limit.\x20It\
    \x20uses\x20the\x20same\x20syntax\x20as\n\x20[Metric.unit][].\x20The\x20\
    supported\x20unit\x20kinds\x20are\x20determined\x20by\x20the\x20quota\n\
    \x20backend\x20system.\n\n\x20Here\x20are\x20some\x20examples:\n\x20*\
    \x20\"1/min/{project}\"\x20for\x20quota\x20per\x20minute\x20per\x20proje\
    ct.\n\n\x20Note:\x20the\x20order\x20of\x20unit\x20components\x20is\x20in\
    significant.\n\x20The\x20\"1\"\x20at\x20the\x20beginning\x20is\x20requir\
    ed\x20to\x20follow\x20the\x20metric\x20unit\x20syntax.\n\n\r\n\x05\x04\
    \x02\x02\x07\x05\x12\x04\xae\x01\x02\x08\n\r\n\x05\x04\x02\x02\x07\x01\
    \x12\x04\xae\x01\t\r\n\r\n\x05\x04\x02\x02\x07\x03\x12\x04\xae\x01\x10\
    \x11\n\xd5\x01\n\x04\x04\x02\x02\x08\x12\x04\xb3\x01\x02!\x1a\xc6\x01\
    \x20Tiered\x20limit\x20values.\x20You\x20must\x20specify\x20this\x20as\
    \x20a\x20key:value\x20pair,\x20with\x20an\n\x20integer\x20value\x20that\
    \x20is\x20the\x20maximum\x20number\x20of\x20requests\x20allowed\x20for\
    \x20the\n\x20specified\x20unit.\x20Currently\x20only\x20STANDARD\x20is\
    \x20supported.\n\n\r\n\x05\x04\x02\x02\x08\x06\x12\x04\xb3\x01\x02\x14\n\
    \r\n\x05\x04\x02\x02\x08\x01\x12\x04\xb3\x01\x15\x1b\n\r\n\x05\x04\x02\
    \x02\x08\x03\x12\x04\xb3\x01\x1e\x20\n\xfe\x01\n\x04\x04\x02\x02\t\x12\
    \x04\xb9\x01\x02\x1b\x1a\xef\x01\x20User-visible\x20display\x20name\x20f\
    or\x20this\x20limit.\n\x20Optional.\x20If\x20not\x20set,\x20the\x20UI\
    \x20will\x20provide\x20a\x20default\x20display\x20name\x20based\x20on\n\
    \x20the\x20quota\x20configuration.\x20This\x20field\x20can\x20be\x20used\
    \x20to\x20override\x20the\x20default\n\x20display\x20name\x20generated\
    \x20from\x20the\x20configuration.\n\n\r\n\x05\x04\x02\x02\t\x05\x12\x04\
    \xb9\x01\x02\x08\n\r\n\x05\x04\x02\x02\t\x01\x12\x04\xb9\x01\t\x15\n\r\n\
    \x05\x04\x02\x02\t\x03\x12\x04\xb9\x01\x18\x1ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(3);
            messages.push(Quota::generated_message_descriptor_data());
            messages.push(MetricRule::generated_message_descriptor_data());
            messages.push(QuotaLimit::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
