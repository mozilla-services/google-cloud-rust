// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/api/servicecontrol/v1/quota_controller.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

///  Request message for the AllocateQuota method.
// @@protoc_insertion_point(message:google.api.servicecontrol.v1.AllocateQuotaRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocateQuotaRequest {
    // message fields
    ///  Name of the service as specified in the service configuration. For example,
    ///  `"pubsub.googleapis.com"`.
    ///
    ///  See [google.api.Service][google.api.Service] for the definition of a
    ///  service name.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.AllocateQuotaRequest.service_name)
    pub service_name: ::std::string::String,
    ///  Operation that describes the quota allocation.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.AllocateQuotaRequest.allocate_operation)
    pub allocate_operation: ::protobuf::MessageField<QuotaOperation>,
    ///  Specifies which version of service configuration should be used to process
    ///  the request. If unspecified or no matching version can be found, the latest
    ///  one will be used.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.AllocateQuotaRequest.service_config_id)
    pub service_config_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicecontrol.v1.AllocateQuotaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocateQuotaRequest {
    fn default() -> &'a AllocateQuotaRequest {
        <AllocateQuotaRequest as ::protobuf::Message>::default_instance()
    }
}

impl AllocateQuotaRequest {
    pub fn new() -> AllocateQuotaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_name",
            |m: &AllocateQuotaRequest| { &m.service_name },
            |m: &mut AllocateQuotaRequest| { &mut m.service_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QuotaOperation>(
            "allocate_operation",
            |m: &AllocateQuotaRequest| { &m.allocate_operation },
            |m: &mut AllocateQuotaRequest| { &mut m.allocate_operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_config_id",
            |m: &AllocateQuotaRequest| { &m.service_config_id },
            |m: &mut AllocateQuotaRequest| { &mut m.service_config_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocateQuotaRequest>(
            "AllocateQuotaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocateQuotaRequest {
    const NAME: &'static str = "AllocateQuotaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.service_name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allocate_operation)?;
                },
                34 => {
                    self.service_config_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(v) = self.allocate_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.service_config_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.service_config_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(v) = self.allocate_operation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.service_config_id.is_empty() {
            os.write_string(4, &self.service_config_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocateQuotaRequest {
        AllocateQuotaRequest::new()
    }

    fn clear(&mut self) {
        self.service_name.clear();
        self.allocate_operation.clear();
        self.service_config_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocateQuotaRequest {
        static instance: AllocateQuotaRequest = AllocateQuotaRequest {
            service_name: ::std::string::String::new(),
            allocate_operation: ::protobuf::MessageField::none(),
            service_config_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocateQuotaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocateQuotaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocateQuotaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocateQuotaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Represents information regarding a quota operation.
// @@protoc_insertion_point(message:google.api.servicecontrol.v1.QuotaOperation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuotaOperation {
    // message fields
    ///  Identity of the operation. This is expected to be unique within the scope
    ///  of the service that generated the operation, and guarantees idempotency in
    ///  case of retries.
    ///
    ///  UUID version 4 is recommended, though not required. In scenarios where an
    ///  operation is computed from existing information and an idempotent id is
    ///  desirable for deduplication purpose, UUID version 5 is recommended. See
    ///  RFC 4122 for details.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaOperation.operation_id)
    pub operation_id: ::std::string::String,
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaOperation.method_name)
    pub method_name: ::std::string::String,
    ///  Identity of the consumer for whom this quota operation is being performed.
    ///
    ///  This can be in one of the following formats:
    ///    project:<project_id>,
    ///    project_number:<project_number>,
    ///    api_key:<api_key>.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaOperation.consumer_id)
    pub consumer_id: ::std::string::String,
    ///  Labels describing the operation.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaOperation.labels)
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  Represents information about this operation. Each MetricValueSet
    ///  corresponds to a metric defined in the service configuration.
    ///  The data type used in the MetricValueSet must agree with
    ///  the data type specified in the metric definition.
    ///
    ///  Within a single operation, it is not allowed to have more than one
    ///  MetricValue instances that have the same metric names and identical
    ///  label value combinations. If a request has such duplicated MetricValue
    ///  instances, the entire request is rejected with
    ///  an invalid argument error.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaOperation.quota_metrics)
    pub quota_metrics: ::std::vec::Vec<super::metric_value::MetricValueSet>,
    ///  Quota mode for this operation.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaOperation.quota_mode)
    pub quota_mode: ::protobuf::EnumOrUnknown<quota_operation::QuotaMode>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicecontrol.v1.QuotaOperation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuotaOperation {
    fn default() -> &'a QuotaOperation {
        <QuotaOperation as ::protobuf::Message>::default_instance()
    }
}

impl QuotaOperation {
    pub fn new() -> QuotaOperation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "operation_id",
            |m: &QuotaOperation| { &m.operation_id },
            |m: &mut QuotaOperation| { &mut m.operation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "method_name",
            |m: &QuotaOperation| { &m.method_name },
            |m: &mut QuotaOperation| { &mut m.method_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "consumer_id",
            |m: &QuotaOperation| { &m.consumer_id },
            |m: &mut QuotaOperation| { &mut m.consumer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "labels",
            |m: &QuotaOperation| { &m.labels },
            |m: &mut QuotaOperation| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "quota_metrics",
            |m: &QuotaOperation| { &m.quota_metrics },
            |m: &mut QuotaOperation| { &mut m.quota_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "quota_mode",
            |m: &QuotaOperation| { &m.quota_mode },
            |m: &mut QuotaOperation| { &mut m.quota_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuotaOperation>(
            "QuotaOperation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuotaOperation {
    const NAME: &'static str = "QuotaOperation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operation_id = is.read_string()?;
                },
                18 => {
                    self.method_name = is.read_string()?;
                },
                26 => {
                    self.consumer_id = is.read_string()?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                42 => {
                    self.quota_metrics.push(is.read_message()?);
                },
                48 => {
                    self.quota_mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.operation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operation_id);
        }
        if !self.method_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.method_name);
        }
        if !self.consumer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.consumer_id);
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.quota_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.quota_mode != ::protobuf::EnumOrUnknown::new(quota_operation::QuotaMode::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(6, self.quota_mode.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.operation_id.is_empty() {
            os.write_string(1, &self.operation_id)?;
        }
        if !self.method_name.is_empty() {
            os.write_string(2, &self.method_name)?;
        }
        if !self.consumer_id.is_empty() {
            os.write_string(3, &self.consumer_id)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.quota_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.quota_mode != ::protobuf::EnumOrUnknown::new(quota_operation::QuotaMode::UNSPECIFIED) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.quota_mode))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuotaOperation {
        QuotaOperation::new()
    }

    fn clear(&mut self) {
        self.operation_id.clear();
        self.method_name.clear();
        self.consumer_id.clear();
        self.labels.clear();
        self.quota_metrics.clear();
        self.quota_mode = ::protobuf::EnumOrUnknown::new(quota_operation::QuotaMode::UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuotaOperation {
        static instance: ::protobuf::rt::Lazy<QuotaOperation> = ::protobuf::rt::Lazy::new();
        instance.get(QuotaOperation::new)
    }
}

impl ::protobuf::MessageFull for QuotaOperation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuotaOperation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuotaOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuotaOperation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `QuotaOperation`
pub mod quota_operation {
    ///  Supported quota modes.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.servicecontrol.v1.QuotaOperation.QuotaMode)
    pub enum QuotaMode {
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaOperation.QuotaMode.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaOperation.QuotaMode.NORMAL)
        NORMAL = 1,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaOperation.QuotaMode.BEST_EFFORT)
        BEST_EFFORT = 2,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaOperation.QuotaMode.CHECK_ONLY)
        CHECK_ONLY = 3,
    }

    impl ::protobuf::Enum for QuotaMode {
        const NAME: &'static str = "QuotaMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<QuotaMode> {
            match value {
                0 => ::std::option::Option::Some(QuotaMode::UNSPECIFIED),
                1 => ::std::option::Option::Some(QuotaMode::NORMAL),
                2 => ::std::option::Option::Some(QuotaMode::BEST_EFFORT),
                3 => ::std::option::Option::Some(QuotaMode::CHECK_ONLY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<QuotaMode> {
            match str {
                "UNSPECIFIED" => ::std::option::Option::Some(QuotaMode::UNSPECIFIED),
                "NORMAL" => ::std::option::Option::Some(QuotaMode::NORMAL),
                "BEST_EFFORT" => ::std::option::Option::Some(QuotaMode::BEST_EFFORT),
                "CHECK_ONLY" => ::std::option::Option::Some(QuotaMode::CHECK_ONLY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [QuotaMode] = &[
            QuotaMode::UNSPECIFIED,
            QuotaMode::NORMAL,
            QuotaMode::BEST_EFFORT,
            QuotaMode::CHECK_ONLY,
        ];
    }

    impl ::protobuf::EnumFull for QuotaMode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("QuotaOperation.QuotaMode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for QuotaMode {
        fn default() -> Self {
            QuotaMode::UNSPECIFIED
        }
    }

    impl QuotaMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<QuotaMode>("QuotaOperation.QuotaMode")
        }
    }
}

///  Response message for the AllocateQuota method.
// @@protoc_insertion_point(message:google.api.servicecontrol.v1.AllocateQuotaResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocateQuotaResponse {
    // message fields
    ///  The same operation_id value used in the AllocateQuotaRequest. Used for
    ///  logging and diagnostics purposes.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.AllocateQuotaResponse.operation_id)
    pub operation_id: ::std::string::String,
    ///  Indicates the decision of the allocate.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.AllocateQuotaResponse.allocate_errors)
    pub allocate_errors: ::std::vec::Vec<QuotaError>,
    ///  Quota metrics to indicate the result of allocation. Depending on the
    ///  request, one or more of the following metrics will be included:
    ///
    ///  1. Per quota group or per quota metric incremental usage will be specified
    ///  using the following delta metric :
    ///    "serviceruntime.googleapis.com/api/consumer/quota_used_count"
    ///
    ///  2. The quota limit reached condition will be specified using the following
    ///  boolean metric :
    ///    "serviceruntime.googleapis.com/quota/exceeded"
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.AllocateQuotaResponse.quota_metrics)
    pub quota_metrics: ::std::vec::Vec<super::metric_value::MetricValueSet>,
    ///  ID of the actual config used to process the request.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.AllocateQuotaResponse.service_config_id)
    pub service_config_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicecontrol.v1.AllocateQuotaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocateQuotaResponse {
    fn default() -> &'a AllocateQuotaResponse {
        <AllocateQuotaResponse as ::protobuf::Message>::default_instance()
    }
}

impl AllocateQuotaResponse {
    pub fn new() -> AllocateQuotaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "operation_id",
            |m: &AllocateQuotaResponse| { &m.operation_id },
            |m: &mut AllocateQuotaResponse| { &mut m.operation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allocate_errors",
            |m: &AllocateQuotaResponse| { &m.allocate_errors },
            |m: &mut AllocateQuotaResponse| { &mut m.allocate_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "quota_metrics",
            |m: &AllocateQuotaResponse| { &m.quota_metrics },
            |m: &mut AllocateQuotaResponse| { &mut m.quota_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_config_id",
            |m: &AllocateQuotaResponse| { &m.service_config_id },
            |m: &mut AllocateQuotaResponse| { &mut m.service_config_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocateQuotaResponse>(
            "AllocateQuotaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocateQuotaResponse {
    const NAME: &'static str = "AllocateQuotaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operation_id = is.read_string()?;
                },
                18 => {
                    self.allocate_errors.push(is.read_message()?);
                },
                26 => {
                    self.quota_metrics.push(is.read_message()?);
                },
                34 => {
                    self.service_config_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.operation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operation_id);
        }
        for value in &self.allocate_errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.quota_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.service_config_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.service_config_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.operation_id.is_empty() {
            os.write_string(1, &self.operation_id)?;
        }
        for v in &self.allocate_errors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.quota_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.service_config_id.is_empty() {
            os.write_string(4, &self.service_config_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocateQuotaResponse {
        AllocateQuotaResponse::new()
    }

    fn clear(&mut self) {
        self.operation_id.clear();
        self.allocate_errors.clear();
        self.quota_metrics.clear();
        self.service_config_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocateQuotaResponse {
        static instance: AllocateQuotaResponse = AllocateQuotaResponse {
            operation_id: ::std::string::String::new(),
            allocate_errors: ::std::vec::Vec::new(),
            quota_metrics: ::std::vec::Vec::new(),
            service_config_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocateQuotaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocateQuotaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocateQuotaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocateQuotaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Represents error information for
///  [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation].
// @@protoc_insertion_point(message:google.api.servicecontrol.v1.QuotaError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuotaError {
    // message fields
    ///  Error code.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaError.code)
    pub code: ::protobuf::EnumOrUnknown<quota_error::Code>,
    ///  Subject to whom this error applies. See the specific enum for more details
    ///  on this field. For example, "clientip:<ip address of client>" or
    ///  "project:<Google developer project id>".
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaError.subject)
    pub subject: ::std::string::String,
    ///  Free-form text that provides details on the cause of the error.
    // @@protoc_insertion_point(field:google.api.servicecontrol.v1.QuotaError.description)
    pub description: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.servicecontrol.v1.QuotaError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuotaError {
    fn default() -> &'a QuotaError {
        <QuotaError as ::protobuf::Message>::default_instance()
    }
}

impl QuotaError {
    pub fn new() -> QuotaError {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &QuotaError| { &m.code },
            |m: &mut QuotaError| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subject",
            |m: &QuotaError| { &m.subject },
            |m: &mut QuotaError| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &QuotaError| { &m.description },
            |m: &mut QuotaError| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuotaError>(
            "QuotaError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuotaError {
    const NAME: &'static str = "QuotaError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.subject = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != ::protobuf::EnumOrUnknown::new(quota_error::Code::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.code.value());
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subject);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != ::protobuf::EnumOrUnknown::new(quota_error::Code::UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.code))?;
        }
        if !self.subject.is_empty() {
            os.write_string(2, &self.subject)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuotaError {
        QuotaError::new()
    }

    fn clear(&mut self) {
        self.code = ::protobuf::EnumOrUnknown::new(quota_error::Code::UNSPECIFIED);
        self.subject.clear();
        self.description.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuotaError {
        static instance: QuotaError = QuotaError {
            code: ::protobuf::EnumOrUnknown::from_i32(0),
            subject: ::std::string::String::new(),
            description: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuotaError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuotaError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuotaError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuotaError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `QuotaError`
pub mod quota_error {
    ///  Error codes related to project config validations are deprecated since the
    ///  quota controller methods do not perform these validations. Instead services
    ///  have to call the Check method, without quota_properties field, to perform
    ///  these validations before calling the quota controller methods. These
    ///  methods check only for project deletion to be wipe out compliant.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.api.servicecontrol.v1.QuotaError.Code)
    pub enum Code {
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaError.Code.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaError.Code.RESOURCE_EXHAUSTED)
        RESOURCE_EXHAUSTED = 8,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaError.Code.BILLING_NOT_ACTIVE)
        BILLING_NOT_ACTIVE = 107,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaError.Code.PROJECT_DELETED)
        PROJECT_DELETED = 108,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaError.Code.API_KEY_INVALID)
        API_KEY_INVALID = 105,
        // @@protoc_insertion_point(enum_value:google.api.servicecontrol.v1.QuotaError.Code.API_KEY_EXPIRED)
        API_KEY_EXPIRED = 112,
    }

    impl ::protobuf::Enum for Code {
        const NAME: &'static str = "Code";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Code> {
            match value {
                0 => ::std::option::Option::Some(Code::UNSPECIFIED),
                8 => ::std::option::Option::Some(Code::RESOURCE_EXHAUSTED),
                107 => ::std::option::Option::Some(Code::BILLING_NOT_ACTIVE),
                108 => ::std::option::Option::Some(Code::PROJECT_DELETED),
                105 => ::std::option::Option::Some(Code::API_KEY_INVALID),
                112 => ::std::option::Option::Some(Code::API_KEY_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Code> {
            match str {
                "UNSPECIFIED" => ::std::option::Option::Some(Code::UNSPECIFIED),
                "RESOURCE_EXHAUSTED" => ::std::option::Option::Some(Code::RESOURCE_EXHAUSTED),
                "BILLING_NOT_ACTIVE" => ::std::option::Option::Some(Code::BILLING_NOT_ACTIVE),
                "PROJECT_DELETED" => ::std::option::Option::Some(Code::PROJECT_DELETED),
                "API_KEY_INVALID" => ::std::option::Option::Some(Code::API_KEY_INVALID),
                "API_KEY_EXPIRED" => ::std::option::Option::Some(Code::API_KEY_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Code] = &[
            Code::UNSPECIFIED,
            Code::RESOURCE_EXHAUSTED,
            Code::BILLING_NOT_ACTIVE,
            Code::PROJECT_DELETED,
            Code::API_KEY_INVALID,
            Code::API_KEY_EXPIRED,
        ];
    }

    impl ::protobuf::EnumFull for Code {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("QuotaError.Code").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Code::UNSPECIFIED => 0,
                Code::RESOURCE_EXHAUSTED => 1,
                Code::BILLING_NOT_ACTIVE => 2,
                Code::PROJECT_DELETED => 3,
                Code::API_KEY_INVALID => 4,
                Code::API_KEY_EXPIRED => 5,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Code {
        fn default() -> Self {
            Code::UNSPECIFIED
        }
    }

    impl Code {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Code>("QuotaError.Code")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n3google/api/servicecontrol/v1/quota_controller.proto\x12\x1cgoogle.api\
    .servicecontrol.v1\x1a\x1cgoogle/api/annotations.proto\x1a/google/api/se\
    rvicecontrol/v1/metric_value.proto\"\xc2\x01\n\x14AllocateQuotaRequest\
    \x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12[\n\x12all\
    ocate_operation\x18\x02\x20\x01(\x0b2,.google.api.servicecontrol.v1.Quot\
    aOperationR\x11allocateOperation\x12*\n\x11service_config_id\x18\x04\x20\
    \x01(\tR\x0fserviceConfigId\"\xf7\x03\n\x0eQuotaOperation\x12!\n\x0coper\
    ation_id\x18\x01\x20\x01(\tR\x0boperationId\x12\x1f\n\x0bmethod_name\x18\
    \x02\x20\x01(\tR\nmethodName\x12\x1f\n\x0bconsumer_id\x18\x03\x20\x01(\t\
    R\nconsumerId\x12P\n\x06labels\x18\x04\x20\x03(\x0b28.google.api.service\
    control.v1.QuotaOperation.LabelsEntryR\x06labels\x12Q\n\rquota_metrics\
    \x18\x05\x20\x03(\x0b2,.google.api.servicecontrol.v1.MetricValueSetR\x0c\
    quotaMetrics\x12U\n\nquota_mode\x18\x06\x20\x01(\x0e26.google.api.servic\
    econtrol.v1.QuotaOperation.QuotaModeR\tquotaMode\x1a9\n\x0bLabelsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"I\n\tQuotaMode\x12\x0f\n\x0bUNSPECIFIED\
    \x10\0\x12\n\n\x06NORMAL\x10\x01\x12\x0f\n\x0bBEST_EFFORT\x10\x02\x12\
    \x0e\n\nCHECK_ONLY\x10\x03\"\x8c\x02\n\x15AllocateQuotaResponse\x12!\n\
    \x0coperation_id\x18\x01\x20\x01(\tR\x0boperationId\x12Q\n\x0fallocate_e\
    rrors\x18\x02\x20\x03(\x0b2(.google.api.servicecontrol.v1.QuotaErrorR\
    \x0eallocateErrors\x12Q\n\rquota_metrics\x18\x03\x20\x03(\x0b2,.google.a\
    pi.servicecontrol.v1.MetricValueSetR\x0cquotaMetrics\x12*\n\x11service_c\
    onfig_id\x18\x04\x20\x01(\tR\x0fserviceConfigId\"\x94\x02\n\nQuotaError\
    \x12A\n\x04code\x18\x01\x20\x01(\x0e2-.google.api.servicecontrol.v1.Quot\
    aError.CodeR\x04code\x12\x18\n\x07subject\x18\x02\x20\x01(\tR\x07subject\
    \x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\"\x86\x01\n\
    \x04Code\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x16\n\x12RESOURCE_EXHAUSTED\
    \x10\x08\x12\x16\n\x12BILLING_NOT_ACTIVE\x10k\x12\x13\n\x0fPROJECT_DELET\
    ED\x10l\x12\x13\n\x0fAPI_KEY_INVALID\x10i\x12\x13\n\x0fAPI_KEY_EXPIRED\
    \x10p2\xc2\x01\n\x0fQuotaController\x12\xae\x01\n\rAllocateQuota\x122.go\
    ogle.api.servicecontrol.v1.AllocateQuotaRequest\x1a3.google.api.servicec\
    ontrol.v1.AllocateQuotaResponse\"4\x82\xd3\xe4\x93\x02.\")/v1/services/{\
    service_name}:allocateQuota:\x01*B\x89\x01\n\x20com.google.api.serviceco\
    ntrol.v1B\x14QuotaControllerProtoP\x01ZJgoogle.golang.org/genproto/googl\
    eapis/api/servicecontrol/v1;servicecontrol\xf8\x01\x01J\xf3=\n\x07\x12\
    \x05\x0e\0\xcd\x01\x01\n\xbd\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb2\x04\
    \x20Copyright\x202017\x20Google\x20Inc.\n\n\x20Licensed\x20under\x20the\
    \x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20y\
    ou\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\
    \x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\
    \x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/li\
    censes/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\
    \x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\
    \x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20\
    IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20A\
    NY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20Li\
    cense\x20for\x20the\x20specific\x20language\x20governing\x20permissions\
    \x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\
    \x12\x03\x10\0%\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\x03\
    \x13\09\n\x08\n\x01\x08\x12\x03\x15\0\x1f\n\t\n\x02\x08\x1f\x12\x03\x15\
    \0\x1f\n\x08\n\x01\x08\x12\x03\x16\0a\n\t\n\x02\x08\x0b\x12\x03\x16\0a\n\
    \x08\n\x01\x08\x12\x03\x17\0\"\n\t\n\x02\x08\n\x12\x03\x17\0\"\n\x08\n\
    \x01\x08\x12\x03\x18\05\n\t\n\x02\x08\x08\x12\x03\x18\05\n\x08\n\x01\x08\
    \x12\x03\x19\09\n\t\n\x02\x08\x01\x12\x03\x19\09\n\x9b\x02\n\x02\x06\0\
    \x12\x04\x1f\01\x01\x1a\x8e\x02\x20[Google\x20Quota\x20Control\x20API](/\
    service-control/overview)\n\n\x20Allows\x20clients\x20to\x20allocate\x20\
    and\x20release\x20quota\x20against\x20a\x20[managed\n\x20service](https:\
    //cloud.google.com/service-management/reference/rpc/google.api/servicema\
    nagement.v1#google.api.servicemanagement.v1.ManagedService).\n\n\n\n\x03\
    \x06\0\x01\x12\x03\x1f\x08\x17\n\xa2\x04\n\x04\x06\0\x02\0\x12\x04+\x020\
    \x03\x1a\x93\x04\x20Attempts\x20to\x20allocate\x20quota\x20for\x20the\
    \x20specified\x20consumer.\x20It\x20should\x20be\x20called\n\x20before\
    \x20the\x20operation\x20is\x20executed.\n\n\x20This\x20method\x20require\
    s\x20the\x20`servicemanagement.services.quota`\n\x20permission\x20on\x20\
    the\x20specified\x20service.\x20For\x20more\x20information,\x20see\n\x20\
    [Cloud\x20IAM](https://cloud.google.com/iam).\n\n\x20**NOTE:**\x20The\
    \x20client\x20**must**\x20fail-open\x20on\x20server\x20errors\x20`INTERN\
    AL`,\n\x20`UNKNOWN`,\x20`DEADLINE_EXCEEDED`,\x20and\x20`UNAVAILABLE`.\
    \x20To\x20ensure\x20system\n\x20reliability,\x20the\x20server\x20may\x20\
    inject\x20these\x20errors\x20to\x20prohibit\x20any\x20hard\n\x20dependen\
    cy\x20on\x20the\x20quota\x20functionality.\n\n\x0c\n\x05\x06\0\x02\0\x01\
    \x12\x03+\x06\x13\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03+\x14(\n\x0c\n\x05\
    \x06\0\x02\0\x03\x12\x03+3H\n\r\n\x05\x06\0\x02\0\x04\x12\x04,\x04/\x06\
    \n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04,\x04/\x06\n;\n\x02\x04\
    \0\x12\x044\0C\x01\x1a/\x20Request\x20message\x20for\x20the\x20AllocateQ\
    uota\x20method.\n\n\n\n\x03\x04\0\x01\x12\x034\x08\x1c\n\xcd\x01\n\x04\
    \x04\0\x02\0\x12\x03:\x02\x1a\x1a\xbf\x01\x20Name\x20of\x20the\x20servic\
    e\x20as\x20specified\x20in\x20the\x20service\x20configuration.\x20For\
    \x20example,\n\x20`\"pubsub.googleapis.com\"`.\n\n\x20See\x20[google.api\
    .Service][google.api.Service]\x20for\x20the\x20definition\x20of\x20a\n\
    \x20service\x20name.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03:\x02\x08\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03:\t\x15\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03:\x18\x19\n=\n\x04\x04\0\x02\x01\x12\x03=\x02(\x1a0\x20Operation\
    \x20that\x20describes\x20the\x20quota\x20allocation.\n\n\x0c\n\x05\x04\0\
    \x02\x01\x06\x12\x03=\x02\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03=\x11\
    #\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03=&'\n\xba\x01\n\x04\x04\0\x02\x02\
    \x12\x03B\x02\x1f\x1a\xac\x01\x20Specifies\x20which\x20version\x20of\x20\
    service\x20configuration\x20should\x20be\x20used\x20to\x20process\n\x20t\
    he\x20request.\x20If\x20unspecified\x20or\x20no\x20matching\x20version\
    \x20can\x20be\x20found,\x20the\x20latest\n\x20one\x20will\x20be\x20used.\
    \n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03B\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03B\t\x1a\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03B\x1d\x1e\n\
    B\n\x02\x04\x01\x12\x05F\0\x8a\x01\x01\x1a5\x20Represents\x20information\
    \x20regarding\x20a\x20quota\x20operation.\n\n\n\n\x03\x04\x01\x01\x12\
    \x03F\x08\x16\n&\n\x04\x04\x01\x04\0\x12\x04H\x02\\\x03\x1a\x18\x20Suppo\
    rted\x20quota\x20modes.\n\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03H\x07\x10\
    \nB\n\x06\x04\x01\x04\0\x02\0\x12\x03J\x04\x14\x1a3\x20Guard\x20against\
    \x20implicit\x20default.\x20Must\x20not\x20be\x20used.\n\n\x0e\n\x07\x04\
    \x01\x04\0\x02\0\x01\x12\x03J\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\0\
    \x02\x12\x03J\x12\x13\n\x8f\x02\n\x06\x04\x01\x04\0\x02\x01\x12\x03P\x04\
    \x0f\x1a\xff\x01\x20For\x20AllocateQuota\x20request,\x20allocates\x20quo\
    ta\x20for\x20the\x20amount\x20specified\x20in\n\x20the\x20service\x20con\
    figuration\x20or\x20specified\x20using\x20the\x20quota\x20metrics.\x20If\
    \x20the\n\x20amount\x20is\x20higher\x20than\x20the\x20available\x20quota\
    ,\x20allocation\x20error\x20will\x20be\n\x20returned\x20and\x20no\x20quo\
    ta\x20will\x20be\x20allocated.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\
    \x12\x03P\x04\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03P\r\x0e\n\
    \x81\x02\n\x06\x04\x01\x04\0\x02\x02\x12\x03V\x04\x14\x1a\xf1\x01\x20The\
    \x20operation\x20allocates\x20quota\x20for\x20the\x20amount\x20specified\
    \x20in\x20the\x20service\n\x20configuration\x20or\x20specified\x20using\
    \x20the\x20quota\x20metrics.\x20If\x20the\x20amount\x20is\n\x20higher\
    \x20than\x20the\x20available\x20quota,\x20request\x20does\x20not\x20fail\
    \x20but\x20all\x20available\n\x20quota\x20will\x20be\x20allocated.\n\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x03V\x04\x0f\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x02\x02\x12\x03V\x12\x13\n\xb7\x01\n\x06\x04\x01\x04\0\
    \x02\x03\x12\x03[\x04\x13\x1a\xa7\x01\x20For\x20AllocateQuota\x20request\
    ,\x20only\x20checks\x20if\x20there\x20is\x20enough\x20quota\n\x20availab\
    le\x20and\x20does\x20not\x20change\x20the\x20available\x20quota.\x20No\
    \x20lock\x20is\x20placed\x20on\n\x20the\x20available\x20quota\x20either.\
    \n\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x03[\x04\x0e\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x03\x02\x12\x03[\x11\x12\n\xac\x03\n\x04\x04\x01\x02\
    \0\x12\x03f\x02\x1a\x1a\x9e\x03\x20Identity\x20of\x20the\x20operation.\
    \x20This\x20is\x20expected\x20to\x20be\x20unique\x20within\x20the\x20sco\
    pe\n\x20of\x20the\x20service\x20that\x20generated\x20the\x20operation,\
    \x20and\x20guarantees\x20idempotency\x20in\n\x20case\x20of\x20retries.\n\
    \n\x20UUID\x20version\x204\x20is\x20recommended,\x20though\x20not\x20req\
    uired.\x20In\x20scenarios\x20where\x20an\n\x20operation\x20is\x20compute\
    d\x20from\x20existing\x20information\x20and\x20an\x20idempotent\x20id\
    \x20is\n\x20desirable\x20for\x20deduplication\x20purpose,\x20UUID\x20ver\
    sion\x205\x20is\x20recommended.\x20See\n\x20RFC\x204122\x20for\x20detail\
    s.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03f\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03f\t\x15\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03f\x18\x19\
    \n\x8c\x03\n\x04\x04\x01\x02\x01\x12\x03o\x02\x19\x1a\xfe\x02\x20Fully\
    \x20qualified\x20name\x20of\x20the\x20API\x20method\x20for\x20which\x20t\
    his\x20quota\x20operation\x20is\n\x20requested.\x20This\x20name\x20is\
    \x20used\x20for\x20matching\x20quota\x20rules\x20or\x20metric\x20rules\
    \x20and\n\x20billing\x20status\x20rules\x20defined\x20in\x20service\x20c\
    onfiguration.\x20This\x20field\x20is\x20not\n\x20required\x20if\x20the\
    \x20quota\x20operation\x20is\x20performed\x20on\x20non-API\x20resources.\
    \n\n\x20Example\x20of\x20an\x20RPC\x20method\x20name:\n\x20\x20\x20\x20\
    \x20google.example.library.v1.LibraryService.CreateShelf\n\n\x0c\n\x05\
    \x04\x01\x02\x01\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03o\t\x14\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03o\x17\x18\n\xdc\
    \x01\n\x04\x04\x01\x02\x02\x12\x03w\x02\x19\x1a\xce\x01\x20Identity\x20o\
    f\x20the\x20consumer\x20for\x20whom\x20this\x20quota\x20operation\x20is\
    \x20being\x20performed.\n\n\x20This\x20can\x20be\x20in\x20one\x20of\x20t\
    he\x20following\x20formats:\n\x20\x20\x20project:<project_id>,\n\x20\x20\
    \x20project_number:<project_number>,\n\x20\x20\x20api_key:<api_key>.\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x05\x12\x03w\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x03w\t\x14\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03w\x17\x18\
    \n/\n\x04\x04\x01\x02\x03\x12\x03z\x02!\x1a\"\x20Labels\x20describing\
    \x20the\x20operation.\n\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03z\x02\x15\
    \n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03z\x16\x1c\n\x0c\n\x05\x04\x01\
    \x02\x03\x03\x12\x03z\x1f\x20\n\x9b\x04\n\x04\x04\x01\x02\x04\x12\x04\
    \x86\x01\x02,\x1a\x8c\x04\x20Represents\x20information\x20about\x20this\
    \x20operation.\x20Each\x20MetricValueSet\n\x20corresponds\x20to\x20a\x20\
    metric\x20defined\x20in\x20the\x20service\x20configuration.\n\x20The\x20\
    data\x20type\x20used\x20in\x20the\x20MetricValueSet\x20must\x20agree\x20\
    with\n\x20the\x20data\x20type\x20specified\x20in\x20the\x20metric\x20def\
    inition.\n\n\x20Within\x20a\x20single\x20operation,\x20it\x20is\x20not\
    \x20allowed\x20to\x20have\x20more\x20than\x20one\n\x20MetricValue\x20ins\
    tances\x20that\x20have\x20the\x20same\x20metric\x20names\x20and\x20ident\
    ical\n\x20label\x20value\x20combinations.\x20If\x20a\x20request\x20has\
    \x20such\x20duplicated\x20MetricValue\n\x20instances,\x20the\x20entire\
    \x20request\x20is\x20rejected\x20with\n\x20an\x20invalid\x20argument\x20\
    error.\n\n\r\n\x05\x04\x01\x02\x04\x04\x12\x04\x86\x01\x02\n\n\r\n\x05\
    \x04\x01\x02\x04\x06\x12\x04\x86\x01\x0b\x19\n\r\n\x05\x04\x01\x02\x04\
    \x01\x12\x04\x86\x01\x1a'\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\x86\x01*\
    +\n.\n\x04\x04\x01\x02\x05\x12\x04\x89\x01\x02\x1b\x1a\x20\x20Quota\x20m\
    ode\x20for\x20this\x20operation.\n\n\r\n\x05\x04\x01\x02\x05\x06\x12\x04\
    \x89\x01\x02\x0b\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\x89\x01\x0c\x16\n\
    \r\n\x05\x04\x01\x02\x05\x03\x12\x04\x89\x01\x19\x1a\n>\n\x02\x04\x02\
    \x12\x06\x8d\x01\0\xa3\x01\x01\x1a0\x20Response\x20message\x20for\x20the\
    \x20AllocateQuota\x20method.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\x8d\x01\
    \x08\x1d\ny\n\x04\x04\x02\x02\0\x12\x04\x90\x01\x02\x1a\x1ak\x20The\x20s\
    ame\x20operation_id\x20value\x20used\x20in\x20the\x20AllocateQuotaReques\
    t.\x20Used\x20for\n\x20logging\x20and\x20diagnostics\x20purposes.\n\n\r\
    \n\x05\x04\x02\x02\0\x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\x90\x01\t\x15\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x90\x01\
    \x18\x19\n7\n\x04\x04\x02\x02\x01\x12\x04\x93\x01\x02*\x1a)\x20Indicates\
    \x20the\x20decision\x20of\x20the\x20allocate.\n\n\r\n\x05\x04\x02\x02\
    \x01\x04\x12\x04\x93\x01\x02\n\n\r\n\x05\x04\x02\x02\x01\x06\x12\x04\x93\
    \x01\x0b\x15\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x93\x01\x16%\n\r\n\
    \x05\x04\x02\x02\x01\x03\x12\x04\x93\x01()\n\xd9\x03\n\x04\x04\x02\x02\
    \x02\x12\x04\x9f\x01\x02,\x1a\xca\x03\x20Quota\x20metrics\x20to\x20indic\
    ate\x20the\x20result\x20of\x20allocation.\x20Depending\x20on\x20the\n\
    \x20request,\x20one\x20or\x20more\x20of\x20the\x20following\x20metrics\
    \x20will\x20be\x20included:\n\n\x201.\x20Per\x20quota\x20group\x20or\x20\
    per\x20quota\x20metric\x20incremental\x20usage\x20will\x20be\x20specifie\
    d\n\x20using\x20the\x20following\x20delta\x20metric\x20:\n\x20\x20\x20\"\
    serviceruntime.googleapis.com/api/consumer/quota_used_count\"\n\n\x202.\
    \x20The\x20quota\x20limit\x20reached\x20condition\x20will\x20be\x20speci\
    fied\x20using\x20the\x20following\n\x20boolean\x20metric\x20:\n\x20\x20\
    \x20\"serviceruntime.googleapis.com/quota/exceeded\"\n\n\r\n\x05\x04\x02\
    \x02\x02\x04\x12\x04\x9f\x01\x02\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\
    \x9f\x01\x0b\x19\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x9f\x01\x1a'\n\r\
    \n\x05\x04\x02\x02\x02\x03\x12\x04\x9f\x01*+\nD\n\x04\x04\x02\x02\x03\
    \x12\x04\xa2\x01\x02\x1f\x1a6\x20ID\x20of\x20the\x20actual\x20config\x20\
    used\x20to\x20process\x20the\x20request.\n\n\r\n\x05\x04\x02\x02\x03\x05\
    \x12\x04\xa2\x01\x02\x08\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xa2\x01\t\
    \x1a\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xa2\x01\x1d\x1e\np\n\x02\x04\
    \x03\x12\x06\xa7\x01\0\xcd\x01\x01\x1ab\x20Represents\x20error\x20inform\
    ation\x20for\n\x20[QuotaOperation][google.api.servicecontrol.v1.QuotaOpe\
    ration].\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xa7\x01\x08\x12\n\xfe\x02\n\
    \x04\x04\x03\x04\0\x12\x06\xad\x01\x02\xc1\x01\x03\x1a\xed\x02\x20Error\
    \x20codes\x20related\x20to\x20project\x20config\x20validations\x20are\
    \x20deprecated\x20since\x20the\n\x20quota\x20controller\x20methods\x20do\
    \x20not\x20perform\x20these\x20validations.\x20Instead\x20services\n\x20\
    have\x20to\x20call\x20the\x20Check\x20method,\x20without\x20quota_proper\
    ties\x20field,\x20to\x20perform\n\x20these\x20validations\x20before\x20c\
    alling\x20the\x20quota\x20controller\x20methods.\x20These\n\x20methods\
    \x20check\x20only\x20for\x20project\x20deletion\x20to\x20be\x20wipe\x20o\
    ut\x20compliant.\n\n\r\n\x05\x04\x03\x04\0\x01\x12\x04\xad\x01\x07\x0b\n\
    %\n\x06\x04\x03\x04\0\x02\0\x12\x04\xaf\x01\x04\x14\x1a\x15\x20This\x20i\
    s\x20never\x20used.\n\n\x0f\n\x07\x04\x03\x04\0\x02\0\x01\x12\x04\xaf\
    \x01\x04\x0f\n\x0f\n\x07\x04\x03\x04\0\x02\0\x02\x12\x04\xaf\x01\x12\x13\
    \n[\n\x06\x04\x03\x04\0\x02\x01\x12\x04\xb3\x01\x04\x1b\x1aK\x20Quota\
    \x20allocation\x20failed.\n\x20Same\x20as\x20[google.rpc.Code.RESOURCE_E\
    XHAUSTED][].\n\n\x0f\n\x07\x04\x03\x04\0\x02\x01\x01\x12\x04\xb3\x01\x04\
    \x16\n\x0f\n\x07\x04\x03\x04\0\x02\x01\x02\x12\x04\xb3\x01\x19\x1a\nb\n\
    \x06\x04\x03\x04\0\x02\x02\x12\x04\xb7\x01\x04\x1d\x1aR\x20Consumer\x20c\
    annot\x20access\x20the\x20service\x20because\x20the\x20service\x20requir\
    es\x20active\n\x20billing.\n\n\x0f\n\x07\x04\x03\x04\0\x02\x02\x01\x12\
    \x04\xb7\x01\x04\x16\n\x0f\n\x07\x04\x03\x04\0\x02\x02\x02\x12\x04\xb7\
    \x01\x19\x1c\nP\n\x06\x04\x03\x04\0\x02\x03\x12\x04\xba\x01\x04\x1a\x1a@\
    \x20Consumer's\x20project\x20has\x20been\x20marked\x20as\x20deleted\x20(\
    soft\x20deletion).\n\n\x0f\n\x07\x04\x03\x04\0\x02\x03\x01\x12\x04\xba\
    \x01\x04\x13\n\x0f\n\x07\x04\x03\x04\0\x02\x03\x02\x12\x04\xba\x01\x16\
    \x19\n/\n\x06\x04\x03\x04\0\x02\x04\x12\x04\xbd\x01\x04\x1a\x1a\x1f\x20S\
    pecified\x20API\x20key\x20is\x20invalid.\n\n\x0f\n\x07\x04\x03\x04\0\x02\
    \x04\x01\x12\x04\xbd\x01\x04\x13\n\x0f\n\x07\x04\x03\x04\0\x02\x04\x02\
    \x12\x04\xbd\x01\x16\x19\n0\n\x06\x04\x03\x04\0\x02\x05\x12\x04\xc0\x01\
    \x04\x1a\x1a\x20\x20Specified\x20API\x20Key\x20has\x20expired.\n\n\x0f\n\
    \x07\x04\x03\x04\0\x02\x05\x01\x12\x04\xc0\x01\x04\x13\n\x0f\n\x07\x04\
    \x03\x04\0\x02\x05\x02\x12\x04\xc0\x01\x16\x19\n\x1b\n\x04\x04\x03\x02\0\
    \x12\x04\xc4\x01\x02\x10\x1a\r\x20Error\x20code.\n\n\r\n\x05\x04\x03\x02\
    \0\x06\x12\x04\xc4\x01\x02\x06\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xc4\
    \x01\x07\x0b\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xc4\x01\x0e\x0f\n\xc7\
    \x01\n\x04\x04\x03\x02\x01\x12\x04\xc9\x01\x02\x15\x1a\xb8\x01\x20Subjec\
    t\x20to\x20whom\x20this\x20error\x20applies.\x20See\x20the\x20specific\
    \x20enum\x20for\x20more\x20details\n\x20on\x20this\x20field.\x20For\x20e\
    xample,\x20\"clientip:<ip\x20address\x20of\x20client>\"\x20or\n\x20\"pro\
    ject:<Google\x20developer\x20project\x20id>\".\n\n\r\n\x05\x04\x03\x02\
    \x01\x05\x12\x04\xc9\x01\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\
    \xc9\x01\t\x10\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xc9\x01\x13\x14\nO\
    \n\x04\x04\x03\x02\x02\x12\x04\xcc\x01\x02\x19\x1aA\x20Free-form\x20text\
    \x20that\x20provides\x20details\x20on\x20the\x20cause\x20of\x20the\x20er\
    ror.\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xcc\x01\x02\x08\n\r\n\x05\
    \x04\x03\x02\x02\x01\x12\x04\xcc\x01\t\x14\n\r\n\x05\x04\x03\x02\x02\x03\
    \x12\x04\xcc\x01\x17\x18b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::metric_value::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(4);
            messages.push(AllocateQuotaRequest::generated_message_descriptor_data());
            messages.push(QuotaOperation::generated_message_descriptor_data());
            messages.push(AllocateQuotaResponse::generated_message_descriptor_data());
            messages.push(QuotaError::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(quota_operation::QuotaMode::generated_enum_descriptor_data());
            enums.push(quota_error::Code::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
