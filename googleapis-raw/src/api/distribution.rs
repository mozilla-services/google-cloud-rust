// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/api/distribution.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  `Distribution` contains summary statistics for a population of values. It
///  optionally contains a histogram representing the distribution of those values
///  across a set of buckets.
///
///  The summary statistics are the count, mean, sum of the squared deviation from
///  the mean, the minimum, and the maximum of the set of population of values.
///  The histogram is based on a sequence of buckets and gives a count of values
///  that fall into each bucket. The boundaries of the buckets are given either
///  explicitly or by formulas for buckets of fixed or exponentially increasing
///  widths.
///
///  Although it is not forbidden, it is generally a bad idea to include
///  non-finite values (infinities or NaNs) in the population of values, as this
///  will render the `mean` and `sum_of_squared_deviation` fields meaningless.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.api.Distribution)
pub struct Distribution {
    // message fields
    ///  The number of values in the population. Must be non-negative. This value
    ///  must equal the sum of the values in `bucket_counts` if a histogram is
    ///  provided.
    // @@protoc_insertion_point(field:google.api.Distribution.count)
    pub count: i64,
    ///  The arithmetic mean of the values in the population. If `count` is zero
    ///  then this field must be zero.
    // @@protoc_insertion_point(field:google.api.Distribution.mean)
    pub mean: f64,
    // @@protoc_insertion_point(field:google.api.Distribution.sum_of_squared_deviation)
    pub sum_of_squared_deviation: f64,
    ///  If specified, contains the range of the population values. The field
    ///  must not be present if the `count` is zero.
    // @@protoc_insertion_point(field:google.api.Distribution.range)
    pub range: ::protobuf::MessageField<distribution::Range>,
    ///  Defines the histogram bucket boundaries. If the distribution does not
    ///  contain a histogram, then omit this field.
    // @@protoc_insertion_point(field:google.api.Distribution.bucket_options)
    pub bucket_options: ::protobuf::MessageField<distribution::BucketOptions>,
    ///  The number of values in each bucket of the histogram, as described in
    ///  `bucket_options`. If the distribution does not have a histogram, then omit
    ///  this field. If there is a histogram, then the sum of the values in
    ///  `bucket_counts` must equal the value in the `count` field of the
    ///  distribution.
    ///
    ///  If present, `bucket_counts` should contain N values, where N is the number
    ///  of buckets specified in `bucket_options`. If you supply fewer than N
    ///  values, the remaining values are assumed to be 0.
    ///
    ///  The order of the values in `bucket_counts` follows the bucket numbering
    ///  schemes described for the three bucket types. The first value must be the
    ///  count for the underflow bucket (number 0). The next N-2 values are the
    ///  counts for the finite buckets (number 1 through N-2). The N'th value in
    ///  `bucket_counts` is the count for the overflow bucket (number N-1).
    // @@protoc_insertion_point(field:google.api.Distribution.bucket_counts)
    pub bucket_counts: ::std::vec::Vec<i64>,
    ///  Must be in increasing order of `value` field.
    // @@protoc_insertion_point(field:google.api.Distribution.exemplars)
    pub exemplars: ::std::vec::Vec<distribution::Exemplar>,
    // special fields
    // @@protoc_insertion_point(special_field:google.api.Distribution.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Distribution {
    fn default() -> &'a Distribution {
        <Distribution as ::protobuf::Message>::default_instance()
    }
}

impl Distribution {
    pub fn new() -> Distribution {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &Distribution| { &m.count },
            |m: &mut Distribution| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mean",
            |m: &Distribution| { &m.mean },
            |m: &mut Distribution| { &mut m.mean },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sum_of_squared_deviation",
            |m: &Distribution| { &m.sum_of_squared_deviation },
            |m: &mut Distribution| { &mut m.sum_of_squared_deviation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, distribution::Range>(
            "range",
            |m: &Distribution| { &m.range },
            |m: &mut Distribution| { &mut m.range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, distribution::BucketOptions>(
            "bucket_options",
            |m: &Distribution| { &m.bucket_options },
            |m: &mut Distribution| { &mut m.bucket_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bucket_counts",
            |m: &Distribution| { &m.bucket_counts },
            |m: &mut Distribution| { &mut m.bucket_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exemplars",
            |m: &Distribution| { &m.exemplars },
            |m: &mut Distribution| { &mut m.exemplars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Distribution>(
            "Distribution",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Distribution {
    const NAME: &'static str = "Distribution";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = is.read_int64()?;
                },
                17 => {
                    self.mean = is.read_double()?;
                },
                25 => {
                    self.sum_of_squared_deviation = is.read_double()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.range)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bucket_options)?;
                },
                58 => {
                    is.read_repeated_packed_int64_into(&mut self.bucket_counts)?;
                },
                56 => {
                    self.bucket_counts.push(is.read_int64()?);
                },
                82 => {
                    self.exemplars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.count);
        }
        if self.mean != 0. {
            my_size += 1 + 8;
        }
        if self.sum_of_squared_deviation != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bucket_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.bucket_counts {
            my_size += ::protobuf::rt::int64_size(7, *value);
        };
        for value in &self.exemplars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.count != 0 {
            os.write_int64(1, self.count)?;
        }
        if self.mean != 0. {
            os.write_double(2, self.mean)?;
        }
        if self.sum_of_squared_deviation != 0. {
            os.write_double(3, self.sum_of_squared_deviation)?;
        }
        if let Some(v) = self.range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.bucket_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.bucket_counts {
            os.write_int64(7, *v)?;
        };
        for v in &self.exemplars {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Distribution {
        Distribution::new()
    }

    fn clear(&mut self) {
        self.count = 0;
        self.mean = 0.;
        self.sum_of_squared_deviation = 0.;
        self.range.clear();
        self.bucket_options.clear();
        self.bucket_counts.clear();
        self.exemplars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Distribution {
        static instance: Distribution = Distribution {
            count: 0,
            mean: 0.,
            sum_of_squared_deviation: 0.,
            range: ::protobuf::MessageField::none(),
            bucket_options: ::protobuf::MessageField::none(),
            bucket_counts: ::std::vec::Vec::new(),
            exemplars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Distribution {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Distribution").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Distribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Distribution {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Distribution`
pub mod distribution {
    ///  The range of the population values.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.api.Distribution.Range)
    pub struct Range {
        // message fields
        ///  The minimum of the population values.
        // @@protoc_insertion_point(field:google.api.Distribution.Range.min)
        pub min: f64,
        ///  The maximum of the population values.
        // @@protoc_insertion_point(field:google.api.Distribution.Range.max)
        pub max: f64,
        // special fields
        // @@protoc_insertion_point(special_field:google.api.Distribution.Range.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Range {
        fn default() -> &'a Range {
            <Range as ::protobuf::Message>::default_instance()
        }
    }

    impl Range {
        pub fn new() -> Range {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min",
                |m: &Range| { &m.min },
                |m: &mut Range| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max",
                |m: &Range| { &m.max },
                |m: &mut Range| { &mut m.max },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Range>(
                "Distribution.Range",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Range {
        const NAME: &'static str = "Range";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.min = is.read_double()?;
                    },
                    17 => {
                        self.max = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.min != 0. {
                my_size += 1 + 8;
            }
            if self.max != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.min != 0. {
                os.write_double(1, self.min)?;
            }
            if self.max != 0. {
                os.write_double(2, self.max)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Range {
            Range::new()
        }

        fn clear(&mut self) {
            self.min = 0.;
            self.max = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Range {
            static instance: Range = Range {
                min: 0.,
                max: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Range {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Distribution.Range").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Range {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Range {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  `BucketOptions` describes the bucket boundaries used to create a histogram
    ///  for the distribution. The buckets can be in a linear sequence, an
    ///  exponential sequence, or each bucket can be specified explicitly.
    ///  `BucketOptions` does not include the number of values in each bucket.
    ///
    ///  A bucket has an inclusive lower bound and exclusive upper bound for the
    ///  values that are counted for that bucket. The upper bound of a bucket must
    ///  be strictly greater than the lower bound. The sequence of N buckets for a
    ///  distribution consists of an underflow bucket (number 0), zero or more
    ///  finite buckets (number 1 through N - 2) and an overflow bucket (number N -
    ///  1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the
    ///  same as the upper bound of bucket i - 1. The buckets span the whole range
    ///  of finite values: lower bound of the underflow bucket is -infinity and the
    ///  upper bound of the overflow bucket is +infinity. The finite buckets are
    ///  so-called because both bounds are finite.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.api.Distribution.BucketOptions)
    pub struct BucketOptions {
        // message oneof groups
        pub options: ::std::option::Option<bucket_options::Options>,
        // special fields
        // @@protoc_insertion_point(special_field:google.api.Distribution.BucketOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BucketOptions {
        fn default() -> &'a BucketOptions {
            <BucketOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl BucketOptions {
        pub fn new() -> BucketOptions {
            ::std::default::Default::default()
        }

        // .google.api.Distribution.BucketOptions.Linear linear_buckets = 1;

        pub fn linear_buckets(&self) -> &bucket_options::Linear {
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::LinearBuckets(ref v)) => v,
                _ => <bucket_options::Linear as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_linear_buckets(&mut self) {
            self.options = ::std::option::Option::None;
        }

        pub fn has_linear_buckets(&self) -> bool {
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::LinearBuckets(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_linear_buckets(&mut self, v: bucket_options::Linear) {
            self.options = ::std::option::Option::Some(bucket_options::Options::LinearBuckets(v))
        }

        // Mutable pointer to the field.
        pub fn mut_linear_buckets(&mut self) -> &mut bucket_options::Linear {
            if let ::std::option::Option::Some(bucket_options::Options::LinearBuckets(_)) = self.options {
            } else {
                self.options = ::std::option::Option::Some(bucket_options::Options::LinearBuckets(bucket_options::Linear::new()));
            }
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::LinearBuckets(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_linear_buckets(&mut self) -> bucket_options::Linear {
            if self.has_linear_buckets() {
                match self.options.take() {
                    ::std::option::Option::Some(bucket_options::Options::LinearBuckets(v)) => v,
                    _ => panic!(),
                }
            } else {
                bucket_options::Linear::new()
            }
        }

        // .google.api.Distribution.BucketOptions.Exponential exponential_buckets = 2;

        pub fn exponential_buckets(&self) -> &bucket_options::Exponential {
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(ref v)) => v,
                _ => <bucket_options::Exponential as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_exponential_buckets(&mut self) {
            self.options = ::std::option::Option::None;
        }

        pub fn has_exponential_buckets(&self) -> bool {
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_exponential_buckets(&mut self, v: bucket_options::Exponential) {
            self.options = ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(v))
        }

        // Mutable pointer to the field.
        pub fn mut_exponential_buckets(&mut self) -> &mut bucket_options::Exponential {
            if let ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(_)) = self.options {
            } else {
                self.options = ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(bucket_options::Exponential::new()));
            }
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_exponential_buckets(&mut self) -> bucket_options::Exponential {
            if self.has_exponential_buckets() {
                match self.options.take() {
                    ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(v)) => v,
                    _ => panic!(),
                }
            } else {
                bucket_options::Exponential::new()
            }
        }

        // .google.api.Distribution.BucketOptions.Explicit explicit_buckets = 3;

        pub fn explicit_buckets(&self) -> &bucket_options::Explicit {
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(ref v)) => v,
                _ => <bucket_options::Explicit as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_explicit_buckets(&mut self) {
            self.options = ::std::option::Option::None;
        }

        pub fn has_explicit_buckets(&self) -> bool {
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_explicit_buckets(&mut self, v: bucket_options::Explicit) {
            self.options = ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(v))
        }

        // Mutable pointer to the field.
        pub fn mut_explicit_buckets(&mut self) -> &mut bucket_options::Explicit {
            if let ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(_)) = self.options {
            } else {
                self.options = ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(bucket_options::Explicit::new()));
            }
            match self.options {
                ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_explicit_buckets(&mut self) -> bucket_options::Explicit {
            if self.has_explicit_buckets() {
                match self.options.take() {
                    ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(v)) => v,
                    _ => panic!(),
                }
            } else {
                bucket_options::Explicit::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, bucket_options::Linear>(
                "linear_buckets",
                BucketOptions::has_linear_buckets,
                BucketOptions::linear_buckets,
                BucketOptions::mut_linear_buckets,
                BucketOptions::set_linear_buckets,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, bucket_options::Exponential>(
                "exponential_buckets",
                BucketOptions::has_exponential_buckets,
                BucketOptions::exponential_buckets,
                BucketOptions::mut_exponential_buckets,
                BucketOptions::set_exponential_buckets,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, bucket_options::Explicit>(
                "explicit_buckets",
                BucketOptions::has_explicit_buckets,
                BucketOptions::explicit_buckets,
                BucketOptions::mut_explicit_buckets,
                BucketOptions::set_explicit_buckets,
            ));
            oneofs.push(bucket_options::Options::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BucketOptions>(
                "Distribution.BucketOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BucketOptions {
        const NAME: &'static str = "BucketOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.options = ::std::option::Option::Some(bucket_options::Options::LinearBuckets(is.read_message()?));
                    },
                    18 => {
                        self.options = ::std::option::Option::Some(bucket_options::Options::ExponentialBuckets(is.read_message()?));
                    },
                    26 => {
                        self.options = ::std::option::Option::Some(bucket_options::Options::ExplicitBuckets(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.options {
                match v {
                    &bucket_options::Options::LinearBuckets(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &bucket_options::Options::ExponentialBuckets(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &bucket_options::Options::ExplicitBuckets(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.options {
                match v {
                    &bucket_options::Options::LinearBuckets(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &bucket_options::Options::ExponentialBuckets(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &bucket_options::Options::ExplicitBuckets(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BucketOptions {
            BucketOptions::new()
        }

        fn clear(&mut self) {
            self.options = ::std::option::Option::None;
            self.options = ::std::option::Option::None;
            self.options = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BucketOptions {
            static instance: BucketOptions = BucketOptions {
                options: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BucketOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Distribution.BucketOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BucketOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BucketOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `BucketOptions`
    pub mod bucket_options {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:google.api.Distribution.BucketOptions.options)
        pub enum Options {
            // @@protoc_insertion_point(oneof_field:google.api.Distribution.BucketOptions.linear_buckets)
            LinearBuckets(Linear),
            // @@protoc_insertion_point(oneof_field:google.api.Distribution.BucketOptions.exponential_buckets)
            ExponentialBuckets(Exponential),
            // @@protoc_insertion_point(oneof_field:google.api.Distribution.BucketOptions.explicit_buckets)
            ExplicitBuckets(Explicit),
        }

        impl ::protobuf::Oneof for Options {
        }

        impl ::protobuf::OneofFull for Options {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::BucketOptions as ::protobuf::MessageFull>::descriptor().oneof_by_name("options").unwrap()).clone()
            }
        }

        impl Options {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Options>("options")
            }
        }
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:google.api.Distribution.BucketOptions.Linear)
        pub struct Linear {
            // message fields
            ///  Must be greater than 0.
            // @@protoc_insertion_point(field:google.api.Distribution.BucketOptions.Linear.num_finite_buckets)
            pub num_finite_buckets: i32,
            ///  Must be greater than 0.
            // @@protoc_insertion_point(field:google.api.Distribution.BucketOptions.Linear.width)
            pub width: f64,
            ///  Lower bound of the first bucket.
            // @@protoc_insertion_point(field:google.api.Distribution.BucketOptions.Linear.offset)
            pub offset: f64,
            // special fields
            // @@protoc_insertion_point(special_field:google.api.Distribution.BucketOptions.Linear.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Linear {
            fn default() -> &'a Linear {
                <Linear as ::protobuf::Message>::default_instance()
            }
        }

        impl Linear {
            pub fn new() -> Linear {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "num_finite_buckets",
                    |m: &Linear| { &m.num_finite_buckets },
                    |m: &mut Linear| { &mut m.num_finite_buckets },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "width",
                    |m: &Linear| { &m.width },
                    |m: &mut Linear| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "offset",
                    |m: &Linear| { &m.offset },
                    |m: &mut Linear| { &mut m.offset },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Linear>(
                    "Distribution.BucketOptions.Linear",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Linear {
            const NAME: &'static str = "Linear";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.num_finite_buckets = is.read_int32()?;
                        },
                        17 => {
                            self.width = is.read_double()?;
                        },
                        25 => {
                            self.offset = is.read_double()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.num_finite_buckets != 0 {
                    my_size += ::protobuf::rt::int32_size(1, self.num_finite_buckets);
                }
                if self.width != 0. {
                    my_size += 1 + 8;
                }
                if self.offset != 0. {
                    my_size += 1 + 8;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.num_finite_buckets != 0 {
                    os.write_int32(1, self.num_finite_buckets)?;
                }
                if self.width != 0. {
                    os.write_double(2, self.width)?;
                }
                if self.offset != 0. {
                    os.write_double(3, self.offset)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Linear {
                Linear::new()
            }

            fn clear(&mut self) {
                self.num_finite_buckets = 0;
                self.width = 0.;
                self.offset = 0.;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Linear {
                static instance: Linear = Linear {
                    num_finite_buckets: 0,
                    width: 0.,
                    offset: 0.,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Linear {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Distribution.BucketOptions.Linear").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Linear {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Linear {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:google.api.Distribution.BucketOptions.Exponential)
        pub struct Exponential {
            // message fields
            ///  Must be greater than 0.
            // @@protoc_insertion_point(field:google.api.Distribution.BucketOptions.Exponential.num_finite_buckets)
            pub num_finite_buckets: i32,
            ///  Must be greater than 1.
            // @@protoc_insertion_point(field:google.api.Distribution.BucketOptions.Exponential.growth_factor)
            pub growth_factor: f64,
            ///  Must be greater than 0.
            // @@protoc_insertion_point(field:google.api.Distribution.BucketOptions.Exponential.scale)
            pub scale: f64,
            // special fields
            // @@protoc_insertion_point(special_field:google.api.Distribution.BucketOptions.Exponential.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Exponential {
            fn default() -> &'a Exponential {
                <Exponential as ::protobuf::Message>::default_instance()
            }
        }

        impl Exponential {
            pub fn new() -> Exponential {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "num_finite_buckets",
                    |m: &Exponential| { &m.num_finite_buckets },
                    |m: &mut Exponential| { &mut m.num_finite_buckets },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "growth_factor",
                    |m: &Exponential| { &m.growth_factor },
                    |m: &mut Exponential| { &mut m.growth_factor },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "scale",
                    |m: &Exponential| { &m.scale },
                    |m: &mut Exponential| { &mut m.scale },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exponential>(
                    "Distribution.BucketOptions.Exponential",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Exponential {
            const NAME: &'static str = "Exponential";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.num_finite_buckets = is.read_int32()?;
                        },
                        17 => {
                            self.growth_factor = is.read_double()?;
                        },
                        25 => {
                            self.scale = is.read_double()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.num_finite_buckets != 0 {
                    my_size += ::protobuf::rt::int32_size(1, self.num_finite_buckets);
                }
                if self.growth_factor != 0. {
                    my_size += 1 + 8;
                }
                if self.scale != 0. {
                    my_size += 1 + 8;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.num_finite_buckets != 0 {
                    os.write_int32(1, self.num_finite_buckets)?;
                }
                if self.growth_factor != 0. {
                    os.write_double(2, self.growth_factor)?;
                }
                if self.scale != 0. {
                    os.write_double(3, self.scale)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Exponential {
                Exponential::new()
            }

            fn clear(&mut self) {
                self.num_finite_buckets = 0;
                self.growth_factor = 0.;
                self.scale = 0.;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Exponential {
                static instance: Exponential = Exponential {
                    num_finite_buckets: 0,
                    growth_factor: 0.,
                    scale: 0.,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Exponential {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Distribution.BucketOptions.Exponential").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Exponential {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Exponential {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:google.api.Distribution.BucketOptions.Explicit)
        pub struct Explicit {
            // message fields
            ///  The values must be monotonically increasing.
            // @@protoc_insertion_point(field:google.api.Distribution.BucketOptions.Explicit.bounds)
            pub bounds: ::std::vec::Vec<f64>,
            // special fields
            // @@protoc_insertion_point(special_field:google.api.Distribution.BucketOptions.Explicit.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Explicit {
            fn default() -> &'a Explicit {
                <Explicit as ::protobuf::Message>::default_instance()
            }
        }

        impl Explicit {
            pub fn new() -> Explicit {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "bounds",
                    |m: &Explicit| { &m.bounds },
                    |m: &mut Explicit| { &mut m.bounds },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Explicit>(
                    "Distribution.BucketOptions.Explicit",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Explicit {
            const NAME: &'static str = "Explicit";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            is.read_repeated_packed_double_into(&mut self.bounds)?;
                        },
                        9 => {
                            self.bounds.push(is.read_double()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += 9 * self.bounds.len() as u64;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.bounds {
                    os.write_double(1, *v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Explicit {
                Explicit::new()
            }

            fn clear(&mut self) {
                self.bounds.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Explicit {
                static instance: Explicit = Explicit {
                    bounds: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Explicit {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Distribution.BucketOptions.Explicit").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Explicit {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Explicit {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    ///  Exemplars are example points that may be used to annotate aggregated
    ///  distribution values. They are metadata that gives information about a
    ///  particular value added to a Distribution bucket, such as a trace ID that
    ///  was active when a value was added. They may contain further information,
    ///  such as a example values and timestamps, origin, etc.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.api.Distribution.Exemplar)
    pub struct Exemplar {
        // message fields
        ///  Value of the exemplar point. This value determines to which bucket the
        ///  exemplar belongs.
        // @@protoc_insertion_point(field:google.api.Distribution.Exemplar.value)
        pub value: f64,
        ///  The observation (sampling) time of the above value.
        // @@protoc_insertion_point(field:google.api.Distribution.Exemplar.timestamp)
        pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
        // @@protoc_insertion_point(field:google.api.Distribution.Exemplar.attachments)
        pub attachments: ::std::vec::Vec<::protobuf::well_known_types::any::Any>,
        // special fields
        // @@protoc_insertion_point(special_field:google.api.Distribution.Exemplar.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Exemplar {
        fn default() -> &'a Exemplar {
            <Exemplar as ::protobuf::Message>::default_instance()
        }
    }

    impl Exemplar {
        pub fn new() -> Exemplar {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &Exemplar| { &m.value },
                |m: &mut Exemplar| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                "timestamp",
                |m: &Exemplar| { &m.timestamp },
                |m: &mut Exemplar| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "attachments",
                |m: &Exemplar| { &m.attachments },
                |m: &mut Exemplar| { &mut m.attachments },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exemplar>(
                "Distribution.Exemplar",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Exemplar {
        const NAME: &'static str = "Exemplar";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.value = is.read_double()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                    },
                    26 => {
                        self.attachments.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != 0. {
                my_size += 1 + 8;
            }
            if let Some(v) = self.timestamp.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.attachments {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != 0. {
                os.write_double(1, self.value)?;
            }
            if let Some(v) = self.timestamp.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.attachments {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Exemplar {
            Exemplar::new()
        }

        fn clear(&mut self) {
            self.value = 0.;
            self.timestamp.clear();
            self.attachments.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Exemplar {
            static instance: Exemplar = Exemplar {
                value: 0.,
                timestamp: ::protobuf::MessageField::none(),
                attachments: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Exemplar {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Distribution.Exemplar").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Exemplar {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Exemplar {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dgoogle/api/distribution.proto\x12\ngoogle.api\x1a\x19google/protob\
    uf/any.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xda\x08\n\x0cDistr\
    ibution\x12\x14\n\x05count\x18\x01\x20\x01(\x03R\x05count\x12\x12\n\x04m\
    ean\x18\x02\x20\x01(\x01R\x04mean\x127\n\x18sum_of_squared_deviation\x18\
    \x03\x20\x01(\x01R\x15sumOfSquaredDeviation\x124\n\x05range\x18\x04\x20\
    \x01(\x0b2\x1e.google.api.Distribution.RangeR\x05range\x12M\n\x0ebucket_\
    options\x18\x06\x20\x01(\x0b2&.google.api.Distribution.BucketOptionsR\rb\
    ucketOptions\x12#\n\rbucket_counts\x18\x07\x20\x03(\x03R\x0cbucketCounts\
    \x12?\n\texemplars\x18\n\x20\x03(\x0b2!.google.api.Distribution.Exemplar\
    R\texemplars\x1a+\n\x05Range\x12\x10\n\x03min\x18\x01\x20\x01(\x01R\x03m\
    in\x12\x10\n\x03max\x18\x02\x20\x01(\x01R\x03max\x1a\xb9\x04\n\rBucketOp\
    tions\x12V\n\x0elinear_buckets\x18\x01\x20\x01(\x0b2-.google.api.Distrib\
    ution.BucketOptions.LinearH\0R\rlinearBuckets\x12e\n\x13exponential_buck\
    ets\x18\x02\x20\x01(\x0b22.google.api.Distribution.BucketOptions.Exponen\
    tialH\0R\x12exponentialBuckets\x12\\\n\x10explicit_buckets\x18\x03\x20\
    \x01(\x0b2/.google.api.Distribution.BucketOptions.ExplicitH\0R\x0fexplic\
    itBuckets\x1ad\n\x06Linear\x12,\n\x12num_finite_buckets\x18\x01\x20\x01(\
    \x05R\x10numFiniteBuckets\x12\x14\n\x05width\x18\x02\x20\x01(\x01R\x05wi\
    dth\x12\x16\n\x06offset\x18\x03\x20\x01(\x01R\x06offset\x1av\n\x0bExpone\
    ntial\x12,\n\x12num_finite_buckets\x18\x01\x20\x01(\x05R\x10numFiniteBuc\
    kets\x12#\n\rgrowth_factor\x18\x02\x20\x01(\x01R\x0cgrowthFactor\x12\x14\
    \n\x05scale\x18\x03\x20\x01(\x01R\x05scale\x1a\"\n\x08Explicit\x12\x16\n\
    \x06bounds\x18\x01\x20\x03(\x01R\x06boundsB\t\n\x07options\x1a\x92\x01\n\
    \x08Exemplar\x12\x14\n\x05value\x18\x01\x20\x01(\x01R\x05value\x128\n\tt\
    imestamp\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ttimestamp\
    \x126\n\x0battachments\x18\x03\x20\x03(\x0b2\x14.google.protobuf.AnyR\
    \x0battachmentsBq\n\x0ecom.google.apiB\x11DistributionProtoP\x01ZCgoogle\
    .golang.org/genproto/googleapis/api/distribution;distribution\xa2\x02\
    \x04GAPIJ\x81D\n\x07\x12\x05\x0f\0\xd3\x01\x01\n\xbe\x04\n\x01\x0c\x12\
    \x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20LLC.\n\n\x20Li\
    censed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\
    \x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20excep\
    t\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obta\
    in\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20htt\
    p://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\
    \x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20softwar\
    e\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\n\x08\n\x01\x02\x12\x03\x11\0\x13\n\t\n\x02\x03\0\x12\x03\x13\0#\n\
    \t\n\x02\x03\x01\x12\x03\x14\0)\n\x08\n\x01\x08\x12\x03\x16\0Z\n\t\n\x02\
    \x08\x0b\x12\x03\x16\0Z\n\x08\n\x01\x08\x12\x03\x17\0\"\n\t\n\x02\x08\n\
    \x12\x03\x17\0\"\n\x08\n\x01\x08\x12\x03\x18\02\n\t\n\x02\x08\x08\x12\
    \x03\x18\02\n\x08\n\x01\x08\x12\x03\x19\0'\n\t\n\x02\x08\x01\x12\x03\x19\
    \0'\n\x08\n\x01\x08\x12\x03\x1a\0\"\n\t\n\x02\x08$\x12\x03\x1a\0\"\n\xaa\
    \x06\n\x02\x04\0\x12\x05*\0\xd3\x01\x01\x1a\x9c\x06\x20`Distribution`\
    \x20contains\x20summary\x20statistics\x20for\x20a\x20population\x20of\
    \x20values.\x20It\n\x20optionally\x20contains\x20a\x20histogram\x20repre\
    senting\x20the\x20distribution\x20of\x20those\x20values\n\x20across\x20a\
    \x20set\x20of\x20buckets.\n\n\x20The\x20summary\x20statistics\x20are\x20\
    the\x20count,\x20mean,\x20sum\x20of\x20the\x20squared\x20deviation\x20fr\
    om\n\x20the\x20mean,\x20the\x20minimum,\x20and\x20the\x20maximum\x20of\
    \x20the\x20set\x20of\x20population\x20of\x20values.\n\x20The\x20histogra\
    m\x20is\x20based\x20on\x20a\x20sequence\x20of\x20buckets\x20and\x20gives\
    \x20a\x20count\x20of\x20values\n\x20that\x20fall\x20into\x20each\x20buck\
    et.\x20The\x20boundaries\x20of\x20the\x20buckets\x20are\x20given\x20eith\
    er\n\x20explicitly\x20or\x20by\x20formulas\x20for\x20buckets\x20of\x20fi\
    xed\x20or\x20exponentially\x20increasing\n\x20widths.\n\n\x20Although\
    \x20it\x20is\x20not\x20forbidden,\x20it\x20is\x20generally\x20a\x20bad\
    \x20idea\x20to\x20include\n\x20non-finite\x20values\x20(infinities\x20or\
    \x20NaNs)\x20in\x20the\x20population\x20of\x20values,\x20as\x20this\n\
    \x20will\x20render\x20the\x20`mean`\x20and\x20`sum_of_squared_deviation`\
    \x20fields\x20meaningless.\n\n\n\n\x03\x04\0\x01\x12\x03*\x08\x14\n3\n\
    \x04\x04\0\x03\0\x12\x04,\x022\x03\x1a%\x20The\x20range\x20of\x20the\x20\
    population\x20values.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03,\n\x0f\n6\n\
    \x06\x04\0\x03\0\x02\0\x12\x03.\x04\x13\x1a'\x20The\x20minimum\x20of\x20\
    the\x20population\x20values.\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03\
    .\x04\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03.\x0b\x0e\n\x0e\n\x07\
    \x04\0\x03\0\x02\0\x03\x12\x03.\x11\x12\n6\n\x06\x04\0\x03\0\x02\x01\x12\
    \x031\x04\x13\x1a'\x20The\x20maximum\x20of\x20the\x20population\x20value\
    s.\n\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x031\x04\n\n\x0e\n\x07\x04\
    \0\x03\0\x02\x01\x01\x12\x031\x0b\x0e\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x03\x12\x031\x11\x12\n\xf3\x07\n\x04\x04\0\x03\x01\x12\x05C\x02\x87\x01\
    \x03\x1a\xe3\x07\x20`BucketOptions`\x20describes\x20the\x20bucket\x20bou\
    ndaries\x20used\x20to\x20create\x20a\x20histogram\n\x20for\x20the\x20dis\
    tribution.\x20The\x20buckets\x20can\x20be\x20in\x20a\x20linear\x20sequen\
    ce,\x20an\n\x20exponential\x20sequence,\x20or\x20each\x20bucket\x20can\
    \x20be\x20specified\x20explicitly.\n\x20`BucketOptions`\x20does\x20not\
    \x20include\x20the\x20number\x20of\x20values\x20in\x20each\x20bucket.\n\
    \n\x20A\x20bucket\x20has\x20an\x20inclusive\x20lower\x20bound\x20and\x20\
    exclusive\x20upper\x20bound\x20for\x20the\n\x20values\x20that\x20are\x20\
    counted\x20for\x20that\x20bucket.\x20The\x20upper\x20bound\x20of\x20a\
    \x20bucket\x20must\n\x20be\x20strictly\x20greater\x20than\x20the\x20lowe\
    r\x20bound.\x20The\x20sequence\x20of\x20N\x20buckets\x20for\x20a\n\x20di\
    stribution\x20consists\x20of\x20an\x20underflow\x20bucket\x20(number\x20\
    0),\x20zero\x20or\x20more\n\x20finite\x20buckets\x20(number\x201\x20thro\
    ugh\x20N\x20-\x202)\x20and\x20an\x20overflow\x20bucket\x20(number\x20N\
    \x20-\n\x201).\x20The\x20buckets\x20are\x20contiguous:\x20the\x20lower\
    \x20bound\x20of\x20bucket\x20i\x20(i\x20>\x200)\x20is\x20the\n\x20same\
    \x20as\x20the\x20upper\x20bound\x20of\x20bucket\x20i\x20-\x201.\x20The\
    \x20buckets\x20span\x20the\x20whole\x20range\n\x20of\x20finite\x20values\
    :\x20lower\x20bound\x20of\x20the\x20underflow\x20bucket\x20is\x20-infini\
    ty\x20and\x20the\n\x20upper\x20bound\x20of\x20the\x20overflow\x20bucket\
    \x20is\x20+infinity.\x20The\x20finite\x20buckets\x20are\n\x20so-called\
    \x20because\x20both\x20bounds\x20are\x20finite.\n\n\x0c\n\x05\x04\0\x03\
    \x01\x01\x12\x03C\n\x17\n\xae\x03\n\x06\x04\0\x03\x01\x03\0\x12\x04M\x04\
    V\x05\x1a\x9d\x03\x20Specifies\x20a\x20linear\x20sequence\x20of\x20bucke\
    ts\x20that\x20all\x20have\x20the\x20same\x20width\n\x20(except\x20overfl\
    ow\x20and\x20underflow).\x20Each\x20bucket\x20represents\x20a\x20constan\
    t\n\x20absolute\x20uncertainty\x20on\x20the\x20specific\x20value\x20in\
    \x20the\x20bucket.\n\n\x20There\x20are\x20`num_finite_buckets\x20+\x202`\
    \x20(=\x20N)\x20buckets.\x20Bucket\x20`i`\x20has\x20the\n\x20following\
    \x20boundaries:\n\n\x20\x20\x20\x20Upper\x20bound\x20(0\x20<=\x20i\x20<\
    \x20N-1):\x20\x20\x20\x20\x20offset\x20+\x20(width\x20*\x20i).\n\x20\x20\
    \x20\x20Lower\x20bound\x20(1\x20<=\x20i\x20<\x20N):\x20\x20\x20\x20\x20\
    \x20\x20offset\x20+\x20(width\x20*\x20(i\x20-\x201)).\n\n\x0e\n\x07\x04\
    \0\x03\x01\x03\0\x01\x12\x03M\x0c\x12\n*\n\x08\x04\0\x03\x01\x03\0\x02\0\
    \x12\x03O\x06#\x1a\x19\x20Must\x20be\x20greater\x20than\x200.\n\n\x10\n\
    \t\x04\0\x03\x01\x03\0\x02\0\x05\x12\x03O\x06\x0b\n\x10\n\t\x04\0\x03\
    \x01\x03\0\x02\0\x01\x12\x03O\x0c\x1e\n\x10\n\t\x04\0\x03\x01\x03\0\x02\
    \0\x03\x12\x03O!\"\n*\n\x08\x04\0\x03\x01\x03\0\x02\x01\x12\x03R\x06\x17\
    \x1a\x19\x20Must\x20be\x20greater\x20than\x200.\n\n\x10\n\t\x04\0\x03\
    \x01\x03\0\x02\x01\x05\x12\x03R\x06\x0c\n\x10\n\t\x04\0\x03\x01\x03\0\
    \x02\x01\x01\x12\x03R\r\x12\n\x10\n\t\x04\0\x03\x01\x03\0\x02\x01\x03\
    \x12\x03R\x15\x16\n3\n\x08\x04\0\x03\x01\x03\0\x02\x02\x12\x03U\x06\x18\
    \x1a\"\x20Lower\x20bound\x20of\x20the\x20first\x20bucket.\n\n\x10\n\t\
    \x04\0\x03\x01\x03\0\x02\x02\x05\x12\x03U\x06\x0c\n\x10\n\t\x04\0\x03\
    \x01\x03\0\x02\x02\x01\x12\x03U\r\x13\n\x10\n\t\x04\0\x03\x01\x03\0\x02\
    \x02\x03\x12\x03U\x16\x17\n\xca\x03\n\x06\x04\0\x03\x01\x03\x01\x12\x04a\
    \x04j\x05\x1a\xb9\x03\x20Specifies\x20an\x20exponential\x20sequence\x20o\
    f\x20buckets\x20that\x20have\x20a\x20width\x20that\x20is\n\x20proportion\
    al\x20to\x20the\x20value\x20of\x20the\x20lower\x20bound.\x20Each\x20buck\
    et\x20represents\x20a\n\x20constant\x20relative\x20uncertainty\x20on\x20\
    a\x20specific\x20value\x20in\x20the\x20bucket.\n\n\x20There\x20are\x20`n\
    um_finite_buckets\x20+\x202`\x20(=\x20N)\x20buckets.\x20Bucket\x20`i`\
    \x20has\x20the\n\x20following\x20boundaries:\n\n\x20\x20\x20\x20Upper\
    \x20bound\x20(0\x20<=\x20i\x20<\x20N-1):\x20\x20\x20\x20\x20scale\x20*\
    \x20(growth_factor\x20^\x20i).\n\x20\x20\x20\x20Lower\x20bound\x20(1\x20\
    <=\x20i\x20<\x20N):\x20\x20\x20\x20\x20\x20\x20scale\x20*\x20(growth_fac\
    tor\x20^\x20(i\x20-\x201)).\n\n\x0e\n\x07\x04\0\x03\x01\x03\x01\x01\x12\
    \x03a\x0c\x17\n*\n\x08\x04\0\x03\x01\x03\x01\x02\0\x12\x03c\x06#\x1a\x19\
    \x20Must\x20be\x20greater\x20than\x200.\n\n\x10\n\t\x04\0\x03\x01\x03\
    \x01\x02\0\x05\x12\x03c\x06\x0b\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\0\
    \x01\x12\x03c\x0c\x1e\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\0\x03\x12\x03c\
    !\"\n*\n\x08\x04\0\x03\x01\x03\x01\x02\x01\x12\x03f\x06\x1f\x1a\x19\x20M\
    ust\x20be\x20greater\x20than\x201.\n\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\
    \x01\x05\x12\x03f\x06\x0c\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\x01\x01\
    \x12\x03f\r\x1a\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\x01\x03\x12\x03f\x1d\
    \x1e\n*\n\x08\x04\0\x03\x01\x03\x01\x02\x02\x12\x03i\x06\x17\x1a\x19\x20\
    Must\x20be\x20greater\x20than\x200.\n\n\x10\n\t\x04\0\x03\x01\x03\x01\
    \x02\x02\x05\x12\x03i\x06\x0c\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\x02\
    \x01\x12\x03i\r\x12\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\x02\x03\x12\x03i\
    \x15\x16\n\xd1\x03\n\x06\x04\0\x03\x01\x03\x02\x12\x04w\x04z\x05\x1a\xc0\
    \x03\x20Specifies\x20a\x20set\x20of\x20buckets\x20with\x20arbitrary\x20w\
    idths.\n\n\x20There\x20are\x20`size(bounds)\x20+\x201`\x20(=\x20N)\x20bu\
    ckets.\x20Bucket\x20`i`\x20has\x20the\x20following\n\x20boundaries:\n\n\
    \x20\x20\x20\x20Upper\x20bound\x20(0\x20<=\x20i\x20<\x20N-1):\x20\x20\
    \x20\x20\x20bounds[i]\n\x20\x20\x20\x20Lower\x20bound\x20(1\x20<=\x20i\
    \x20<\x20N);\x20\x20\x20\x20\x20\x20\x20bounds[i\x20-\x201]\n\n\x20The\
    \x20`bounds`\x20field\x20must\x20contain\x20at\x20least\x20one\x20elemen\
    t.\x20If\x20`bounds`\x20has\n\x20only\x20one\x20element,\x20then\x20ther\
    e\x20are\x20no\x20finite\x20buckets,\x20and\x20that\x20single\n\x20eleme\
    nt\x20is\x20the\x20common\x20boundary\x20of\x20the\x20overflow\x20and\
    \x20underflow\x20buckets.\n\n\x0e\n\x07\x04\0\x03\x01\x03\x02\x01\x12\
    \x03w\x0c\x14\n?\n\x08\x04\0\x03\x01\x03\x02\x02\0\x12\x03y\x06!\x1a.\
    \x20The\x20values\x20must\x20be\x20monotonically\x20increasing.\n\n\x10\
    \n\t\x04\0\x03\x01\x03\x02\x02\0\x04\x12\x03y\x06\x0e\n\x10\n\t\x04\0\
    \x03\x01\x03\x02\x02\0\x05\x12\x03y\x0f\x15\n\x10\n\t\x04\0\x03\x01\x03\
    \x02\x02\0\x01\x12\x03y\x16\x1c\n\x10\n\t\x04\0\x03\x01\x03\x02\x02\0\
    \x03\x12\x03y\x1f\x20\nA\n\x06\x04\0\x03\x01\x08\0\x12\x05}\x04\x86\x01\
    \x05\x1a0\x20Exactly\x20one\x20of\x20these\x20three\x20fields\x20must\
    \x20be\x20set.\n\n\x0e\n\x07\x04\0\x03\x01\x08\0\x01\x12\x03}\n\x11\n#\n\
    \x06\x04\0\x03\x01\x02\0\x12\x03\x7f\x06\x20\x1a\x14\x20The\x20linear\
    \x20bucket.\n\n\x0e\n\x07\x04\0\x03\x01\x02\0\x06\x12\x03\x7f\x06\x0c\n\
    \x0e\n\x07\x04\0\x03\x01\x02\0\x01\x12\x03\x7f\r\x1b\n\x0e\n\x07\x04\0\
    \x03\x01\x02\0\x03\x12\x03\x7f\x1e\x1f\n*\n\x06\x04\0\x03\x01\x02\x01\
    \x12\x04\x82\x01\x06*\x1a\x1a\x20The\x20exponential\x20buckets.\n\n\x0f\
    \n\x07\x04\0\x03\x01\x02\x01\x06\x12\x04\x82\x01\x06\x11\n\x0f\n\x07\x04\
    \0\x03\x01\x02\x01\x01\x12\x04\x82\x01\x12%\n\x0f\n\x07\x04\0\x03\x01\
    \x02\x01\x03\x12\x04\x82\x01()\n'\n\x06\x04\0\x03\x01\x02\x02\x12\x04\
    \x85\x01\x06$\x1a\x17\x20The\x20explicit\x20buckets.\n\n\x0f\n\x07\x04\0\
    \x03\x01\x02\x02\x06\x12\x04\x85\x01\x06\x0e\n\x0f\n\x07\x04\0\x03\x01\
    \x02\x02\x01\x12\x04\x85\x01\x0f\x1f\n\x0f\n\x07\x04\0\x03\x01\x02\x02\
    \x03\x12\x04\x85\x01\"#\n\xe9\x02\n\x04\x04\0\x03\x02\x12\x06\x8e\x01\
    \x02\xa2\x01\x03\x1a\xd8\x02\x20Exemplars\x20are\x20example\x20points\
    \x20that\x20may\x20be\x20used\x20to\x20annotate\x20aggregated\n\x20distr\
    ibution\x20values.\x20They\x20are\x20metadata\x20that\x20gives\x20inform\
    ation\x20about\x20a\n\x20particular\x20value\x20added\x20to\x20a\x20Dist\
    ribution\x20bucket,\x20such\x20as\x20a\x20trace\x20ID\x20that\n\x20was\
    \x20active\x20when\x20a\x20value\x20was\x20added.\x20They\x20may\x20cont\
    ain\x20further\x20information,\n\x20such\x20as\x20a\x20example\x20values\
    \x20and\x20timestamps,\x20origin,\x20etc.\n\n\r\n\x05\x04\0\x03\x02\x01\
    \x12\x04\x8e\x01\n\x12\nk\n\x06\x04\0\x03\x02\x02\0\x12\x04\x91\x01\x04\
    \x15\x1a[\x20Value\x20of\x20the\x20exemplar\x20point.\x20This\x20value\
    \x20determines\x20to\x20which\x20bucket\x20the\n\x20exemplar\x20belongs.\
    \n\n\x0f\n\x07\x04\0\x03\x02\x02\0\x05\x12\x04\x91\x01\x04\n\n\x0f\n\x07\
    \x04\0\x03\x02\x02\0\x01\x12\x04\x91\x01\x0b\x10\n\x0f\n\x07\x04\0\x03\
    \x02\x02\0\x03\x12\x04\x91\x01\x13\x14\nE\n\x06\x04\0\x03\x02\x02\x01\
    \x12\x04\x94\x01\x04,\x1a5\x20The\x20observation\x20(sampling)\x20time\
    \x20of\x20the\x20above\x20value.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x06\
    \x12\x04\x94\x01\x04\x1d\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x01\x12\x04\
    \x94\x01\x1e'\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x03\x12\x04\x94\x01*+\n\
    \xb4\x03\n\x06\x04\0\x03\x02\x02\x02\x12\x04\xa1\x01\x041\x1a\xa3\x03\
    \x20Contextual\x20information\x20about\x20the\x20example\x20value.\x20Ex\
    amples\x20are:\n\n\x20\x20\x20Trace:\x20type.googleapis.com/google.monit\
    oring.v3.SpanContext\n\n\x20\x20\x20Literal\x20string:\x20type.googleapi\
    s.com/google.protobuf.StringValue\n\n\x20\x20\x20Labels\x20dropped\x20du\
    ring\x20aggregation:\n\x20\x20\x20\x20\x20type.googleapis.com/google.mon\
    itoring.v3.DroppedLabels\n\n\x20There\x20may\x20be\x20only\x20a\x20singl\
    e\x20attachment\x20of\x20any\x20given\x20message\x20type\x20in\x20a\n\
    \x20single\x20exemplar,\x20and\x20this\x20is\x20enforced\x20by\x20the\
    \x20system.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x04\x12\x04\xa1\x01\x04\
    \x0c\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x06\x12\x04\xa1\x01\r\x20\n\x0f\n\
    \x07\x04\0\x03\x02\x02\x02\x01\x12\x04\xa1\x01!,\n\x0f\n\x07\x04\0\x03\
    \x02\x02\x02\x03\x12\x04\xa1\x01/0\n\xab\x01\n\x04\x04\0\x02\0\x12\x04\
    \xa7\x01\x02\x12\x1a\x9c\x01\x20The\x20number\x20of\x20values\x20in\x20t\
    he\x20population.\x20Must\x20be\x20non-negative.\x20This\x20value\n\x20m\
    ust\x20equal\x20the\x20sum\x20of\x20the\x20values\x20in\x20`bucket_count\
    s`\x20if\x20a\x20histogram\x20is\n\x20provided.\n\n\r\n\x05\x04\0\x02\0\
    \x05\x12\x04\xa7\x01\x02\x07\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xa7\x01\
    \x08\r\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xa7\x01\x10\x11\nv\n\x04\x04\0\
    \x02\x01\x12\x04\xab\x01\x02\x12\x1ah\x20The\x20arithmetic\x20mean\x20of\
    \x20the\x20values\x20in\x20the\x20population.\x20If\x20`count`\x20is\x20\
    zero\n\x20then\x20this\x20field\x20must\x20be\x20zero.\n\n\r\n\x05\x04\0\
    \x02\x01\x05\x12\x04\xab\x01\x02\x08\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\
    \xab\x01\t\r\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xab\x01\x10\x11\n\xd8\
    \x02\n\x04\x04\0\x02\x02\x12\x04\xb6\x01\x02&\x1a\xc9\x02\x20The\x20sum\
    \x20of\x20squared\x20deviations\x20from\x20the\x20mean\x20of\x20the\x20v\
    alues\x20in\x20the\n\x20population.\x20For\x20values\x20x_i\x20this\x20i\
    s:\n\n\x20\x20\x20\x20\x20Sum[i=1..n]((x_i\x20-\x20mean)^2)\n\n\x20Knuth\
    ,\x20\"The\x20Art\x20of\x20Computer\x20Programming\",\x20Vol.\x202,\x20p\
    age\x20323,\x203rd\x20edition\n\x20describes\x20Welford's\x20method\x20f\
    or\x20accumulating\x20this\x20sum\x20in\x20one\x20pass.\n\n\x20If\x20`co\
    unt`\x20is\x20zero\x20then\x20this\x20field\x20must\x20be\x20zero.\n\n\r\
    \n\x05\x04\0\x02\x02\x05\x12\x04\xb6\x01\x02\x08\n\r\n\x05\x04\0\x02\x02\
    \x01\x12\x04\xb6\x01\t!\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xb6\x01$%\n\
    \x81\x01\n\x04\x04\0\x02\x03\x12\x04\xba\x01\x02\x12\x1as\x20If\x20speci\
    fied,\x20contains\x20the\x20range\x20of\x20the\x20population\x20values.\
    \x20The\x20field\n\x20must\x20not\x20be\x20present\x20if\x20the\x20`coun\
    t`\x20is\x20zero.\n\n\r\n\x05\x04\0\x02\x03\x06\x12\x04\xba\x01\x02\x07\
    \n\r\n\x05\x04\0\x02\x03\x01\x12\x04\xba\x01\x08\r\n\r\n\x05\x04\0\x02\
    \x03\x03\x12\x04\xba\x01\x10\x11\n\x81\x01\n\x04\x04\0\x02\x04\x12\x04\
    \xbe\x01\x02#\x1as\x20Defines\x20the\x20histogram\x20bucket\x20boundarie\
    s.\x20If\x20the\x20distribution\x20does\x20not\n\x20contain\x20a\x20hist\
    ogram,\x20then\x20omit\x20this\x20field.\n\n\r\n\x05\x04\0\x02\x04\x06\
    \x12\x04\xbe\x01\x02\x0f\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\xbe\x01\x10\
    \x1e\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xbe\x01!\"\n\xe7\x06\n\x04\x04\
    \0\x02\x05\x12\x04\xcf\x01\x02#\x1a\xd8\x06\x20The\x20number\x20of\x20va\
    lues\x20in\x20each\x20bucket\x20of\x20the\x20histogram,\x20as\x20describ\
    ed\x20in\n\x20`bucket_options`.\x20If\x20the\x20distribution\x20does\x20\
    not\x20have\x20a\x20histogram,\x20then\x20omit\n\x20this\x20field.\x20If\
    \x20there\x20is\x20a\x20histogram,\x20then\x20the\x20sum\x20of\x20the\
    \x20values\x20in\n\x20`bucket_counts`\x20must\x20equal\x20the\x20value\
    \x20in\x20the\x20`count`\x20field\x20of\x20the\n\x20distribution.\n\n\
    \x20If\x20present,\x20`bucket_counts`\x20should\x20contain\x20N\x20value\
    s,\x20where\x20N\x20is\x20the\x20number\n\x20of\x20buckets\x20specified\
    \x20in\x20`bucket_options`.\x20If\x20you\x20supply\x20fewer\x20than\x20N\
    \n\x20values,\x20the\x20remaining\x20values\x20are\x20assumed\x20to\x20b\
    e\x200.\n\n\x20The\x20order\x20of\x20the\x20values\x20in\x20`bucket_coun\
    ts`\x20follows\x20the\x20bucket\x20numbering\n\x20schemes\x20described\
    \x20for\x20the\x20three\x20bucket\x20types.\x20The\x20first\x20value\x20\
    must\x20be\x20the\n\x20count\x20for\x20the\x20underflow\x20bucket\x20(nu\
    mber\x200).\x20The\x20next\x20N-2\x20values\x20are\x20the\n\x20counts\
    \x20for\x20the\x20finite\x20buckets\x20(number\x201\x20through\x20N-2).\
    \x20The\x20N'th\x20value\x20in\n\x20`bucket_counts`\x20is\x20the\x20coun\
    t\x20for\x20the\x20overflow\x20bucket\x20(number\x20N-1).\n\n\r\n\x05\
    \x04\0\x02\x05\x04\x12\x04\xcf\x01\x02\n\n\r\n\x05\x04\0\x02\x05\x05\x12\
    \x04\xcf\x01\x0b\x10\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xcf\x01\x11\x1e\
    \n\r\n\x05\x04\0\x02\x05\x03\x12\x04\xcf\x01!\"\n=\n\x04\x04\0\x02\x06\
    \x12\x04\xd2\x01\x02#\x1a/\x20Must\x20be\x20in\x20increasing\x20order\
    \x20of\x20`value`\x20field.\n\n\r\n\x05\x04\0\x02\x06\x04\x12\x04\xd2\
    \x01\x02\n\n\r\n\x05\x04\0\x02\x06\x06\x12\x04\xd2\x01\x0b\x13\n\r\n\x05\
    \x04\0\x02\x06\x01\x12\x04\xd2\x01\x14\x1d\n\r\n\x05\x04\0\x02\x06\x03\
    \x12\x04\xd2\x01\x20\"b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(Distribution::generated_message_descriptor_data());
            messages.push(distribution::Range::generated_message_descriptor_data());
            messages.push(distribution::BucketOptions::generated_message_descriptor_data());
            messages.push(distribution::Exemplar::generated_message_descriptor_data());
            messages.push(distribution::bucket_options::Linear::generated_message_descriptor_data());
            messages.push(distribution::bucket_options::Exponential::generated_message_descriptor_data());
            messages.push(distribution::bucket_options::Explicit::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
