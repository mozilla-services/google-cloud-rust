// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/identity/accesscontextmanager/v1/service_perimeter.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeter {
    // message fields
    pub name: ::std::string::String,
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub perimeter_type: ServicePerimeter_PerimeterType,
    pub status: ::protobuf::SingularPtrField<ServicePerimeterConfig>,
    pub spec: ::protobuf::SingularPtrField<ServicePerimeterConfig>,
    pub use_explicit_dry_run_spec: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeter {
    fn default() -> &'a ServicePerimeter {
        <ServicePerimeter as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeter {
    pub fn new() -> ServicePerimeter {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string title = 2;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp create_time = 4;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 5;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeter.PerimeterType perimeter_type = 6;


    pub fn get_perimeter_type(&self) -> ServicePerimeter_PerimeterType {
        self.perimeter_type
    }
    pub fn clear_perimeter_type(&mut self) {
        self.perimeter_type = ServicePerimeter_PerimeterType::PERIMETER_TYPE_REGULAR;
    }

    // Param is passed by value, moved
    pub fn set_perimeter_type(&mut self, v: ServicePerimeter_PerimeterType) {
        self.perimeter_type = v;
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig status = 7;


    pub fn get_status(&self) -> &ServicePerimeterConfig {
        self.status.as_ref().unwrap_or_else(|| <ServicePerimeterConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ServicePerimeterConfig) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ServicePerimeterConfig {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ServicePerimeterConfig {
        self.status.take().unwrap_or_else(|| ServicePerimeterConfig::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig spec = 8;


    pub fn get_spec(&self) -> &ServicePerimeterConfig {
        self.spec.as_ref().unwrap_or_else(|| <ServicePerimeterConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ServicePerimeterConfig) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ServicePerimeterConfig {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ServicePerimeterConfig {
        self.spec.take().unwrap_or_else(|| ServicePerimeterConfig::new())
    }

    // bool use_explicit_dry_run_spec = 9;


    pub fn get_use_explicit_dry_run_spec(&self) -> bool {
        self.use_explicit_dry_run_spec
    }
    pub fn clear_use_explicit_dry_run_spec(&mut self) {
        self.use_explicit_dry_run_spec = false;
    }

    // Param is passed by value, moved
    pub fn set_use_explicit_dry_run_spec(&mut self, v: bool) {
        self.use_explicit_dry_run_spec = v;
    }
}

impl ::protobuf::Message for ServicePerimeter {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.perimeter_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_explicit_dry_run_spec = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.perimeter_type != ServicePerimeter_PerimeterType::PERIMETER_TYPE_REGULAR {
            my_size += ::protobuf::rt::enum_size(6, self.perimeter_type);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.use_explicit_dry_run_spec != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.perimeter_type != ServicePerimeter_PerimeterType::PERIMETER_TYPE_REGULAR {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.perimeter_type))?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.use_explicit_dry_run_spec != false {
            os.write_bool(9, self.use_explicit_dry_run_spec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeter {
        ServicePerimeter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ServicePerimeter| { &m.name },
                |m: &mut ServicePerimeter| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ServicePerimeter| { &m.title },
                |m: &mut ServicePerimeter| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ServicePerimeter| { &m.description },
                |m: &mut ServicePerimeter| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &ServicePerimeter| { &m.create_time },
                |m: &mut ServicePerimeter| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &ServicePerimeter| { &m.update_time },
                |m: &mut ServicePerimeter| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServicePerimeter_PerimeterType>>(
                "perimeter_type",
                |m: &ServicePerimeter| { &m.perimeter_type },
                |m: &mut ServicePerimeter| { &mut m.perimeter_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig>>(
                "status",
                |m: &ServicePerimeter| { &m.status },
                |m: &mut ServicePerimeter| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig>>(
                "spec",
                |m: &ServicePerimeter| { &m.spec },
                |m: &mut ServicePerimeter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_explicit_dry_run_spec",
                |m: &ServicePerimeter| { &m.use_explicit_dry_run_spec },
                |m: &mut ServicePerimeter| { &mut m.use_explicit_dry_run_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeter>(
                "ServicePerimeter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeter {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeter::new)
    }
}

impl ::protobuf::Clear for ServicePerimeter {
    fn clear(&mut self) {
        self.name.clear();
        self.title.clear();
        self.description.clear();
        self.create_time.clear();
        self.update_time.clear();
        self.perimeter_type = ServicePerimeter_PerimeterType::PERIMETER_TYPE_REGULAR;
        self.status.clear();
        self.spec.clear();
        self.use_explicit_dry_run_spec = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServicePerimeter_PerimeterType {
    PERIMETER_TYPE_REGULAR = 0,
    PERIMETER_TYPE_BRIDGE = 1,
}

impl ::protobuf::ProtobufEnum for ServicePerimeter_PerimeterType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServicePerimeter_PerimeterType> {
        match value {
            0 => ::std::option::Option::Some(ServicePerimeter_PerimeterType::PERIMETER_TYPE_REGULAR),
            1 => ::std::option::Option::Some(ServicePerimeter_PerimeterType::PERIMETER_TYPE_BRIDGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServicePerimeter_PerimeterType] = &[
            ServicePerimeter_PerimeterType::PERIMETER_TYPE_REGULAR,
            ServicePerimeter_PerimeterType::PERIMETER_TYPE_BRIDGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ServicePerimeter_PerimeterType>("ServicePerimeter.PerimeterType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ServicePerimeter_PerimeterType {
}

impl ::std::default::Default for ServicePerimeter_PerimeterType {
    fn default() -> Self {
        ServicePerimeter_PerimeterType::PERIMETER_TYPE_REGULAR
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeter_PerimeterType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig {
    // message fields
    pub resources: ::protobuf::RepeatedField<::std::string::String>,
    pub access_levels: ::protobuf::RepeatedField<::std::string::String>,
    pub restricted_services: ::protobuf::RepeatedField<::std::string::String>,
    pub vpc_accessible_services: ::protobuf::SingularPtrField<ServicePerimeterConfig_VpcAccessibleServices>,
    pub ingress_policies: ::protobuf::RepeatedField<ServicePerimeterConfig_IngressPolicy>,
    pub egress_policies: ::protobuf::RepeatedField<ServicePerimeterConfig_EgressPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig {
    fn default() -> &'a ServicePerimeterConfig {
        <ServicePerimeterConfig as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig {
    pub fn new() -> ServicePerimeterConfig {
        ::std::default::Default::default()
    }

    // repeated string resources = 1;


    pub fn get_resources(&self) -> &[::std::string::String] {
        &self.resources
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    // repeated string access_levels = 2;


    pub fn get_access_levels(&self) -> &[::std::string::String] {
        &self.access_levels
    }
    pub fn clear_access_levels(&mut self) {
        self.access_levels.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_levels(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.access_levels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_access_levels(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.access_levels
    }

    // Take field
    pub fn take_access_levels(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.access_levels, ::protobuf::RepeatedField::new())
    }

    // repeated string restricted_services = 4;


    pub fn get_restricted_services(&self) -> &[::std::string::String] {
        &self.restricted_services
    }
    pub fn clear_restricted_services(&mut self) {
        self.restricted_services.clear();
    }

    // Param is passed by value, moved
    pub fn set_restricted_services(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.restricted_services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_restricted_services(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.restricted_services
    }

    // Take field
    pub fn take_restricted_services(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.restricted_services, ::protobuf::RepeatedField::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.VpcAccessibleServices vpc_accessible_services = 10;


    pub fn get_vpc_accessible_services(&self) -> &ServicePerimeterConfig_VpcAccessibleServices {
        self.vpc_accessible_services.as_ref().unwrap_or_else(|| <ServicePerimeterConfig_VpcAccessibleServices as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vpc_accessible_services(&mut self) {
        self.vpc_accessible_services.clear();
    }

    pub fn has_vpc_accessible_services(&self) -> bool {
        self.vpc_accessible_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vpc_accessible_services(&mut self, v: ServicePerimeterConfig_VpcAccessibleServices) {
        self.vpc_accessible_services = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vpc_accessible_services(&mut self) -> &mut ServicePerimeterConfig_VpcAccessibleServices {
        if self.vpc_accessible_services.is_none() {
            self.vpc_accessible_services.set_default();
        }
        self.vpc_accessible_services.as_mut().unwrap()
    }

    // Take field
    pub fn take_vpc_accessible_services(&mut self) -> ServicePerimeterConfig_VpcAccessibleServices {
        self.vpc_accessible_services.take().unwrap_or_else(|| ServicePerimeterConfig_VpcAccessibleServices::new())
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy ingress_policies = 8;


    pub fn get_ingress_policies(&self) -> &[ServicePerimeterConfig_IngressPolicy] {
        &self.ingress_policies
    }
    pub fn clear_ingress_policies(&mut self) {
        self.ingress_policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress_policies(&mut self, v: ::protobuf::RepeatedField<ServicePerimeterConfig_IngressPolicy>) {
        self.ingress_policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress_policies(&mut self) -> &mut ::protobuf::RepeatedField<ServicePerimeterConfig_IngressPolicy> {
        &mut self.ingress_policies
    }

    // Take field
    pub fn take_ingress_policies(&mut self) -> ::protobuf::RepeatedField<ServicePerimeterConfig_IngressPolicy> {
        ::std::mem::replace(&mut self.ingress_policies, ::protobuf::RepeatedField::new())
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy egress_policies = 9;


    pub fn get_egress_policies(&self) -> &[ServicePerimeterConfig_EgressPolicy] {
        &self.egress_policies
    }
    pub fn clear_egress_policies(&mut self) {
        self.egress_policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_egress_policies(&mut self, v: ::protobuf::RepeatedField<ServicePerimeterConfig_EgressPolicy>) {
        self.egress_policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_egress_policies(&mut self) -> &mut ::protobuf::RepeatedField<ServicePerimeterConfig_EgressPolicy> {
        &mut self.egress_policies
    }

    // Take field
    pub fn take_egress_policies(&mut self) -> ::protobuf::RepeatedField<ServicePerimeterConfig_EgressPolicy> {
        ::std::mem::replace(&mut self.egress_policies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServicePerimeterConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.vpc_accessible_services {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ingress_policies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.egress_policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.resources)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.access_levels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.restricted_services)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vpc_accessible_services)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ingress_policies)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.egress_policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.access_levels {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.restricted_services {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.vpc_accessible_services.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ingress_policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.egress_policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resources {
            os.write_string(1, &v)?;
        };
        for v in &self.access_levels {
            os.write_string(2, &v)?;
        };
        for v in &self.restricted_services {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.vpc_accessible_services.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ingress_policies {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.egress_policies {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig {
        ServicePerimeterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resources",
                |m: &ServicePerimeterConfig| { &m.resources },
                |m: &mut ServicePerimeterConfig| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "access_levels",
                |m: &ServicePerimeterConfig| { &m.access_levels },
                |m: &mut ServicePerimeterConfig| { &mut m.access_levels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "restricted_services",
                |m: &ServicePerimeterConfig| { &m.restricted_services },
                |m: &mut ServicePerimeterConfig| { &mut m.restricted_services },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_VpcAccessibleServices>>(
                "vpc_accessible_services",
                |m: &ServicePerimeterConfig| { &m.vpc_accessible_services },
                |m: &mut ServicePerimeterConfig| { &mut m.vpc_accessible_services },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_IngressPolicy>>(
                "ingress_policies",
                |m: &ServicePerimeterConfig| { &m.ingress_policies },
                |m: &mut ServicePerimeterConfig| { &mut m.ingress_policies },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_EgressPolicy>>(
                "egress_policies",
                |m: &ServicePerimeterConfig| { &m.egress_policies },
                |m: &mut ServicePerimeterConfig| { &mut m.egress_policies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig>(
                "ServicePerimeterConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig {
    fn clear(&mut self) {
        self.resources.clear();
        self.access_levels.clear();
        self.restricted_services.clear();
        self.vpc_accessible_services.clear();
        self.ingress_policies.clear();
        self.egress_policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_VpcAccessibleServices {
    // message fields
    pub enable_restriction: bool,
    pub allowed_services: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_VpcAccessibleServices {
    fn default() -> &'a ServicePerimeterConfig_VpcAccessibleServices {
        <ServicePerimeterConfig_VpcAccessibleServices as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_VpcAccessibleServices {
    pub fn new() -> ServicePerimeterConfig_VpcAccessibleServices {
        ::std::default::Default::default()
    }

    // bool enable_restriction = 1;


    pub fn get_enable_restriction(&self) -> bool {
        self.enable_restriction
    }
    pub fn clear_enable_restriction(&mut self) {
        self.enable_restriction = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_restriction(&mut self, v: bool) {
        self.enable_restriction = v;
    }

    // repeated string allowed_services = 2;


    pub fn get_allowed_services(&self) -> &[::std::string::String] {
        &self.allowed_services
    }
    pub fn clear_allowed_services(&mut self) {
        self.allowed_services.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_services(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_services(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_services
    }

    // Take field
    pub fn take_allowed_services(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_VpcAccessibleServices {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_restriction = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable_restriction != false {
            my_size += 2;
        }
        for value in &self.allowed_services {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable_restriction != false {
            os.write_bool(1, self.enable_restriction)?;
        }
        for v in &self.allowed_services {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_VpcAccessibleServices {
        ServicePerimeterConfig_VpcAccessibleServices::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_restriction",
                |m: &ServicePerimeterConfig_VpcAccessibleServices| { &m.enable_restriction },
                |m: &mut ServicePerimeterConfig_VpcAccessibleServices| { &mut m.enable_restriction },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allowed_services",
                |m: &ServicePerimeterConfig_VpcAccessibleServices| { &m.allowed_services },
                |m: &mut ServicePerimeterConfig_VpcAccessibleServices| { &mut m.allowed_services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_VpcAccessibleServices>(
                "ServicePerimeterConfig.VpcAccessibleServices",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_VpcAccessibleServices {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_VpcAccessibleServices> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_VpcAccessibleServices::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_VpcAccessibleServices {
    fn clear(&mut self) {
        self.enable_restriction = false;
        self.allowed_services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_VpcAccessibleServices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_VpcAccessibleServices {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_MethodSelector {
    // message oneof groups
    pub kind: ::std::option::Option<ServicePerimeterConfig_MethodSelector_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_MethodSelector {
    fn default() -> &'a ServicePerimeterConfig_MethodSelector {
        <ServicePerimeterConfig_MethodSelector as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ServicePerimeterConfig_MethodSelector_oneof_kind {
    method(::std::string::String),
    permission(::std::string::String),
}

impl ServicePerimeterConfig_MethodSelector {
    pub fn new() -> ServicePerimeterConfig_MethodSelector {
        ::std::default::Default::default()
    }

    // string method = 1;


    pub fn get_method(&self) -> &str {
        match self.kind {
            ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_method(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_method(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(v))
    }

    // Mutable pointer to the field.
    pub fn mut_method(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(::std::string::String::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_method(&mut self) -> ::std::string::String {
        if self.has_method() {
            match self.kind.take() {
                ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string permission = 2;


    pub fn get_permission(&self) -> &str {
        match self.kind {
            ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_permission(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(v))
    }

    // Mutable pointer to the field.
    pub fn mut_permission(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(::std::string::String::new()));
        }
        match self.kind {
            ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_permission(&mut self) -> ::std::string::String {
        if self.has_permission() {
            match self.kind.take() {
                ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_MethodSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::method(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(ServicePerimeterConfig_MethodSelector_oneof_kind::permission(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &ServicePerimeterConfig_MethodSelector_oneof_kind::method(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &ServicePerimeterConfig_MethodSelector_oneof_kind::permission(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &ServicePerimeterConfig_MethodSelector_oneof_kind::method(ref v) => {
                    os.write_string(1, v)?;
                },
                &ServicePerimeterConfig_MethodSelector_oneof_kind::permission(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_MethodSelector {
        ServicePerimeterConfig_MethodSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "method",
                ServicePerimeterConfig_MethodSelector::has_method,
                ServicePerimeterConfig_MethodSelector::get_method,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "permission",
                ServicePerimeterConfig_MethodSelector::has_permission,
                ServicePerimeterConfig_MethodSelector::get_permission,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_MethodSelector>(
                "ServicePerimeterConfig.MethodSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_MethodSelector {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_MethodSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_MethodSelector::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_MethodSelector {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_MethodSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_MethodSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_ApiOperation {
    // message fields
    pub service_name: ::std::string::String,
    pub method_selectors: ::protobuf::RepeatedField<ServicePerimeterConfig_MethodSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_ApiOperation {
    fn default() -> &'a ServicePerimeterConfig_ApiOperation {
        <ServicePerimeterConfig_ApiOperation as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_ApiOperation {
    pub fn new() -> ServicePerimeterConfig_ApiOperation {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector method_selectors = 2;


    pub fn get_method_selectors(&self) -> &[ServicePerimeterConfig_MethodSelector] {
        &self.method_selectors
    }
    pub fn clear_method_selectors(&mut self) {
        self.method_selectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_method_selectors(&mut self, v: ::protobuf::RepeatedField<ServicePerimeterConfig_MethodSelector>) {
        self.method_selectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_method_selectors(&mut self) -> &mut ::protobuf::RepeatedField<ServicePerimeterConfig_MethodSelector> {
        &mut self.method_selectors
    }

    // Take field
    pub fn take_method_selectors(&mut self) -> ::protobuf::RepeatedField<ServicePerimeterConfig_MethodSelector> {
        ::std::mem::replace(&mut self.method_selectors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_ApiOperation {
    fn is_initialized(&self) -> bool {
        for v in &self.method_selectors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.method_selectors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        for value in &self.method_selectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        for v in &self.method_selectors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_ApiOperation {
        ServicePerimeterConfig_ApiOperation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &ServicePerimeterConfig_ApiOperation| { &m.service_name },
                |m: &mut ServicePerimeterConfig_ApiOperation| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_MethodSelector>>(
                "method_selectors",
                |m: &ServicePerimeterConfig_ApiOperation| { &m.method_selectors },
                |m: &mut ServicePerimeterConfig_ApiOperation| { &mut m.method_selectors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_ApiOperation>(
                "ServicePerimeterConfig.ApiOperation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_ApiOperation {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_ApiOperation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_ApiOperation::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_ApiOperation {
    fn clear(&mut self) {
        self.service_name.clear();
        self.method_selectors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_ApiOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_ApiOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_IngressSource {
    // message oneof groups
    pub source: ::std::option::Option<ServicePerimeterConfig_IngressSource_oneof_source>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_IngressSource {
    fn default() -> &'a ServicePerimeterConfig_IngressSource {
        <ServicePerimeterConfig_IngressSource as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ServicePerimeterConfig_IngressSource_oneof_source {
    access_level(::std::string::String),
    resource(::std::string::String),
}

impl ServicePerimeterConfig_IngressSource {
    pub fn new() -> ServicePerimeterConfig_IngressSource {
        ::std::default::Default::default()
    }

    // string access_level = 1;


    pub fn get_access_level(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_access_level(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_access_level(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_access_level(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(v))
    }

    // Mutable pointer to the field.
    pub fn mut_access_level(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_access_level(&mut self) -> ::std::string::String {
        if self.has_access_level() {
            match self.source.take() {
                ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string resource = 2;


    pub fn get_resource(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_resource(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        if self.has_resource() {
            match self.source.take() {
                ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_IngressSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::access_level(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(ServicePerimeterConfig_IngressSource_oneof_source::resource(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &ServicePerimeterConfig_IngressSource_oneof_source::access_level(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &ServicePerimeterConfig_IngressSource_oneof_source::resource(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &ServicePerimeterConfig_IngressSource_oneof_source::access_level(ref v) => {
                    os.write_string(1, v)?;
                },
                &ServicePerimeterConfig_IngressSource_oneof_source::resource(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_IngressSource {
        ServicePerimeterConfig_IngressSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "access_level",
                ServicePerimeterConfig_IngressSource::has_access_level,
                ServicePerimeterConfig_IngressSource::get_access_level,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "resource",
                ServicePerimeterConfig_IngressSource::has_resource,
                ServicePerimeterConfig_IngressSource::get_resource,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_IngressSource>(
                "ServicePerimeterConfig.IngressSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_IngressSource {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_IngressSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_IngressSource::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_IngressSource {
    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_IngressSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_IngressSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_EgressTo {
    // message fields
    pub resources: ::protobuf::RepeatedField<::std::string::String>,
    pub operations: ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_EgressTo {
    fn default() -> &'a ServicePerimeterConfig_EgressTo {
        <ServicePerimeterConfig_EgressTo as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_EgressTo {
    pub fn new() -> ServicePerimeterConfig_EgressTo {
        ::std::default::Default::default()
    }

    // repeated string resources = 1;


    pub fn get_resources(&self) -> &[::std::string::String] {
        &self.resources
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation operations = 2;


    pub fn get_operations(&self) -> &[ServicePerimeterConfig_ApiOperation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_EgressTo {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.resources)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resources {
            os.write_string(1, &v)?;
        };
        for v in &self.operations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_EgressTo {
        ServicePerimeterConfig_EgressTo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resources",
                |m: &ServicePerimeterConfig_EgressTo| { &m.resources },
                |m: &mut ServicePerimeterConfig_EgressTo| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_ApiOperation>>(
                "operations",
                |m: &ServicePerimeterConfig_EgressTo| { &m.operations },
                |m: &mut ServicePerimeterConfig_EgressTo| { &mut m.operations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_EgressTo>(
                "ServicePerimeterConfig.EgressTo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_EgressTo {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_EgressTo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_EgressTo::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_EgressTo {
    fn clear(&mut self) {
        self.resources.clear();
        self.operations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_EgressTo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_EgressTo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_IngressFrom {
    // message fields
    pub sources: ::protobuf::RepeatedField<ServicePerimeterConfig_IngressSource>,
    pub identities: ::protobuf::RepeatedField<::std::string::String>,
    pub identity_type: ServicePerimeterConfig_IdentityType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_IngressFrom {
    fn default() -> &'a ServicePerimeterConfig_IngressFrom {
        <ServicePerimeterConfig_IngressFrom as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_IngressFrom {
    pub fn new() -> ServicePerimeterConfig_IngressFrom {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource sources = 1;


    pub fn get_sources(&self) -> &[ServicePerimeterConfig_IngressSource] {
        &self.sources
    }
    pub fn clear_sources(&mut self) {
        self.sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_sources(&mut self, v: ::protobuf::RepeatedField<ServicePerimeterConfig_IngressSource>) {
        self.sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sources(&mut self) -> &mut ::protobuf::RepeatedField<ServicePerimeterConfig_IngressSource> {
        &mut self.sources
    }

    // Take field
    pub fn take_sources(&mut self) -> ::protobuf::RepeatedField<ServicePerimeterConfig_IngressSource> {
        ::std::mem::replace(&mut self.sources, ::protobuf::RepeatedField::new())
    }

    // repeated string identities = 2;


    pub fn get_identities(&self) -> &[::std::string::String] {
        &self.identities
    }
    pub fn clear_identities(&mut self) {
        self.identities.clear();
    }

    // Param is passed by value, moved
    pub fn set_identities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.identities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_identities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.identities
    }

    // Take field
    pub fn take_identities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.identities, ::protobuf::RepeatedField::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IdentityType identity_type = 3;


    pub fn get_identity_type(&self) -> ServicePerimeterConfig_IdentityType {
        self.identity_type
    }
    pub fn clear_identity_type(&mut self) {
        self.identity_type = ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_identity_type(&mut self, v: ServicePerimeterConfig_IdentityType) {
        self.identity_type = v;
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_IngressFrom {
    fn is_initialized(&self) -> bool {
        for v in &self.sources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sources)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.identities)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.identity_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.identities {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.identity_type != ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.identity_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.identities {
            os.write_string(2, &v)?;
        };
        if self.identity_type != ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.identity_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_IngressFrom {
        ServicePerimeterConfig_IngressFrom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_IngressSource>>(
                "sources",
                |m: &ServicePerimeterConfig_IngressFrom| { &m.sources },
                |m: &mut ServicePerimeterConfig_IngressFrom| { &mut m.sources },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identities",
                |m: &ServicePerimeterConfig_IngressFrom| { &m.identities },
                |m: &mut ServicePerimeterConfig_IngressFrom| { &mut m.identities },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServicePerimeterConfig_IdentityType>>(
                "identity_type",
                |m: &ServicePerimeterConfig_IngressFrom| { &m.identity_type },
                |m: &mut ServicePerimeterConfig_IngressFrom| { &mut m.identity_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_IngressFrom>(
                "ServicePerimeterConfig.IngressFrom",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_IngressFrom {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_IngressFrom> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_IngressFrom::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_IngressFrom {
    fn clear(&mut self) {
        self.sources.clear();
        self.identities.clear();
        self.identity_type = ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_IngressFrom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_IngressFrom {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_IngressTo {
    // message fields
    pub operations: ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation>,
    pub resources: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_IngressTo {
    fn default() -> &'a ServicePerimeterConfig_IngressTo {
        <ServicePerimeterConfig_IngressTo as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_IngressTo {
    pub fn new() -> ServicePerimeterConfig_IngressTo {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation operations = 1;


    pub fn get_operations(&self) -> &[ServicePerimeterConfig_ApiOperation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<ServicePerimeterConfig_ApiOperation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    // repeated string resources = 2;


    pub fn get_resources(&self) -> &[::std::string::String] {
        &self.resources
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_IngressTo {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.operations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.resources {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_IngressTo {
        ServicePerimeterConfig_IngressTo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_ApiOperation>>(
                "operations",
                |m: &ServicePerimeterConfig_IngressTo| { &m.operations },
                |m: &mut ServicePerimeterConfig_IngressTo| { &mut m.operations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resources",
                |m: &ServicePerimeterConfig_IngressTo| { &m.resources },
                |m: &mut ServicePerimeterConfig_IngressTo| { &mut m.resources },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_IngressTo>(
                "ServicePerimeterConfig.IngressTo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_IngressTo {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_IngressTo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_IngressTo::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_IngressTo {
    fn clear(&mut self) {
        self.operations.clear();
        self.resources.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_IngressTo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_IngressTo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_IngressPolicy {
    // message fields
    pub ingress_from: ::protobuf::SingularPtrField<ServicePerimeterConfig_IngressFrom>,
    pub ingress_to: ::protobuf::SingularPtrField<ServicePerimeterConfig_IngressTo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_IngressPolicy {
    fn default() -> &'a ServicePerimeterConfig_IngressPolicy {
        <ServicePerimeterConfig_IngressPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_IngressPolicy {
    pub fn new() -> ServicePerimeterConfig_IngressPolicy {
        ::std::default::Default::default()
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom ingress_from = 1;


    pub fn get_ingress_from(&self) -> &ServicePerimeterConfig_IngressFrom {
        self.ingress_from.as_ref().unwrap_or_else(|| <ServicePerimeterConfig_IngressFrom as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ingress_from(&mut self) {
        self.ingress_from.clear();
    }

    pub fn has_ingress_from(&self) -> bool {
        self.ingress_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingress_from(&mut self, v: ServicePerimeterConfig_IngressFrom) {
        self.ingress_from = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingress_from(&mut self) -> &mut ServicePerimeterConfig_IngressFrom {
        if self.ingress_from.is_none() {
            self.ingress_from.set_default();
        }
        self.ingress_from.as_mut().unwrap()
    }

    // Take field
    pub fn take_ingress_from(&mut self) -> ServicePerimeterConfig_IngressFrom {
        self.ingress_from.take().unwrap_or_else(|| ServicePerimeterConfig_IngressFrom::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressTo ingress_to = 2;


    pub fn get_ingress_to(&self) -> &ServicePerimeterConfig_IngressTo {
        self.ingress_to.as_ref().unwrap_or_else(|| <ServicePerimeterConfig_IngressTo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ingress_to(&mut self) {
        self.ingress_to.clear();
    }

    pub fn has_ingress_to(&self) -> bool {
        self.ingress_to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingress_to(&mut self, v: ServicePerimeterConfig_IngressTo) {
        self.ingress_to = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingress_to(&mut self) -> &mut ServicePerimeterConfig_IngressTo {
        if self.ingress_to.is_none() {
            self.ingress_to.set_default();
        }
        self.ingress_to.as_mut().unwrap()
    }

    // Take field
    pub fn take_ingress_to(&mut self) -> ServicePerimeterConfig_IngressTo {
        self.ingress_to.take().unwrap_or_else(|| ServicePerimeterConfig_IngressTo::new())
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_IngressPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.ingress_from {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ingress_to {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ingress_from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ingress_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ingress_from.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ingress_to.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ingress_from.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ingress_to.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_IngressPolicy {
        ServicePerimeterConfig_IngressPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_IngressFrom>>(
                "ingress_from",
                |m: &ServicePerimeterConfig_IngressPolicy| { &m.ingress_from },
                |m: &mut ServicePerimeterConfig_IngressPolicy| { &mut m.ingress_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_IngressTo>>(
                "ingress_to",
                |m: &ServicePerimeterConfig_IngressPolicy| { &m.ingress_to },
                |m: &mut ServicePerimeterConfig_IngressPolicy| { &mut m.ingress_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_IngressPolicy>(
                "ServicePerimeterConfig.IngressPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_IngressPolicy {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_IngressPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_IngressPolicy::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_IngressPolicy {
    fn clear(&mut self) {
        self.ingress_from.clear();
        self.ingress_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_IngressPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_IngressPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_EgressPolicy {
    // message fields
    pub egress_from: ::protobuf::SingularPtrField<ServicePerimeterConfig_EgressFrom>,
    pub egress_to: ::protobuf::SingularPtrField<ServicePerimeterConfig_EgressTo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_EgressPolicy {
    fn default() -> &'a ServicePerimeterConfig_EgressPolicy {
        <ServicePerimeterConfig_EgressPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_EgressPolicy {
    pub fn new() -> ServicePerimeterConfig_EgressPolicy {
        ::std::default::Default::default()
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom egress_from = 1;


    pub fn get_egress_from(&self) -> &ServicePerimeterConfig_EgressFrom {
        self.egress_from.as_ref().unwrap_or_else(|| <ServicePerimeterConfig_EgressFrom as ::protobuf::Message>::default_instance())
    }
    pub fn clear_egress_from(&mut self) {
        self.egress_from.clear();
    }

    pub fn has_egress_from(&self) -> bool {
        self.egress_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_egress_from(&mut self, v: ServicePerimeterConfig_EgressFrom) {
        self.egress_from = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_egress_from(&mut self) -> &mut ServicePerimeterConfig_EgressFrom {
        if self.egress_from.is_none() {
            self.egress_from.set_default();
        }
        self.egress_from.as_mut().unwrap()
    }

    // Take field
    pub fn take_egress_from(&mut self) -> ServicePerimeterConfig_EgressFrom {
        self.egress_from.take().unwrap_or_else(|| ServicePerimeterConfig_EgressFrom::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo egress_to = 2;


    pub fn get_egress_to(&self) -> &ServicePerimeterConfig_EgressTo {
        self.egress_to.as_ref().unwrap_or_else(|| <ServicePerimeterConfig_EgressTo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_egress_to(&mut self) {
        self.egress_to.clear();
    }

    pub fn has_egress_to(&self) -> bool {
        self.egress_to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_egress_to(&mut self, v: ServicePerimeterConfig_EgressTo) {
        self.egress_to = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_egress_to(&mut self) -> &mut ServicePerimeterConfig_EgressTo {
        if self.egress_to.is_none() {
            self.egress_to.set_default();
        }
        self.egress_to.as_mut().unwrap()
    }

    // Take field
    pub fn take_egress_to(&mut self) -> ServicePerimeterConfig_EgressTo {
        self.egress_to.take().unwrap_or_else(|| ServicePerimeterConfig_EgressTo::new())
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_EgressPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.egress_from {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.egress_to {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.egress_from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.egress_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.egress_from.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.egress_to.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.egress_from.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.egress_to.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_EgressPolicy {
        ServicePerimeterConfig_EgressPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_EgressFrom>>(
                "egress_from",
                |m: &ServicePerimeterConfig_EgressPolicy| { &m.egress_from },
                |m: &mut ServicePerimeterConfig_EgressPolicy| { &mut m.egress_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePerimeterConfig_EgressTo>>(
                "egress_to",
                |m: &ServicePerimeterConfig_EgressPolicy| { &m.egress_to },
                |m: &mut ServicePerimeterConfig_EgressPolicy| { &mut m.egress_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_EgressPolicy>(
                "ServicePerimeterConfig.EgressPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_EgressPolicy {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_EgressPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_EgressPolicy::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_EgressPolicy {
    fn clear(&mut self) {
        self.egress_from.clear();
        self.egress_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_EgressPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_EgressPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePerimeterConfig_EgressFrom {
    // message fields
    pub identities: ::protobuf::RepeatedField<::std::string::String>,
    pub identity_type: ServicePerimeterConfig_IdentityType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePerimeterConfig_EgressFrom {
    fn default() -> &'a ServicePerimeterConfig_EgressFrom {
        <ServicePerimeterConfig_EgressFrom as ::protobuf::Message>::default_instance()
    }
}

impl ServicePerimeterConfig_EgressFrom {
    pub fn new() -> ServicePerimeterConfig_EgressFrom {
        ::std::default::Default::default()
    }

    // repeated string identities = 1;


    pub fn get_identities(&self) -> &[::std::string::String] {
        &self.identities
    }
    pub fn clear_identities(&mut self) {
        self.identities.clear();
    }

    // Param is passed by value, moved
    pub fn set_identities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.identities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_identities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.identities
    }

    // Take field
    pub fn take_identities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.identities, ::protobuf::RepeatedField::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IdentityType identity_type = 2;


    pub fn get_identity_type(&self) -> ServicePerimeterConfig_IdentityType {
        self.identity_type
    }
    pub fn clear_identity_type(&mut self) {
        self.identity_type = ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_identity_type(&mut self, v: ServicePerimeterConfig_IdentityType) {
        self.identity_type = v;
    }
}

impl ::protobuf::Message for ServicePerimeterConfig_EgressFrom {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.identities)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.identity_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.identities {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.identity_type != ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.identity_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.identities {
            os.write_string(1, &v)?;
        };
        if self.identity_type != ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.identity_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePerimeterConfig_EgressFrom {
        ServicePerimeterConfig_EgressFrom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identities",
                |m: &ServicePerimeterConfig_EgressFrom| { &m.identities },
                |m: &mut ServicePerimeterConfig_EgressFrom| { &mut m.identities },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServicePerimeterConfig_IdentityType>>(
                "identity_type",
                |m: &ServicePerimeterConfig_EgressFrom| { &m.identity_type },
                |m: &mut ServicePerimeterConfig_EgressFrom| { &mut m.identity_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePerimeterConfig_EgressFrom>(
                "ServicePerimeterConfig.EgressFrom",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePerimeterConfig_EgressFrom {
        static instance: ::protobuf::rt::LazyV2<ServicePerimeterConfig_EgressFrom> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePerimeterConfig_EgressFrom::new)
    }
}

impl ::protobuf::Clear for ServicePerimeterConfig_EgressFrom {
    fn clear(&mut self) {
        self.identities.clear();
        self.identity_type = ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePerimeterConfig_EgressFrom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_EgressFrom {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServicePerimeterConfig_IdentityType {
    IDENTITY_TYPE_UNSPECIFIED = 0,
    ANY_IDENTITY = 1,
    ANY_USER_ACCOUNT = 2,
    ANY_SERVICE_ACCOUNT = 3,
}

impl ::protobuf::ProtobufEnum for ServicePerimeterConfig_IdentityType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServicePerimeterConfig_IdentityType> {
        match value {
            0 => ::std::option::Option::Some(ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ServicePerimeterConfig_IdentityType::ANY_IDENTITY),
            2 => ::std::option::Option::Some(ServicePerimeterConfig_IdentityType::ANY_USER_ACCOUNT),
            3 => ::std::option::Option::Some(ServicePerimeterConfig_IdentityType::ANY_SERVICE_ACCOUNT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServicePerimeterConfig_IdentityType] = &[
            ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED,
            ServicePerimeterConfig_IdentityType::ANY_IDENTITY,
            ServicePerimeterConfig_IdentityType::ANY_USER_ACCOUNT,
            ServicePerimeterConfig_IdentityType::ANY_SERVICE_ACCOUNT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ServicePerimeterConfig_IdentityType>("ServicePerimeterConfig.IdentityType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ServicePerimeterConfig_IdentityType {
}

impl ::std::default::Default for ServicePerimeterConfig_IdentityType {
    fn default() -> Self {
        ServicePerimeterConfig_IdentityType::IDENTITY_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePerimeterConfig_IdentityType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n?google/identity/accesscontextmanager/v1/service_perimeter.proto\x12'g\
    oogle.identity.accesscontextmanager.v1\x1a\x19google/api/resource.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoogle/api/annotations.pr\
    oto\"\xf9\x05\n\x10ServicePerimeter\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x20\n\x0bd\
    escription\x18\x03\x20\x01(\tR\x0bdescription\x12;\n\x0bcreate_time\x18\
    \x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\x0b\
    update_time\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nupdate\
    Time\x12n\n\x0eperimeter_type\x18\x06\x20\x01(\x0e2G.google.identity.acc\
    esscontextmanager.v1.ServicePerimeter.PerimeterTypeR\rperimeterType\x12W\
    \n\x06status\x18\x07\x20\x01(\x0b2?.google.identity.accesscontextmanager\
    .v1.ServicePerimeterConfigR\x06status\x12S\n\x04spec\x18\x08\x20\x01(\
    \x0b2?.google.identity.accesscontextmanager.v1.ServicePerimeterConfigR\
    \x04spec\x128\n\x19use_explicit_dry_run_spec\x18\t\x20\x01(\x08R\x15useE\
    xplicitDryRunSpec\"F\n\rPerimeterType\x12\x1a\n\x16PERIMETER_TYPE_REGULA\
    R\x10\0\x12\x19\n\x15PERIMETER_TYPE_BRIDGE\x10\x01:\x7f\xeaA|\n4accessco\
    ntextmanager.googleapis.com/ServicePerimeter\x12DaccessPolicies/{access_\
    policy}/servicePerimeters/{service_perimeter}\"\x85\x12\n\x16ServicePeri\
    meterConfig\x12\x1c\n\tresources\x18\x01\x20\x03(\tR\tresources\x12#\n\r\
    access_levels\x18\x02\x20\x03(\tR\x0caccessLevels\x12/\n\x13restricted_s\
    ervices\x18\x04\x20\x03(\tR\x12restrictedServices\x12\x8d\x01\n\x17vpc_a\
    ccessible_services\x18\n\x20\x01(\x0b2U.google.identity.accesscontextman\
    ager.v1.ServicePerimeterConfig.VpcAccessibleServicesR\x15vpcAccessibleSe\
    rvices\x12x\n\x10ingress_policies\x18\x08\x20\x03(\x0b2M.google.identity\
    .accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicyR\x0fingres\
    sPolicies\x12u\n\x0fegress_policies\x18\t\x20\x03(\x0b2L.google.identity\
    .accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicyR\x0eegressP\
    olicies\x1aq\n\x15VpcAccessibleServices\x12-\n\x12enable_restriction\x18\
    \x01\x20\x01(\x08R\x11enableRestriction\x12)\n\x10allowed_services\x18\
    \x02\x20\x03(\tR\x0fallowedServices\x1aT\n\x0eMethodSelector\x12\x18\n\
    \x06method\x18\x01\x20\x01(\tH\0R\x06method\x12\x20\n\npermission\x18\
    \x02\x20\x01(\tH\0R\npermissionB\x06\n\x04kind\x1a\xac\x01\n\x0cApiOpera\
    tion\x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12y\n\
    \x10method_selectors\x18\x02\x20\x03(\x0b2N.google.identity.accesscontex\
    tmanager.v1.ServicePerimeterConfig.MethodSelectorR\x0fmethodSelectors\
    \x1a\\\n\rIngressSource\x12#\n\x0caccess_level\x18\x01\x20\x01(\tH\0R\
    \x0baccessLevel\x12\x1c\n\x08resource\x18\x02\x20\x01(\tH\0R\x08resource\
    B\x08\n\x06source\x1a\x96\x01\n\x08EgressTo\x12\x1c\n\tresources\x18\x01\
    \x20\x03(\tR\tresources\x12l\n\noperations\x18\x02\x20\x03(\x0b2L.google\
    .identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperationR\n\
    operations\x1a\x89\x02\n\x0bIngressFrom\x12g\n\x07sources\x18\x01\x20\
    \x03(\x0b2M.google.identity.accesscontextmanager.v1.ServicePerimeterConf\
    ig.IngressSourceR\x07sources\x12\x1e\n\nidentities\x18\x02\x20\x03(\tR\n\
    identities\x12q\n\ridentity_type\x18\x03\x20\x01(\x0e2L.google.identity.\
    accesscontextmanager.v1.ServicePerimeterConfig.IdentityTypeR\x0cidentity\
    Type\x1a\x97\x01\n\tIngressTo\x12l\n\noperations\x18\x01\x20\x03(\x0b2L.\
    google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperat\
    ionR\noperations\x12\x1c\n\tresources\x18\x02\x20\x03(\tR\tresources\x1a\
    \xe9\x01\n\rIngressPolicy\x12n\n\x0cingress_from\x18\x01\x20\x01(\x0b2K.\
    google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFr\
    omR\x0bingressFrom\x12h\n\ningress_to\x18\x02\x20\x01(\x0b2I.google.iden\
    tity.accesscontextmanager.v1.ServicePerimeterConfig.IngressToR\tingressT\
    o\x1a\xe2\x01\n\x0cEgressPolicy\x12k\n\x0begress_from\x18\x01\x20\x01(\
    \x0b2J.google.identity.accesscontextmanager.v1.ServicePerimeterConfig.Eg\
    ressFromR\negressFrom\x12e\n\tegress_to\x18\x02\x20\x01(\x0b2H.google.id\
    entity.accesscontextmanager.v1.ServicePerimeterConfig.EgressToR\x08egres\
    sTo\x1a\x9f\x01\n\nEgressFrom\x12\x1e\n\nidentities\x18\x01\x20\x03(\tR\
    \nidentities\x12q\n\ridentity_type\x18\x02\x20\x01(\x0e2L.google.identit\
    y.accesscontextmanager.v1.ServicePerimeterConfig.IdentityTypeR\x0cidenti\
    tyType\"n\n\x0cIdentityType\x12\x1d\n\x19IDENTITY_TYPE_UNSPECIFIED\x10\0\
    \x12\x10\n\x0cANY_IDENTITY\x10\x01\x12\x14\n\x10ANY_USER_ACCOUNT\x10\x02\
    \x12\x17\n\x13ANY_SERVICE_ACCOUNT\x10\x03B\xab\x02\n+com.google.identity\
    .accesscontextmanager.v1B\x15ServicePerimeterProtoP\x01Z[google.golang.o\
    rg/genproto/googleapis/identity/accesscontextmanager/v1;accesscontextman\
    ager\xa2\x02\x04GACM\xaa\x02'Google.Identity.AccessContextManager.V1\xca\
    \x02'Google\\Identity\\AccessContextManager\\V1\xea\x02*Google::Identity\
    ::AccessContextManager::V1J\xbb\xae\x01\n\x07\x12\x05\x0e\0\xd0\x03\x01\
    \n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202021\x20\
    Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20V\
    ersion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20\
    this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\00\n\t\n\x02\x03\0\
    \x12\x03\x12\0#\n\t\n\x02\x03\x01\x12\x03\x13\0)\n\t\n\x02\x03\x02\x12\
    \x03\x14\0&\n\x08\n\x01\x08\x12\x03\x16\0D\n\t\n\x02\x08%\x12\x03\x16\0D\
    \n\x08\n\x01\x08\x12\x03\x17\0r\n\t\n\x02\x08\x0b\x12\x03\x17\0r\n\x08\n\
    \x01\x08\x12\x03\x18\0\"\n\t\n\x02\x08\n\x12\x03\x18\0\"\n\x08\n\x01\x08\
    \x12\x03\x19\06\n\t\n\x02\x08\x08\x12\x03\x19\06\n\x08\n\x01\x08\x12\x03\
    \x1a\0D\n\t\n\x02\x08\x01\x12\x03\x1a\0D\n\x08\n\x01\x08\x12\x03\x1b\0\"\
    \n\t\n\x02\x08$\x12\x03\x1b\0\"\n\x08\n\x01\x08\x12\x03\x1c\0D\n\t\n\x02\
    \x08)\x12\x03\x1c\0D\n\x08\n\x01\x08\x12\x03\x1d\0C\n\t\n\x02\x08-\x12\
    \x03\x1d\0C\n\xc7\x05\n\x02\x04\0\x12\x04)\0w\x01\x1a\xba\x05\x20`Servic\
    ePerimeter`\x20describes\x20a\x20set\x20of\x20Google\x20Cloud\x20resourc\
    es\x20which\x20can\x20freely\n\x20import\x20and\x20export\x20data\x20amo\
    ngst\x20themselves,\x20but\x20not\x20export\x20outside\x20of\x20the\n\
    \x20`ServicePerimeter`.\x20If\x20a\x20request\x20with\x20a\x20source\x20\
    within\x20this\x20`ServicePerimeter`\n\x20has\x20a\x20target\x20outside\
    \x20of\x20the\x20`ServicePerimeter`,\x20the\x20request\x20will\x20be\x20\
    blocked.\n\x20Otherwise\x20the\x20request\x20is\x20allowed.\x20There\x20\
    are\x20two\x20types\x20of\x20Service\x20Perimeter\x20-\n\x20Regular\x20a\
    nd\x20Bridge.\x20Regular\x20Service\x20Perimeters\x20cannot\x20overlap,\
    \x20a\x20single\n\x20Google\x20Cloud\x20project\x20can\x20only\x20belong\
    \x20to\x20a\x20single\x20regular\x20Service\x20Perimeter.\n\x20Service\
    \x20Perimeter\x20Bridges\x20can\x20contain\x20only\x20Google\x20Cloud\
    \x20projects\x20as\x20members,\n\x20a\x20single\x20Google\x20Cloud\x20pr\
    oject\x20may\x20belong\x20to\x20multiple\x20Service\x20Perimeter\n\x20Br\
    idges.\n\n\n\n\x03\x04\0\x01\x12\x03)\x08\x18\n\x0b\n\x03\x04\0\x07\x12\
    \x04*\x02-\x04\n\r\n\x05\x04\0\x07\x9d\x08\x12\x04*\x02-\x04\n\xf3\x06\n\
    \x04\x04\0\x04\0\x12\x04>\x02D\x03\x1a\xe4\x06\x20Specifies\x20the\x20ty\
    pe\x20of\x20the\x20Perimeter.\x20There\x20are\x20two\x20types:\x20regula\
    r\x20and\n\x20bridge.\x20Regular\x20Service\x20Perimeter\x20contains\x20\
    resources,\x20access\x20levels,\x20and\n\x20restricted\x20services.\x20E\
    very\x20resource\x20can\x20be\x20in\x20at\x20most\x20ONE\n\x20regular\
    \x20Service\x20Perimeter.\n\n\x20In\x20addition\x20to\x20being\x20in\x20\
    a\x20regular\x20service\x20perimeter,\x20a\x20resource\x20can\x20also\n\
    \x20be\x20in\x20zero\x20or\x20more\x20perimeter\x20bridges.\x20\x20A\x20\
    perimeter\x20bridge\x20only\x20contains\n\x20resources.\x20\x20Cross\x20\
    project\x20operations\x20are\x20permitted\x20if\x20all\x20effected\n\x20\
    resources\x20share\x20some\x20perimeter\x20(whether\x20bridge\x20or\x20r\
    egular).\x20Perimeter\n\x20Bridge\x20does\x20not\x20contain\x20access\
    \x20levels\x20or\x20services:\x20those\x20are\x20governed\n\x20entirely\
    \x20by\x20the\x20regular\x20perimeter\x20that\x20resource\x20is\x20in.\n\
    \n\x20Perimeter\x20Bridges\x20are\x20typically\x20useful\x20when\x20buil\
    ding\x20more\x20complex\x20toplogies\n\x20with\x20many\x20independent\
    \x20perimeters\x20that\x20need\x20to\x20share\x20some\x20data\x20with\
    \x20a\x20common\n\x20perimeter,\x20but\x20should\x20not\x20be\x20able\
    \x20to\x20share\x20data\x20among\x20themselves.\n\n\x0c\n\x05\x04\0\x04\
    \0\x01\x12\x03>\x07\x14\n#\n\x06\x04\0\x04\0\x02\0\x12\x03@\x04\x1f\x1a\
    \x14\x20Regular\x20Perimeter.\n\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\
    \x03@\x04\x1a\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x03@\x1d\x1e\n\"\n\
    \x06\x04\0\x04\0\x02\x01\x12\x03C\x04\x1e\x1a\x13\x20Perimeter\x20Bridge\
    .\n\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03C\x04\x19\n\x0e\n\x07\x04\
    \0\x04\0\x02\x01\x02\x12\x03C\x1c\x1d\n\xef\x01\n\x04\x04\0\x02\0\x12\
    \x03J\x02\x12\x1a\xe1\x01\x20Required.\x20Resource\x20name\x20for\x20the\
    \x20ServicePerimeter.\x20\x20The\x20`short_name`\n\x20component\x20must\
    \x20begin\x20with\x20a\x20letter\x20and\x20only\x20include\x20alphanumer\
    ic\x20and\x20'_'.\n\x20Format:\n\x20`accessPolicies/{access_policy}/serv\
    icePerimeters/{service_perimeter}`\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    J\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03J\t\r\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03J\x10\x11\nF\n\x04\x04\0\x02\x01\x12\x03M\x02\x13\x1a9\x20\
    Human\x20readable\x20title.\x20Must\x20be\x20unique\x20within\x20the\x20\
    Policy.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03M\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x01\x01\x12\x03M\t\x0e\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03M\x11\
    \x12\n\\\n\x04\x04\0\x02\x02\x12\x03Q\x02\x19\x1aO\x20Description\x20of\
    \x20the\x20`ServicePerimeter`\x20and\x20its\x20use.\x20Does\x20not\x20af\
    fect\n\x20behavior.\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03Q\x02\x08\n\
    \x0c\n\x05\x04\0\x02\x02\x01\x12\x03Q\t\x14\n\x0c\n\x05\x04\0\x02\x02\
    \x03\x12\x03Q\x17\x18\nK\n\x04\x04\0\x02\x03\x12\x03T\x02,\x1a>\x20Outpu\
    t\x20only.\x20Time\x20the\x20`ServicePerimeter`\x20was\x20created\x20in\
    \x20UTC.\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03T\x02\x1b\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03T\x1c'\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03T*\
    +\nK\n\x04\x04\0\x02\x04\x12\x03W\x02,\x1a>\x20Output\x20only.\x20Time\
    \x20the\x20`ServicePerimeter`\x20was\x20updated\x20in\x20UTC.\n\n\x0c\n\
    \x05\x04\0\x02\x04\x06\x12\x03W\x02\x1b\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x03W\x1c'\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03W*+\n\xe0\x02\n\x04\
    \x04\0\x02\x05\x12\x03_\x02#\x1a\xd2\x02\x20Perimeter\x20type\x20indicat\
    or.\x20A\x20single\x20project\x20is\n\x20allowed\x20to\x20be\x20a\x20mem\
    ber\x20of\x20single\x20regular\x20perimeter,\x20but\x20multiple\x20servi\
    ce\n\x20perimeter\x20bridges.\x20A\x20project\x20cannot\x20be\x20a\x20in\
    cluded\x20in\x20a\x20perimeter\x20bridge\n\x20without\x20being\x20includ\
    ed\x20in\x20regular\x20perimeter.\x20For\x20perimeter\x20bridges,\n\x20t\
    he\x20restricted\x20service\x20list\x20as\x20well\x20as\x20access\x20lev\
    el\x20lists\x20must\x20be\n\x20empty.\n\n\x0c\n\x05\x04\0\x02\x05\x06\
    \x12\x03_\x02\x0f\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03_\x10\x1e\n\x0c\n\
    \x05\x04\0\x02\x05\x03\x12\x03_!\"\n\xad\x01\n\x04\x04\0\x02\x06\x12\x03\
    d\x02$\x1a\x9f\x01\x20Current\x20ServicePerimeter\x20configuration.\x20S\
    pecifies\x20sets\x20of\x20resources,\n\x20restricted\x20services\x20and\
    \x20access\x20levels\x20that\x20determine\x20perimeter\n\x20content\x20a\
    nd\x20boundaries.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03d\x02\x18\n\x0c\
    \n\x05\x04\0\x02\x06\x01\x12\x03d\x19\x1f\n\x0c\n\x05\x04\0\x02\x06\x03\
    \x12\x03d\"#\n\x8c\x02\n\x04\x04\0\x02\x07\x12\x03j\x02\"\x1a\xfe\x01\
    \x20Proposed\x20(or\x20dry\x20run)\x20ServicePerimeter\x20configuration.\
    \x20This\x20configuration\n\x20allows\x20to\x20specify\x20and\x20test\
    \x20ServicePerimeter\x20configuration\x20without\x20enforcing\n\x20actua\
    l\x20access\x20restrictions.\x20Only\x20allowed\x20to\x20be\x20set\x20wh\
    en\x20the\n\x20\"use_explicit_dry_run_spec\"\x20flag\x20is\x20set.\n\n\
    \x0c\n\x05\x04\0\x02\x07\x06\x12\x03j\x02\x18\n\x0c\n\x05\x04\0\x02\x07\
    \x01\x12\x03j\x19\x1d\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03j\x20!\n\xd5\
    \x05\n\x04\x04\0\x02\x08\x12\x03v\x02%\x1a\xc7\x05\x20Use\x20explicit\
    \x20dry\x20run\x20spec\x20flag.\x20Ordinarily,\x20a\x20dry-run\x20spec\
    \x20implicitly\n\x20exists\x20\x20for\x20all\x20Service\x20Perimeters,\
    \x20and\x20that\x20spec\x20is\x20identical\x20to\x20the\n\x20status\x20f\
    or\x20those\x20Service\x20Perimeters.\x20When\x20this\x20flag\x20is\x20s\
    et,\x20it\x20inhibits\x20the\n\x20generation\x20of\x20the\x20implicit\
    \x20spec,\x20thereby\x20allowing\x20the\x20user\x20to\x20explicitly\n\
    \x20provide\x20a\x20configuration\x20(\"spec\")\x20to\x20use\x20in\x20a\
    \x20dry-run\x20version\x20of\x20the\x20Service\n\x20Perimeter.\x20This\
    \x20allows\x20the\x20user\x20to\x20test\x20changes\x20to\x20the\x20enfor\
    ced\x20config\n\x20(\"status\")\x20without\x20actually\x20enforcing\x20t\
    hem.\x20This\x20testing\x20is\x20done\x20through\n\x20analyzing\x20the\
    \x20differences\x20between\x20currently\x20enforced\x20and\x20suggested\
    \n\x20restrictions.\x20use_explicit_dry_run_spec\x20must\x20bet\x20set\
    \x20to\x20True\x20if\x20any\x20of\x20the\n\x20fields\x20in\x20the\x20spe\
    c\x20are\x20set\x20to\x20non-default\x20values.\n\n\x0c\n\x05\x04\0\x02\
    \x08\x05\x12\x03v\x02\x06\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03v\x07\x20\
    \n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03v#$\n\x8a\x01\n\x02\x04\x01\x12\
    \x05{\0\xd0\x03\x01\x1a}\x20`ServicePerimeterConfig`\x20specifies\x20a\
    \x20set\x20of\x20Google\x20Cloud\x20resources\x20that\n\x20describe\x20s\
    pecific\x20Service\x20Perimeter\x20configuration.\n\n\n\n\x03\x04\x01\
    \x01\x12\x03{\x08\x1e\n]\n\x04\x04\x01\x03\0\x12\x05~\x02\x88\x01\x03\
    \x1aN\x20Specifies\x20how\x20APIs\x20are\x20allowed\x20to\x20communicate\
    \x20within\x20the\x20Service\n\x20Perimeter.\n\n\x0c\n\x05\x04\x01\x03\0\
    \x01\x12\x03~\n\x1f\n\x82\x01\n\x06\x04\x01\x03\0\x02\0\x12\x04\x81\x01\
    \x04\x20\x1ar\x20Whether\x20to\x20restrict\x20API\x20calls\x20within\x20\
    the\x20Service\x20Perimeter\x20to\x20the\x20list\x20of\n\x20APIs\x20spec\
    ified\x20in\x20'allowed_services'.\n\n\x0f\n\x07\x04\x01\x03\0\x02\0\x05\
    \x12\x04\x81\x01\x04\x08\n\x0f\n\x07\x04\x01\x03\0\x02\0\x01\x12\x04\x81\
    \x01\t\x1b\n\x0f\n\x07\x04\x01\x03\0\x02\0\x03\x12\x04\x81\x01\x1e\x1f\n\
    \xae\x02\n\x06\x04\x01\x03\0\x02\x01\x12\x04\x87\x01\x04)\x1a\x9d\x02\
    \x20The\x20list\x20of\x20APIs\x20usable\x20within\x20the\x20Service\x20P\
    erimeter.\x20Must\x20be\x20empty\n\x20unless\x20'enable_restriction'\x20\
    is\x20True.\x20You\x20can\x20specify\x20a\x20list\x20of\x20individual\n\
    \x20services,\x20as\x20well\x20as\x20include\x20the\x20'RESTRICTED-SERVI\
    CES'\x20value,\x20which\n\x20automatically\x20includes\x20all\x20of\x20t\
    he\x20services\x20protected\x20by\x20the\x20perimeter.\n\n\x0f\n\x07\x04\
    \x01\x03\0\x02\x01\x04\x12\x04\x87\x01\x04\x0c\n\x0f\n\x07\x04\x01\x03\0\
    \x02\x01\x05\x12\x04\x87\x01\r\x13\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x01\
    \x12\x04\x87\x01\x14$\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x03\x12\x04\x87\
    \x01'(\n\xab\x01\n\x04\x04\x01\x03\x01\x12\x06\x8c\x01\x02\x9b\x01\x03\
    \x1a\x9a\x01\x20An\x20allowed\x20method\x20or\x20permission\x20of\x20a\
    \x20service\x20specified\x20in\x20[ApiOperation]\n\x20[google.identity.a\
    ccesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].\n\n\r\n\x05\
    \x04\x01\x03\x01\x01\x12\x04\x8c\x01\n\x18\nN\n\x06\x04\x01\x03\x01\x08\
    \0\x12\x06\x8e\x01\x04\x9a\x01\x05\x1a<\x20The\x20API\x20method\x20name\
    \x20or\x20Cloud\x20IAM\x20permission\x20name\x20to\x20allow.\n\n\x0f\n\
    \x07\x04\x01\x03\x01\x08\0\x01\x12\x04\x8e\x01\n\x0e\n\x9e\x02\n\x06\x04\
    \x01\x03\x01\x02\0\x12\x04\x94\x01\x06\x18\x1a\x8d\x02\x20Value\x20for\
    \x20`method`\x20should\x20be\x20a\x20valid\x20method\x20name\x20for\x20t\
    he\x20corresponding\n\x20`service_name`\x20in\x20[ApiOperation]\n\x20[go\
    ogle.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperatio\
    n].\n\x20If\x20`*`\x20used\x20as\x20value\x20for\x20`method`,\x20then\
    \x20ALL\x20methods\x20and\x20permissions\x20are\n\x20allowed.\n\n\x0f\n\
    \x07\x04\x01\x03\x01\x02\0\x05\x12\x04\x94\x01\x06\x0c\n\x0f\n\x07\x04\
    \x01\x03\x01\x02\0\x01\x12\x04\x94\x01\r\x13\n\x0f\n\x07\x04\x01\x03\x01\
    \x02\0\x03\x12\x04\x94\x01\x16\x17\n\xd8\x01\n\x06\x04\x01\x03\x01\x02\
    \x01\x12\x04\x99\x01\x06\x1c\x1a\xc7\x01\x20Value\x20for\x20`permission`\
    \x20should\x20be\x20a\x20valid\x20Cloud\x20IAM\x20permission\x20for\x20t\
    he\n\x20corresponding\x20`service_name`\x20in\x20[ApiOperation]\n\x20[go\
    ogle.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperatio\
    n].\n\n\x0f\n\x07\x04\x01\x03\x01\x02\x01\x05\x12\x04\x99\x01\x06\x0c\n\
    \x0f\n\x07\x04\x01\x03\x01\x02\x01\x01\x12\x04\x99\x01\r\x17\n\x0f\n\x07\
    \x04\x01\x03\x01\x02\x01\x03\x12\x04\x99\x01\x1a\x1b\n6\n\x04\x04\x01\
    \x03\x02\x12\x06\x9e\x01\x02\xaf\x01\x03\x1a&\x20Identification\x20for\
    \x20an\x20API\x20Operation.\n\n\r\n\x05\x04\x01\x03\x02\x01\x12\x04\x9e\
    \x01\n\x16\n\xe0\x03\n\x06\x04\x01\x03\x02\x02\0\x12\x04\xa7\x01\x04\x1c\
    \x1a\xcf\x03\x20The\x20name\x20of\x20the\x20API\x20whose\x20methods\x20o\
    r\x20permissions\x20the\x20[IngressPolicy]\n\x20[google.identity.accessc\
    ontextmanager.v1.ServicePerimeterConfig.IngressPolicy]\n\x20or\x20[Egres\
    sPolicy]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeterC\
    onfig.EgressPolicy]\n\x20want\x20to\x20allow.\x20A\x20single\x20[ApiOper\
    ation]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeterCon\
    fig.ApiOperation]\n\x20with\x20`service_name`\x20field\x20set\x20to\x20`\
    *`\x20will\x20allow\x20all\x20methods\x20AND\n\x20permissions\x20for\x20\
    all\x20services.\n\n\x0f\n\x07\x04\x01\x03\x02\x02\0\x05\x12\x04\xa7\x01\
    \x04\n\n\x0f\n\x07\x04\x01\x03\x02\x02\0\x01\x12\x04\xa7\x01\x0b\x17\n\
    \x0f\n\x07\x04\x01\x03\x02\x02\0\x03\x12\x04\xa7\x01\x1a\x1b\n\xfc\x02\n\
    \x06\x04\x01\x03\x02\x02\x01\x12\x04\xae\x01\x041\x1a\xeb\x02\x20API\x20\
    methods\x20or\x20permissions\x20to\x20allow.\x20Method\x20or\x20permissi\
    on\x20must\x20belong\x20to\n\x20the\x20service\x20specified\x20by\x20`se\
    rvice_name`\x20field.\x20A\x20single\x20[MethodSelector]\n\x20[google.id\
    entity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector]\n\
    \x20entry\x20with\x20`*`\x20specified\x20for\x20the\x20`method`\x20field\
    \x20will\x20allow\x20all\x20methods\n\x20AND\x20permissions\x20for\x20th\
    e\x20service\x20specified\x20in\x20`service_name`.\n\n\x0f\n\x07\x04\x01\
    \x03\x02\x02\x01\x04\x12\x04\xae\x01\x04\x0c\n\x0f\n\x07\x04\x01\x03\x02\
    \x02\x01\x06\x12\x04\xae\x01\r\x1b\n\x0f\n\x07\x04\x01\x03\x02\x02\x01\
    \x01\x12\x04\xae\x01\x1c,\n\x0f\n\x07\x04\x01\x03\x02\x02\x01\x03\x12\
    \x04\xae\x01/0\n\x9b\x01\n\x04\x04\x01\x03\x03\x12\x06\xb4\x01\x02\xd6\
    \x01\x03\x1a\x8a\x01\x20The\x20source\x20that\x20[IngressPolicy]\n\x20[g\
    oogle.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPol\
    icy]\n\x20authorizes\x20access\x20from.\n\n\r\n\x05\x04\x01\x03\x03\x01\
    \x12\x04\xb4\x01\n\x17\n\x9d\x01\n\x06\x04\x01\x03\x03\x08\0\x12\x06\xb8\
    \x01\x04\xd5\x01\x05\x1a\x8a\x01\x20Allowed\x20ingress\x20source.\x20It\
    \x20can\x20be\x20one\x20of\x20[AccessLevel]\n\x20[google.identity.access\
    contextmanager.v1.AccessLevel]\x20or\x20Google\n\x20Cloud\x20resource.\n\
    \n\x0f\n\x07\x04\x01\x03\x03\x08\0\x01\x12\x04\xb8\x01\n\x10\n\xf2\x07\n\
    \x06\x04\x01\x03\x03\x02\0\x12\x04\xcb\x01\x06\x1e\x1a\xe1\x07\x20An\x20\
    [AccessLevel]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\
    \x20resource\n\x20name\x20that\x20allow\x20resources\x20within\x20the\
    \x20[ServicePerimeters]\n\x20[google.identity.accesscontextmanager.v1.Se\
    rvicePerimeter]\x20to\x20be\n\x20accessed\x20from\x20the\x20internet.\
    \x20[AccessLevels]\n\x20[google.identity.accesscontextmanager.v1.AccessL\
    evel]\x20listed\x20must\n\x20be\x20in\x20the\x20same\x20policy\x20as\x20\
    this\x20[ServicePerimeter]\n\x20[google.identity.accesscontextmanager.v1\
    .ServicePerimeter].\n\x20Referencing\x20a\x20nonexistent\x20[AccessLevel\
    ]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\x20will\x20\
    cause\n\x20an\x20error.\x20If\x20no\x20[AccessLevel]\n\x20[google.identi\
    ty.accesscontextmanager.v1.AccessLevel]\x20names\x20are\n\x20listed,\x20\
    resources\x20within\x20the\x20perimeter\x20can\x20only\x20be\x20accessed\
    \x20via\x20Google\n\x20Cloud\x20calls\x20with\x20request\x20origins\x20w\
    ithin\x20the\x20perimeter.\x20Example:\n\x20`accessPolicies/MY_POLICY/ac\
    cessLevels/MY_LEVEL`.\x20If\x20a\x20single\x20`*`\x20is\n\x20specified\
    \x20for\x20`access_level`,\x20then\x20all\x20[IngressSources]\n\x20[goog\
    le.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource\
    ]\n\x20will\x20be\x20allowed.\n\n\x0f\n\x07\x04\x01\x03\x03\x02\0\x05\
    \x12\x04\xcb\x01\x06\x0c\n\x0f\n\x07\x04\x01\x03\x03\x02\0\x01\x12\x04\
    \xcb\x01\r\x19\n\x0f\n\x07\x04\x01\x03\x03\x02\0\x03\x12\x04\xcb\x01\x1c\
    \x1d\n\xb7\x03\n\x06\x04\x01\x03\x03\x02\x01\x12\x04\xd4\x01\x06\x1a\x1a\
    \xa6\x03\x20A\x20Google\x20Cloud\x20resource\x20that\x20is\x20allowed\
    \x20to\x20ingress\x20the\x20perimeter.\n\x20Requests\x20from\x20these\
    \x20resources\x20will\x20be\x20allowed\x20to\x20access\x20perimeter\x20d\
    ata.\n\x20Currently\x20only\x20projects\x20are\x20allowed.\n\x20Format:\
    \x20`projects/{project_number}`\n\x20The\x20project\x20may\x20be\x20in\
    \x20any\x20Google\x20Cloud\x20organization,\x20not\x20just\x20the\n\x20o\
    rganization\x20that\x20the\x20perimeter\x20is\x20defined\x20in.\x20`*`\
    \x20is\x20not\x20allowed,\x20the\n\x20case\x20of\x20allowing\x20all\x20G\
    oogle\x20Cloud\x20resources\x20only\x20is\x20not\x20supported.\n\n\x0f\n\
    \x07\x04\x01\x03\x03\x02\x01\x05\x12\x04\xd4\x01\x06\x0c\n\x0f\n\x07\x04\
    \x01\x03\x03\x02\x01\x01\x12\x04\xd4\x01\r\x15\n\x0f\n\x07\x04\x01\x03\
    \x03\x02\x01\x03\x12\x04\xd4\x01\x18\x19\n\xf7\x06\n\x04\x04\x01\x03\x04\
    \x12\x06\xe7\x01\x02\xf9\x01\x03\x1a\xe6\x06\x20Defines\x20the\x20condit\
    ions\x20under\x20which\x20an\x20[EgressPolicy]\n\x20[google.identity.acc\
    esscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]\n\x20matches\
    \x20a\x20request.\x20Conditions\x20are\x20based\x20on\x20information\x20\
    about\x20the\n\x20[ApiOperation]\n\x20[google.identity.accesscontextmana\
    ger.v1.ServicePerimeterConfig.ApiOperation]\n\x20intended\x20to\x20be\
    \x20performed\x20on\x20the\x20`resources`\x20specified.\x20Note\x20that\
    \x20if\x20the\n\x20destination\x20of\x20the\x20request\x20is\x20also\x20\
    protected\x20by\x20a\x20[ServicePerimeter]\n\x20[google.identity.accessc\
    ontextmanager.v1.ServicePerimeter],\x20then\x20that\n\x20[ServicePerimet\
    er]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\x20m\
    ust\x20have\n\x20an\x20[IngressPolicy]\n\x20[google.identity.accessconte\
    xtmanager.v1.ServicePerimeterConfig.IngressPolicy]\n\x20which\x20allows\
    \x20access\x20in\x20order\x20for\x20this\x20request\x20to\x20succeed.\
    \x20The\x20request\x20must\n\x20match\x20`operations`\x20AND\x20`resourc\
    es`\x20fields\x20in\x20order\x20to\x20be\x20allowed\x20egress\x20out\n\
    \x20of\x20the\x20perimeter.\n\n\r\n\x05\x04\x01\x03\x04\x01\x12\x04\xe7\
    \x01\n\x12\n\x92\x04\n\x06\x04\x01\x03\x04\x02\0\x12\x04\xf0\x01\x04\"\
    \x1a\x81\x04\x20A\x20list\x20of\x20resources,\x20currently\x20only\x20pr\
    ojects\x20in\x20the\x20form\n\x20`projects/<projectnumber>`,\x20that\x20\
    are\x20allowed\x20to\x20be\x20accessed\x20by\x20sources\n\x20defined\x20\
    in\x20the\x20corresponding\x20[EgressFrom]\n\x20[google.identity.accessc\
    ontextmanager.v1.ServicePerimeterConfig.EgressFrom].\n\x20A\x20request\
    \x20matches\x20if\x20it\x20contains\x20a\x20resource\x20in\x20this\x20li\
    st.\x20\x20If\x20`*`\x20is\n\x20specified\x20for\x20`resources`,\x20then\
    \x20this\x20[EgressTo]\n\x20[google.identity.accesscontextmanager.v1.Ser\
    vicePerimeterConfig.EgressTo]\n\x20rule\x20will\x20authorize\x20access\
    \x20to\x20all\x20resources\x20outside\x20the\x20perimeter.\n\n\x0f\n\x07\
    \x04\x01\x03\x04\x02\0\x04\x12\x04\xf0\x01\x04\x0c\n\x0f\n\x07\x04\x01\
    \x03\x04\x02\0\x05\x12\x04\xf0\x01\r\x13\n\x0f\n\x07\x04\x01\x03\x04\x02\
    \0\x01\x12\x04\xf0\x01\x14\x1d\n\x0f\n\x07\x04\x01\x03\x04\x02\0\x03\x12\
    \x04\xf0\x01\x20!\n\xdf\x02\n\x06\x04\x01\x03\x04\x02\x01\x12\x04\xf8\
    \x01\x04)\x1a\xce\x02\x20A\x20list\x20of\x20[ApiOperations]\n\x20[google\
    .identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]\n\
    \x20allowed\x20to\x20be\x20performed\x20by\x20the\x20sources\x20specifie\
    d\x20in\x20the\x20corresponding\n\x20[EgressFrom]\n\x20[google.identity.\
    accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom].\n\x20A\x20re\
    quest\x20matches\x20if\x20it\x20uses\x20an\x20operation/service\x20in\
    \x20this\x20list.\n\n\x0f\n\x07\x04\x01\x03\x04\x02\x01\x04\x12\x04\xf8\
    \x01\x04\x0c\n\x0f\n\x07\x04\x01\x03\x04\x02\x01\x06\x12\x04\xf8\x01\r\
    \x19\n\x0f\n\x07\x04\x01\x03\x04\x02\x01\x01\x12\x04\xf8\x01\x1a$\n\x0f\
    \n\x07\x04\x01\x03\x04\x02\x01\x03\x12\x04\xf8\x01'(\n\xd8\x02\n\x04\x04\
    \x01\x03\x05\x12\x06\x80\x02\x02\x8f\x02\x03\x1a\xc7\x02\x20Defines\x20t\
    he\x20conditions\x20under\x20which\x20an\x20[IngressPolicy]\n\x20[google\
    .identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]\
    \n\x20matches\x20a\x20request.\x20Conditions\x20are\x20based\x20on\x20in\
    formation\x20about\x20the\x20source\x20of\n\x20the\x20request.\x20The\
    \x20request\x20must\x20satisfy\x20what\x20is\x20defined\x20in\x20`source\
    s`\x20AND\n\x20identity\x20related\x20fields\x20in\x20order\x20to\x20mat\
    ch.\n\n\r\n\x05\x04\x01\x03\x05\x01\x12\x04\x80\x02\n\x15\n\x9d\x01\n\
    \x06\x04\x01\x03\x05\x02\0\x12\x04\x84\x02\x04'\x1a\x8c\x01\x20Sources\
    \x20that\x20this\x20[IngressPolicy]\n\x20[google.identity.accesscontextm\
    anager.v1.ServicePerimeterConfig.IngressPolicy]\n\x20authorizes\x20acces\
    s\x20from.\n\n\x0f\n\x07\x04\x01\x03\x05\x02\0\x04\x12\x04\x84\x02\x04\
    \x0c\n\x0f\n\x07\x04\x01\x03\x05\x02\0\x06\x12\x04\x84\x02\r\x1a\n\x0f\n\
    \x07\x04\x01\x03\x05\x02\0\x01\x12\x04\x84\x02\x1b\"\n\x0f\n\x07\x04\x01\
    \x03\x05\x02\0\x03\x12\x04\x84\x02%&\n\xd4\x01\n\x06\x04\x01\x03\x05\x02\
    \x01\x12\x04\x89\x02\x04#\x1a\xc3\x01\x20A\x20list\x20of\x20identities\
    \x20that\x20are\x20allowed\x20access\x20through\x20this\x20ingress\n\x20\
    policy.\x20Should\x20be\x20in\x20the\x20format\x20of\x20email\x20address\
    .\x20The\x20email\x20address\n\x20should\x20represent\x20individual\x20u\
    ser\x20or\x20service\x20account\x20only.\n\n\x0f\n\x07\x04\x01\x03\x05\
    \x02\x01\x04\x12\x04\x89\x02\x04\x0c\n\x0f\n\x07\x04\x01\x03\x05\x02\x01\
    \x05\x12\x04\x89\x02\r\x13\n\x0f\n\x07\x04\x01\x03\x05\x02\x01\x01\x12\
    \x04\x89\x02\x14\x1e\n\x0f\n\x07\x04\x01\x03\x05\x02\x01\x03\x12\x04\x89\
    \x02!\"\n\xb9\x01\n\x06\x04\x01\x03\x05\x02\x02\x12\x04\x8e\x02\x04#\x1a\
    \xa8\x01\x20Specifies\x20the\x20type\x20of\x20identities\x20that\x20are\
    \x20allowed\x20access\x20from\x20outside\x20the\n\x20perimeter.\x20If\
    \x20left\x20unspecified,\x20then\x20members\x20of\x20`identities`\x20fie\
    ld\x20will\n\x20be\x20allowed\x20access.\n\n\x0f\n\x07\x04\x01\x03\x05\
    \x02\x02\x06\x12\x04\x8e\x02\x04\x10\n\x0f\n\x07\x04\x01\x03\x05\x02\x02\
    \x01\x12\x04\x8e\x02\x11\x1e\n\x0f\n\x07\x04\x01\x03\x05\x02\x02\x03\x12\
    \x04\x8e\x02!\"\n\xd8\x03\n\x04\x04\x01\x03\x06\x12\x06\x99\x02\x02\xac\
    \x02\x03\x1a\xc7\x03\x20Defines\x20the\x20conditions\x20under\x20which\
    \x20an\x20[IngressPolicy]\n\x20[google.identity.accesscontextmanager.v1.\
    ServicePerimeterConfig.IngressPolicy]\n\x20matches\x20a\x20request.\x20C\
    onditions\x20are\x20based\x20on\x20information\x20about\x20the\n\x20[Api\
    Operation]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimete\
    rConfig.ApiOperation]\n\x20intended\x20to\x20be\x20performed\x20on\x20th\
    e\x20target\x20resource\x20of\x20the\x20request.\x20The\x20request\n\x20\
    must\x20satisfy\x20what\x20is\x20defined\x20in\x20`operations`\x20AND\
    \x20`resources`\x20in\x20order\x20to\n\x20match.\n\n\r\n\x05\x04\x01\x03\
    \x06\x01\x12\x04\x99\x02\n\x13\n\xf4\x02\n\x06\x04\x01\x03\x06\x02\0\x12\
    \x04\xa1\x02\x04)\x1a\xe3\x02\x20A\x20list\x20of\x20[ApiOperations]\n\
    \x20[google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiO\
    peration]\n\x20allowed\x20to\x20be\x20performed\x20by\x20the\x20sources\
    \x20specified\x20in\x20corresponding\n\x20[IngressFrom]\n\x20[google.ide\
    ntity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom]\n\x20i\
    n\x20this\x20[ServicePerimeter]\n\x20[google.identity.accesscontextmanag\
    er.v1.ServicePerimeter].\n\n\x0f\n\x07\x04\x01\x03\x06\x02\0\x04\x12\x04\
    \xa1\x02\x04\x0c\n\x0f\n\x07\x04\x01\x03\x06\x02\0\x06\x12\x04\xa1\x02\r\
    \x19\n\x0f\n\x07\x04\x01\x03\x06\x02\0\x01\x12\x04\xa1\x02\x1a$\n\x0f\n\
    \x07\x04\x01\x03\x06\x02\0\x03\x12\x04\xa1\x02'(\n\xcf\x03\n\x06\x04\x01\
    \x03\x06\x02\x01\x12\x04\xab\x02\x04\"\x1a\xbe\x03\x20A\x20list\x20of\
    \x20resources,\x20currently\x20only\x20projects\x20in\x20the\x20form\n\
    \x20`projects/<projectnumber>`,\x20protected\x20by\x20this\x20[ServicePe\
    rimeter]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\
    \x20that\x20are\n\x20allowed\x20to\x20be\x20accessed\x20by\x20sources\
    \x20defined\x20in\x20the\x20corresponding\n\x20[IngressFrom]\n\x20[googl\
    e.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom].\
    \n\x20If\x20a\x20single\x20`*`\x20is\x20specified,\x20then\x20access\x20\
    to\x20all\x20resources\x20inside\x20the\n\x20perimeter\x20are\x20allowed\
    .\n\n\x0f\n\x07\x04\x01\x03\x06\x02\x01\x04\x12\x04\xab\x02\x04\x0c\n\
    \x0f\n\x07\x04\x01\x03\x06\x02\x01\x05\x12\x04\xab\x02\r\x13\n\x0f\n\x07\
    \x04\x01\x03\x06\x02\x01\x01\x12\x04\xab\x02\x14\x1d\n\x0f\n\x07\x04\x01\
    \x03\x06\x02\x01\x03\x12\x04\xab\x02\x20!\n\x8b\x08\n\x04\x04\x01\x03\
    \x07\x12\x06\xc2\x02\x02\xcf\x02\x03\x1a\xfa\x07\x20Policy\x20for\x20ing\
    ress\x20into\x20[ServicePerimeter]\n\x20[google.identity.accesscontextma\
    nager.v1.ServicePerimeter].\n\n\x20[IngressPolicies]\n\x20[google.identi\
    ty.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]\n\x20ma\
    tch\x20requests\x20based\x20on\x20`ingress_from`\x20and\x20`ingress_to`\
    \x20stanzas.\x20\x20For\x20an\n\x20ingress\x20policy\x20to\x20match,\x20\
    both\x20the\x20`ingress_from`\x20and\x20`ingress_to`\x20stanzas\n\x20mus\
    t\x20be\x20matched.\x20If\x20an\x20[IngressPolicy]\n\x20[google.identity\
    .accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]\n\x20matc\
    hes\x20a\x20request,\x20the\x20request\x20is\x20allowed\x20through\x20th\
    e\x20perimeter\x20boundary\n\x20from\x20outside\x20the\x20perimeter.\n\n\
    \x20For\x20example,\x20access\x20from\x20the\x20internet\x20can\x20be\
    \x20allowed\x20either\n\x20based\x20on\x20an\x20[AccessLevel]\n\x20[goog\
    le.identity.accesscontextmanager.v1.AccessLevel]\x20or,\x20for\x20traffi\
    c\n\x20hosted\x20on\x20Google\x20Cloud,\x20the\x20project\x20of\x20the\
    \x20source\x20network.\x20For\x20access\x20from\n\x20private\x20networks\
    ,\x20using\x20the\x20project\x20of\x20the\x20hosting\x20network\x20is\
    \x20required.\n\n\x20Individual\x20ingress\x20policies\x20can\x20be\x20l\
    imited\x20by\x20restricting\x20which\n\x20services\x20and/or\x20actions\
    \x20they\x20match\x20using\x20the\x20`ingress_to`\x20field.\n\n\r\n\x05\
    \x04\x01\x03\x07\x01\x12\x04\xc2\x02\n\x17\n\xbd\x01\n\x06\x04\x01\x03\
    \x07\x02\0\x12\x04\xc7\x02\x04!\x1a\xac\x01\x20Defines\x20the\x20conditi\
    ons\x20on\x20the\x20source\x20of\x20a\x20request\x20causing\x20this\n\
    \x20[IngressPolicy]\n\x20[google.identity.accesscontextmanager.v1.Servic\
    ePerimeterConfig.IngressPolicy]\n\x20to\x20apply.\n\n\x0f\n\x07\x04\x01\
    \x03\x07\x02\0\x06\x12\x04\xc7\x02\x04\x0f\n\x0f\n\x07\x04\x01\x03\x07\
    \x02\0\x01\x12\x04\xc7\x02\x10\x1c\n\x0f\n\x07\x04\x01\x03\x07\x02\0\x03\
    \x12\x04\xc7\x02\x1f\x20\n\xa2\x02\n\x06\x04\x01\x03\x07\x02\x01\x12\x04\
    \xce\x02\x04\x1d\x1a\x91\x02\x20Defines\x20the\x20conditions\x20on\x20th\
    e\x20[ApiOperation]\n\x20[google.identity.accesscontextmanager.v1.Servic\
    ePerimeterConfig.ApiOperation]\n\x20and\x20request\x20destination\x20tha\
    t\x20cause\x20this\x20[IngressPolicy]\n\x20[google.identity.accesscontex\
    tmanager.v1.ServicePerimeterConfig.IngressPolicy]\n\x20to\x20apply.\n\n\
    \x0f\n\x07\x04\x01\x03\x07\x02\x01\x06\x12\x04\xce\x02\x04\r\n\x0f\n\x07\
    \x04\x01\x03\x07\x02\x01\x01\x12\x04\xce\x02\x0e\x18\n\x0f\n\x07\x04\x01\
    \x03\x07\x02\x01\x03\x12\x04\xce\x02\x1b\x1c\n\xa5\x0c\n\x04\x04\x01\x03\
    \x08\x12\x06\xed\x02\x02\xf9\x02\x03\x1a\x94\x0c\x20Policy\x20for\x20egr\
    ess\x20from\x20perimeter.\n\n\x20[EgressPolicies]\n\x20[google.identity.\
    accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]\n\x20match\
    \x20requests\x20based\x20on\x20`egress_from`\x20and\x20`egress_to`\x20st\
    anzas.\x20\x20For\x20an\n\x20[EgressPolicy]\n\x20[google.identity.access\
    contextmanager.v1.ServicePerimeterConfig.EgressPolicy]\n\x20to\x20match,\
    \x20both\x20`egress_from`\x20and\x20`egress_to`\x20stanzas\x20must\x20be\
    \x20matched.\x20If\x20an\n\x20[EgressPolicy]\n\x20[google.identity.acces\
    scontextmanager.v1.ServicePerimeterConfig.EgressPolicy]\n\x20matches\x20\
    a\x20request,\x20the\x20request\x20is\x20allowed\x20to\x20span\x20the\
    \x20[ServicePerimeter]\n\x20[google.identity.accesscontextmanager.v1.Ser\
    vicePerimeter]\x20boundary.\n\x20For\x20example,\x20an\x20[EgressPolicy]\
    \n\x20[google.identity.accesscontextmanager.v1.ServicePerimeterConfig.Eg\
    ressPolicy]\n\x20can\x20be\x20used\x20to\x20allow\x20VMs\x20on\x20networ\
    ks\x20within\x20the\x20[ServicePerimeter]\n\x20[google.identity.accessco\
    ntextmanager.v1.ServicePerimeter]\x20to\x20access\x20a\n\x20defined\x20s\
    et\x20of\x20projects\x20outside\x20the\x20perimeter\x20in\x20certain\x20\
    contexts\x20(e.g.\x20to\n\x20read\x20data\x20from\x20a\x20Cloud\x20Stora\
    ge\x20bucket\x20or\x20query\x20against\x20a\x20BigQuery\x20dataset).\n\n\
    \x20[EgressPolicies]\n\x20[google.identity.accesscontextmanager.v1.Servi\
    cePerimeterConfig.EgressPolicy]\n\x20are\x20concerned\x20with\x20the\x20\
    *resources*\x20that\x20a\x20request\x20relates\x20as\x20well\x20as\x20th\
    e\n\x20API\x20services\x20and\x20API\x20actions\x20being\x20used.\x20\
    \x20They\x20do\x20not\x20related\x20to\x20the\n\x20direction\x20of\x20da\
    ta\x20movement.\x20\x20More\x20detailed\x20documentation\x20for\x20this\
    \x20concept\n\x20can\x20be\x20found\x20in\x20the\x20descriptions\x20of\
    \x20[EgressFrom]\n\x20[google.identity.accesscontextmanager.v1.ServicePe\
    rimeterConfig.EgressFrom]\n\x20and\x20[EgressTo]\n\x20[google.identity.a\
    ccesscontextmanager.v1.ServicePerimeterConfig.EgressTo].\n\n\r\n\x05\x04\
    \x01\x03\x08\x01\x12\x04\xed\x02\n\x16\n\xb6\x01\n\x06\x04\x01\x03\x08\
    \x02\0\x12\x04\xf1\x02\x04\x1f\x1a\xa5\x01\x20Defines\x20conditions\x20o\
    n\x20the\x20source\x20of\x20a\x20request\x20causing\x20this\x20[EgressPo\
    licy]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeterConf\
    ig.EgressPolicy]\n\x20to\x20apply.\n\n\x0f\n\x07\x04\x01\x03\x08\x02\0\
    \x06\x12\x04\xf1\x02\x04\x0e\n\x0f\n\x07\x04\x01\x03\x08\x02\0\x01\x12\
    \x04\xf1\x02\x0f\x1a\n\x0f\n\x07\x04\x01\x03\x08\x02\0\x03\x12\x04\xf1\
    \x02\x1d\x1e\n\xa2\x02\n\x06\x04\x01\x03\x08\x02\x01\x12\x04\xf8\x02\x04\
    \x1b\x1a\x91\x02\x20Defines\x20the\x20conditions\x20on\x20the\x20[ApiOpe\
    ration]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeterCo\
    nfig.ApiOperation]\n\x20and\x20destination\x20resources\x20that\x20cause\
    \x20this\x20[EgressPolicy]\n\x20[google.identity.accesscontextmanager.v1\
    .ServicePerimeterConfig.EgressPolicy]\n\x20to\x20apply.\n\n\x0f\n\x07\
    \x04\x01\x03\x08\x02\x01\x06\x12\x04\xf8\x02\x04\x0c\n\x0f\n\x07\x04\x01\
    \x03\x08\x02\x01\x01\x12\x04\xf8\x02\r\x16\n\x0f\n\x07\x04\x01\x03\x08\
    \x02\x01\x03\x12\x04\xf8\x02\x19\x1a\n\x83\x05\n\x04\x04\x01\x03\t\x12\
    \x06\x86\x03\x02\x90\x03\x03\x1a\xf2\x04\x20Defines\x20the\x20conditions\
    \x20under\x20which\x20an\x20[EgressPolicy]\n\x20[google.identity.accessc\
    ontextmanager.v1.ServicePerimeterConfig.EgressPolicy]\n\x20matches\x20a\
    \x20request.\x20Conditions\x20based\x20on\x20information\x20about\x20the\
    \x20source\x20of\x20the\n\x20request.\x20Note\x20that\x20if\x20the\x20de\
    stination\x20of\x20the\x20request\x20is\x20also\x20protected\x20by\x20a\
    \n\x20[ServicePerimeter]\n\x20[google.identity.accesscontextmanager.v1.S\
    ervicePerimeter],\x20then\x20that\n\x20[ServicePerimeter]\n\x20[google.i\
    dentity.accesscontextmanager.v1.ServicePerimeter]\x20must\x20have\n\x20a\
    n\x20[IngressPolicy]\n\x20[google.identity.accesscontextmanager.v1.Servi\
    cePerimeterConfig.IngressPolicy]\n\x20which\x20allows\x20access\x20in\
    \x20order\x20for\x20this\x20request\x20to\x20succeed.\n\n\r\n\x05\x04\
    \x01\x03\t\x01\x12\x04\x86\x03\n\x14\n\xd4\x01\n\x06\x04\x01\x03\t\x02\0\
    \x12\x04\x8a\x03\x04#\x1a\xc3\x01\x20A\x20list\x20of\x20identities\x20th\
    at\x20are\x20allowed\x20access\x20through\x20this\x20[EgressPolicy].\n\
    \x20Should\x20be\x20in\x20the\x20format\x20of\x20email\x20address.\x20Th\
    e\x20email\x20address\x20should\n\x20represent\x20individual\x20user\x20\
    or\x20service\x20account\x20only.\n\n\x0f\n\x07\x04\x01\x03\t\x02\0\x04\
    \x12\x04\x8a\x03\x04\x0c\n\x0f\n\x07\x04\x01\x03\t\x02\0\x05\x12\x04\x8a\
    \x03\r\x13\n\x0f\n\x07\x04\x01\x03\t\x02\0\x01\x12\x04\x8a\x03\x14\x1e\n\
    \x0f\n\x07\x04\x01\x03\t\x02\0\x03\x12\x04\x8a\x03!\"\n\xb7\x01\n\x06\
    \x04\x01\x03\t\x02\x01\x12\x04\x8f\x03\x04#\x1a\xa6\x01\x20Specifies\x20\
    the\x20type\x20of\x20identities\x20that\x20are\x20allowed\x20access\x20t\
    o\x20outside\x20the\n\x20perimeter.\x20If\x20left\x20unspecified,\x20the\
    n\x20members\x20of\x20`identities`\x20field\x20will\n\x20be\x20allowed\
    \x20access.\n\n\x0f\n\x07\x04\x01\x03\t\x02\x01\x06\x12\x04\x8f\x03\x04\
    \x10\n\x0f\n\x07\x04\x01\x03\t\x02\x01\x01\x12\x04\x8f\x03\x11\x1e\n\x0f\
    \n\x07\x04\x01\x03\t\x02\x01\x03\x12\x04\x8f\x03!\"\n\x99\x02\n\x04\x04\
    \x01\x04\0\x12\x06\x98\x03\x02\xa4\x03\x03\x1a\x88\x02\x20Specifies\x20t\
    he\x20types\x20of\x20identities\x20that\x20are\x20allowed\x20access\x20i\
    n\x20either\n\x20[IngressFrom]\n\x20[google.identity.accesscontextmanage\
    r.v1.ServicePerimeterConfig.IngressFrom]\n\x20or\x20[EgressFrom]\n\x20[g\
    oogle.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom\
    ]\n\x20rules.\n\n\r\n\x05\x04\x01\x04\0\x01\x12\x04\x98\x03\x07\x13\n6\n\
    \x06\x04\x01\x04\0\x02\0\x12\x04\x9a\x03\x04\"\x1a&\x20No\x20blanket\x20\
    identity\x20group\x20specified.\n\n\x0f\n\x07\x04\x01\x04\0\x02\0\x01\
    \x12\x04\x9a\x03\x04\x1d\n\x0f\n\x07\x04\x01\x04\0\x02\0\x02\x12\x04\x9a\
    \x03\x20!\nM\n\x06\x04\x01\x04\0\x02\x01\x12\x04\x9d\x03\x04\x15\x1a=\
    \x20Authorize\x20access\x20from\x20all\x20identities\x20outside\x20the\
    \x20perimeter.\n\n\x0f\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x04\x9d\x03\
    \x04\x10\n\x0f\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x04\x9d\x03\x13\x14\n\
    N\n\x06\x04\x01\x04\0\x02\x02\x12\x04\xa0\x03\x04\x19\x1a>\x20Authorize\
    \x20access\x20from\x20all\x20human\x20users\x20outside\x20the\x20perimet\
    er.\n\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x04\xa0\x03\x04\x14\n\
    \x0f\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x04\xa0\x03\x17\x18\nS\n\x06\
    \x04\x01\x04\0\x02\x03\x12\x04\xa3\x03\x04\x1c\x1aC\x20Authorize\x20acce\
    ss\x20from\x20all\x20service\x20accounts\x20outside\x20the\x20perimeter.\
    \n\n\x0f\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x04\xa3\x03\x04\x17\n\x0f\n\
    \x07\x04\x01\x04\0\x02\x03\x02\x12\x04\xa3\x03\x1a\x1b\n\xa5\x01\n\x04\
    \x04\x01\x02\0\x12\x04\xa8\x03\x02\x20\x1a\x96\x01\x20A\x20list\x20of\
    \x20Google\x20Cloud\x20resources\x20that\x20are\x20inside\x20of\x20the\
    \x20service\x20perimeter.\n\x20Currently\x20only\x20projects\x20are\x20a\
    llowed.\x20Format:\x20`projects/{project_number}`\n\n\r\n\x05\x04\x01\
    \x02\0\x04\x12\x04\xa8\x03\x02\n\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xa8\
    \x03\x0b\x11\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xa8\x03\x12\x1b\n\r\n\
    \x05\x04\x01\x02\0\x03\x12\x04\xa8\x03\x1e\x1f\n\xa1\x04\n\x04\x04\x01\
    \x02\x01\x12\x04\xb2\x03\x02$\x1a\x92\x04\x20A\x20list\x20of\x20`AccessL\
    evel`\x20resource\x20names\x20that\x20allow\x20resources\x20within\x20th\
    e\n\x20`ServicePerimeter`\x20to\x20be\x20accessed\x20from\x20the\x20inte\
    rnet.\x20`AccessLevels`\x20listed\n\x20must\x20be\x20in\x20the\x20same\
    \x20policy\x20as\x20this\x20`ServicePerimeter`.\x20Referencing\x20a\n\
    \x20nonexistent\x20`AccessLevel`\x20is\x20a\x20syntax\x20error.\x20If\
    \x20no\x20`AccessLevel`\x20names\x20are\n\x20listed,\x20resources\x20wit\
    hin\x20the\x20perimeter\x20can\x20only\x20be\x20accessed\x20via\x20Googl\
    e\n\x20Cloud\x20calls\x20with\x20request\x20origins\x20within\x20the\x20\
    perimeter.\x20Example:\n\x20`\"accessPolicies/MY_POLICY/accessLevels/MY_\
    LEVEL\"`.\n\x20For\x20Service\x20Perimeter\x20Bridge,\x20must\x20be\x20e\
    mpty.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\xb2\x03\x02\n\n\r\n\x05\
    \x04\x01\x02\x01\x05\x12\x04\xb2\x03\x0b\x11\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\xb2\x03\x12\x1f\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xb2\
    \x03\"#\n\xfa\x01\n\x04\x04\x01\x02\x02\x12\x04\xb8\x03\x02*\x1a\xeb\x01\
    \x20Google\x20Cloud\x20services\x20that\x20are\x20subject\x20to\x20the\
    \x20Service\x20Perimeter\n\x20restrictions.\x20For\x20example,\x20if\x20\
    `storage.googleapis.com`\x20is\x20specified,\x20access\n\x20to\x20the\
    \x20storage\x20buckets\x20inside\x20the\x20perimeter\x20must\x20meet\x20\
    the\x20perimeter's\n\x20access\x20restrictions.\n\n\r\n\x05\x04\x01\x02\
    \x02\x04\x12\x04\xb8\x03\x02\n\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xb8\
    \x03\x0b\x11\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xb8\x03\x12%\n\r\n\
    \x05\x04\x01\x02\x02\x03\x12\x04\xb8\x03()\n@\n\x04\x04\x01\x02\x03\x12\
    \x04\xbb\x03\x025\x1a2\x20Configuration\x20for\x20APIs\x20allowed\x20wit\
    hin\x20Perimeter.\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\xbb\x03\x02\
    \x17\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\xbb\x03\x18/\n\r\n\x05\x04\
    \x01\x02\x03\x03\x12\x04\xbb\x0324\n\xec\x03\n\x04\x04\x01\x02\x04\x12\
    \x04\xc5\x03\x02.\x1a\xdd\x03\x20List\x20of\x20[IngressPolicies]\n\x20[g\
    oogle.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPol\
    icy]\n\x20to\x20apply\x20to\x20the\x20perimeter.\x20A\x20perimeter\x20ma\
    y\x20have\x20multiple\x20[IngressPolicies]\n\x20[google.identity.accessc\
    ontextmanager.v1.ServicePerimeterConfig.IngressPolicy],\n\x20each\x20of\
    \x20which\x20is\x20evaluated\x20separately.\x20Access\x20is\x20granted\
    \x20if\x20any\x20[Ingress\n\x20Policy]\n\x20[google.identity.accessconte\
    xtmanager.v1.ServicePerimeterConfig.IngressPolicy]\n\x20grants\x20it.\
    \x20Must\x20be\x20empty\x20for\x20a\x20perimeter\x20bridge.\n\n\r\n\x05\
    \x04\x01\x02\x04\x04\x12\x04\xc5\x03\x02\n\n\r\n\x05\x04\x01\x02\x04\x06\
    \x12\x04\xc5\x03\x0b\x18\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\xc5\x03\
    \x19)\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\xc5\x03,-\n\xe5\x03\n\x04\
    \x04\x01\x02\x05\x12\x04\xcf\x03\x02,\x1a\xd6\x03\x20List\x20of\x20[Egre\
    ssPolicies]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimet\
    erConfig.EgressPolicy]\n\x20to\x20apply\x20to\x20the\x20perimeter.\x20A\
    \x20perimeter\x20may\x20have\x20multiple\x20[EgressPolicies]\n\x20[googl\
    e.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy],\
    \n\x20each\x20of\x20which\x20is\x20evaluated\x20separately.\x20Access\
    \x20is\x20granted\x20if\x20any\n\x20[EgressPolicy]\n\x20[google.identity\
    .accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]\n\x20grant\
    s\x20it.\x20Must\x20be\x20empty\x20for\x20a\x20perimeter\x20bridge.\n\n\
    \r\n\x05\x04\x01\x02\x05\x04\x12\x04\xcf\x03\x02\n\n\r\n\x05\x04\x01\x02\
    \x05\x06\x12\x04\xcf\x03\x0b\x17\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\
    \xcf\x03\x18'\n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\xcf\x03*+b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
