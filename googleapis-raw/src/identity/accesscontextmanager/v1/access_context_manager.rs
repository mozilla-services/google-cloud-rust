// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/identity/accesscontextmanager/v1/access_context_manager.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct ListAccessPoliciesRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAccessPoliciesRequest {
    fn default() -> &'a ListAccessPoliciesRequest {
        <ListAccessPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAccessPoliciesRequest {
    pub fn new() -> ListAccessPoliciesRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAccessPoliciesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAccessPoliciesRequest {
        ListAccessPoliciesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListAccessPoliciesRequest| { &m.parent },
                |m: &mut ListAccessPoliciesRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListAccessPoliciesRequest| { &m.page_size },
                |m: &mut ListAccessPoliciesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListAccessPoliciesRequest| { &m.page_token },
                |m: &mut ListAccessPoliciesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAccessPoliciesRequest>(
                "ListAccessPoliciesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAccessPoliciesRequest {
        static instance: ::protobuf::rt::LazyV2<ListAccessPoliciesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAccessPoliciesRequest::new)
    }
}

impl ::protobuf::Clear for ListAccessPoliciesRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAccessPoliciesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAccessPoliciesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAccessPoliciesResponse {
    // message fields
    pub access_policies: ::protobuf::RepeatedField<super::access_policy::AccessPolicy>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAccessPoliciesResponse {
    fn default() -> &'a ListAccessPoliciesResponse {
        <ListAccessPoliciesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListAccessPoliciesResponse {
    pub fn new() -> ListAccessPoliciesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.AccessPolicy access_policies = 1;


    pub fn get_access_policies(&self) -> &[super::access_policy::AccessPolicy] {
        &self.access_policies
    }
    pub fn clear_access_policies(&mut self) {
        self.access_policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_policies(&mut self, v: ::protobuf::RepeatedField<super::access_policy::AccessPolicy>) {
        self.access_policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_access_policies(&mut self) -> &mut ::protobuf::RepeatedField<super::access_policy::AccessPolicy> {
        &mut self.access_policies
    }

    // Take field
    pub fn take_access_policies(&mut self) -> ::protobuf::RepeatedField<super::access_policy::AccessPolicy> {
        ::std::mem::replace(&mut self.access_policies, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAccessPoliciesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.access_policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.access_policies)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.access_policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.access_policies {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAccessPoliciesResponse {
        ListAccessPoliciesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_policy::AccessPolicy>>(
                "access_policies",
                |m: &ListAccessPoliciesResponse| { &m.access_policies },
                |m: &mut ListAccessPoliciesResponse| { &mut m.access_policies },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListAccessPoliciesResponse| { &m.next_page_token },
                |m: &mut ListAccessPoliciesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAccessPoliciesResponse>(
                "ListAccessPoliciesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAccessPoliciesResponse {
        static instance: ::protobuf::rt::LazyV2<ListAccessPoliciesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAccessPoliciesResponse::new)
    }
}

impl ::protobuf::Clear for ListAccessPoliciesResponse {
    fn clear(&mut self) {
        self.access_policies.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAccessPoliciesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAccessPoliciesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAccessPolicyRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccessPolicyRequest {
    fn default() -> &'a GetAccessPolicyRequest {
        <GetAccessPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccessPolicyRequest {
    pub fn new() -> GetAccessPolicyRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAccessPolicyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccessPolicyRequest {
        GetAccessPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetAccessPolicyRequest| { &m.name },
                |m: &mut GetAccessPolicyRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAccessPolicyRequest>(
                "GetAccessPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAccessPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<GetAccessPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAccessPolicyRequest::new)
    }
}

impl ::protobuf::Clear for GetAccessPolicyRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccessPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccessPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateAccessPolicyRequest {
    // message fields
    pub policy: ::protobuf::SingularPtrField<super::access_policy::AccessPolicy>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAccessPolicyRequest {
    fn default() -> &'a UpdateAccessPolicyRequest {
        <UpdateAccessPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAccessPolicyRequest {
    pub fn new() -> UpdateAccessPolicyRequest {
        ::std::default::Default::default()
    }

    // .google.identity.accesscontextmanager.v1.AccessPolicy policy = 1;


    pub fn get_policy(&self) -> &super::access_policy::AccessPolicy {
        self.policy.as_ref().unwrap_or_else(|| <super::access_policy::AccessPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: super::access_policy::AccessPolicy) {
        self.policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut super::access_policy::AccessPolicy {
        if self.policy.is_none() {
            self.policy.set_default();
        }
        self.policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_policy(&mut self) -> super::access_policy::AccessPolicy {
        self.policy.take().unwrap_or_else(|| super::access_policy::AccessPolicy::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateAccessPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.policy)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAccessPolicyRequest {
        UpdateAccessPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_policy::AccessPolicy>>(
                "policy",
                |m: &UpdateAccessPolicyRequest| { &m.policy },
                |m: &mut UpdateAccessPolicyRequest| { &mut m.policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateAccessPolicyRequest| { &m.update_mask },
                |m: &mut UpdateAccessPolicyRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateAccessPolicyRequest>(
                "UpdateAccessPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateAccessPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateAccessPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateAccessPolicyRequest::new)
    }
}

impl ::protobuf::Clear for UpdateAccessPolicyRequest {
    fn clear(&mut self) {
        self.policy.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateAccessPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAccessPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAccessPolicyRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAccessPolicyRequest {
    fn default() -> &'a DeleteAccessPolicyRequest {
        <DeleteAccessPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAccessPolicyRequest {
    pub fn new() -> DeleteAccessPolicyRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteAccessPolicyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAccessPolicyRequest {
        DeleteAccessPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteAccessPolicyRequest| { &m.name },
                |m: &mut DeleteAccessPolicyRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAccessPolicyRequest>(
                "DeleteAccessPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAccessPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAccessPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAccessPolicyRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAccessPolicyRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAccessPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAccessPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAccessLevelsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub access_level_format: LevelFormat,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAccessLevelsRequest {
    fn default() -> &'a ListAccessLevelsRequest {
        <ListAccessLevelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAccessLevelsRequest {
    pub fn new() -> ListAccessLevelsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // .google.identity.accesscontextmanager.v1.LevelFormat access_level_format = 4;


    pub fn get_access_level_format(&self) -> LevelFormat {
        self.access_level_format
    }
    pub fn clear_access_level_format(&mut self) {
        self.access_level_format = LevelFormat::LEVEL_FORMAT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_access_level_format(&mut self, v: LevelFormat) {
        self.access_level_format = v;
    }
}

impl ::protobuf::Message for ListAccessLevelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.access_level_format, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        if self.access_level_format != LevelFormat::LEVEL_FORMAT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.access_level_format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        if self.access_level_format != LevelFormat::LEVEL_FORMAT_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.access_level_format))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAccessLevelsRequest {
        ListAccessLevelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListAccessLevelsRequest| { &m.parent },
                |m: &mut ListAccessLevelsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListAccessLevelsRequest| { &m.page_size },
                |m: &mut ListAccessLevelsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListAccessLevelsRequest| { &m.page_token },
                |m: &mut ListAccessLevelsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LevelFormat>>(
                "access_level_format",
                |m: &ListAccessLevelsRequest| { &m.access_level_format },
                |m: &mut ListAccessLevelsRequest| { &mut m.access_level_format },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAccessLevelsRequest>(
                "ListAccessLevelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAccessLevelsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAccessLevelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAccessLevelsRequest::new)
    }
}

impl ::protobuf::Clear for ListAccessLevelsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.access_level_format = LevelFormat::LEVEL_FORMAT_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAccessLevelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAccessLevelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAccessLevelsResponse {
    // message fields
    pub access_levels: ::protobuf::RepeatedField<super::access_level::AccessLevel>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAccessLevelsResponse {
    fn default() -> &'a ListAccessLevelsResponse {
        <ListAccessLevelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListAccessLevelsResponse {
    pub fn new() -> ListAccessLevelsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.AccessLevel access_levels = 1;


    pub fn get_access_levels(&self) -> &[super::access_level::AccessLevel] {
        &self.access_levels
    }
    pub fn clear_access_levels(&mut self) {
        self.access_levels.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_levels(&mut self, v: ::protobuf::RepeatedField<super::access_level::AccessLevel>) {
        self.access_levels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_access_levels(&mut self) -> &mut ::protobuf::RepeatedField<super::access_level::AccessLevel> {
        &mut self.access_levels
    }

    // Take field
    pub fn take_access_levels(&mut self) -> ::protobuf::RepeatedField<super::access_level::AccessLevel> {
        ::std::mem::replace(&mut self.access_levels, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAccessLevelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.access_levels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.access_levels)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.access_levels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.access_levels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAccessLevelsResponse {
        ListAccessLevelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_level::AccessLevel>>(
                "access_levels",
                |m: &ListAccessLevelsResponse| { &m.access_levels },
                |m: &mut ListAccessLevelsResponse| { &mut m.access_levels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListAccessLevelsResponse| { &m.next_page_token },
                |m: &mut ListAccessLevelsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAccessLevelsResponse>(
                "ListAccessLevelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAccessLevelsResponse {
        static instance: ::protobuf::rt::LazyV2<ListAccessLevelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAccessLevelsResponse::new)
    }
}

impl ::protobuf::Clear for ListAccessLevelsResponse {
    fn clear(&mut self) {
        self.access_levels.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAccessLevelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAccessLevelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAccessLevelRequest {
    // message fields
    pub name: ::std::string::String,
    pub access_level_format: LevelFormat,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccessLevelRequest {
    fn default() -> &'a GetAccessLevelRequest {
        <GetAccessLevelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccessLevelRequest {
    pub fn new() -> GetAccessLevelRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.identity.accesscontextmanager.v1.LevelFormat access_level_format = 2;


    pub fn get_access_level_format(&self) -> LevelFormat {
        self.access_level_format
    }
    pub fn clear_access_level_format(&mut self) {
        self.access_level_format = LevelFormat::LEVEL_FORMAT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_access_level_format(&mut self, v: LevelFormat) {
        self.access_level_format = v;
    }
}

impl ::protobuf::Message for GetAccessLevelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.access_level_format, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.access_level_format != LevelFormat::LEVEL_FORMAT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.access_level_format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.access_level_format != LevelFormat::LEVEL_FORMAT_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.access_level_format))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccessLevelRequest {
        GetAccessLevelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetAccessLevelRequest| { &m.name },
                |m: &mut GetAccessLevelRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LevelFormat>>(
                "access_level_format",
                |m: &GetAccessLevelRequest| { &m.access_level_format },
                |m: &mut GetAccessLevelRequest| { &mut m.access_level_format },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAccessLevelRequest>(
                "GetAccessLevelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAccessLevelRequest {
        static instance: ::protobuf::rt::LazyV2<GetAccessLevelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAccessLevelRequest::new)
    }
}

impl ::protobuf::Clear for GetAccessLevelRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.access_level_format = LevelFormat::LEVEL_FORMAT_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccessLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccessLevelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateAccessLevelRequest {
    // message fields
    pub parent: ::std::string::String,
    pub access_level: ::protobuf::SingularPtrField<super::access_level::AccessLevel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateAccessLevelRequest {
    fn default() -> &'a CreateAccessLevelRequest {
        <CreateAccessLevelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateAccessLevelRequest {
    pub fn new() -> CreateAccessLevelRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.identity.accesscontextmanager.v1.AccessLevel access_level = 2;


    pub fn get_access_level(&self) -> &super::access_level::AccessLevel {
        self.access_level.as_ref().unwrap_or_else(|| <super::access_level::AccessLevel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_access_level(&mut self) {
        self.access_level.clear();
    }

    pub fn has_access_level(&self) -> bool {
        self.access_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_level(&mut self, v: super::access_level::AccessLevel) {
        self.access_level = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_level(&mut self) -> &mut super::access_level::AccessLevel {
        if self.access_level.is_none() {
            self.access_level.set_default();
        }
        self.access_level.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_level(&mut self) -> super::access_level::AccessLevel {
        self.access_level.take().unwrap_or_else(|| super::access_level::AccessLevel::new())
    }
}

impl ::protobuf::Message for CreateAccessLevelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.access_level {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.access_level)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.access_level.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.access_level.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateAccessLevelRequest {
        CreateAccessLevelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateAccessLevelRequest| { &m.parent },
                |m: &mut CreateAccessLevelRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_level::AccessLevel>>(
                "access_level",
                |m: &CreateAccessLevelRequest| { &m.access_level },
                |m: &mut CreateAccessLevelRequest| { &mut m.access_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateAccessLevelRequest>(
                "CreateAccessLevelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateAccessLevelRequest {
        static instance: ::protobuf::rt::LazyV2<CreateAccessLevelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateAccessLevelRequest::new)
    }
}

impl ::protobuf::Clear for CreateAccessLevelRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.access_level.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateAccessLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateAccessLevelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateAccessLevelRequest {
    // message fields
    pub access_level: ::protobuf::SingularPtrField<super::access_level::AccessLevel>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAccessLevelRequest {
    fn default() -> &'a UpdateAccessLevelRequest {
        <UpdateAccessLevelRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAccessLevelRequest {
    pub fn new() -> UpdateAccessLevelRequest {
        ::std::default::Default::default()
    }

    // .google.identity.accesscontextmanager.v1.AccessLevel access_level = 1;


    pub fn get_access_level(&self) -> &super::access_level::AccessLevel {
        self.access_level.as_ref().unwrap_or_else(|| <super::access_level::AccessLevel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_access_level(&mut self) {
        self.access_level.clear();
    }

    pub fn has_access_level(&self) -> bool {
        self.access_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_level(&mut self, v: super::access_level::AccessLevel) {
        self.access_level = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_level(&mut self) -> &mut super::access_level::AccessLevel {
        if self.access_level.is_none() {
            self.access_level.set_default();
        }
        self.access_level.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_level(&mut self) -> super::access_level::AccessLevel {
        self.access_level.take().unwrap_or_else(|| super::access_level::AccessLevel::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateAccessLevelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.access_level {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.access_level)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.access_level.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.access_level.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAccessLevelRequest {
        UpdateAccessLevelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_level::AccessLevel>>(
                "access_level",
                |m: &UpdateAccessLevelRequest| { &m.access_level },
                |m: &mut UpdateAccessLevelRequest| { &mut m.access_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateAccessLevelRequest| { &m.update_mask },
                |m: &mut UpdateAccessLevelRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateAccessLevelRequest>(
                "UpdateAccessLevelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateAccessLevelRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateAccessLevelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateAccessLevelRequest::new)
    }
}

impl ::protobuf::Clear for UpdateAccessLevelRequest {
    fn clear(&mut self) {
        self.access_level.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateAccessLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAccessLevelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAccessLevelRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAccessLevelRequest {
    fn default() -> &'a DeleteAccessLevelRequest {
        <DeleteAccessLevelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAccessLevelRequest {
    pub fn new() -> DeleteAccessLevelRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteAccessLevelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAccessLevelRequest {
        DeleteAccessLevelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteAccessLevelRequest| { &m.name },
                |m: &mut DeleteAccessLevelRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAccessLevelRequest>(
                "DeleteAccessLevelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAccessLevelRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAccessLevelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAccessLevelRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAccessLevelRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAccessLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAccessLevelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplaceAccessLevelsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub access_levels: ::protobuf::RepeatedField<super::access_level::AccessLevel>,
    pub etag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplaceAccessLevelsRequest {
    fn default() -> &'a ReplaceAccessLevelsRequest {
        <ReplaceAccessLevelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReplaceAccessLevelsRequest {
    pub fn new() -> ReplaceAccessLevelsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // repeated .google.identity.accesscontextmanager.v1.AccessLevel access_levels = 2;


    pub fn get_access_levels(&self) -> &[super::access_level::AccessLevel] {
        &self.access_levels
    }
    pub fn clear_access_levels(&mut self) {
        self.access_levels.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_levels(&mut self, v: ::protobuf::RepeatedField<super::access_level::AccessLevel>) {
        self.access_levels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_access_levels(&mut self) -> &mut ::protobuf::RepeatedField<super::access_level::AccessLevel> {
        &mut self.access_levels
    }

    // Take field
    pub fn take_access_levels(&mut self) -> ::protobuf::RepeatedField<super::access_level::AccessLevel> {
        ::std::mem::replace(&mut self.access_levels, ::protobuf::RepeatedField::new())
    }

    // string etag = 4;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReplaceAccessLevelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.access_levels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.access_levels)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        for value in &self.access_levels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.etag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        for v in &self.access_levels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.etag.is_empty() {
            os.write_string(4, &self.etag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplaceAccessLevelsRequest {
        ReplaceAccessLevelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ReplaceAccessLevelsRequest| { &m.parent },
                |m: &mut ReplaceAccessLevelsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_level::AccessLevel>>(
                "access_levels",
                |m: &ReplaceAccessLevelsRequest| { &m.access_levels },
                |m: &mut ReplaceAccessLevelsRequest| { &mut m.access_levels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &ReplaceAccessLevelsRequest| { &m.etag },
                |m: &mut ReplaceAccessLevelsRequest| { &mut m.etag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplaceAccessLevelsRequest>(
                "ReplaceAccessLevelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplaceAccessLevelsRequest {
        static instance: ::protobuf::rt::LazyV2<ReplaceAccessLevelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplaceAccessLevelsRequest::new)
    }
}

impl ::protobuf::Clear for ReplaceAccessLevelsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.access_levels.clear();
        self.etag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplaceAccessLevelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplaceAccessLevelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplaceAccessLevelsResponse {
    // message fields
    pub access_levels: ::protobuf::RepeatedField<super::access_level::AccessLevel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplaceAccessLevelsResponse {
    fn default() -> &'a ReplaceAccessLevelsResponse {
        <ReplaceAccessLevelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReplaceAccessLevelsResponse {
    pub fn new() -> ReplaceAccessLevelsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.AccessLevel access_levels = 1;


    pub fn get_access_levels(&self) -> &[super::access_level::AccessLevel] {
        &self.access_levels
    }
    pub fn clear_access_levels(&mut self) {
        self.access_levels.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_levels(&mut self, v: ::protobuf::RepeatedField<super::access_level::AccessLevel>) {
        self.access_levels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_access_levels(&mut self) -> &mut ::protobuf::RepeatedField<super::access_level::AccessLevel> {
        &mut self.access_levels
    }

    // Take field
    pub fn take_access_levels(&mut self) -> ::protobuf::RepeatedField<super::access_level::AccessLevel> {
        ::std::mem::replace(&mut self.access_levels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReplaceAccessLevelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.access_levels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.access_levels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.access_levels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.access_levels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplaceAccessLevelsResponse {
        ReplaceAccessLevelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::access_level::AccessLevel>>(
                "access_levels",
                |m: &ReplaceAccessLevelsResponse| { &m.access_levels },
                |m: &mut ReplaceAccessLevelsResponse| { &mut m.access_levels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplaceAccessLevelsResponse>(
                "ReplaceAccessLevelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplaceAccessLevelsResponse {
        static instance: ::protobuf::rt::LazyV2<ReplaceAccessLevelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplaceAccessLevelsResponse::new)
    }
}

impl ::protobuf::Clear for ReplaceAccessLevelsResponse {
    fn clear(&mut self) {
        self.access_levels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplaceAccessLevelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplaceAccessLevelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServicePerimetersRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServicePerimetersRequest {
    fn default() -> &'a ListServicePerimetersRequest {
        <ListServicePerimetersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListServicePerimetersRequest {
    pub fn new() -> ListServicePerimetersRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServicePerimetersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServicePerimetersRequest {
        ListServicePerimetersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListServicePerimetersRequest| { &m.parent },
                |m: &mut ListServicePerimetersRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListServicePerimetersRequest| { &m.page_size },
                |m: &mut ListServicePerimetersRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListServicePerimetersRequest| { &m.page_token },
                |m: &mut ListServicePerimetersRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServicePerimetersRequest>(
                "ListServicePerimetersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServicePerimetersRequest {
        static instance: ::protobuf::rt::LazyV2<ListServicePerimetersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServicePerimetersRequest::new)
    }
}

impl ::protobuf::Clear for ListServicePerimetersRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServicePerimetersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServicePerimetersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServicePerimetersResponse {
    // message fields
    pub service_perimeters: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServicePerimetersResponse {
    fn default() -> &'a ListServicePerimetersResponse {
        <ListServicePerimetersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListServicePerimetersResponse {
    pub fn new() -> ListServicePerimetersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeter service_perimeters = 1;


    pub fn get_service_perimeters(&self) -> &[super::service_perimeter::ServicePerimeter] {
        &self.service_perimeters
    }
    pub fn clear_service_perimeters(&mut self) {
        self.service_perimeters.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_perimeters(&mut self, v: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>) {
        self.service_perimeters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_perimeters(&mut self) -> &mut ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        &mut self.service_perimeters
    }

    // Take field
    pub fn take_service_perimeters(&mut self) -> ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        ::std::mem::replace(&mut self.service_perimeters, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServicePerimetersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service_perimeters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_perimeters)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.service_perimeters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.service_perimeters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServicePerimetersResponse {
        ListServicePerimetersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service_perimeter::ServicePerimeter>>(
                "service_perimeters",
                |m: &ListServicePerimetersResponse| { &m.service_perimeters },
                |m: &mut ListServicePerimetersResponse| { &mut m.service_perimeters },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListServicePerimetersResponse| { &m.next_page_token },
                |m: &mut ListServicePerimetersResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServicePerimetersResponse>(
                "ListServicePerimetersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServicePerimetersResponse {
        static instance: ::protobuf::rt::LazyV2<ListServicePerimetersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServicePerimetersResponse::new)
    }
}

impl ::protobuf::Clear for ListServicePerimetersResponse {
    fn clear(&mut self) {
        self.service_perimeters.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServicePerimetersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServicePerimetersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServicePerimeterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServicePerimeterRequest {
    fn default() -> &'a GetServicePerimeterRequest {
        <GetServicePerimeterRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServicePerimeterRequest {
    pub fn new() -> GetServicePerimeterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetServicePerimeterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServicePerimeterRequest {
        GetServicePerimeterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetServicePerimeterRequest| { &m.name },
                |m: &mut GetServicePerimeterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServicePerimeterRequest>(
                "GetServicePerimeterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServicePerimeterRequest {
        static instance: ::protobuf::rt::LazyV2<GetServicePerimeterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServicePerimeterRequest::new)
    }
}

impl ::protobuf::Clear for GetServicePerimeterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServicePerimeterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServicePerimeterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateServicePerimeterRequest {
    // message fields
    pub parent: ::std::string::String,
    pub service_perimeter: ::protobuf::SingularPtrField<super::service_perimeter::ServicePerimeter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateServicePerimeterRequest {
    fn default() -> &'a CreateServicePerimeterRequest {
        <CreateServicePerimeterRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateServicePerimeterRequest {
    pub fn new() -> CreateServicePerimeterRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeter service_perimeter = 2;


    pub fn get_service_perimeter(&self) -> &super::service_perimeter::ServicePerimeter {
        self.service_perimeter.as_ref().unwrap_or_else(|| <super::service_perimeter::ServicePerimeter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_perimeter(&mut self) {
        self.service_perimeter.clear();
    }

    pub fn has_service_perimeter(&self) -> bool {
        self.service_perimeter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_perimeter(&mut self, v: super::service_perimeter::ServicePerimeter) {
        self.service_perimeter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_perimeter(&mut self) -> &mut super::service_perimeter::ServicePerimeter {
        if self.service_perimeter.is_none() {
            self.service_perimeter.set_default();
        }
        self.service_perimeter.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_perimeter(&mut self) -> super::service_perimeter::ServicePerimeter {
        self.service_perimeter.take().unwrap_or_else(|| super::service_perimeter::ServicePerimeter::new())
    }
}

impl ::protobuf::Message for CreateServicePerimeterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service_perimeter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_perimeter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.service_perimeter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.service_perimeter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateServicePerimeterRequest {
        CreateServicePerimeterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateServicePerimeterRequest| { &m.parent },
                |m: &mut CreateServicePerimeterRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service_perimeter::ServicePerimeter>>(
                "service_perimeter",
                |m: &CreateServicePerimeterRequest| { &m.service_perimeter },
                |m: &mut CreateServicePerimeterRequest| { &mut m.service_perimeter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateServicePerimeterRequest>(
                "CreateServicePerimeterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateServicePerimeterRequest {
        static instance: ::protobuf::rt::LazyV2<CreateServicePerimeterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateServicePerimeterRequest::new)
    }
}

impl ::protobuf::Clear for CreateServicePerimeterRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.service_perimeter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateServicePerimeterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateServicePerimeterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateServicePerimeterRequest {
    // message fields
    pub service_perimeter: ::protobuf::SingularPtrField<super::service_perimeter::ServicePerimeter>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateServicePerimeterRequest {
    fn default() -> &'a UpdateServicePerimeterRequest {
        <UpdateServicePerimeterRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateServicePerimeterRequest {
    pub fn new() -> UpdateServicePerimeterRequest {
        ::std::default::Default::default()
    }

    // .google.identity.accesscontextmanager.v1.ServicePerimeter service_perimeter = 1;


    pub fn get_service_perimeter(&self) -> &super::service_perimeter::ServicePerimeter {
        self.service_perimeter.as_ref().unwrap_or_else(|| <super::service_perimeter::ServicePerimeter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_perimeter(&mut self) {
        self.service_perimeter.clear();
    }

    pub fn has_service_perimeter(&self) -> bool {
        self.service_perimeter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_perimeter(&mut self, v: super::service_perimeter::ServicePerimeter) {
        self.service_perimeter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_perimeter(&mut self) -> &mut super::service_perimeter::ServicePerimeter {
        if self.service_perimeter.is_none() {
            self.service_perimeter.set_default();
        }
        self.service_perimeter.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_perimeter(&mut self) -> super::service_perimeter::ServicePerimeter {
        self.service_perimeter.take().unwrap_or_else(|| super::service_perimeter::ServicePerimeter::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateServicePerimeterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service_perimeter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_perimeter)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service_perimeter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service_perimeter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateServicePerimeterRequest {
        UpdateServicePerimeterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service_perimeter::ServicePerimeter>>(
                "service_perimeter",
                |m: &UpdateServicePerimeterRequest| { &m.service_perimeter },
                |m: &mut UpdateServicePerimeterRequest| { &mut m.service_perimeter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateServicePerimeterRequest| { &m.update_mask },
                |m: &mut UpdateServicePerimeterRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateServicePerimeterRequest>(
                "UpdateServicePerimeterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateServicePerimeterRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateServicePerimeterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateServicePerimeterRequest::new)
    }
}

impl ::protobuf::Clear for UpdateServicePerimeterRequest {
    fn clear(&mut self) {
        self.service_perimeter.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateServicePerimeterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateServicePerimeterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteServicePerimeterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteServicePerimeterRequest {
    fn default() -> &'a DeleteServicePerimeterRequest {
        <DeleteServicePerimeterRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteServicePerimeterRequest {
    pub fn new() -> DeleteServicePerimeterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteServicePerimeterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteServicePerimeterRequest {
        DeleteServicePerimeterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteServicePerimeterRequest| { &m.name },
                |m: &mut DeleteServicePerimeterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteServicePerimeterRequest>(
                "DeleteServicePerimeterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteServicePerimeterRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteServicePerimeterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteServicePerimeterRequest::new)
    }
}

impl ::protobuf::Clear for DeleteServicePerimeterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteServicePerimeterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteServicePerimeterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplaceServicePerimetersRequest {
    // message fields
    pub parent: ::std::string::String,
    pub service_perimeters: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>,
    pub etag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplaceServicePerimetersRequest {
    fn default() -> &'a ReplaceServicePerimetersRequest {
        <ReplaceServicePerimetersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReplaceServicePerimetersRequest {
    pub fn new() -> ReplaceServicePerimetersRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeter service_perimeters = 2;


    pub fn get_service_perimeters(&self) -> &[super::service_perimeter::ServicePerimeter] {
        &self.service_perimeters
    }
    pub fn clear_service_perimeters(&mut self) {
        self.service_perimeters.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_perimeters(&mut self, v: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>) {
        self.service_perimeters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_perimeters(&mut self) -> &mut ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        &mut self.service_perimeters
    }

    // Take field
    pub fn take_service_perimeters(&mut self) -> ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        ::std::mem::replace(&mut self.service_perimeters, ::protobuf::RepeatedField::new())
    }

    // string etag = 3;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReplaceServicePerimetersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service_perimeters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_perimeters)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        for value in &self.service_perimeters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.etag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        for v in &self.service_perimeters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.etag.is_empty() {
            os.write_string(3, &self.etag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplaceServicePerimetersRequest {
        ReplaceServicePerimetersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ReplaceServicePerimetersRequest| { &m.parent },
                |m: &mut ReplaceServicePerimetersRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service_perimeter::ServicePerimeter>>(
                "service_perimeters",
                |m: &ReplaceServicePerimetersRequest| { &m.service_perimeters },
                |m: &mut ReplaceServicePerimetersRequest| { &mut m.service_perimeters },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &ReplaceServicePerimetersRequest| { &m.etag },
                |m: &mut ReplaceServicePerimetersRequest| { &mut m.etag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplaceServicePerimetersRequest>(
                "ReplaceServicePerimetersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplaceServicePerimetersRequest {
        static instance: ::protobuf::rt::LazyV2<ReplaceServicePerimetersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplaceServicePerimetersRequest::new)
    }
}

impl ::protobuf::Clear for ReplaceServicePerimetersRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.service_perimeters.clear();
        self.etag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplaceServicePerimetersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplaceServicePerimetersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplaceServicePerimetersResponse {
    // message fields
    pub service_perimeters: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplaceServicePerimetersResponse {
    fn default() -> &'a ReplaceServicePerimetersResponse {
        <ReplaceServicePerimetersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReplaceServicePerimetersResponse {
    pub fn new() -> ReplaceServicePerimetersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeter service_perimeters = 1;


    pub fn get_service_perimeters(&self) -> &[super::service_perimeter::ServicePerimeter] {
        &self.service_perimeters
    }
    pub fn clear_service_perimeters(&mut self) {
        self.service_perimeters.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_perimeters(&mut self, v: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>) {
        self.service_perimeters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_perimeters(&mut self) -> &mut ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        &mut self.service_perimeters
    }

    // Take field
    pub fn take_service_perimeters(&mut self) -> ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        ::std::mem::replace(&mut self.service_perimeters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReplaceServicePerimetersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service_perimeters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_perimeters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.service_perimeters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.service_perimeters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplaceServicePerimetersResponse {
        ReplaceServicePerimetersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service_perimeter::ServicePerimeter>>(
                "service_perimeters",
                |m: &ReplaceServicePerimetersResponse| { &m.service_perimeters },
                |m: &mut ReplaceServicePerimetersResponse| { &mut m.service_perimeters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplaceServicePerimetersResponse>(
                "ReplaceServicePerimetersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplaceServicePerimetersResponse {
        static instance: ::protobuf::rt::LazyV2<ReplaceServicePerimetersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplaceServicePerimetersResponse::new)
    }
}

impl ::protobuf::Clear for ReplaceServicePerimetersResponse {
    fn clear(&mut self) {
        self.service_perimeters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplaceServicePerimetersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplaceServicePerimetersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitServicePerimetersRequest {
    // message fields
    pub parent: ::std::string::String,
    pub etag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitServicePerimetersRequest {
    fn default() -> &'a CommitServicePerimetersRequest {
        <CommitServicePerimetersRequest as ::protobuf::Message>::default_instance()
    }
}

impl CommitServicePerimetersRequest {
    pub fn new() -> CommitServicePerimetersRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string etag = 2;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommitServicePerimetersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.etag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.etag.is_empty() {
            os.write_string(2, &self.etag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitServicePerimetersRequest {
        CommitServicePerimetersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CommitServicePerimetersRequest| { &m.parent },
                |m: &mut CommitServicePerimetersRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &CommitServicePerimetersRequest| { &m.etag },
                |m: &mut CommitServicePerimetersRequest| { &mut m.etag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitServicePerimetersRequest>(
                "CommitServicePerimetersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitServicePerimetersRequest {
        static instance: ::protobuf::rt::LazyV2<CommitServicePerimetersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitServicePerimetersRequest::new)
    }
}

impl ::protobuf::Clear for CommitServicePerimetersRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.etag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitServicePerimetersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitServicePerimetersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitServicePerimetersResponse {
    // message fields
    pub service_perimeters: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitServicePerimetersResponse {
    fn default() -> &'a CommitServicePerimetersResponse {
        <CommitServicePerimetersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommitServicePerimetersResponse {
    pub fn new() -> CommitServicePerimetersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.ServicePerimeter service_perimeters = 1;


    pub fn get_service_perimeters(&self) -> &[super::service_perimeter::ServicePerimeter] {
        &self.service_perimeters
    }
    pub fn clear_service_perimeters(&mut self) {
        self.service_perimeters.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_perimeters(&mut self, v: ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter>) {
        self.service_perimeters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_perimeters(&mut self) -> &mut ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        &mut self.service_perimeters
    }

    // Take field
    pub fn take_service_perimeters(&mut self) -> ::protobuf::RepeatedField<super::service_perimeter::ServicePerimeter> {
        ::std::mem::replace(&mut self.service_perimeters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommitServicePerimetersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service_perimeters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_perimeters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.service_perimeters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.service_perimeters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitServicePerimetersResponse {
        CommitServicePerimetersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service_perimeter::ServicePerimeter>>(
                "service_perimeters",
                |m: &CommitServicePerimetersResponse| { &m.service_perimeters },
                |m: &mut CommitServicePerimetersResponse| { &mut m.service_perimeters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitServicePerimetersResponse>(
                "CommitServicePerimetersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitServicePerimetersResponse {
        static instance: ::protobuf::rt::LazyV2<CommitServicePerimetersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitServicePerimetersResponse::new)
    }
}

impl ::protobuf::Clear for CommitServicePerimetersResponse {
    fn clear(&mut self) {
        self.service_perimeters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitServicePerimetersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitServicePerimetersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListGcpUserAccessBindingsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGcpUserAccessBindingsRequest {
    fn default() -> &'a ListGcpUserAccessBindingsRequest {
        <ListGcpUserAccessBindingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListGcpUserAccessBindingsRequest {
    pub fn new() -> ListGcpUserAccessBindingsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListGcpUserAccessBindingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGcpUserAccessBindingsRequest {
        ListGcpUserAccessBindingsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListGcpUserAccessBindingsRequest| { &m.parent },
                |m: &mut ListGcpUserAccessBindingsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListGcpUserAccessBindingsRequest| { &m.page_size },
                |m: &mut ListGcpUserAccessBindingsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListGcpUserAccessBindingsRequest| { &m.page_token },
                |m: &mut ListGcpUserAccessBindingsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGcpUserAccessBindingsRequest>(
                "ListGcpUserAccessBindingsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListGcpUserAccessBindingsRequest {
        static instance: ::protobuf::rt::LazyV2<ListGcpUserAccessBindingsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGcpUserAccessBindingsRequest::new)
    }
}

impl ::protobuf::Clear for ListGcpUserAccessBindingsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGcpUserAccessBindingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGcpUserAccessBindingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListGcpUserAccessBindingsResponse {
    // message fields
    pub gcp_user_access_bindings: ::protobuf::RepeatedField<super::gcp_user_access_binding::GcpUserAccessBinding>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGcpUserAccessBindingsResponse {
    fn default() -> &'a ListGcpUserAccessBindingsResponse {
        <ListGcpUserAccessBindingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListGcpUserAccessBindingsResponse {
    pub fn new() -> ListGcpUserAccessBindingsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.identity.accesscontextmanager.v1.GcpUserAccessBinding gcp_user_access_bindings = 1;


    pub fn get_gcp_user_access_bindings(&self) -> &[super::gcp_user_access_binding::GcpUserAccessBinding] {
        &self.gcp_user_access_bindings
    }
    pub fn clear_gcp_user_access_bindings(&mut self) {
        self.gcp_user_access_bindings.clear();
    }

    // Param is passed by value, moved
    pub fn set_gcp_user_access_bindings(&mut self, v: ::protobuf::RepeatedField<super::gcp_user_access_binding::GcpUserAccessBinding>) {
        self.gcp_user_access_bindings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gcp_user_access_bindings(&mut self) -> &mut ::protobuf::RepeatedField<super::gcp_user_access_binding::GcpUserAccessBinding> {
        &mut self.gcp_user_access_bindings
    }

    // Take field
    pub fn take_gcp_user_access_bindings(&mut self) -> ::protobuf::RepeatedField<super::gcp_user_access_binding::GcpUserAccessBinding> {
        ::std::mem::replace(&mut self.gcp_user_access_bindings, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListGcpUserAccessBindingsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.gcp_user_access_bindings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gcp_user_access_bindings)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gcp_user_access_bindings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gcp_user_access_bindings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGcpUserAccessBindingsResponse {
        ListGcpUserAccessBindingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gcp_user_access_binding::GcpUserAccessBinding>>(
                "gcp_user_access_bindings",
                |m: &ListGcpUserAccessBindingsResponse| { &m.gcp_user_access_bindings },
                |m: &mut ListGcpUserAccessBindingsResponse| { &mut m.gcp_user_access_bindings },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListGcpUserAccessBindingsResponse| { &m.next_page_token },
                |m: &mut ListGcpUserAccessBindingsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGcpUserAccessBindingsResponse>(
                "ListGcpUserAccessBindingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListGcpUserAccessBindingsResponse {
        static instance: ::protobuf::rt::LazyV2<ListGcpUserAccessBindingsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGcpUserAccessBindingsResponse::new)
    }
}

impl ::protobuf::Clear for ListGcpUserAccessBindingsResponse {
    fn clear(&mut self) {
        self.gcp_user_access_bindings.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGcpUserAccessBindingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGcpUserAccessBindingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetGcpUserAccessBindingRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetGcpUserAccessBindingRequest {
    fn default() -> &'a GetGcpUserAccessBindingRequest {
        <GetGcpUserAccessBindingRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetGcpUserAccessBindingRequest {
    pub fn new() -> GetGcpUserAccessBindingRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetGcpUserAccessBindingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetGcpUserAccessBindingRequest {
        GetGcpUserAccessBindingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetGcpUserAccessBindingRequest| { &m.name },
                |m: &mut GetGcpUserAccessBindingRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetGcpUserAccessBindingRequest>(
                "GetGcpUserAccessBindingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetGcpUserAccessBindingRequest {
        static instance: ::protobuf::rt::LazyV2<GetGcpUserAccessBindingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetGcpUserAccessBindingRequest::new)
    }
}

impl ::protobuf::Clear for GetGcpUserAccessBindingRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetGcpUserAccessBindingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGcpUserAccessBindingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateGcpUserAccessBindingRequest {
    // message fields
    pub parent: ::std::string::String,
    pub gcp_user_access_binding: ::protobuf::SingularPtrField<super::gcp_user_access_binding::GcpUserAccessBinding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateGcpUserAccessBindingRequest {
    fn default() -> &'a CreateGcpUserAccessBindingRequest {
        <CreateGcpUserAccessBindingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateGcpUserAccessBindingRequest {
    pub fn new() -> CreateGcpUserAccessBindingRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.identity.accesscontextmanager.v1.GcpUserAccessBinding gcp_user_access_binding = 2;


    pub fn get_gcp_user_access_binding(&self) -> &super::gcp_user_access_binding::GcpUserAccessBinding {
        self.gcp_user_access_binding.as_ref().unwrap_or_else(|| <super::gcp_user_access_binding::GcpUserAccessBinding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gcp_user_access_binding(&mut self) {
        self.gcp_user_access_binding.clear();
    }

    pub fn has_gcp_user_access_binding(&self) -> bool {
        self.gcp_user_access_binding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcp_user_access_binding(&mut self, v: super::gcp_user_access_binding::GcpUserAccessBinding) {
        self.gcp_user_access_binding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcp_user_access_binding(&mut self) -> &mut super::gcp_user_access_binding::GcpUserAccessBinding {
        if self.gcp_user_access_binding.is_none() {
            self.gcp_user_access_binding.set_default();
        }
        self.gcp_user_access_binding.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcp_user_access_binding(&mut self) -> super::gcp_user_access_binding::GcpUserAccessBinding {
        self.gcp_user_access_binding.take().unwrap_or_else(|| super::gcp_user_access_binding::GcpUserAccessBinding::new())
    }
}

impl ::protobuf::Message for CreateGcpUserAccessBindingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.gcp_user_access_binding {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcp_user_access_binding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.gcp_user_access_binding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.gcp_user_access_binding.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateGcpUserAccessBindingRequest {
        CreateGcpUserAccessBindingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateGcpUserAccessBindingRequest| { &m.parent },
                |m: &mut CreateGcpUserAccessBindingRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gcp_user_access_binding::GcpUserAccessBinding>>(
                "gcp_user_access_binding",
                |m: &CreateGcpUserAccessBindingRequest| { &m.gcp_user_access_binding },
                |m: &mut CreateGcpUserAccessBindingRequest| { &mut m.gcp_user_access_binding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateGcpUserAccessBindingRequest>(
                "CreateGcpUserAccessBindingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateGcpUserAccessBindingRequest {
        static instance: ::protobuf::rt::LazyV2<CreateGcpUserAccessBindingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateGcpUserAccessBindingRequest::new)
    }
}

impl ::protobuf::Clear for CreateGcpUserAccessBindingRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.gcp_user_access_binding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateGcpUserAccessBindingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateGcpUserAccessBindingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateGcpUserAccessBindingRequest {
    // message fields
    pub gcp_user_access_binding: ::protobuf::SingularPtrField<super::gcp_user_access_binding::GcpUserAccessBinding>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateGcpUserAccessBindingRequest {
    fn default() -> &'a UpdateGcpUserAccessBindingRequest {
        <UpdateGcpUserAccessBindingRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateGcpUserAccessBindingRequest {
    pub fn new() -> UpdateGcpUserAccessBindingRequest {
        ::std::default::Default::default()
    }

    // .google.identity.accesscontextmanager.v1.GcpUserAccessBinding gcp_user_access_binding = 1;


    pub fn get_gcp_user_access_binding(&self) -> &super::gcp_user_access_binding::GcpUserAccessBinding {
        self.gcp_user_access_binding.as_ref().unwrap_or_else(|| <super::gcp_user_access_binding::GcpUserAccessBinding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gcp_user_access_binding(&mut self) {
        self.gcp_user_access_binding.clear();
    }

    pub fn has_gcp_user_access_binding(&self) -> bool {
        self.gcp_user_access_binding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcp_user_access_binding(&mut self, v: super::gcp_user_access_binding::GcpUserAccessBinding) {
        self.gcp_user_access_binding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcp_user_access_binding(&mut self) -> &mut super::gcp_user_access_binding::GcpUserAccessBinding {
        if self.gcp_user_access_binding.is_none() {
            self.gcp_user_access_binding.set_default();
        }
        self.gcp_user_access_binding.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcp_user_access_binding(&mut self) -> super::gcp_user_access_binding::GcpUserAccessBinding {
        self.gcp_user_access_binding.take().unwrap_or_else(|| super::gcp_user_access_binding::GcpUserAccessBinding::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateGcpUserAccessBindingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.gcp_user_access_binding {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcp_user_access_binding)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gcp_user_access_binding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gcp_user_access_binding.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateGcpUserAccessBindingRequest {
        UpdateGcpUserAccessBindingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gcp_user_access_binding::GcpUserAccessBinding>>(
                "gcp_user_access_binding",
                |m: &UpdateGcpUserAccessBindingRequest| { &m.gcp_user_access_binding },
                |m: &mut UpdateGcpUserAccessBindingRequest| { &mut m.gcp_user_access_binding },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateGcpUserAccessBindingRequest| { &m.update_mask },
                |m: &mut UpdateGcpUserAccessBindingRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateGcpUserAccessBindingRequest>(
                "UpdateGcpUserAccessBindingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateGcpUserAccessBindingRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateGcpUserAccessBindingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateGcpUserAccessBindingRequest::new)
    }
}

impl ::protobuf::Clear for UpdateGcpUserAccessBindingRequest {
    fn clear(&mut self) {
        self.gcp_user_access_binding.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateGcpUserAccessBindingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateGcpUserAccessBindingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteGcpUserAccessBindingRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteGcpUserAccessBindingRequest {
    fn default() -> &'a DeleteGcpUserAccessBindingRequest {
        <DeleteGcpUserAccessBindingRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteGcpUserAccessBindingRequest {
    pub fn new() -> DeleteGcpUserAccessBindingRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteGcpUserAccessBindingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteGcpUserAccessBindingRequest {
        DeleteGcpUserAccessBindingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteGcpUserAccessBindingRequest| { &m.name },
                |m: &mut DeleteGcpUserAccessBindingRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteGcpUserAccessBindingRequest>(
                "DeleteGcpUserAccessBindingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteGcpUserAccessBindingRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteGcpUserAccessBindingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteGcpUserAccessBindingRequest::new)
    }
}

impl ::protobuf::Clear for DeleteGcpUserAccessBindingRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteGcpUserAccessBindingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteGcpUserAccessBindingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcpUserAccessBindingOperationMetadata {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcpUserAccessBindingOperationMetadata {
    fn default() -> &'a GcpUserAccessBindingOperationMetadata {
        <GcpUserAccessBindingOperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl GcpUserAccessBindingOperationMetadata {
    pub fn new() -> GcpUserAccessBindingOperationMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GcpUserAccessBindingOperationMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcpUserAccessBindingOperationMetadata {
        GcpUserAccessBindingOperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcpUserAccessBindingOperationMetadata>(
                "GcpUserAccessBindingOperationMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcpUserAccessBindingOperationMetadata {
        static instance: ::protobuf::rt::LazyV2<GcpUserAccessBindingOperationMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcpUserAccessBindingOperationMetadata::new)
    }
}

impl ::protobuf::Clear for GcpUserAccessBindingOperationMetadata {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcpUserAccessBindingOperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcpUserAccessBindingOperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccessContextManagerOperationMetadata {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccessContextManagerOperationMetadata {
    fn default() -> &'a AccessContextManagerOperationMetadata {
        <AccessContextManagerOperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl AccessContextManagerOperationMetadata {
    pub fn new() -> AccessContextManagerOperationMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AccessContextManagerOperationMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccessContextManagerOperationMetadata {
        AccessContextManagerOperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccessContextManagerOperationMetadata>(
                "AccessContextManagerOperationMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccessContextManagerOperationMetadata {
        static instance: ::protobuf::rt::LazyV2<AccessContextManagerOperationMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccessContextManagerOperationMetadata::new)
    }
}

impl ::protobuf::Clear for AccessContextManagerOperationMetadata {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccessContextManagerOperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessContextManagerOperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LevelFormat {
    LEVEL_FORMAT_UNSPECIFIED = 0,
    AS_DEFINED = 1,
    CEL = 2,
}

impl ::protobuf::ProtobufEnum for LevelFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LevelFormat> {
        match value {
            0 => ::std::option::Option::Some(LevelFormat::LEVEL_FORMAT_UNSPECIFIED),
            1 => ::std::option::Option::Some(LevelFormat::AS_DEFINED),
            2 => ::std::option::Option::Some(LevelFormat::CEL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LevelFormat] = &[
            LevelFormat::LEVEL_FORMAT_UNSPECIFIED,
            LevelFormat::AS_DEFINED,
            LevelFormat::CEL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LevelFormat>("LevelFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LevelFormat {
}

impl ::std::default::Default for LevelFormat {
    fn default() -> Self {
        LevelFormat::LEVEL_FORMAT_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for LevelFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nDgoogle/identity/accesscontextmanager/v1/access_context_manager.proto\
    \x12'google.identity.accesscontextmanager.v1\x1a\x1cgoogle/api/annotatio\
    ns.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior\
    .proto\x1a\x19google/api/resource.proto\x1a\x1egoogle/iam/v1/iam_policy.\
    proto\x1a\x1agoogle/iam/v1/policy.proto\x1a:google/identity/accesscontex\
    tmanager/v1/access_level.proto\x1a;google/identity/accesscontextmanager/\
    v1/access_policy.proto\x1aEgoogle/identity/accesscontextmanager/v1/gcp_u\
    ser_access_binding.proto\x1a?google/identity/accesscontextmanager/v1/ser\
    vice_perimeter.proto\x1a#google/longrunning/operations.proto\x1a\x20goog\
    le/protobuf/field_mask.proto\"\xa9\x01\n\x19ListAccessPoliciesRequest\
    \x12P\n\x06parent\x18\x01\x20\x01(\tR\x06parentB8\xfaA2\n0cloudresourcem\
    anager.googleapis.com/Organization\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\
    \x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpa\
    geToken\"\xa4\x01\n\x1aListAccessPoliciesResponse\x12^\n\x0faccess_polic\
    ies\x18\x01\x20\x03(\x0b25.google.identity.accesscontextmanager.v1.Acces\
    sPolicyR\x0eaccessPolicies\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\
    \rnextPageToken\"f\n\x16GetAccessPolicyRequest\x12L\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB8\xfaA2\n0accesscontextmanager.googleapis.com/Acces\
    sPolicy\xe0A\x02\"\xb1\x01\n\x19UpdateAccessPolicyRequest\x12R\n\x06poli\
    cy\x18\x01\x20\x01(\x0b25.google.identity.accesscontextmanager.v1.Access\
    PolicyR\x06policyB\x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.FieldMaskR\nupdateMaskB\x03\xe0A\x02\"i\n\x19D\
    eleteAccessPolicyRequest\x12L\n\x04name\x18\x01\x20\x01(\tR\x04nameB8\
    \xfaA2\n0accesscontextmanager.googleapis.com/AccessPolicy\xe0A\x02\"\x8c\
    \x02\n\x17ListAccessLevelsRequest\x12O\n\x06parent\x18\x01\x20\x01(\tR\
    \x06parentB7\xfaA1\x12/accesscontextmanager.googleapis.com/AccessLevel\
    \xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\
    \n\npage_token\x18\x03\x20\x01(\tR\tpageToken\x12d\n\x13access_level_for\
    mat\x18\x04\x20\x01(\x0e24.google.identity.accesscontextmanager.v1.Level\
    FormatR\x11accessLevelFormat\"\x9d\x01\n\x18ListAccessLevelsResponse\x12\
    Y\n\raccess_levels\x18\x01\x20\x03(\x0b24.google.identity.accesscontextm\
    anager.v1.AccessLevelR\x0caccessLevels\x12&\n\x0fnext_page_token\x18\x02\
    \x20\x01(\tR\rnextPageToken\"\xca\x01\n\x15GetAccessLevelRequest\x12K\n\
    \x04name\x18\x01\x20\x01(\tR\x04nameB7\xfaA1\n/accesscontextmanager.goog\
    leapis.com/AccessLevel\xe0A\x02\x12d\n\x13access_level_format\x18\x02\
    \x20\x01(\x0e24.google.identity.accesscontextmanager.v1.LevelFormatR\x11\
    accessLevelFormat\"\xc9\x01\n\x18CreateAccessLevelRequest\x12O\n\x06pare\
    nt\x18\x01\x20\x01(\tR\x06parentB7\xfaA1\x12/accesscontextmanager.google\
    apis.com/AccessLevel\xe0A\x02\x12\\\n\x0caccess_level\x18\x02\x20\x01(\
    \x0b24.google.identity.accesscontextmanager.v1.AccessLevelR\x0baccessLev\
    elB\x03\xe0A\x02\"\xba\x01\n\x18UpdateAccessLevelRequest\x12\\\n\x0cacce\
    ss_level\x18\x01\x20\x01(\x0b24.google.identity.accesscontextmanager.v1.\
    AccessLevelR\x0baccessLevelB\x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMaskB\x03\xe0A\x02\
    \"g\n\x18DeleteAccessLevelRequest\x12K\n\x04name\x18\x01\x20\x01(\tR\x04\
    nameB7\xfaA1\n/accesscontextmanager.googleapis.com/AccessLevel\xe0A\x02\
    \"\xe1\x01\n\x1aReplaceAccessLevelsRequest\x12O\n\x06parent\x18\x01\x20\
    \x01(\tR\x06parentB7\xfaA1\x12/accesscontextmanager.googleapis.com/Acces\
    sLevel\xe0A\x02\x12^\n\raccess_levels\x18\x02\x20\x03(\x0b24.google.iden\
    tity.accesscontextmanager.v1.AccessLevelR\x0caccessLevelsB\x03\xe0A\x02\
    \x12\x12\n\x04etag\x18\x04\x20\x01(\tR\x04etag\"x\n\x1bReplaceAccessLeve\
    lsResponse\x12Y\n\raccess_levels\x18\x01\x20\x03(\x0b24.google.identity.\
    accesscontextmanager.v1.AccessLevelR\x0caccessLevels\"\xb0\x01\n\x1cList\
    ServicePerimetersRequest\x12T\n\x06parent\x18\x01\x20\x01(\tR\x06parentB\
    <\xfaA6\x124accesscontextmanager.googleapis.com/ServicePerimeter\xe0A\
    \x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\np\
    age_token\x18\x03\x20\x01(\tR\tpageToken\"\xb1\x01\n\x1dListServicePerim\
    etersResponse\x12h\n\x12service_perimeters\x18\x01\x20\x03(\x0b29.google\
    .identity.accesscontextmanager.v1.ServicePerimeterR\x11servicePerimeters\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"n\n\x1aGe\
    tServicePerimeterRequest\x12P\n\x04name\x18\x01\x20\x01(\tR\x04nameB<\
    \xfaA6\n4accesscontextmanager.googleapis.com/ServicePerimeter\xe0A\x02\"\
    \xe2\x01\n\x1dCreateServicePerimeterRequest\x12T\n\x06parent\x18\x01\x20\
    \x01(\tR\x06parentB<\xfaA6\x124accesscontextmanager.googleapis.com/Servi\
    cePerimeter\xe0A\x02\x12k\n\x11service_perimeter\x18\x02\x20\x01(\x0b29.\
    google.identity.accesscontextmanager.v1.ServicePerimeterR\x10servicePeri\
    meterB\x03\xe0A\x02\"\xce\x01\n\x1dUpdateServicePerimeterRequest\x12k\n\
    \x11service_perimeter\x18\x01\x20\x01(\x0b29.google.identity.accessconte\
    xtmanager.v1.ServicePerimeterR\x10servicePerimeterB\x03\xe0A\x02\x12@\n\
    \x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nup\
    dateMaskB\x03\xe0A\x02\"q\n\x1dDeleteServicePerimeterRequest\x12P\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04nameB<\xfaA6\n4accesscontextmanager.googleapi\
    s.com/ServicePerimeter\xe0A\x02\"\xfa\x01\n\x1fReplaceServicePerimetersR\
    equest\x12T\n\x06parent\x18\x01\x20\x01(\tR\x06parentB<\xfaA6\x124access\
    contextmanager.googleapis.com/ServicePerimeter\xe0A\x02\x12m\n\x12servic\
    e_perimeters\x18\x02\x20\x03(\x0b29.google.identity.accesscontextmanager\
    .v1.ServicePerimeterR\x11servicePerimetersB\x03\xe0A\x02\x12\x12\n\x04et\
    ag\x18\x03\x20\x01(\tR\x04etag\"\x8c\x01\n\x20ReplaceServicePerimetersRe\
    sponse\x12h\n\x12service_perimeters\x18\x01\x20\x03(\x0b29.google.identi\
    ty.accesscontextmanager.v1.ServicePerimeterR\x11servicePerimeters\"\x8a\
    \x01\n\x1eCommitServicePerimetersRequest\x12T\n\x06parent\x18\x01\x20\
    \x01(\tR\x06parentB<\xfaA6\x124accesscontextmanager.googleapis.com/Servi\
    cePerimeter\xe0A\x02\x12\x12\n\x04etag\x18\x02\x20\x01(\tR\x04etag\"\x8b\
    \x01\n\x1fCommitServicePerimetersResponse\x12h\n\x12service_perimeters\
    \x18\x01\x20\x03(\x0b29.google.identity.accesscontextmanager.v1.ServiceP\
    erimeterR\x11servicePerimeters\"\xba\x01\n\x20ListGcpUserAccessBindingsR\
    equest\x12P\n\x06parent\x18\x01\x20\x01(\tR\x06parentB8\xfaA2\n0cloudres\
    ourcemanager.googleapis.com/Organization\xe0A\x02\x12\x20\n\tpage_size\
    \x18\x02\x20\x01(\x05R\x08pageSizeB\x03\xe0A\x01\x12\"\n\npage_token\x18\
    \x03\x20\x01(\tR\tpageTokenB\x03\xe0A\x01\"\xc3\x01\n!ListGcpUserAccessB\
    indingsResponse\x12v\n\x18gcp_user_access_bindings\x18\x01\x20\x03(\x0b2\
    =.google.identity.accesscontextmanager.v1.GcpUserAccessBindingR\x15gcpUs\
    erAccessBindings\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPage\
    Token\"v\n\x1eGetGcpUserAccessBindingRequest\x12T\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB@\xfaA:\n8accesscontextmanager.googleapis.com/GcpUserAc\
    cessBinding\xe0A\x02\"\xf0\x01\n!CreateGcpUserAccessBindingRequest\x12P\
    \n\x06parent\x18\x01\x20\x01(\tR\x06parentB8\xfaA2\n0cloudresourcemanage\
    r.googleapis.com/Organization\xe0A\x02\x12y\n\x17gcp_user_access_binding\
    \x18\x02\x20\x01(\x0b2=.google.identity.accesscontextmanager.v1.GcpUserA\
    ccessBindingR\x14gcpUserAccessBindingB\x03\xe0A\x02\"\xe0\x01\n!UpdateGc\
    pUserAccessBindingRequest\x12y\n\x17gcp_user_access_binding\x18\x01\x20\
    \x01(\x0b2=.google.identity.accesscontextmanager.v1.GcpUserAccessBinding\
    R\x14gcpUserAccessBindingB\x03\xe0A\x02\x12@\n\x0bupdate_mask\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMaskB\x03\xe0A\x02\
    \"y\n!DeleteGcpUserAccessBindingRequest\x12T\n\x04name\x18\x01\x20\x01(\
    \tR\x04nameB@\xfaA:\n8accesscontextmanager.googleapis.com/GcpUserAccessB\
    inding\xe0A\x02\"'\n%GcpUserAccessBindingOperationMetadata\"'\n%AccessCo\
    ntextManagerOperationMetadata*D\n\x0bLevelFormat\x12\x1c\n\x18LEVEL_FORM\
    AT_UNSPECIFIED\x10\0\x12\x0e\n\nAS_DEFINED\x10\x01\x12\x07\n\x03CEL\x10\
    \x022\xf12\n\x14AccessContextManager\x12\xb9\x01\n\x12ListAccessPolicies\
    \x12B.google.identity.accesscontextmanager.v1.ListAccessPoliciesRequest\
    \x1aC.google.identity.accesscontextmanager.v1.ListAccessPoliciesResponse\
    \"\x1a\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/accessPolicies\x12\xb5\x01\n\
    \x0fGetAccessPolicy\x12?.google.identity.accesscontextmanager.v1.GetAcce\
    ssPolicyRequest\x1a5.google.identity.accesscontextmanager.v1.AccessPolic\
    y\"*\x82\xd3\xe4\x93\x02\x1d\x12\x1b/v1/{name=accessPolicies/*}\xdaA\x04\
    name\x12\xc1\x01\n\x12CreateAccessPolicy\x125.google.identity.accesscont\
    extmanager.v1.AccessPolicy\x1a\x1d.google.longrunning.Operation\"U\xcaA5\
    \n\x0cAccessPolicy\x12%AccessContextManagerOperationMetadata\x82\xd3\xe4\
    \x93\x02\x17\"\x12/v1/accessPolicies:\x01*\x12\xf8\x01\n\x12UpdateAccess\
    Policy\x12B.google.identity.accesscontextmanager.v1.UpdateAccessPolicyRe\
    quest\x1a\x1d.google.longrunning.Operation\"\x7f\xcaA5\n\x0cAccessPolicy\
    \x12%AccessContextManagerOperationMetadata\x82\xd3\xe4\x93\x02,2\"/v1/{p\
    olicy.name=accessPolicies/*}:\x06policy\xdaA\x12policy,update_mask\x12\
    \xe4\x01\n\x12DeleteAccessPolicy\x12B.google.identity.accesscontextmanag\
    er.v1.DeleteAccessPolicyRequest\x1a\x1d.google.longrunning.Operation\"k\
    \xcaA>\n\x15google.protobuf.Empty\x12%AccessContextManagerOperationMetad\
    ata\x82\xd3\xe4\x93\x02\x1d*\x1b/v1/{name=accessPolicies/*}\xdaA\x04name\
    \x12\xd4\x01\n\x10ListAccessLevels\x12@.google.identity.accesscontextman\
    ager.v1.ListAccessLevelsRequest\x1aA.google.identity.accesscontextmanage\
    r.v1.ListAccessLevelsResponse\";\x82\xd3\xe4\x93\x02,\x12*/v1/{parent=ac\
    cessPolicies/*}/accessLevels\xdaA\x06parent\x12\xc1\x01\n\x0eGetAccessLe\
    vel\x12>.google.identity.accesscontextmanager.v1.GetAccessLevelRequest\
    \x1a4.google.identity.accesscontextmanager.v1.AccessLevel\"9\x82\xd3\xe4\
    \x93\x02,\x12*/v1/{name=accessPolicies/*/accessLevels/*}\xdaA\x04name\
    \x12\x85\x02\n\x11CreateAccessLevel\x12A.google.identity.accesscontextma\
    nager.v1.CreateAccessLevelRequest\x1a\x1d.google.longrunning.Operation\"\
    \x8d\x01\xcaA4\n\x0bAccessLevel\x12%AccessContextManagerOperationMetadat\
    a\x82\xd3\xe4\x93\x02:\"*/v1/{parent=accessPolicies/*}/accessLevels:\x0c\
    access_level\xdaA\x13parent,access_level\x12\x97\x02\n\x11UpdateAccessLe\
    vel\x12A.google.identity.accesscontextmanager.v1.UpdateAccessLevelReques\
    t\x1a\x1d.google.longrunning.Operation\"\x9f\x01\xcaA4\n\x0bAccessLevel\
    \x12%AccessContextManagerOperationMetadata\x82\xd3\xe4\x93\x02G27/v1/{ac\
    cess_level.name=accessPolicies/*/accessLevels/*}:\x0caccess_level\xdaA\
    \x18access_level,update_mask\x12\xf1\x01\n\x11DeleteAccessLevel\x12A.goo\
    gle.identity.accesscontextmanager.v1.DeleteAccessLevelRequest\x1a\x1d.go\
    ogle.longrunning.Operation\"z\xcaA>\n\x15google.protobuf.Empty\x12%Acces\
    sContextManagerOperationMetadata\x82\xd3\xe4\x93\x02,**/v1/{name=accessP\
    olicies/*/accessLevels/*}\xdaA\x04name\x12\x83\x02\n\x13ReplaceAccessLev\
    els\x12C.google.identity.accesscontextmanager.v1.ReplaceAccessLevelsRequ\
    est\x1a\x1d.google.longrunning.Operation\"\x87\x01\xcaAD\n\x1bReplaceAcc\
    essLevelsResponse\x12%AccessContextManagerOperationMetadata\x82\xd3\xe4\
    \x93\x02:\"5/v1/{parent=accessPolicies/*}/accessLevels:replaceAll:\x01*\
    \x12\xe8\x01\n\x15ListServicePerimeters\x12E.google.identity.accessconte\
    xtmanager.v1.ListServicePerimetersRequest\x1aF.google.identity.accesscon\
    textmanager.v1.ListServicePerimetersResponse\"@\x82\xd3\xe4\x93\x021\x12\
    //v1/{parent=accessPolicies/*}/servicePerimeters\xdaA\x06parent\x12\xd5\
    \x01\n\x13GetServicePerimeter\x12C.google.identity.accesscontextmanager.\
    v1.GetServicePerimeterRequest\x1a9.google.identity.accesscontextmanager.\
    v1.ServicePerimeter\">\x82\xd3\xe4\x93\x021\x12//v1/{name=accessPolicies\
    /*/servicePerimeters/*}\xdaA\x04name\x12\xa3\x02\n\x16CreateServicePerim\
    eter\x12F.google.identity.accesscontextmanager.v1.CreateServicePerimeter\
    Request\x1a\x1d.google.longrunning.Operation\"\xa1\x01\xcaA9\n\x10Servic\
    ePerimeter\x12%AccessContextManagerOperationMetadata\x82\xd3\xe4\x93\x02\
    D\"//v1/{parent=accessPolicies/*}/servicePerimeters:\x11service_perimete\
    r\xdaA\x18parent,service_perimeter\x12\xba\x02\n\x16UpdateServicePerimet\
    er\x12F.google.identity.accesscontextmanager.v1.UpdateServicePerimeterRe\
    quest\x1a\x1d.google.longrunning.Operation\"\xb8\x01\xcaA9\n\x10ServiceP\
    erimeter\x12%AccessContextManagerOperationMetadata\x82\xd3\xe4\x93\x02V2\
    A/v1/{service_perimeter.name=accessPolicies/*/servicePerimeters/*}:\x11s\
    ervice_perimeter\xdaA\x1dservice_perimeter,update_mask\x12\x80\x02\n\x16\
    DeleteServicePerimeter\x12F.google.identity.accesscontextmanager.v1.Dele\
    teServicePerimeterRequest\x1a\x1d.google.longrunning.Operation\"\x7f\xca\
    A>\n\x15google.protobuf.Empty\x12%AccessContextManagerOperationMetadata\
    \x82\xd3\xe4\x93\x021*//v1/{name=accessPolicies/*/servicePerimeters/*}\
    \xdaA\x04name\x12\x97\x02\n\x18ReplaceServicePerimeters\x12H.google.iden\
    tity.accesscontextmanager.v1.ReplaceServicePerimetersRequest\x1a\x1d.goo\
    gle.longrunning.Operation\"\x91\x01\xcaAI\n\x20ReplaceServicePerimetersR\
    esponse\x12%AccessContextManagerOperationMetadata\x82\xd3\xe4\x93\x02?\"\
    :/v1/{parent=accessPolicies/*}/servicePerimeters:replaceAll:\x01*\x12\
    \x90\x02\n\x17CommitServicePerimeters\x12G.google.identity.accesscontext\
    manager.v1.CommitServicePerimetersRequest\x1a\x1d.google.longrunning.Ope\
    ration\"\x8c\x01\xcaAH\n\x1fCommitServicePerimetersResponse\x12%AccessCo\
    ntextManagerOperationMetadata\x82\xd3\xe4\x93\x02;\"6/v1/{parent=accessP\
    olicies/*}/servicePerimeters:commit:\x01*\x12\xf7\x01\n\x19ListGcpUserAc\
    cessBindings\x12I.google.identity.accesscontextmanager.v1.ListGcpUserAcc\
    essBindingsRequest\x1aJ.google.identity.accesscontextmanager.v1.ListGcpU\
    serAccessBindingsResponse\"C\x82\xd3\xe4\x93\x024\x122/v1/{parent=organi\
    zations/*}/gcpUserAccessBindings\xdaA\x06parent\x12\xe4\x01\n\x17GetGcpU\
    serAccessBinding\x12G.google.identity.accesscontextmanager.v1.GetGcpUser\
    AccessBindingRequest\x1a=.google.identity.accesscontextmanager.v1.GcpUse\
    rAccessBinding\"A\x82\xd3\xe4\x93\x024\x122/v1/{name=organizations/*/gcp\
    UserAccessBindings/*}\xdaA\x04name\x12\xbe\x02\n\x1aCreateGcpUserAccessB\
    inding\x12J.google.identity.accesscontextmanager.v1.CreateGcpUserAccessB\
    indingRequest\x1a\x1d.google.longrunning.Operation\"\xb4\x01\xcaA=\n\x14\
    GcpUserAccessBinding\x12%GcpUserAccessBindingOperationMetadata\x82\xd3\
    \xe4\x93\x02M\"2/v1/{parent=organizations/*}/gcpUserAccessBindings:\x17g\
    cp_user_access_binding\xdaA\x1eparent,gcp_user_access_binding\x12\xdb\
    \x02\n\x1aUpdateGcpUserAccessBinding\x12J.google.identity.accesscontextm\
    anager.v1.UpdateGcpUserAccessBindingRequest\x1a\x1d.google.longrunning.O\
    peration\"\xd1\x01\xcaA=\n\x14GcpUserAccessBinding\x12%GcpUserAccessBind\
    ingOperationMetadata\x82\xd3\xe4\x93\x02e2J/v1/{gcp_user_access_binding.\
    name=organizations/*/gcpUserAccessBindings/*}:\x17gcp_user_access_bindin\
    g\xdaA#gcp_user_access_binding,update_mask\x12\x8c\x02\n\x1aDeleteGcpUse\
    rAccessBinding\x12J.google.identity.accesscontextmanager.v1.DeleteGcpUse\
    rAccessBindingRequest\x1a\x1d.google.longrunning.Operation\"\x82\x01\xca\
    A>\n\x15google.protobuf.Empty\x12%GcpUserAccessBindingOperationMetadata\
    \x82\xd3\xe4\x93\x024*2/v1/{name=organizations/*/gcpUserAccessBindings/*\
    }\xdaA\x04name\x12\x82\x01\n\x0cSetIamPolicy\x12\".google.iam.v1.SetIamP\
    olicyRequest\x1a\x15.google.iam.v1.Policy\"7\x82\xd3\xe4\x93\x021\",/v1/\
    {resource=accessPolicies/*}:setIamPolicy:\x01*\x12\x82\x01\n\x0cGetIamPo\
    licy\x12\".google.iam.v1.GetIamPolicyRequest\x1a\x15.google.iam.v1.Polic\
    y\"7\x82\xd3\xe4\x93\x021\",/v1/{resource=accessPolicies/*}:getIamPolicy\
    :\x01*\x12\xbf\x02\n\x12TestIamPermissions\x12(.google.iam.v1.TestIamPer\
    missionsRequest\x1a).google.iam.v1.TestIamPermissionsResponse\"\xd3\x01\
    \x82\xd3\xe4\x93\x02\xcc\x01\"2/v1/{resource=accessPolicies/*}:testIamPe\
    rmissions:\x01*ZF\"A/v1/{resource=accessPolicies/*/accessLevels/*}:testI\
    amPermissions:\x01*ZK\"F/v1/{resource=accessPolicies/*/servicePerimeters\
    /*}:testIamPermissions:\x01*\x1aW\xd2A.https://www.googleapis.com/auth/c\
    loud-platform\xcaA#accesscontextmanager.googleapis.comB\xb0\x02\n+com.go\
    ogle.identity.accesscontextmanager.v1B\x19AccessContextManagerProtoP\x01\
    Z\\cloud.google.com/go/accesscontextmanager/apiv1/accesscontextmanagerpb\
    ;accesscontextmanagerpb\xa2\x02\x04GACM\xaa\x02'Google.Identity.AccessCo\
    ntextManager.V1\xca\x02'Google\\Identity\\AccessContextManager\\V1\xea\
    \x02*Google::Identity::AccessContextManager::V1J\xbc\xfc\x01\n\x07\x12\
    \x05\x0e\0\xd9\x07\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\
    \x20Copyright\x202022\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\
    \x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20y\
    ou\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\
    \x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\
    \x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/li\
    censes/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\
    \x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\
    \x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20\
    IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20A\
    NY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20Li\
    cense\x20for\x20the\x20specific\x20language\x20governing\x20permissions\
    \x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\
    \x12\x03\x10\00\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\x03\
    \x13\0!\n\t\n\x02\x03\x02\x12\x03\x14\0)\n\t\n\x02\x03\x03\x12\x03\x15\0\
    #\n\t\n\x02\x03\x04\x12\x03\x16\0(\n\t\n\x02\x03\x05\x12\x03\x17\0$\n\t\
    \n\x02\x03\x06\x12\x03\x18\0D\n\t\n\x02\x03\x07\x12\x03\x19\0E\n\t\n\x02\
    \x03\x08\x12\x03\x1a\0O\n\t\n\x02\x03\t\x12\x03\x1b\0I\n\t\n\x02\x03\n\
    \x12\x03\x1c\0-\n\t\n\x02\x03\x0b\x12\x03\x1d\0*\n\x08\n\x01\x08\x12\x03\
    \x1f\0D\n\t\n\x02\x08%\x12\x03\x1f\0D\n\x08\n\x01\x08\x12\x03\x20\0s\n\t\
    \n\x02\x08\x0b\x12\x03\x20\0s\n\x08\n\x01\x08\x12\x03!\0\"\n\t\n\x02\x08\
    \n\x12\x03!\0\"\n\x08\n\x01\x08\x12\x03\"\0:\n\t\n\x02\x08\x08\x12\x03\"\
    \0:\n\x08\n\x01\x08\x12\x03#\0D\n\t\n\x02\x08\x01\x12\x03#\0D\n\x08\n\
    \x01\x08\x12\x03$\0\"\n\t\n\x02\x08$\x12\x03$\0\"\n\x08\n\x01\x08\x12\
    \x03%\0D\n\t\n\x02\x08)\x12\x03%\0D\n\x08\n\x01\x08\x12\x03&\0C\n\t\n\
    \x02\x08-\x12\x03&\0C\n\xfb\x04\n\x02\x06\0\x12\x053\0\xd7\x03\x01\x1a\
    \xed\x04\x20API\x20for\x20setting\x20[access\x20levels]\n\x20[google.ide\
    ntity.accesscontextmanager.v1.AccessLevel]\x20and\x20[service\n\x20perim\
    eters]\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\n\
    \x20for\x20Google\x20Cloud\x20projects.\x20Each\x20organization\x20has\
    \x20one\x20[access\x20policy]\n\x20[google.identity.accesscontextmanager\
    .v1.AccessPolicy]\x20that\x20contains\x20the\n\x20[access\x20levels]\x20\
    [google.identity.accesscontextmanager.v1.AccessLevel]\n\x20and\x20[servi\
    ce\x20perimeters]\n\x20[google.identity.accesscontextmanager.v1.ServiceP\
    erimeter].\x20This\n\x20[access\x20policy]\x20[google.identity.accesscon\
    textmanager.v1.AccessPolicy]\x20is\n\x20applicable\x20to\x20all\x20resou\
    rces\x20in\x20the\x20organization.\n\x20AccessPolicies\n\n\n\n\x03\x06\0\
    \x01\x12\x033\x08\x1c\n\n\n\x03\x06\0\x03\x12\x034\x02K\n\x0c\n\x05\x06\
    \0\x03\x99\x08\x12\x034\x02K\n\n\n\x03\x06\0\x03\x12\x035\x02V\n\x0c\n\
    \x05\x06\0\x03\x9a\x08\x12\x035\x02V\nx\n\x04\x06\0\x02\0\x12\x04:\x02>\
    \x03\x1aj\x20Lists\x20all\x20[access\x20policies]\n\x20[google.identity.\
    accesscontextmanager.v1.AccessPolicy]\x20in\x20an\n\x20organization.\n\n\
    \x0c\n\x05\x06\0\x02\0\x01\x12\x03:\x06\x18\n\x0c\n\x05\x06\0\x02\0\x02\
    \x12\x03:\x192\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03:=W\n\r\n\x05\x06\0\
    \x02\0\x04\x12\x04;\x04=\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\
    \x04;\x04=\x06\nu\n\x04\x06\0\x02\x01\x12\x04B\x02G\x03\x1ag\x20Returns\
    \x20an\x20[access\x20policy]\n\x20[google.identity.accesscontextmanager.\
    v1.AccessPolicy]\x20based\x20on\x20the\x20name.\n\n\x0c\n\x05\x06\0\x02\
    \x01\x01\x12\x03B\x06\x15\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03B\x16,\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x03B7C\n\r\n\x05\x06\0\x02\x01\x04\x12\
    \x04C\x04E\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04C\x04E\
    \x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03F\x042\n\x0f\n\x08\x06\0\x02\
    \x01\x04\x9b\x08\0\x12\x03F\x042\n\xb7\x02\n\x04\x06\0\x02\x02\x12\x04N\
    \x02W\x03\x1a\xa8\x02\x20Creates\x20an\x20access\x20policy.\x20This\x20m\
    ethod\x20fails\x20if\x20the\x20organization\x20already\x20has\n\x20an\
    \x20access\x20policy.\x20The\x20long-running\x20operation\x20has\x20a\
    \x20successful\x20status\n\x20after\x20the\x20access\x20policy\x20propag\
    ates\x20to\x20long-lasting\x20storage.\n\x20Syntactic\x20and\x20basic\
    \x20semantic\x20errors\x20are\x20returned\x20in\x20`metadata`\x20as\x20a\
    \n\x20BadRequest\x20proto.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03N\x06\
    \x18\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03N\x19%\n\x0c\n\x05\x06\0\x02\
    \x02\x03\x12\x03N0L\n\r\n\x05\x06\0\x02\x02\x04\x12\x04O\x04R\x06\n\x11\
    \n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04O\x04R\x06\n\r\n\x05\x06\0\
    \x02\x02\x04\x12\x04S\x04V\x06\n\x0f\n\x07\x06\0\x02\x02\x04\x99\x08\x12\
    \x04S\x04V\x06\n\xac\x02\n\x04\x06\0\x02\x03\x12\x04_\x02i\x03\x1a\x9d\
    \x02\x20Updates\x20an\x20[access\x20policy]\n\x20[google.identity.access\
    contextmanager.v1.AccessPolicy].\x20The\n\x20long-running\x20operation\
    \x20from\x20this\x20RPC\x20has\x20a\x20successful\x20status\x20after\x20\
    the\n\x20changes\x20to\x20the\x20[access\x20policy]\n\x20[google.identit\
    y.accesscontextmanager.v1.AccessPolicy]\x20propagate\n\x20to\x20long-las\
    ting\x20storage.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03_\x06\x18\n\x0c\
    \n\x05\x06\0\x02\x03\x02\x12\x03_\x192\n\x0c\n\x05\x06\0\x02\x03\x03\x12\
    \x03_=Y\n\r\n\x05\x06\0\x02\x03\x04\x12\x04`\x04c\x06\n\x11\n\t\x06\0\
    \x02\x03\x04\xb0\xca\xbc\"\x12\x04`\x04c\x06\n\x0c\n\x05\x06\0\x02\x03\
    \x04\x12\x03d\x04@\n\x0f\n\x08\x06\0\x02\x03\x04\x9b\x08\0\x12\x03d\x04@\
    \n\r\n\x05\x06\0\x02\x03\x04\x12\x04e\x04h\x06\n\x0f\n\x07\x06\0\x02\x03\
    \x04\x99\x08\x12\x04e\x04h\x06\n\xac\x02\n\x04\x06\0\x02\x04\x12\x04p\
    \x02y\x03\x1a\x9d\x02\x20Deletes\x20an\x20[access\x20policy]\n\x20[googl\
    e.identity.accesscontextmanager.v1.AccessPolicy]\x20based\x20on\x20the\n\
    \x20resource\x20name.\x20The\x20long-running\x20operation\x20has\x20a\
    \x20successful\x20status\x20after\x20the\n\x20[access\x20policy]\x20[goo\
    gle.identity.accesscontextmanager.v1.AccessPolicy]\n\x20is\x20removed\
    \x20from\x20long-lasting\x20storage.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\
    \x03p\x06\x18\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03p\x192\n\x0c\n\x05\
    \x06\0\x02\x04\x03\x12\x03p=Y\n\r\n\x05\x06\0\x02\x04\x04\x12\x04q\x04s\
    \x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x04q\x04s\x06\n\x0c\n\
    \x05\x06\0\x02\x04\x04\x12\x03t\x042\n\x0f\n\x08\x06\0\x02\x04\x04\x9b\
    \x08\0\x12\x03t\x042\n\r\n\x05\x06\0\x02\x04\x04\x12\x04u\x04x\x06\n\x0f\
    \n\x07\x06\0\x02\x04\x04\x99\x08\x12\x04u\x04x\x06\nx\n\x04\x06\0\x02\
    \x05\x12\x05~\x02\x83\x01\x03\x1ai\x20Lists\x20all\x20[access\x20levels]\
    \n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\x20for\x20an\
    \x20access\n\x20policy.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03~\x06\x16\
    \n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03~\x17.\n\x0c\n\x05\x06\0\x02\x05\
    \x03\x12\x03~9Q\n\x0e\n\x05\x06\0\x02\x05\x04\x12\x05\x7f\x04\x81\x01\
    \x06\n\x12\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x05\x7f\x04\x81\x01\
    \x06\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\x82\x01\x044\n\x10\n\x08\x06\0\
    \x02\x05\x04\x9b\x08\0\x12\x04\x82\x01\x044\n|\n\x04\x06\0\x02\x06\x12\
    \x06\x88\x01\x02\x8d\x01\x03\x1al\x20Gets\x20an\x20[access\x20level]\n\
    \x20[google.identity.accesscontextmanager.v1.AccessLevel]\x20based\x20on\
    \x20the\x20resource\n\x20name.\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\x88\
    \x01\x06\x14\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x88\x01\x15*\n\r\n\x05\
    \x06\0\x02\x06\x03\x12\x04\x88\x015@\n\x0f\n\x05\x06\0\x02\x06\x04\x12\
    \x06\x89\x01\x04\x8b\x01\x06\n\x13\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\
    \x12\x06\x89\x01\x04\x8b\x01\x06\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x8c\
    \x01\x042\n\x10\n\x08\x06\0\x02\x06\x04\x9b\x08\0\x12\x04\x8c\x01\x042\n\
    \xb5\x03\n\x04\x06\0\x02\x07\x12\x06\x96\x01\x02\xa0\x01\x03\x1a\xa4\x03\
    \x20Creates\x20an\x20[access\x20level]\n\x20[google.identity.accessconte\
    xtmanager.v1.AccessLevel].\x20The\x20long-running\n\x20operation\x20from\
    \x20this\x20RPC\x20has\x20a\x20successful\x20status\x20after\x20the\x20[\
    access\n\x20level]\x20[google.identity.accesscontextmanager.v1.AccessLev\
    el]\n\x20propagates\x20to\x20long-lasting\x20storage.\x20If\x20[access\
    \x20levels]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\
    \x20contain\n\x20errors,\x20an\x20error\x20response\x20is\x20returned\
    \x20for\x20the\x20first\x20error\x20encountered.\n\n\r\n\x05\x06\0\x02\
    \x07\x01\x12\x04\x96\x01\x06\x17\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\x96\
    \x01\x180\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\x96\x01;W\n\x0f\n\x05\x06\
    \0\x02\x07\x04\x12\x06\x97\x01\x04\x9a\x01\x06\n\x13\n\t\x06\0\x02\x07\
    \x04\xb0\xca\xbc\"\x12\x06\x97\x01\x04\x9a\x01\x06\n\r\n\x05\x06\0\x02\
    \x07\x04\x12\x04\x9b\x01\x04A\n\x10\n\x08\x06\0\x02\x07\x04\x9b\x08\0\
    \x12\x04\x9b\x01\x04A\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x9c\x01\x04\
    \x9f\x01\x06\n\x11\n\x07\x06\0\x02\x07\x04\x99\x08\x12\x06\x9c\x01\x04\
    \x9f\x01\x06\n\xc4\x03\n\x04\x06\0\x02\x08\x12\x06\xaa\x01\x02\xb4\x01\
    \x03\x1a\xb3\x03\x20Updates\x20an\x20[access\x20level]\n\x20[google.iden\
    tity.accesscontextmanager.v1.AccessLevel].\x20The\x20long-running\n\x20o\
    peration\x20from\x20this\x20RPC\x20has\x20a\x20successful\x20status\x20a\
    fter\x20the\x20changes\x20to\n\x20the\x20[access\x20level]\n\x20[google.\
    identity.accesscontextmanager.v1.AccessLevel]\x20propagate\n\x20to\x20lo\
    ng-lasting\x20storage.\x20If\x20[access\x20levels]\n\x20[google.identity\
    .accesscontextmanager.v1.AccessLevel]\x20contain\n\x20errors,\x20an\x20e\
    rror\x20response\x20is\x20returned\x20for\x20the\x20first\x20error\x20en\
    countered.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xaa\x01\x06\x17\n\r\n\
    \x05\x06\0\x02\x08\x02\x12\x04\xaa\x01\x180\n\r\n\x05\x06\0\x02\x08\x03\
    \x12\x04\xaa\x01;W\n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\xab\x01\x04\xae\
    \x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xab\x01\x04\
    \xae\x01\x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xaf\x01\x04F\n\x10\n\
    \x08\x06\0\x02\x08\x04\x9b\x08\0\x12\x04\xaf\x01\x04F\n\x0f\n\x05\x06\0\
    \x02\x08\x04\x12\x06\xb0\x01\x04\xb3\x01\x06\n\x11\n\x07\x06\0\x02\x08\
    \x04\x99\x08\x12\x06\xb0\x01\x04\xb3\x01\x06\n\xbf\x02\n\x04\x06\0\x02\t\
    \x12\x06\xbc\x01\x02\xc5\x01\x03\x1a\xae\x02\x20Deletes\x20an\x20[access\
    \x20level]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\
    \x20based\x20on\x20the\x20resource\n\x20name.\x20The\x20long-running\x20\
    operation\x20from\x20this\x20RPC\x20has\x20a\x20successful\x20status\n\
    \x20after\x20the\x20[access\x20level]\n\x20[google.identity.accesscontex\
    tmanager.v1.AccessLevel]\x20has\x20been\x20removed\n\x20from\x20long-las\
    ting\x20storage.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xbc\x01\x06\x17\n\r\
    \n\x05\x06\0\x02\t\x02\x12\x04\xbc\x01\x180\n\r\n\x05\x06\0\x02\t\x03\
    \x12\x04\xbc\x01;W\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\xbd\x01\x04\xbf\
    \x01\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\xbd\x01\x04\xbf\
    \x01\x06\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xc0\x01\x042\n\x10\n\x08\x06\
    \0\x02\t\x04\x9b\x08\0\x12\x04\xc0\x01\x042\n\x0f\n\x05\x06\0\x02\t\x04\
    \x12\x06\xc1\x01\x04\xc4\x01\x06\n\x11\n\x07\x06\0\x02\t\x04\x99\x08\x12\
    \x06\xc1\x01\x04\xc4\x01\x06\n\xb7\x07\n\x04\x06\0\x02\n\x12\x06\xd8\x01\
    \x02\xe1\x01\x03\x1a\xa6\x07\x20Replaces\x20all\x20existing\x20[access\
    \x20levels]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\
    \x20in\x20an\x20[access\n\x20policy]\x20[google.identity.accesscontextma\
    nager.v1.AccessPolicy]\x20with\n\x20the\x20[access\x20levels]\n\x20[goog\
    le.identity.accesscontextmanager.v1.AccessLevel]\x20provided.\x20This\n\
    \x20is\x20done\x20atomically.\x20The\x20long-running\x20operation\x20fro\
    m\x20this\x20RPC\x20has\x20a\n\x20successful\x20status\x20after\x20all\
    \x20replacements\x20propagate\x20to\x20long-lasting\n\x20storage.\x20If\
    \x20the\x20replacement\x20contains\x20errors,\x20an\x20error\x20response\
    \x20is\x20returned\n\x20for\x20the\x20first\x20error\x20encountered.\x20\
    \x20Upon\x20error,\x20the\x20replacement\x20is\x20cancelled,\n\x20and\
    \x20existing\x20[access\x20levels]\n\x20[google.identity.accesscontextma\
    nager.v1.AccessLevel]\x20are\x20not\n\x20affected.\x20The\x20Operation.r\
    esponse\x20field\x20contains\n\x20ReplaceAccessLevelsResponse.\x20Removi\
    ng\x20[access\x20levels]\n\x20[google.identity.accesscontextmanager.v1.A\
    ccessLevel]\x20contained\x20in\x20existing\n\x20[service\x20perimeters]\
    \n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\x20resu\
    lt\x20in\x20an\n\x20error.\n\n\r\n\x05\x06\0\x02\n\x01\x12\x04\xd8\x01\
    \x06\x19\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xd8\x01\x1a4\n\r\n\x05\x06\0\
    \x02\n\x03\x12\x04\xd8\x01?[\n\x0f\n\x05\x06\0\x02\n\x04\x12\x06\xd9\x01\
    \x04\xdc\x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\x06\xd9\x01\
    \x04\xdc\x01\x06\n\x0f\n\x05\x06\0\x02\n\x04\x12\x06\xdd\x01\x04\xe0\x01\
    \x06\n\x11\n\x07\x06\0\x02\n\x04\x99\x08\x12\x06\xdd\x01\x04\xe0\x01\x06\
    \n\x83\x01\n\x04\x06\0\x02\x0b\x12\x06\xe6\x01\x02\xeb\x01\x03\x1as\x20L\
    ists\x20all\x20[service\x20perimeters]\n\x20[google.identity.accessconte\
    xtmanager.v1.ServicePerimeter]\x20for\x20an\n\x20access\x20policy.\n\n\r\
    \n\x05\x06\0\x02\x0b\x01\x12\x04\xe6\x01\x06\x1b\n\r\n\x05\x06\0\x02\x0b\
    \x02\x12\x04\xe6\x01\x1c8\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xe6\x01C`\
    \n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xe7\x01\x04\xe9\x01\x06\n\x13\n\t\
    \x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xe7\x01\x04\xe9\x01\x06\n\r\n\
    \x05\x06\0\x02\x0b\x04\x12\x04\xea\x01\x044\n\x10\n\x08\x06\0\x02\x0b\
    \x04\x9b\x08\0\x12\x04\xea\x01\x044\n\x85\x01\n\x04\x06\0\x02\x0c\x12\
    \x06\xf0\x01\x02\xf5\x01\x03\x1au\x20Gets\x20a\x20[service\x20perimeter]\
    \n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\x20base\
    d\x20on\x20the\n\x20resource\x20name.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\
    \x04\xf0\x01\x06\x19\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xf0\x01\x1a4\n\
    \r\n\x05\x06\0\x02\x0c\x03\x12\x04\xf0\x01?O\n\x0f\n\x05\x06\0\x02\x0c\
    \x04\x12\x06\xf1\x01\x04\xf3\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\
    \xbc\"\x12\x06\xf1\x01\x04\xf3\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\
    \x04\xf4\x01\x042\n\x10\n\x08\x06\0\x02\x0c\x04\x9b\x08\0\x12\x04\xf4\
    \x01\x042\n\xd5\x03\n\x04\x06\0\x02\r\x12\x06\xff\x01\x02\x89\x02\x03\
    \x1a\xc4\x03\x20Creates\x20a\x20[service\x20perimeter]\n\x20[google.iden\
    tity.accesscontextmanager.v1.ServicePerimeter].\x20The\n\x20long-running\
    \x20operation\x20from\x20this\x20RPC\x20has\x20a\x20successful\x20status\
    \x20after\x20the\n\x20[service\x20perimeter]\n\x20[google.identity.acces\
    scontextmanager.v1.ServicePerimeter]\n\x20propagates\x20to\x20long-lasti\
    ng\x20storage.\x20If\x20a\x20[service\x20perimeter]\n\x20[google.identit\
    y.accesscontextmanager.v1.ServicePerimeter]\x20contains\n\x20errors,\x20\
    an\x20error\x20response\x20is\x20returned\x20for\x20the\x20first\x20erro\
    r\x20encountered.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\xff\x01\x06\x1c\n\
    \r\n\x05\x06\0\x02\r\x02\x12\x04\xff\x01\x1d:\n\r\n\x05\x06\0\x02\r\x03\
    \x12\x04\xff\x01Ea\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\x80\x02\x04\x83\
    \x02\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\x80\x02\x04\x83\
    \x02\x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x84\x02\x04F\n\x10\n\x08\x06\
    \0\x02\r\x04\x9b\x08\0\x12\x04\x84\x02\x04F\n\x0f\n\x05\x06\0\x02\r\x04\
    \x12\x06\x85\x02\x04\x88\x02\x06\n\x11\n\x07\x06\0\x02\r\x04\x99\x08\x12\
    \x06\x85\x02\x04\x88\x02\x06\n\xd5\x03\n\x04\x06\0\x02\x0e\x12\x06\x93\
    \x02\x02\x9d\x02\x03\x1a\xc4\x03\x20Updates\x20a\x20[service\x20perimete\
    r]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter].\x20T\
    he\n\x20long-running\x20operation\x20from\x20this\x20RPC\x20has\x20a\x20\
    successful\x20status\x20after\x20the\n\x20[service\x20perimeter]\n\x20[g\
    oogle.identity.accesscontextmanager.v1.ServicePerimeter]\n\x20propagates\
    \x20to\x20long-lasting\x20storage.\x20If\x20a\x20[service\x20perimeter]\
    \n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\x20cont\
    ains\n\x20errors,\x20an\x20error\x20response\x20is\x20returned\x20for\
    \x20the\x20first\x20error\x20encountered.\n\n\r\n\x05\x06\0\x02\x0e\x01\
    \x12\x04\x93\x02\x06\x1c\n\r\n\x05\x06\0\x02\x0e\x02\x12\x04\x93\x02\x1d\
    :\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\x93\x02Ea\n\x0f\n\x05\x06\0\x02\
    \x0e\x04\x12\x06\x94\x02\x04\x97\x02\x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\
    \xca\xbc\"\x12\x06\x94\x02\x04\x97\x02\x06\n\r\n\x05\x06\0\x02\x0e\x04\
    \x12\x04\x98\x02\x04K\n\x10\n\x08\x06\0\x02\x0e\x04\x9b\x08\0\x12\x04\
    \x98\x02\x04K\n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\x99\x02\x04\x9c\x02\
    \x06\n\x11\n\x07\x06\0\x02\x0e\x04\x99\x08\x12\x06\x99\x02\x04\x9c\x02\
    \x06\n\xcc\x02\n\x04\x06\0\x02\x0f\x12\x06\xa5\x02\x02\xae\x02\x03\x1a\
    \xbb\x02\x20Deletes\x20a\x20[service\x20perimeter]\n\x20[google.identity\
    .accesscontextmanager.v1.ServicePerimeter]\x20based\x20on\x20the\n\x20re\
    source\x20name.\x20The\x20long-running\x20operation\x20from\x20this\x20R\
    PC\x20has\x20a\x20successful\n\x20status\x20after\x20the\x20[service\x20\
    perimeter]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimete\
    r]\x20is\x20removed\x20from\n\x20long-lasting\x20storage.\n\n\r\n\x05\
    \x06\0\x02\x0f\x01\x12\x04\xa5\x02\x06\x1c\n\r\n\x05\x06\0\x02\x0f\x02\
    \x12\x04\xa5\x02\x1d:\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\xa5\x02Ea\n\
    \x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\xa6\x02\x04\xa8\x02\x06\n\x13\n\t\
    \x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\xa6\x02\x04\xa8\x02\x06\n\r\n\
    \x05\x06\0\x02\x0f\x04\x12\x04\xa9\x02\x042\n\x10\n\x08\x06\0\x02\x0f\
    \x04\x9b\x08\0\x12\x04\xa9\x02\x042\n\x0f\n\x05\x06\0\x02\x0f\x04\x12\
    \x06\xaa\x02\x04\xad\x02\x06\n\x11\n\x07\x06\0\x02\x0f\x04\x99\x08\x12\
    \x06\xaa\x02\x04\xad\x02\x06\n\x83\x06\n\x04\x06\0\x02\x10\x12\x06\xbd\
    \x02\x02\xc6\x02\x03\x1a\xf2\x05\x20Replace\x20all\x20existing\x20[servi\
    ce\x20perimeters]\n\x20[google.identity.accesscontextmanager.v1.ServiceP\
    erimeter]\x20in\x20an\x20[access\n\x20policy]\x20[google.identity.access\
    contextmanager.v1.AccessPolicy]\x20with\x20the\n\x20[service\x20perimete\
    rs]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\x20p\
    rovided.\x20This\n\x20is\x20done\x20atomically.\x20The\x20long-running\
    \x20operation\x20from\x20this\x20RPC\x20has\x20a\n\x20successful\x20stat\
    us\x20after\x20all\x20replacements\x20propagate\x20to\x20long-lasting\
    \x20storage.\n\x20Replacements\x20containing\x20errors\x20result\x20in\
    \x20an\x20error\x20response\x20for\x20the\x20first\n\x20error\x20encount\
    ered.\x20Upon\x20an\x20error,\x20replacement\x20are\x20cancelled\x20and\
    \x20existing\n\x20[service\x20perimeters]\n\x20[google.identity.accessco\
    ntextmanager.v1.ServicePerimeter]\x20are\x20not\n\x20affected.\x20The\
    \x20Operation.response\x20field\x20contains\n\x20ReplaceServicePerimeter\
    sResponse.\n\n\r\n\x05\x06\0\x02\x10\x01\x12\x04\xbd\x02\x06\x1e\n\r\n\
    \x05\x06\0\x02\x10\x02\x12\x04\xbd\x02\x1f>\n\r\n\x05\x06\0\x02\x10\x03\
    \x12\x04\xbd\x02Ie\n\x0f\n\x05\x06\0\x02\x10\x04\x12\x06\xbe\x02\x04\xc1\
    \x02\x06\n\x13\n\t\x06\0\x02\x10\x04\xb0\xca\xbc\"\x12\x06\xbe\x02\x04\
    \xc1\x02\x06\n\x0f\n\x05\x06\0\x02\x10\x04\x12\x06\xc2\x02\x04\xc5\x02\
    \x06\n\x11\n\x07\x06\0\x02\x10\x04\x99\x08\x12\x06\xc2\x02\x04\xc5\x02\
    \x06\n\x95\x08\n\x04\x06\0\x02\x11\x12\x06\xd7\x02\x02\xe0\x02\x03\x1a\
    \x84\x08\x20Commits\x20the\x20dry-run\x20specification\x20for\x20all\x20\
    the\x20[service\x20perimeters]\n\x20[google.identity.accesscontextmanage\
    r.v1.ServicePerimeter]\x20in\x20an\n\x20[access\x20policy][google.identi\
    ty.accesscontextmanager.v1.AccessPolicy].\n\x20A\x20commit\x20operation\
    \x20on\x20a\x20service\x20perimeter\x20involves\x20copying\x20its\x20`sp\
    ec`\x20field\n\x20to\x20the\x20`status`\x20field\x20of\x20the\x20service\
    \x20perimeter.\x20Only\x20[service\x20perimeters]\n\x20[google.identity.\
    accesscontextmanager.v1.ServicePerimeter]\x20with\n\x20`use_explicit_dry\
    _run_spec`\x20field\x20set\x20to\x20true\x20are\x20affected\x20by\x20a\
    \x20commit\n\x20operation.\x20The\x20long-running\x20operation\x20from\
    \x20this\x20RPC\x20has\x20a\x20successful\n\x20status\x20after\x20the\
    \x20dry-run\x20specifications\x20for\x20all\x20the\x20[service\x20perime\
    ters]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\
    \x20have\x20been\n\x20committed.\x20If\x20a\x20commit\x20fails,\x20it\
    \x20causes\x20the\x20long-running\x20operation\x20to\n\x20return\x20an\
    \x20error\x20response\x20and\x20the\x20entire\x20commit\x20operation\x20\
    is\x20cancelled.\n\x20When\x20successful,\x20the\x20Operation.response\
    \x20field\x20contains\n\x20CommitServicePerimetersResponse.\x20The\x20`d\
    ry_run`\x20and\x20the\x20`spec`\x20fields\x20are\n\x20cleared\x20after\
    \x20a\x20successful\x20commit\x20operation.\n\n\r\n\x05\x06\0\x02\x11\
    \x01\x12\x04\xd7\x02\x06\x1d\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\xd7\x02\
    \x1e<\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\xd7\x02Gc\n\x0f\n\x05\x06\0\
    \x02\x11\x04\x12\x06\xd8\x02\x04\xdb\x02\x06\n\x13\n\t\x06\0\x02\x11\x04\
    \xb0\xca\xbc\"\x12\x06\xd8\x02\x04\xdb\x02\x06\n\x0f\n\x05\x06\0\x02\x11\
    \x04\x12\x06\xdc\x02\x04\xdf\x02\x06\n\x11\n\x07\x06\0\x02\x11\x04\x99\
    \x08\x12\x06\xdc\x02\x04\xdf\x02\x06\n\x96\x01\n\x04\x06\0\x02\x12\x12\
    \x06\xe5\x02\x02\xea\x02\x03\x1a\x85\x01\x20Lists\x20all\x20[GcpUserAcce\
    ssBindings]\n\x20[google.identity.accesscontextmanager.v1.GcpUserAccessB\
    inding]\x20for\x20a\n\x20Google\x20Cloud\x20organization.\n\n\r\n\x05\
    \x06\0\x02\x12\x01\x12\x04\xe5\x02\x06\x1f\n\r\n\x05\x06\0\x02\x12\x02\
    \x12\x04\xe5\x02\x20@\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\xe5\x02Kl\n\
    \x0f\n\x05\x06\0\x02\x12\x04\x12\x06\xe6\x02\x04\xe8\x02\x06\n\x13\n\t\
    \x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\x06\xe6\x02\x04\xe8\x02\x06\n\r\n\
    \x05\x06\0\x02\x12\x04\x12\x04\xe9\x02\x044\n\x10\n\x08\x06\0\x02\x12\
    \x04\x9b\x08\0\x12\x04\xe9\x02\x044\n\x87\x01\n\x04\x06\0\x02\x13\x12\
    \x06\xef\x02\x02\xf4\x02\x03\x1aw\x20Gets\x20the\x20[GcpUserAccessBindin\
    g]\n\x20[google.identity.accesscontextmanager.v1.GcpUserAccessBinding]\
    \x20with\n\x20the\x20given\x20name.\n\n\r\n\x05\x06\0\x02\x13\x01\x12\
    \x04\xef\x02\x06\x1d\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\xef\x02\x1e<\n\
    \r\n\x05\x06\0\x02\x13\x03\x12\x04\xef\x02G[\n\x0f\n\x05\x06\0\x02\x13\
    \x04\x12\x06\xf0\x02\x04\xf2\x02\x06\n\x13\n\t\x06\0\x02\x13\x04\xb0\xca\
    \xbc\"\x12\x06\xf0\x02\x04\xf2\x02\x06\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xf3\x02\x042\n\x10\n\x08\x06\0\x02\x13\x04\x9b\x08\0\x12\x04\xf3\
    \x02\x042\n\x9b\x04\n\x04\x06\0\x02\x14\x12\x06\x80\x03\x02\x8a\x03\x03\
    \x1a\x8a\x04\x20Creates\x20a\x20[GcpUserAccessBinding]\n\x20[google.iden\
    tity.accesscontextmanager.v1.GcpUserAccessBinding].\x20If\x20the\n\x20cl\
    ient\x20specifies\x20a\x20[name]\n\x20[google.identity.accesscontextmana\
    ger.v1.GcpUserAccessBinding.name],\n\x20the\x20server\x20ignores\x20it.\
    \x20Fails\x20if\x20a\x20resource\x20already\x20exists\x20with\x20the\x20\
    same\n\x20[group_key]\n\x20[google.identity.accesscontextmanager.v1.GcpU\
    serAccessBinding.group_key].\n\x20Completion\x20of\x20this\x20long-runni\
    ng\x20operation\x20does\x20not\x20necessarily\x20signify\x20that\n\x20th\
    e\x20new\x20binding\x20is\x20deployed\x20onto\x20all\x20affected\x20user\
    s,\x20which\x20may\x20take\x20more\n\x20time.\n\n\r\n\x05\x06\0\x02\x14\
    \x01\x12\x04\x80\x03\x06\x20\n\r\n\x05\x06\0\x02\x14\x02\x12\x04\x80\x03\
    !B\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\x80\x03Mi\n\x0f\n\x05\x06\0\x02\
    \x14\x04\x12\x06\x81\x03\x04\x84\x03\x06\n\x13\n\t\x06\0\x02\x14\x04\xb0\
    \xca\xbc\"\x12\x06\x81\x03\x04\x84\x03\x06\n\r\n\x05\x06\0\x02\x14\x04\
    \x12\x04\x85\x03\x04L\n\x10\n\x08\x06\0\x02\x14\x04\x9b\x08\0\x12\x04\
    \x85\x03\x04L\n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\x86\x03\x04\x89\x03\
    \x06\n\x11\n\x07\x06\0\x02\x14\x04\x99\x08\x12\x06\x86\x03\x04\x89\x03\
    \x06\n\x96\x02\n\x04\x06\0\x02\x15\x12\x06\x91\x03\x02\x9b\x03\x03\x1a\
    \x85\x02\x20Updates\x20a\x20[GcpUserAccessBinding]\n\x20[google.identity\
    .accesscontextmanager.v1.GcpUserAccessBinding].\n\x20Completion\x20of\
    \x20this\x20long-running\x20operation\x20does\x20not\x20necessarily\x20s\
    ignify\x20that\n\x20the\x20changed\x20binding\x20is\x20deployed\x20onto\
    \x20all\x20affected\x20users,\x20which\x20may\x20take\n\x20more\x20time.\
    \n\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\x91\x03\x06\x20\n\r\n\x05\x06\0\
    \x02\x15\x02\x12\x04\x91\x03!B\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\x91\
    \x03Mi\n\x0f\n\x05\x06\0\x02\x15\x04\x12\x06\x92\x03\x04\x95\x03\x06\n\
    \x13\n\t\x06\0\x02\x15\x04\xb0\xca\xbc\"\x12\x06\x92\x03\x04\x95\x03\x06\
    \n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x96\x03\x04Q\n\x10\n\x08\x06\0\x02\
    \x15\x04\x9b\x08\0\x12\x04\x96\x03\x04Q\n\x0f\n\x05\x06\0\x02\x15\x04\
    \x12\x06\x97\x03\x04\x9a\x03\x06\n\x11\n\x07\x06\0\x02\x15\x04\x99\x08\
    \x12\x06\x97\x03\x04\x9a\x03\x06\n\x97\x02\n\x04\x06\0\x02\x16\x12\x06\
    \xa2\x03\x02\xab\x03\x03\x1a\x86\x02\x20Deletes\x20a\x20[GcpUserAccessBi\
    nding]\n\x20[google.identity.accesscontextmanager.v1.GcpUserAccessBindin\
    g].\n\x20Completion\x20of\x20this\x20long-running\x20operation\x20does\
    \x20not\x20necessarily\x20signify\x20that\n\x20the\x20binding\x20deletio\
    n\x20is\x20deployed\x20onto\x20all\x20affected\x20users,\x20which\x20may\
    \x20take\n\x20more\x20time.\n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\xa2\
    \x03\x06\x20\n\r\n\x05\x06\0\x02\x16\x02\x12\x04\xa2\x03!B\n\r\n\x05\x06\
    \0\x02\x16\x03\x12\x04\xa2\x03Mi\n\x0f\n\x05\x06\0\x02\x16\x04\x12\x06\
    \xa3\x03\x04\xa5\x03\x06\n\x13\n\t\x06\0\x02\x16\x04\xb0\xca\xbc\"\x12\
    \x06\xa3\x03\x04\xa5\x03\x06\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\xa6\x03\
    \x042\n\x10\n\x08\x06\0\x02\x16\x04\x9b\x08\0\x12\x04\xa6\x03\x042\n\x0f\
    \n\x05\x06\0\x02\x16\x04\x12\x06\xa7\x03\x04\xaa\x03\x06\n\x11\n\x07\x06\
    \0\x02\x16\x04\x99\x08\x12\x06\xa7\x03\x04\xaa\x03\x06\n\x90\x03\n\x04\
    \x06\0\x02\x17\x12\x06\xb3\x03\x02\xb8\x03\x03\x1a\xff\x02\x20Sets\x20th\
    e\x20IAM\x20policy\x20for\x20the\x20specified\x20Access\x20Context\x20Ma\
    nager\n\x20[access\x20policy][google.identity.accesscontextmanager.v1.Ac\
    cessPolicy].\n\x20This\x20method\x20replaces\x20the\x20existing\x20IAM\
    \x20policy\x20on\x20the\x20access\x20policy.\x20The\x20IAM\n\x20policy\
    \x20controls\x20the\x20set\x20of\x20users\x20who\x20can\x20perform\x20sp\
    ecific\x20operations\x20on\x20the\n\x20Access\x20Context\x20Manager\x20[\
    access\n\x20policy][google.identity.accesscontextmanager.v1.AccessPolicy\
    ].\n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\xb3\x03\x06\x12\n\r\n\x05\x06\0\
    \x02\x17\x02\x12\x04\xb3\x03\x134\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\
    \xb3\x03?S\n\x0f\n\x05\x06\0\x02\x17\x04\x12\x06\xb4\x03\x04\xb7\x03\x06\
    \n\x13\n\t\x06\0\x02\x17\x04\xb0\xca\xbc\"\x12\x06\xb4\x03\x04\xb7\x03\
    \x06\n\x97\x01\n\x04\x06\0\x02\x18\x12\x06\xbc\x03\x02\xc1\x03\x03\x1a\
    \x86\x01\x20Gets\x20the\x20IAM\x20policy\x20for\x20the\x20specified\x20A\
    ccess\x20Context\x20Manager\n\x20[access\x20policy][google.identity.acce\
    sscontextmanager.v1.AccessPolicy].\n\n\r\n\x05\x06\0\x02\x18\x01\x12\x04\
    \xbc\x03\x06\x12\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\xbc\x03\x134\n\r\n\
    \x05\x06\0\x02\x18\x03\x12\x04\xbc\x03?S\n\x0f\n\x05\x06\0\x02\x18\x04\
    \x12\x06\xbd\x03\x04\xc0\x03\x06\n\x13\n\t\x06\0\x02\x18\x04\xb0\xca\xbc\
    \"\x12\x06\xbd\x03\x04\xc0\x03\x06\n\x9a\x03\n\x04\x06\0\x02\x19\x12\x06\
    \xc9\x03\x02\xd6\x03\x03\x1a\x89\x03\x20Returns\x20the\x20IAM\x20permiss\
    ions\x20that\x20the\x20caller\x20has\x20on\x20the\x20specified\x20Access\
    \n\x20Context\x20Manager\x20resource.\x20The\x20resource\x20can\x20be\
    \x20an\n\x20[AccessPolicy][google.identity.accesscontextmanager.v1.Acces\
    sPolicy],\n\x20[AccessLevel][google.identity.accesscontextmanager.v1.Acc\
    essLevel],\x20or\n\x20[ServicePerimeter][google.identity.accesscontextma\
    nager.v1.ServicePerimeter\n\x20].\x20This\x20method\x20does\x20not\x20su\
    pport\x20other\x20resources.\n\n\r\n\x05\x06\0\x02\x19\x01\x12\x04\xc9\
    \x03\x06\x18\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xc9\x03\x19@\n\r\n\x05\
    \x06\0\x02\x19\x03\x12\x04\xc9\x03Ks\n\x0f\n\x05\x06\0\x02\x19\x04\x12\
    \x06\xca\x03\x04\xd5\x03\x06\n\x13\n\t\x06\0\x02\x19\x04\xb0\xca\xbc\"\
    \x12\x06\xca\x03\x04\xd5\x03\x06\nG\n\x02\x04\0\x12\x06\xda\x03\0\xed\
    \x03\x01\x1a9\x20A\x20request\x20to\x20list\x20all\x20`AccessPolicies`\
    \x20for\x20a\x20container.\n\n\x0b\n\x03\x04\0\x01\x12\x04\xda\x03\x08!\
    \n\x85\x01\n\x04\x04\0\x02\0\x12\x06\xe0\x03\x02\xe5\x03\x04\x1au\x20Req\
    uired.\x20Resource\x20name\x20for\x20the\x20container\x20to\x20list\x20A\
    ccessPolicy\x20instances\n\x20from.\n\n\x20Format:\n\x20`organizations/{\
    org_id}`\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xe0\x03\x02\x08\n\r\n\x05\
    \x04\0\x02\0\x01\x12\x04\xe0\x03\t\x0f\n\r\n\x05\x04\0\x02\0\x03\x12\x04\
    \xe0\x03\x12\x13\n\x0f\n\x05\x04\0\x02\0\x08\x12\x06\xe0\x03\x14\xe5\x03\
    \x03\n\x10\n\x08\x04\0\x02\0\x08\x9c\x08\0\x12\x04\xe1\x03\x04*\n\x11\n\
    \x07\x04\0\x02\0\x08\x9f\x08\x12\x06\xe2\x03\x04\xe4\x03\x05\nU\n\x04\
    \x04\0\x02\x01\x12\x04\xe8\x03\x02\x16\x1aG\x20Number\x20of\x20AccessPol\
    icy\x20instances\x20to\x20include\x20in\x20the\x20list.\x20Default\x2010\
    0.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\xe8\x03\x02\x07\n\r\n\x05\x04\0\
    \x02\x01\x01\x12\x04\xe8\x03\x08\x11\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\
    \xe8\x03\x14\x15\nu\n\x04\x04\0\x02\x02\x12\x04\xec\x03\x02\x18\x1ag\x20\
    Next\x20page\x20token\x20for\x20the\x20next\x20batch\x20of\x20AccessPoli\
    cy\x20instances.\x20Defaults\x20to\n\x20the\x20first\x20page\x20of\x20re\
    sults.\n\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\xec\x03\x02\x08\n\r\n\x05\
    \x04\0\x02\x02\x01\x12\x04\xec\x03\t\x13\n\r\n\x05\x04\0\x02\x02\x03\x12\
    \x04\xec\x03\x16\x17\n:\n\x02\x04\x01\x12\x06\xf0\x03\0\xf7\x03\x01\x1a,\
    \x20A\x20response\x20to\x20`ListAccessPoliciesRequest`.\n\n\x0b\n\x03\
    \x04\x01\x01\x12\x04\xf0\x03\x08\"\n3\n\x04\x04\x01\x02\0\x12\x04\xf2\
    \x03\x02,\x1a%\x20List\x20of\x20the\x20AccessPolicy\x20instances.\n\n\r\
    \n\x05\x04\x01\x02\0\x04\x12\x04\xf2\x03\x02\n\n\r\n\x05\x04\x01\x02\0\
    \x06\x12\x04\xf2\x03\x0b\x17\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xf2\x03\
    \x18'\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xf2\x03*+\n}\n\x04\x04\x01\x02\
    \x01\x12\x04\xf6\x03\x02\x1d\x1ao\x20The\x20pagination\x20token\x20to\
    \x20retrieve\x20the\x20next\x20page\x20of\x20results.\x20If\x20the\x20va\
    lue\x20is\n\x20empty,\x20no\x20further\x20results\x20remain.\n\n\r\n\x05\
    \x04\x01\x02\x01\x05\x12\x04\xf6\x03\x02\x08\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\xf6\x03\t\x18\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xf6\x03\
    \x1b\x1c\n=\n\x02\x04\x02\x12\x06\xfa\x03\0\x84\x04\x01\x1a/\x20A\x20req\
    uest\x20to\x20get\x20a\x20particular\x20`AccessPolicy`.\n\n\x0b\n\x03\
    \x04\x02\x01\x12\x04\xfa\x03\x08\x1e\nm\n\x04\x04\x02\x02\0\x12\x06\xfe\
    \x03\x02\x83\x04\x04\x1a]\x20Required.\x20Resource\x20name\x20for\x20the\
    \x20access\x20policy\x20to\x20get.\n\n\x20Format\x20`accessPolicies/{pol\
    icy_id}`\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xfe\x03\x02\x08\n\r\n\x05\
    \x04\x02\x02\0\x01\x12\x04\xfe\x03\t\r\n\r\n\x05\x04\x02\x02\0\x03\x12\
    \x04\xfe\x03\x10\x11\n\x0f\n\x05\x04\x02\x02\0\x08\x12\x06\xfe\x03\x12\
    \x83\x04\x03\n\x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\xff\x03\x04\
    *\n\x11\n\x07\x04\x02\x02\0\x08\x9f\x08\x12\x06\x80\x04\x04\x82\x04\x05\
    \n6\n\x02\x04\x03\x12\x06\x87\x04\0\x8d\x04\x01\x1a(\x20A\x20request\x20\
    to\x20update\x20an\x20`AccessPolicy`.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\
    \x87\x04\x08!\n3\n\x04\x04\x03\x02\0\x12\x04\x89\x04\x02C\x1a%\x20Requir\
    ed.\x20The\x20updated\x20AccessPolicy.\n\n\r\n\x05\x04\x03\x02\0\x06\x12\
    \x04\x89\x04\x02\x0e\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x89\x04\x0f\x15\
    \n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x89\x04\x18\x19\n\r\n\x05\x04\x03\
    \x02\0\x08\x12\x04\x89\x04\x1aB\n\x10\n\x08\x04\x03\x02\0\x08\x9c\x08\0\
    \x12\x04\x89\x04\x1bA\nV\n\x04\x04\x03\x02\x01\x12\x04\x8c\x04\x02U\x1aH\
    \x20Required.\x20Mask\x20to\x20control\x20which\x20fields\x20get\x20upda\
    ted.\x20Must\x20be\x20non-empty.\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\
    \x8c\x04\x02\x1b\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x8c\x04\x1c'\n\r\
    \n\x05\x04\x03\x02\x01\x03\x12\x04\x8c\x04*+\n\r\n\x05\x04\x03\x02\x01\
    \x08\x12\x04\x8c\x04,T\n\x10\n\x08\x04\x03\x02\x01\x08\x9c\x08\0\x12\x04\
    \x8c\x04-S\n6\n\x02\x04\x04\x12\x06\x90\x04\0\x9a\x04\x01\x1a(\x20A\x20r\
    equest\x20to\x20delete\x20an\x20`AccessPolicy`.\n\n\x0b\n\x03\x04\x04\
    \x01\x12\x04\x90\x04\x08!\np\n\x04\x04\x04\x02\0\x12\x06\x94\x04\x02\x99\
    \x04\x04\x1a`\x20Required.\x20Resource\x20name\x20for\x20the\x20access\
    \x20policy\x20to\x20delete.\n\n\x20Format\x20`accessPolicies/{policy_id}\
    `\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x94\x04\x02\x08\n\r\n\x05\x04\
    \x04\x02\0\x01\x12\x04\x94\x04\t\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \x94\x04\x10\x11\n\x0f\n\x05\x04\x04\x02\0\x08\x12\x06\x94\x04\x12\x99\
    \x04\x03\n\x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\x95\x04\x04*\n\
    \x11\n\x07\x04\x04\x02\0\x08\x9f\x08\x12\x06\x96\x04\x04\x98\x04\x05\nJ\
    \n\x02\x04\x05\x12\x06\x9d\x04\0\xb8\x04\x01\x1a<\x20A\x20request\x20to\
    \x20list\x20all\x20`AccessLevels`\x20in\x20an\x20`AccessPolicy`.\n\n\x0b\
    \n\x03\x04\x05\x01\x12\x04\x9d\x04\x08\x1f\n\xbd\x01\n\x04\x04\x05\x02\0\
    \x12\x06\xa3\x04\x02\xa8\x04\x04\x1a\xac\x01\x20Required.\x20Resource\
    \x20name\x20for\x20the\x20access\x20policy\x20to\x20list\x20[Access\x20L\
    evels]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\x20fro\
    m.\n\n\x20Format:\n\x20`accessPolicies/{policy_id}`\n\n\r\n\x05\x04\x05\
    \x02\0\x05\x12\x04\xa3\x04\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\
    \xa3\x04\t\x0f\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xa3\x04\x12\x13\n\x0f\
    \n\x05\x04\x05\x02\0\x08\x12\x06\xa3\x04\x14\xa8\x04\x03\n\x10\n\x08\x04\
    \x05\x02\0\x08\x9c\x08\0\x12\x04\xa4\x04\x04*\n\x11\n\x07\x04\x05\x02\0\
    \x08\x9f\x08\x12\x06\xa5\x04\x04\xa7\x04\x05\n\x86\x01\n\x04\x04\x05\x02\
    \x01\x12\x04\xad\x04\x02\x16\x1ax\x20Number\x20of\x20[Access\x20Levels]\
    \n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\x20to\x20inc\
    lude\x20in\n\x20the\x20list.\x20Default\x20100.\n\n\r\n\x05\x04\x05\x02\
    \x01\x05\x12\x04\xad\x04\x02\x07\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\
    \xad\x04\x08\x11\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xad\x04\x14\x15\n\
    \xaf\x01\n\x04\x04\x05\x02\x02\x12\x04\xb2\x04\x02\x18\x1a\xa0\x01\x20Ne\
    xt\x20page\x20token\x20for\x20the\x20next\x20batch\x20of\x20[Access\x20L\
    evel]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\x20inst\
    ances.\n\x20Defaults\x20to\x20the\x20first\x20page\x20of\x20results.\n\n\
    \r\n\x05\x04\x05\x02\x02\x05\x12\x04\xb2\x04\x02\x08\n\r\n\x05\x04\x05\
    \x02\x02\x01\x12\x04\xb2\x04\t\x13\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\
    \xb2\x04\x16\x17\n\xd2\x01\n\x04\x04\x05\x02\x03\x12\x04\xb7\x04\x02&\
    \x1a\xc3\x01\x20Whether\x20to\x20return\x20`BasicLevels`\x20in\x20the\
    \x20Cloud\x20Common\x20Expression\x20language,\x20as\n\x20`CustomLevels`\
    ,\x20rather\x20than\x20as\x20`BasicLevels`.\x20Defaults\x20to\x20returni\
    ng\n\x20`AccessLevels`\x20in\x20the\x20format\x20they\x20were\x20defined\
    .\n\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\xb7\x04\x02\r\n\r\n\x05\x04\
    \x05\x02\x03\x01\x12\x04\xb7\x04\x0e!\n\r\n\x05\x04\x05\x02\x03\x03\x12\
    \x04\xb7\x04$%\n8\n\x02\x04\x06\x12\x06\xbb\x04\0\xc3\x04\x01\x1a*\x20A\
    \x20response\x20to\x20`ListAccessLevelsRequest`.\n\n\x0b\n\x03\x04\x06\
    \x01\x12\x04\xbb\x04\x08\x20\nl\n\x04\x04\x06\x02\0\x12\x04\xbe\x04\x02)\
    \x1a^\x20List\x20of\x20the\x20[Access\x20Level]\n\x20[google.identity.ac\
    cesscontextmanager.v1.AccessLevel]\x20instances.\n\n\r\n\x05\x04\x06\x02\
    \0\x04\x12\x04\xbe\x04\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xbe\x04\
    \x0b\x16\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xbe\x04\x17$\n\r\n\x05\x04\
    \x06\x02\0\x03\x12\x04\xbe\x04'(\n}\n\x04\x04\x06\x02\x01\x12\x04\xc2\
    \x04\x02\x1d\x1ao\x20The\x20pagination\x20token\x20to\x20retrieve\x20the\
    \x20next\x20page\x20of\x20results.\x20If\x20the\x20value\x20is\n\x20empt\
    y,\x20no\x20further\x20results\x20remain.\n\n\r\n\x05\x04\x06\x02\x01\
    \x05\x12\x04\xc2\x04\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xc2\
    \x04\t\x18\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xc2\x04\x1b\x1c\n<\n\
    \x02\x04\x07\x12\x06\xc6\x04\0\xdc\x04\x01\x1a.\x20A\x20request\x20to\
    \x20get\x20a\x20particular\x20`AccessLevel`.\n\n\x0b\n\x03\x04\x07\x01\
    \x12\x04\xc6\x04\x08\x1d\n\xc0\x01\n\x04\x04\x07\x02\0\x12\x06\xcc\x04\
    \x02\xd1\x04\x04\x1a\xaf\x01\x20Required.\x20Resource\x20name\x20for\x20\
    the\x20[Access\x20Level]\n\x20[google.identity.accesscontextmanager.v1.A\
    ccessLevel].\n\n\x20Format:\n\x20`accessPolicies/{policy_id}/accessLevel\
    s/{access_level_id}`\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xcc\x04\x02\
    \x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xcc\x04\t\r\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\xcc\x04\x10\x11\n\x0f\n\x05\x04\x07\x02\0\x08\x12\x06\
    \xcc\x04\x12\xd1\x04\x03\n\x10\n\x08\x04\x07\x02\0\x08\x9c\x08\0\x12\x04\
    \xcd\x04\x04*\n\x11\n\x07\x04\x07\x02\0\x08\x9f\x08\x12\x06\xce\x04\x04\
    \xd0\x04\x05\n\xf6\x03\n\x04\x04\x07\x02\x01\x12\x04\xdb\x04\x02&\x1a\
    \xe7\x03\x20Whether\x20to\x20return\x20`BasicLevels`\x20in\x20the\x20Clo\
    ud\x20Common\x20Expression\n\x20Language\x20rather\x20than\x20as\x20`Bas\
    icLevels`.\x20Defaults\x20to\x20AS_DEFINED,\x20where\n\x20[Access\x20Lev\
    els]\x20[google.identity.accesscontextmanager.v1.AccessLevel]\n\x20are\
    \x20returned\x20as\x20`BasicLevels`\x20or\x20`CustomLevels`\x20based\x20\
    on\x20how\x20they\x20were\n\x20created.\x20If\x20set\x20to\x20CEL,\x20al\
    l\x20[Access\x20Levels]\n\x20[google.identity.accesscontextmanager.v1.Ac\
    cessLevel]\x20are\x20returned\x20as\n\x20`CustomLevels`.\x20In\x20the\
    \x20CEL\x20case,\x20`BasicLevels`\x20are\x20translated\x20to\x20equivale\
    nt\n\x20`CustomLevels`.\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xdb\x04\
    \x02\r\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xdb\x04\x0e!\n\r\n\x05\x04\
    \x07\x02\x01\x03\x12\x04\xdb\x04$%\n5\n\x02\x04\x08\x12\x06\xdf\x04\0\
    \xf1\x04\x01\x1a'\x20A\x20request\x20to\x20create\x20an\x20`AccessLevel`\
    .\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xdf\x04\x08\x20\n\xbe\x01\n\x04\x04\
    \x08\x02\0\x12\x06\xe4\x04\x02\xe9\x04\x04\x1a\xad\x01\x20Required.\x20R\
    esource\x20name\x20for\x20the\x20access\x20policy\x20which\x20owns\x20th\
    is\x20[Access\n\x20Level]\x20[google.identity.accesscontextmanager.v1.Ac\
    cessLevel].\n\n\x20Format:\x20`accessPolicies/{policy_id}`\n\n\r\n\x05\
    \x04\x08\x02\0\x05\x12\x04\xe4\x04\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\
    \x12\x04\xe4\x04\t\x0f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xe4\x04\x12\
    \x13\n\x0f\n\x05\x04\x08\x02\0\x08\x12\x06\xe4\x04\x14\xe9\x04\x03\n\x10\
    \n\x08\x04\x08\x02\0\x08\x9c\x08\0\x12\x04\xe5\x04\x04*\n\x11\n\x07\x04\
    \x08\x02\0\x08\x9f\x08\x12\x06\xe6\x04\x04\xe8\x04\x05\n\xf4\x01\n\x04\
    \x04\x08\x02\x01\x12\x04\xf0\x04\x02H\x1a\xe5\x01\x20Required.\x20The\
    \x20[Access\x20Level]\n\x20[google.identity.accesscontextmanager.v1.Acce\
    ssLevel]\x20to\x20create.\n\x20Syntactic\x20correctness\x20of\x20the\x20\
    [Access\x20Level]\n\x20[google.identity.accesscontextmanager.v1.AccessLe\
    vel]\x20is\x20a\n\x20precondition\x20for\x20creation.\n\n\r\n\x05\x04\
    \x08\x02\x01\x06\x12\x04\xf0\x04\x02\r\n\r\n\x05\x04\x08\x02\x01\x01\x12\
    \x04\xf0\x04\x0e\x1a\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xf0\x04\x1d\
    \x1e\n\r\n\x05\x04\x08\x02\x01\x08\x12\x04\xf0\x04\x1fG\n\x10\n\x08\x04\
    \x08\x02\x01\x08\x9c\x08\0\x12\x04\xf0\x04\x20F\n5\n\x02\x04\t\x12\x06\
    \xf4\x04\0\xfe\x04\x01\x1a'\x20A\x20request\x20to\x20update\x20an\x20`Ac\
    cessLevel`.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xf4\x04\x08\x20\n\xf2\x01\n\
    \x04\x04\t\x02\0\x12\x04\xfa\x04\x02H\x1a\xe3\x01\x20Required.\x20The\
    \x20updated\x20[Access\x20Level]\n\x20[google.identity.accesscontextmana\
    ger.v1.AccessLevel].\x20Syntactic\n\x20correctness\x20of\x20the\x20[Acce\
    ss\x20Level]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel]\
    \x20is\x20a\n\x20precondition\x20for\x20creation.\n\n\r\n\x05\x04\t\x02\
    \0\x06\x12\x04\xfa\x04\x02\r\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xfa\x04\
    \x0e\x1a\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xfa\x04\x1d\x1e\n\r\n\x05\x04\
    \t\x02\0\x08\x12\x04\xfa\x04\x1fG\n\x10\n\x08\x04\t\x02\0\x08\x9c\x08\0\
    \x12\x04\xfa\x04\x20F\nV\n\x04\x04\t\x02\x01\x12\x04\xfd\x04\x02U\x1aH\
    \x20Required.\x20Mask\x20to\x20control\x20which\x20fields\x20get\x20upda\
    ted.\x20Must\x20be\x20non-empty.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\
    \xfd\x04\x02\x1b\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xfd\x04\x1c'\n\r\n\
    \x05\x04\t\x02\x01\x03\x12\x04\xfd\x04*+\n\r\n\x05\x04\t\x02\x01\x08\x12\
    \x04\xfd\x04,T\n\x10\n\x08\x04\t\x02\x01\x08\x9c\x08\0\x12\x04\xfd\x04-S\
    \n5\n\x02\x04\n\x12\x06\x81\x05\0\x8d\x05\x01\x1a'\x20A\x20request\x20to\
    \x20delete\x20an\x20`AccessLevel`.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x81\
    \x05\x08\x20\n\xc0\x01\n\x04\x04\n\x02\0\x12\x06\x87\x05\x02\x8c\x05\x04\
    \x1a\xaf\x01\x20Required.\x20Resource\x20name\x20for\x20the\x20[Access\
    \x20Level]\n\x20[google.identity.accesscontextmanager.v1.AccessLevel].\n\
    \n\x20Format:\n\x20`accessPolicies/{policy_id}/accessLevels/{access_leve\
    l_id}`\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x87\x05\x02\x08\n\r\n\x05\x04\
    \n\x02\0\x01\x12\x04\x87\x05\t\r\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x87\
    \x05\x10\x11\n\x0f\n\x05\x04\n\x02\0\x08\x12\x06\x87\x05\x12\x8c\x05\x03\
    \n\x10\n\x08\x04\n\x02\0\x08\x9c\x08\0\x12\x04\x88\x05\x04*\n\x11\n\x07\
    \x04\n\x02\0\x08\x9f\x08\x12\x06\x89\x05\x04\x8b\x05\x05\n\x8f\x01\n\x02\
    \x04\x0b\x12\x06\x91\x05\0\xae\x05\x01\x1a\x80\x01\x20A\x20request\x20to\
    \x20replace\x20all\x20existing\x20Access\x20Levels\x20in\x20an\x20Access\
    \x20Policy\x20with\n\x20the\x20Access\x20Levels\x20provided.\x20This\x20\
    is\x20done\x20atomically.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x91\x05\x08\
    \"\n\xc1\x01\n\x04\x04\x0b\x02\0\x12\x06\x97\x05\x02\x9c\x05\x04\x1a\xb0\
    \x01\x20Required.\x20Resource\x20name\x20for\x20the\x20access\x20policy\
    \x20which\x20owns\x20these\n\x20[Access\x20Levels]\n\x20[google.identity\
    .accesscontextmanager.v1.AccessLevel].\n\n\x20Format:\x20`accessPolicies\
    /{policy_id}`\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x97\x05\x02\x08\n\r\
    \n\x05\x04\x0b\x02\0\x01\x12\x04\x97\x05\t\x0f\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\x97\x05\x12\x13\n\x0f\n\x05\x04\x0b\x02\0\x08\x12\x06\x97\
    \x05\x14\x9c\x05\x03\n\x10\n\x08\x04\x0b\x02\0\x08\x9c\x08\0\x12\x04\x98\
    \x05\x04*\n\x11\n\x07\x04\x0b\x02\0\x08\x9f\x08\x12\x06\x99\x05\x04\x9b\
    \x05\x05\n\xa7\x02\n\x04\x04\x0b\x02\x01\x12\x04\xa4\x05\x02R\x1a\x98\
    \x02\x20Required.\x20The\x20desired\x20[Access\x20Levels]\n\x20[google.i\
    dentity.accesscontextmanager.v1.AccessLevel]\x20that\x20should\n\x20repl\
    ace\x20all\x20existing\x20[Access\x20Levels]\n\x20[google.identity.acces\
    scontextmanager.v1.AccessLevel]\x20in\x20the\n\x20[Access\x20Policy]\n\
    \x20[google.identity.accesscontextmanager.v1.AccessPolicy].\n\n\r\n\x05\
    \x04\x0b\x02\x01\x04\x12\x04\xa4\x05\x02\n\n\r\n\x05\x04\x0b\x02\x01\x06\
    \x12\x04\xa4\x05\x0b\x16\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xa4\x05\
    \x17$\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xa4\x05'(\n\r\n\x05\x04\x0b\
    \x02\x01\x08\x12\x04\xa4\x05)Q\n\x10\n\x08\x04\x0b\x02\x01\x08\x9c\x08\0\
    \x12\x04\xa4\x05*P\n\xfa\x03\n\x04\x04\x0b\x02\x02\x12\x04\xad\x05\x02\
    \x12\x1a\xeb\x03\x20Optional.\x20The\x20etag\x20for\x20the\x20version\
    \x20of\x20the\x20[Access\x20Policy]\n\x20[google.identity.accesscontextm\
    anager.v1.AccessPolicy]\x20that\x20this\n\x20replace\x20operation\x20is\
    \x20to\x20be\x20performed\x20on.\x20If,\x20at\x20the\x20time\x20of\x20re\
    place,\x20the\n\x20etag\x20for\x20the\x20Access\x20Policy\x20stored\x20i\
    n\x20Access\x20Context\x20Manager\x20is\x20different\n\x20from\x20the\
    \x20specified\x20etag,\x20then\x20the\x20replace\x20operation\x20will\
    \x20not\x20be\x20performed\n\x20and\x20the\x20call\x20will\x20fail.\x20T\
    his\x20field\x20is\x20not\x20required.\x20If\x20etag\x20is\x20not\n\x20p\
    rovided,\x20the\x20operation\x20will\x20be\x20performed\x20as\x20if\x20a\
    \x20valid\x20etag\x20is\x20provided.\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\
    \x04\xad\x05\x02\x08\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xad\x05\t\r\n\
    \r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xad\x05\x10\x11\no\n\x02\x04\x0c\
    \x12\x06\xb2\x05\0\xb6\x05\x01\x1aa\x20A\x20response\x20to\x20ReplaceAcc\
    essLevelsRequest.\x20This\x20will\x20be\x20put\x20inside\x20of\n\x20Oper\
    ation.response\x20field.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xb2\x05\x08#\
    \nl\n\x04\x04\x0c\x02\0\x12\x04\xb5\x05\x02)\x1a^\x20List\x20of\x20the\
    \x20[Access\x20Level]\n\x20[google.identity.accesscontextmanager.v1.Acce\
    ssLevel]\x20instances.\n\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xb5\x05\x02\
    \n\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xb5\x05\x0b\x16\n\r\n\x05\x04\x0c\
    \x02\0\x01\x12\x04\xb5\x05\x17$\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xb5\
    \x05'(\nO\n\x02\x04\r\x12\x06\xb9\x05\0\xcf\x05\x01\x1aA\x20A\x20request\
    \x20to\x20list\x20all\x20`ServicePerimeters`\x20in\x20an\x20`AccessPolic\
    y`.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xb9\x05\x08$\n\xc7\x01\n\x04\x04\r\
    \x02\0\x12\x06\xbf\x05\x02\xc4\x05\x04\x1a\xb6\x01\x20Required.\x20Resou\
    rce\x20name\x20for\x20the\x20access\x20policy\x20to\x20list\x20[Service\
    \x20Perimeters]\n\x20[google.identity.accesscontextmanager.v1.ServicePer\
    imeter]\x20from.\n\n\x20Format:\n\x20`accessPolicies/{policy_id}`\n\n\r\
    \n\x05\x04\r\x02\0\x05\x12\x04\xbf\x05\x02\x08\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xbf\x05\t\x0f\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xbf\x05\x12\x13\
    \n\x0f\n\x05\x04\r\x02\0\x08\x12\x06\xbf\x05\x14\xc4\x05\x03\n\x10\n\x08\
    \x04\r\x02\0\x08\x9c\x08\0\x12\x04\xc0\x05\x04*\n\x11\n\x07\x04\r\x02\0\
    \x08\x9f\x08\x12\x06\xc1\x05\x04\xc3\x05\x05\n\x91\x01\n\x04\x04\r\x02\
    \x01\x12\x04\xc9\x05\x02\x16\x1a\x82\x01\x20Number\x20of\x20[Service\x20\
    Perimeters]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimet\
    er]\x20to\x20include\n\x20in\x20the\x20list.\x20Default\x20100.\n\n\r\n\
    \x05\x04\r\x02\x01\x05\x12\x04\xc9\x05\x02\x07\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\xc9\x05\x08\x11\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc9\x05\
    \x14\x15\n\xb9\x01\n\x04\x04\r\x02\x02\x12\x04\xce\x05\x02\x18\x1a\xaa\
    \x01\x20Next\x20page\x20token\x20for\x20the\x20next\x20batch\x20of\x20[S\
    ervice\x20Perimeter]\n\x20[google.identity.accesscontextmanager.v1.Servi\
    cePerimeter]\x20instances.\n\x20Defaults\x20to\x20the\x20first\x20page\
    \x20of\x20results.\n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xce\x05\x02\x08\
    \n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xce\x05\t\x13\n\r\n\x05\x04\r\x02\
    \x02\x03\x12\x04\xce\x05\x16\x17\n=\n\x02\x04\x0e\x12\x06\xd2\x05\0\xda\
    \x05\x01\x1a/\x20A\x20response\x20to\x20`ListServicePerimetersRequest`.\
    \n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xd2\x05\x08%\nv\n\x04\x04\x0e\x02\0\
    \x12\x04\xd5\x05\x023\x1ah\x20List\x20of\x20the\x20[Service\x20Perimeter\
    ]\n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\x20ins\
    tances.\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xd5\x05\x02\n\n\r\n\x05\
    \x04\x0e\x02\0\x06\x12\x04\xd5\x05\x0b\x1b\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xd5\x05\x1c.\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xd5\x0512\n}\n\
    \x04\x04\x0e\x02\x01\x12\x04\xd9\x05\x02\x1d\x1ao\x20The\x20pagination\
    \x20token\x20to\x20retrieve\x20the\x20next\x20page\x20of\x20results.\x20\
    If\x20the\x20value\x20is\n\x20empty,\x20no\x20further\x20results\x20rema\
    in.\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xd9\x05\x02\x08\n\r\n\x05\
    \x04\x0e\x02\x01\x01\x12\x04\xd9\x05\t\x18\n\r\n\x05\x04\x0e\x02\x01\x03\
    \x12\x04\xd9\x05\x1b\x1c\nA\n\x02\x04\x0f\x12\x06\xdd\x05\0\xe9\x05\x01\
    \x1a3\x20A\x20request\x20to\x20get\x20a\x20particular\x20`ServicePerimet\
    er`.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xdd\x05\x08\"\n\xd5\x01\n\x04\x04\
    \x0f\x02\0\x12\x06\xe3\x05\x02\xe8\x05\x04\x1a\xc4\x01\x20Required.\x20R\
    esource\x20name\x20for\x20the\x20[Service\x20Perimeter]\n\x20[google.ide\
    ntity.accesscontextmanager.v1.ServicePerimeter].\n\n\x20Format:\n\x20`ac\
    cessPolicies/{policy_id}/servicePerimeters/{service_perimeters_id}`\n\n\
    \r\n\x05\x04\x0f\x02\0\x05\x12\x04\xe3\x05\x02\x08\n\r\n\x05\x04\x0f\x02\
    \0\x01\x12\x04\xe3\x05\t\r\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xe3\x05\
    \x10\x11\n\x0f\n\x05\x04\x0f\x02\0\x08\x12\x06\xe3\x05\x12\xe8\x05\x03\n\
    \x10\n\x08\x04\x0f\x02\0\x08\x9c\x08\0\x12\x04\xe4\x05\x04*\n\x11\n\x07\
    \x04\x0f\x02\0\x08\x9f\x08\x12\x06\xe5\x05\x04\xe7\x05\x05\n9\n\x02\x04\
    \x10\x12\x06\xec\x05\0\xfe\x05\x01\x1a+\x20A\x20request\x20to\x20create\
    \x20a\x20`ServicePerimeter`.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xec\x05\
    \x08%\n\xc8\x01\n\x04\x04\x10\x02\0\x12\x06\xf1\x05\x02\xf6\x05\x04\x1a\
    \xb7\x01\x20Required.\x20Resource\x20name\x20for\x20the\x20access\x20pol\
    icy\x20which\x20owns\x20this\x20[Service\n\x20Perimeter]\x20[google.iden\
    tity.accesscontextmanager.v1.ServicePerimeter].\n\n\x20Format:\x20`acces\
    sPolicies/{policy_id}`\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xf1\x05\x02\
    \x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xf1\x05\t\x0f\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xf1\x05\x12\x13\n\x0f\n\x05\x04\x10\x02\0\x08\x12\x06\
    \xf1\x05\x14\xf6\x05\x03\n\x10\n\x08\x04\x10\x02\0\x08\x9c\x08\0\x12\x04\
    \xf2\x05\x04*\n\x11\n\x07\x04\x10\x02\0\x08\x9f\x08\x12\x06\xf3\x05\x04\
    \xf5\x05\x05\n\x88\x02\n\x04\x04\x10\x02\x01\x12\x04\xfd\x05\x02R\x1a\
    \xf9\x01\x20Required.\x20The\x20[Service\x20Perimeter]\n\x20[google.iden\
    tity.accesscontextmanager.v1.ServicePerimeter]\x20to\x20create.\n\x20Syn\
    tactic\x20correctness\x20of\x20the\x20[Service\x20Perimeter]\n\x20[googl\
    e.identity.accesscontextmanager.v1.ServicePerimeter]\x20is\x20a\n\x20pre\
    condition\x20for\x20creation.\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\
    \xfd\x05\x02\x12\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xfd\x05\x13$\n\r\
    \n\x05\x04\x10\x02\x01\x03\x12\x04\xfd\x05'(\n\r\n\x05\x04\x10\x02\x01\
    \x08\x12\x04\xfd\x05)Q\n\x10\n\x08\x04\x10\x02\x01\x08\x9c\x08\0\x12\x04\
    \xfd\x05*P\n9\n\x02\x04\x11\x12\x06\x81\x06\0\x88\x06\x01\x1a+\x20A\x20r\
    equest\x20to\x20update\x20a\x20`ServicePerimeter`.\n\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\x81\x06\x08%\n\x8a\x01\n\x04\x04\x11\x02\0\x12\x04\x84\x06\
    \x02R\x1a|\x20Required.\x20The\x20updated\x20`ServicePerimeter`.\x20Synt\
    actic\x20correctness\x20of\x20the\n\x20`ServicePerimeter`\x20is\x20a\x20\
    precondition\x20for\x20creation.\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\
    \x84\x06\x02\x12\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x84\x06\x13$\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\x84\x06'(\n\r\n\x05\x04\x11\x02\0\x08\x12\
    \x04\x84\x06)Q\n\x10\n\x08\x04\x11\x02\0\x08\x9c\x08\0\x12\x04\x84\x06*P\
    \nV\n\x04\x04\x11\x02\x01\x12\x04\x87\x06\x02U\x1aH\x20Required.\x20Mask\
    \x20to\x20control\x20which\x20fields\x20get\x20updated.\x20Must\x20be\
    \x20non-empty.\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\x87\x06\x02\x1b\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\x87\x06\x1c'\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\x87\x06*+\n\r\n\x05\x04\x11\x02\x01\x08\x12\x04\x87\x06\
    ,T\n\x10\n\x08\x04\x11\x02\x01\x08\x9c\x08\0\x12\x04\x87\x06-S\n9\n\x02\
    \x04\x12\x12\x06\x8b\x06\0\x97\x06\x01\x1a+\x20A\x20request\x20to\x20del\
    ete\x20a\x20`ServicePerimeter`.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\x8b\
    \x06\x08%\n\xd4\x01\n\x04\x04\x12\x02\0\x12\x06\x91\x06\x02\x96\x06\x04\
    \x1a\xc3\x01\x20Required.\x20Resource\x20name\x20for\x20the\x20[Service\
    \x20Perimeter]\n\x20[google.identity.accesscontextmanager.v1.ServicePeri\
    meter].\n\n\x20Format:\n\x20`accessPolicies/{policy_id}/servicePerimeter\
    s/{service_perimeter_id}`\n\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x91\x06\
    \x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x91\x06\t\r\n\r\n\x05\x04\
    \x12\x02\0\x03\x12\x04\x91\x06\x10\x11\n\x0f\n\x05\x04\x12\x02\0\x08\x12\
    \x06\x91\x06\x12\x96\x06\x03\n\x10\n\x08\x04\x12\x02\0\x08\x9c\x08\0\x12\
    \x04\x92\x06\x04*\n\x11\n\x07\x04\x12\x02\0\x08\x9f\x08\x12\x06\x93\x06\
    \x04\x95\x06\x05\n\x99\x01\n\x02\x04\x13\x12\x06\x9b\x06\0\xb8\x06\x01\
    \x1a\x8a\x01\x20A\x20request\x20to\x20replace\x20all\x20existing\x20Serv\
    ice\x20Perimeters\x20in\x20an\x20Access\x20Policy\n\x20with\x20the\x20Se\
    rvice\x20Perimeters\x20provided.\x20This\x20is\x20done\x20atomically.\n\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\x9b\x06\x08'\n\xcb\x01\n\x04\x04\x13\
    \x02\0\x12\x06\xa1\x06\x02\xa6\x06\x04\x1a\xba\x01\x20Required.\x20Resou\
    rce\x20name\x20for\x20the\x20access\x20policy\x20which\x20owns\x20these\
    \n\x20[Service\x20Perimeters]\n\x20[google.identity.accesscontextmanager\
    .v1.ServicePerimeter].\n\n\x20Format:\x20`accessPolicies/{policy_id}`\n\
    \n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xa1\x06\x02\x08\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xa1\x06\t\x0f\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xa1\
    \x06\x12\x13\n\x0f\n\x05\x04\x13\x02\0\x08\x12\x06\xa1\x06\x14\xa6\x06\
    \x03\n\x10\n\x08\x04\x13\x02\0\x08\x9c\x08\0\x12\x04\xa2\x06\x04*\n\x11\
    \n\x07\x04\x13\x02\0\x08\x9f\x08\x12\x06\xa3\x06\x04\xa5\x06\x05\n\xbb\
    \x02\n\x04\x04\x13\x02\x01\x12\x04\xae\x06\x02\\\x1a\xac\x02\x20Required\
    .\x20The\x20desired\x20[Service\x20Perimeters]\n\x20[google.identity.acc\
    esscontextmanager.v1.ServicePerimeter]\x20that\x20should\n\x20replace\
    \x20all\x20existing\x20[Service\x20Perimeters]\n\x20[google.identity.acc\
    esscontextmanager.v1.ServicePerimeter]\x20in\x20the\n\x20[Access\x20Poli\
    cy]\n\x20[google.identity.accesscontextmanager.v1.AccessPolicy].\n\n\r\n\
    \x05\x04\x13\x02\x01\x04\x12\x04\xae\x06\x02\n\n\r\n\x05\x04\x13\x02\x01\
    \x06\x12\x04\xae\x06\x0b\x1b\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xae\
    \x06\x1c.\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xae\x0612\n\r\n\x05\x04\
    \x13\x02\x01\x08\x12\x04\xae\x063[\n\x10\n\x08\x04\x13\x02\x01\x08\x9c\
    \x08\0\x12\x04\xae\x064Z\n\xfa\x03\n\x04\x04\x13\x02\x02\x12\x04\xb7\x06\
    \x02\x12\x1a\xeb\x03\x20Optional.\x20The\x20etag\x20for\x20the\x20versio\
    n\x20of\x20the\x20[Access\x20Policy]\n\x20[google.identity.accesscontext\
    manager.v1.AccessPolicy]\x20that\x20this\n\x20replace\x20operation\x20is\
    \x20to\x20be\x20performed\x20on.\x20If,\x20at\x20the\x20time\x20of\x20re\
    place,\x20the\n\x20etag\x20for\x20the\x20Access\x20Policy\x20stored\x20i\
    n\x20Access\x20Context\x20Manager\x20is\x20different\n\x20from\x20the\
    \x20specified\x20etag,\x20then\x20the\x20replace\x20operation\x20will\
    \x20not\x20be\x20performed\n\x20and\x20the\x20call\x20will\x20fail.\x20T\
    his\x20field\x20is\x20not\x20required.\x20If\x20etag\x20is\x20not\n\x20p\
    rovided,\x20the\x20operation\x20will\x20be\x20performed\x20as\x20if\x20a\
    \x20valid\x20etag\x20is\x20provided.\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\
    \x04\xb7\x06\x02\x08\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xb7\x06\t\r\n\
    \r\n\x05\x04\x13\x02\x02\x03\x12\x04\xb7\x06\x10\x11\nt\n\x02\x04\x14\
    \x12\x06\xbc\x06\0\xc0\x06\x01\x1af\x20A\x20response\x20to\x20ReplaceSer\
    vicePerimetersRequest.\x20This\x20will\x20be\x20put\x20inside\x20of\n\
    \x20Operation.response\x20field.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xbc\
    \x06\x08(\nv\n\x04\x04\x14\x02\0\x12\x04\xbf\x06\x023\x1ah\x20List\x20of\
    \x20the\x20[Service\x20Perimeter]\n\x20[google.identity.accesscontextman\
    ager.v1.ServicePerimeter]\x20instances.\n\n\r\n\x05\x04\x14\x02\0\x04\
    \x12\x04\xbf\x06\x02\n\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xbf\x06\x0b\
    \x1b\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xbf\x06\x1c.\n\r\n\x05\x04\x14\
    \x02\0\x03\x12\x04\xbf\x0612\n\xe2\x01\n\x02\x04\x15\x12\x06\xc5\x06\0\
    \xdc\x06\x01\x1a\xd3\x01\x20A\x20request\x20to\x20commit\x20dry-run\x20s\
    pecs\x20in\x20all\x20[Service\x20Perimeters]\n\x20[google.identity.acces\
    scontextmanager.v1.ServicePerimeter]\x20belonging\x20to\n\x20an\x20[Acce\
    ss\x20Policy][google.identity.accesscontextmanager.v1.AccessPolicy].\n\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xc5\x06\x08&\n\xad\x02\n\x04\x04\x15\x02\
    \0\x12\x06\xcd\x06\x02\xd2\x06\x04\x1a\x9c\x02\x20Required.\x20Resource\
    \x20name\x20for\x20the\x20parent\x20[Access\x20Policy]\n\x20[google.iden\
    tity.accesscontextmanager.v1.AccessPolicy]\x20which\x20owns\x20all\n\x20\
    [Service\x20Perimeters]\n\x20[google.identity.accesscontextmanager.v1.Se\
    rvicePerimeter]\x20in\x20scope\x20for\n\x20the\x20commit\x20operation.\n\
    \n\x20Format:\x20`accessPolicies/{policy_id}`\n\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\xcd\x06\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xcd\x06\
    \t\x0f\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xcd\x06\x12\x13\n\x0f\n\x05\
    \x04\x15\x02\0\x08\x12\x06\xcd\x06\x14\xd2\x06\x03\n\x10\n\x08\x04\x15\
    \x02\0\x08\x9c\x08\0\x12\x04\xce\x06\x04*\n\x11\n\x07\x04\x15\x02\0\x08\
    \x9f\x08\x12\x06\xcf\x06\x04\xd1\x06\x05\n\xf7\x03\n\x04\x04\x15\x02\x01\
    \x12\x04\xdb\x06\x02\x12\x1a\xe8\x03\x20Optional.\x20The\x20etag\x20for\
    \x20the\x20version\x20of\x20the\x20[Access\x20Policy]\n\x20[google.ident\
    ity.accesscontextmanager.v1.AccessPolicy]\x20that\x20this\n\x20commit\
    \x20operation\x20is\x20to\x20be\x20performed\x20on.\x20If,\x20at\x20the\
    \x20time\x20of\x20commit,\x20the\n\x20etag\x20for\x20the\x20Access\x20Po\
    licy\x20stored\x20in\x20Access\x20Context\x20Manager\x20is\x20different\
    \n\x20from\x20the\x20specified\x20etag,\x20then\x20the\x20commit\x20oper\
    ation\x20will\x20not\x20be\x20performed\n\x20and\x20the\x20call\x20will\
    \x20fail.\x20This\x20field\x20is\x20not\x20required.\x20If\x20etag\x20is\
    \x20not\n\x20provided,\x20the\x20operation\x20will\x20be\x20performed\
    \x20as\x20if\x20a\x20valid\x20etag\x20is\x20provided.\n\n\r\n\x05\x04\
    \x15\x02\x01\x05\x12\x04\xdb\x06\x02\x08\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\xdb\x06\t\r\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xdb\x06\x10\
    \x11\ns\n\x02\x04\x16\x12\x06\xe0\x06\0\xe6\x06\x01\x1ae\x20A\x20respons\
    e\x20to\x20CommitServicePerimetersRequest.\x20This\x20will\x20be\x20put\
    \x20inside\x20of\n\x20Operation.response\x20field.\n\n\x0b\n\x03\x04\x16\
    \x01\x12\x04\xe0\x06\x08'\n\xcb\x01\n\x04\x04\x16\x02\0\x12\x04\xe5\x06\
    \x023\x1a\xbc\x01\x20List\x20of\x20all\x20the\x20[Service\x20Perimeter]\
    \n\x20[google.identity.accesscontextmanager.v1.ServicePerimeter]\x20inst\
    ances\x20in\n\x20the\x20[Access\x20Policy]\n\x20[google.identity.accessc\
    ontextmanager.v1.AccessPolicy].\n\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \xe5\x06\x02\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xe5\x06\x0b\x1b\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\xe5\x06\x1c.\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xe5\x0612\n4\n\x02\x05\0\x12\x06\xe9\x06\0\xf4\x06\x01\x1a&\x20\
    The\x20format\x20used\x20in\x20an\x20`AccessLevel`.\n\n\x0b\n\x03\x05\0\
    \x01\x12\x04\xe9\x06\x05\x10\n-\n\x04\x05\0\x02\0\x12\x04\xeb\x06\x02\
    \x1f\x1a\x1f\x20The\x20format\x20was\x20not\x20specified.\n\n\r\n\x05\
    \x05\0\x02\0\x01\x12\x04\xeb\x06\x02\x1a\n\r\n\x05\x05\0\x02\0\x02\x12\
    \x04\xeb\x06\x1d\x1e\n\x92\x01\n\x04\x05\0\x02\x01\x12\x04\xef\x06\x02\
    \x11\x1a\x83\x01\x20Uses\x20the\x20format\x20the\x20resource\x20was\x20d\
    efined\x20in.\x20BasicLevels\x20are\x20returned\x20as\n\x20BasicLevels,\
    \x20CustomLevels\x20are\x20returned\x20as\x20CustomLevels.\n\n\r\n\x05\
    \x05\0\x02\x01\x01\x12\x04\xef\x06\x02\x0c\n\r\n\x05\x05\0\x02\x01\x02\
    \x12\x04\xef\x06\x0f\x10\n\x94\x01\n\x04\x05\0\x02\x02\x12\x04\xf3\x06\
    \x02\n\x1a\x85\x01\x20Use\x20Cloud\x20Common\x20Expression\x20Language\
    \x20when\x20returning\x20the\x20resource.\x20\x20Both\n\x20BasicLevels\
    \x20and\x20CustomLevels\x20are\x20returned\x20as\x20CustomLevels.\n\n\r\
    \n\x05\x05\0\x02\x02\x01\x12\x04\xf3\x06\x02\x05\n\r\n\x05\x05\0\x02\x02\
    \x02\x12\x04\xf3\x06\x08\t\n\x92\x01\n\x02\x04\x17\x12\x06\xf8\x06\0\x8a\
    \x07\x01\x1a\x83\x01\x20Request\x20of\x20[ListGcpUserAccessBindings]\n\
    \x20[google.identity.accesscontextmanager.v1.AccessContextManager.ListGc\
    pUserAccessBindings].\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xf8\x06\x08(\n8\
    \n\x04\x04\x17\x02\0\x12\x06\xfa\x06\x02\xff\x06\x04\x1a(\x20Required.\
    \x20Example:\x20\"organizations/256\"\n\n\r\n\x05\x04\x17\x02\0\x05\x12\
    \x04\xfa\x06\x02\x08\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xfa\x06\t\x0f\n\
    \r\n\x05\x04\x17\x02\0\x03\x12\x04\xfa\x06\x12\x13\n\x0f\n\x05\x04\x17\
    \x02\0\x08\x12\x06\xfa\x06\x14\xff\x06\x03\n\x10\n\x08\x04\x17\x02\0\x08\
    \x9c\x08\0\x12\x04\xfb\x06\x04*\n\x11\n\x07\x04\x17\x02\0\x08\x9f\x08\
    \x12\x06\xfc\x06\x04\xfe\x06\x05\n\x9b\x01\n\x04\x04\x17\x02\x01\x12\x04\
    \x83\x07\x02?\x1a\x8c\x01\x20Optional.\x20Maximum\x20number\x20of\x20ite\
    ms\x20to\x20return.\x20The\x20server\x20may\x20return\x20fewer\x20items.\
    \n\x20If\x20left\x20blank,\x20the\x20server\x20may\x20return\x20any\x20n\
    umber\x20of\x20items.\n\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\x83\x07\
    \x02\x07\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x83\x07\x08\x11\n\r\n\x05\
    \x04\x17\x02\x01\x03\x12\x04\x83\x07\x14\x15\n\r\n\x05\x04\x17\x02\x01\
    \x08\x12\x04\x83\x07\x16>\n\x10\n\x08\x04\x17\x02\x01\x08\x9c\x08\0\x12\
    \x04\x83\x07\x17=\n\xf5\x01\n\x04\x04\x17\x02\x02\x12\x04\x89\x07\x02A\
    \x1a\xe6\x01\x20Optional.\x20If\x20left\x20blank,\x20returns\x20the\x20f\
    irst\x20page.\x20To\x20enumerate\x20all\x20items,\x20use\x20the\n\x20[ne\
    xt_page_token]\n\x20[google.identity.accesscontextmanager.v1.ListGcpUser\
    AccessBindingsResponse.next_page_token]\n\x20from\x20your\x20previous\
    \x20list\x20operation.\n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\x89\x07\
    \x02\x08\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\x89\x07\t\x13\n\r\n\x05\
    \x04\x17\x02\x02\x03\x12\x04\x89\x07\x16\x17\n\r\n\x05\x04\x17\x02\x02\
    \x08\x12\x04\x89\x07\x18@\n\x10\n\x08\x04\x17\x02\x02\x08\x9c\x08\0\x12\
    \x04\x89\x07\x19?\n\x93\x01\n\x02\x04\x18\x12\x06\x8e\x07\0\x95\x07\x01\
    \x1a\x84\x01\x20Response\x20of\x20[ListGcpUserAccessBindings]\n\x20[goog\
    le.identity.accesscontextmanager.v1.AccessContextManager.ListGcpUserAcce\
    ssBindings].\n\n\x0b\n\x03\x04\x18\x01\x12\x04\x8e\x07\x08)\nf\n\x04\x04\
    \x18\x02\0\x12\x04\x91\x07\x02=\x1aX\x20[GcpUserAccessBinding]\n\x20[goo\
    gle.identity.accesscontextmanager.v1.GcpUserAccessBinding]\n\n\r\n\x05\
    \x04\x18\x02\0\x04\x12\x04\x91\x07\x02\n\n\r\n\x05\x04\x18\x02\0\x06\x12\
    \x04\x91\x07\x0b\x1f\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x91\x07\x208\n\
    \r\n\x05\x04\x18\x02\0\x03\x12\x04\x91\x07;<\nW\n\x04\x04\x18\x02\x01\
    \x12\x04\x94\x07\x02\x1d\x1aI\x20Token\x20to\x20get\x20the\x20next\x20pa\
    ge\x20of\x20items.\x20If\x20blank,\x20there\x20are\x20no\x20more\x20item\
    s.\n\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\x94\x07\x02\x08\n\r\n\x05\x04\
    \x18\x02\x01\x01\x12\x04\x94\x07\t\x18\n\r\n\x05\x04\x18\x02\x01\x03\x12\
    \x04\x94\x07\x1b\x1c\n\x8d\x01\n\x02\x04\x19\x12\x06\x99\x07\0\xa1\x07\
    \x01\x1a\x7f\x20Request\x20of\x20[GetGcpUserAccessBinding]\n\x20[google.\
    identity.accesscontextmanager.v1.AccessContextManager.GetGcpUserAccessBi\
    nding].\n\n\x0b\n\x03\x04\x19\x01\x12\x04\x99\x07\x08&\n[\n\x04\x04\x19\
    \x02\0\x12\x06\x9b\x07\x02\xa0\x07\x04\x1aK\x20Required.\x20Example:\x20\
    \"organizations/256/gcpUserAccessBindings/b3-BhcX_Ud5N\"\n\n\r\n\x05\x04\
    \x19\x02\0\x05\x12\x04\x9b\x07\x02\x08\n\r\n\x05\x04\x19\x02\0\x01\x12\
    \x04\x9b\x07\t\r\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x9b\x07\x10\x11\n\
    \x0f\n\x05\x04\x19\x02\0\x08\x12\x06\x9b\x07\x12\xa0\x07\x03\n\x10\n\x08\
    \x04\x19\x02\0\x08\x9c\x08\0\x12\x04\x9c\x07\x04*\n\x11\n\x07\x04\x19\
    \x02\0\x08\x9f\x08\x12\x06\x9d\x07\x04\x9f\x07\x05\n\x94\x01\n\x02\x04\
    \x1a\x12\x06\xa5\x07\0\xb1\x07\x01\x1a\x85\x01\x20Request\x20of\x20[Crea\
    teGcpUserAccessBinding]\n\x20[google.identity.accesscontextmanager.v1.Ac\
    cessContextManager.CreateGcpUserAccessBinding].\n\n\x0b\n\x03\x04\x1a\
    \x01\x12\x04\xa5\x07\x08)\n8\n\x04\x04\x1a\x02\0\x12\x06\xa7\x07\x02\xac\
    \x07\x04\x1a(\x20Required.\x20Example:\x20\"organizations/256\"\n\n\r\n\
    \x05\x04\x1a\x02\0\x05\x12\x04\xa7\x07\x02\x08\n\r\n\x05\x04\x1a\x02\0\
    \x01\x12\x04\xa7\x07\t\x0f\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xa7\x07\
    \x12\x13\n\x0f\n\x05\x04\x1a\x02\0\x08\x12\x06\xa7\x07\x14\xac\x07\x03\n\
    \x10\n\x08\x04\x1a\x02\0\x08\x9c\x08\0\x12\x04\xa8\x07\x04*\n\x11\n\x07\
    \x04\x1a\x02\0\x08\x9f\x08\x12\x06\xa9\x07\x04\xab\x07\x05\np\n\x04\x04\
    \x1a\x02\x01\x12\x04\xb0\x07\x02\\\x1ab\x20Required.\x20[GcpUserAccessBi\
    nding]\n\x20[google.identity.accesscontextmanager.v1.GcpUserAccessBindin\
    g]\n\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xb0\x07\x02\x16\n\r\n\x05\x04\
    \x1a\x02\x01\x01\x12\x04\xb0\x07\x17.\n\r\n\x05\x04\x1a\x02\x01\x03\x12\
    \x04\xb0\x0712\n\r\n\x05\x04\x1a\x02\x01\x08\x12\x04\xb0\x073[\n\x10\n\
    \x08\x04\x1a\x02\x01\x08\x9c\x08\0\x12\x04\xb0\x074Z\n\x94\x01\n\x02\x04\
    \x1b\x12\x06\xb5\x07\0\xc1\x07\x01\x1a\x85\x01\x20Request\x20of\x20[Upda\
    teGcpUserAccessBinding]\n\x20[google.identity.accesscontextmanager.v1.Ac\
    cessContextManager.UpdateGcpUserAccessBinding].\n\n\x0b\n\x03\x04\x1b\
    \x01\x12\x04\xb5\x07\x08)\np\n\x04\x04\x1b\x02\0\x12\x04\xb8\x07\x02\\\
    \x1ab\x20Required.\x20[GcpUserAccessBinding]\n\x20[google.identity.acces\
    scontextmanager.v1.GcpUserAccessBinding]\n\n\r\n\x05\x04\x1b\x02\0\x06\
    \x12\x04\xb8\x07\x02\x16\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xb8\x07\x17\
    .\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xb8\x0712\n\r\n\x05\x04\x1b\x02\0\
    \x08\x12\x04\xb8\x073[\n\x10\n\x08\x04\x1b\x02\0\x08\x9c\x08\0\x12\x04\
    \xb8\x074Z\n\xd4\x01\n\x04\x04\x1b\x02\x01\x12\x04\xc0\x07\x02U\x1a\xc5\
    \x01\x20Required.\x20Only\x20the\x20fields\x20specified\x20in\x20this\
    \x20mask\x20are\x20updated.\x20Because\x20name\x20and\n\x20group_key\x20\
    cannot\x20be\x20changed,\x20update_mask\x20is\x20required\x20and\x20must\
    \x20always\x20be:\n\n\x20update_mask\x20{\n\x20paths:\x20\"access_levels\
    \"\n\x20}\n\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xc0\x07\x02\x1b\n\r\n\
    \x05\x04\x1b\x02\x01\x01\x12\x04\xc0\x07\x1c'\n\r\n\x05\x04\x1b\x02\x01\
    \x03\x12\x04\xc0\x07*+\n\r\n\x05\x04\x1b\x02\x01\x08\x12\x04\xc0\x07,T\n\
    \x10\n\x08\x04\x1b\x02\x01\x08\x9c\x08\0\x12\x04\xc0\x07-S\n\x94\x01\n\
    \x02\x04\x1c\x12\x06\xc5\x07\0\xcd\x07\x01\x1a\x85\x01\x20Request\x20of\
    \x20[DeleteGcpUserAccessBinding]\n\x20[google.identity.accesscontextmana\
    ger.v1.AccessContextManager.DeleteGcpUserAccessBinding].\n\n\x0b\n\x03\
    \x04\x1c\x01\x12\x04\xc5\x07\x08)\n[\n\x04\x04\x1c\x02\0\x12\x06\xc7\x07\
    \x02\xcc\x07\x04\x1aK\x20Required.\x20Example:\x20\"organizations/256/gc\
    pUserAccessBindings/b3-BhcX_Ud5N\"\n\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\
    \xc7\x07\x02\x08\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xc7\x07\t\r\n\r\n\
    \x05\x04\x1c\x02\0\x03\x12\x04\xc7\x07\x10\x11\n\x0f\n\x05\x04\x1c\x02\0\
    \x08\x12\x06\xc7\x07\x12\xcc\x07\x03\n\x10\n\x08\x04\x1c\x02\0\x08\x9c\
    \x08\0\x12\x04\xc8\x07\x04*\n\x11\n\x07\x04\x1c\x02\0\x08\x9f\x08\x12\
    \x06\xc9\x07\x04\xcb\x07\x05\n\xd9\x01\n\x02\x04\x1d\x12\x06\xd2\x07\0\
    \xd4\x07\x01\x1a\xca\x01\x20Currently,\x20a\x20completed\x20operation\
    \x20means\x20nothing.\x20In\x20the\x20future,\x20this\x20metadata\n\x20a\
    nd\x20a\x20completed\x20operation\x20may\x20indicate\x20that\x20the\x20b\
    inding\x20has\x20taken\x20effect\x20and\n\x20is\x20affecting\x20access\
    \x20decisions\x20for\x20all\x20users.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\
    \xd2\x07\x08-\nM\n\x02\x04\x1e\x12\x06\xd7\x07\0\xd9\x07\x01\x1a?\x20Met\
    adata\x20of\x20Access\x20Context\x20Manager's\x20Long\x20Running\x20Oper\
    ations.\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xd7\x07\x08-b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
