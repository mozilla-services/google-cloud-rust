// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/bigtable/v2/data.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Specifies the complete (requested) contents of a single row of a table.
///  Rows which exceed 256MiB in size cannot be read in full.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.Row)
pub struct Row {
    // message fields
    ///  The unique key which identifies this row within its table. This is the same
    ///  key that's used to identify the row in, for example, a MutateRowRequest.
    ///  May contain any non-empty byte string up to 4KiB in length.
    // @@protoc_insertion_point(field:google.bigtable.v2.Row.key)
    pub key: ::std::vec::Vec<u8>,
    ///  May be empty, but only if the entire row is empty.
    ///  The mutual ordering of column families is not specified.
    // @@protoc_insertion_point(field:google.bigtable.v2.Row.families)
    pub families: ::std::vec::Vec<Family>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.Row.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Row {
    fn default() -> &'a Row {
        <Row as ::protobuf::Message>::default_instance()
    }
}

impl Row {
    pub fn new() -> Row {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Row| { &m.key },
            |m: &mut Row| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "families",
            |m: &Row| { &m.families },
            |m: &mut Row| { &mut m.families },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Row>(
            "Row",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Row {
    const NAME: &'static str = "Row";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                18 => {
                    self.families.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        for value in &self.families {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        for v in &self.families {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Row {
        Row::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.families.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Row {
        static instance: Row = Row {
            key: ::std::vec::Vec::new(),
            families: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Row {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Row").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Row {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Specifies (some of) the contents of a single row/column family intersection
///  of a table.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.Family)
pub struct Family {
    // message fields
    ///  The unique key which identifies this family within its row. This is the
    ///  same key that's used to identify the family in, for example, a RowFilter
    ///  which sets its "family_name_regex_filter" field.
    ///  Must match `[-_.a-zA-Z0-9]+`, except that AggregatingRowProcessors may
    ///  produce cells in a sentinel family with an empty name.
    ///  Must be no greater than 64 characters in length.
    // @@protoc_insertion_point(field:google.bigtable.v2.Family.name)
    pub name: ::std::string::String,
    ///  Must not be empty. Sorted in order of increasing "qualifier".
    // @@protoc_insertion_point(field:google.bigtable.v2.Family.columns)
    pub columns: ::std::vec::Vec<Column>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.Family.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Family {
    fn default() -> &'a Family {
        <Family as ::protobuf::Message>::default_instance()
    }
}

impl Family {
    pub fn new() -> Family {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Family| { &m.name },
            |m: &mut Family| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "columns",
            |m: &Family| { &m.columns },
            |m: &mut Family| { &mut m.columns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Family>(
            "Family",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Family {
    const NAME: &'static str = "Family";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.columns.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.columns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.columns {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Family {
        Family::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.columns.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Family {
        static instance: Family = Family {
            name: ::std::string::String::new(),
            columns: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Family {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Family").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Family {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Family {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Specifies (some of) the contents of a single row/column intersection of a
///  table.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.Column)
pub struct Column {
    // message fields
    ///  The unique key which identifies this column within its family. This is the
    ///  same key that's used to identify the column in, for example, a RowFilter
    ///  which sets its `column_qualifier_regex_filter` field.
    ///  May contain any byte string, including the empty string, up to 16kiB in
    ///  length.
    // @@protoc_insertion_point(field:google.bigtable.v2.Column.qualifier)
    pub qualifier: ::std::vec::Vec<u8>,
    ///  Must not be empty. Sorted in order of decreasing "timestamp_micros".
    // @@protoc_insertion_point(field:google.bigtable.v2.Column.cells)
    pub cells: ::std::vec::Vec<Cell>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.Column.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Column {
    fn default() -> &'a Column {
        <Column as ::protobuf::Message>::default_instance()
    }
}

impl Column {
    pub fn new() -> Column {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "qualifier",
            |m: &Column| { &m.qualifier },
            |m: &mut Column| { &mut m.qualifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cells",
            |m: &Column| { &m.cells },
            |m: &mut Column| { &mut m.cells },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Column>(
            "Column",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Column {
    const NAME: &'static str = "Column";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.qualifier = is.read_bytes()?;
                },
                18 => {
                    self.cells.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.qualifier);
        }
        for value in &self.cells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.qualifier.is_empty() {
            os.write_bytes(1, &self.qualifier)?;
        }
        for v in &self.cells {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Column {
        Column::new()
    }

    fn clear(&mut self) {
        self.qualifier.clear();
        self.cells.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Column {
        static instance: Column = Column {
            qualifier: ::std::vec::Vec::new(),
            cells: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Column {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Column").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Column {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Column {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Specifies (some of) the contents of a single row/column/timestamp of a table.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.Cell)
pub struct Cell {
    // message fields
    ///  The cell's stored timestamp, which also uniquely identifies it within
    ///  its column.
    ///  Values are always expressed in microseconds, but individual tables may set
    ///  a coarser granularity to further restrict the allowed values. For
    ///  example, a table which specifies millisecond granularity will only allow
    ///  values of `timestamp_micros` which are multiples of 1000.
    // @@protoc_insertion_point(field:google.bigtable.v2.Cell.timestamp_micros)
    pub timestamp_micros: i64,
    ///  The value stored in the cell.
    ///  May contain any byte string, including the empty string, up to 100MiB in
    ///  length.
    // @@protoc_insertion_point(field:google.bigtable.v2.Cell.value)
    pub value: ::std::vec::Vec<u8>,
    ///  Labels applied to the cell by a [RowFilter][google.bigtable.v2.RowFilter].
    // @@protoc_insertion_point(field:google.bigtable.v2.Cell.labels)
    pub labels: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.Cell.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cell {
    fn default() -> &'a Cell {
        <Cell as ::protobuf::Message>::default_instance()
    }
}

impl Cell {
    pub fn new() -> Cell {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp_micros",
            |m: &Cell| { &m.timestamp_micros },
            |m: &mut Cell| { &mut m.timestamp_micros },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Cell| { &m.value },
            |m: &mut Cell| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &Cell| { &m.labels },
            |m: &mut Cell| { &mut m.labels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cell>(
            "Cell",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cell {
    const NAME: &'static str = "Cell";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp_micros = is.read_int64()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                26 => {
                    self.labels.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp_micros != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.timestamp_micros);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp_micros != 0 {
            os.write_int64(1, self.timestamp_micros)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        for v in &self.labels {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cell {
        Cell::new()
    }

    fn clear(&mut self) {
        self.timestamp_micros = 0;
        self.value.clear();
        self.labels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cell {
        static instance: Cell = Cell {
            timestamp_micros: 0,
            value: ::std::vec::Vec::new(),
            labels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Cell {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cell").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cell {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Specifies a contiguous range of rows.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.RowRange)
pub struct RowRange {
    // message oneof groups
    pub start_key: ::std::option::Option<row_range::Start_key>,
    pub end_key: ::std::option::Option<row_range::End_key>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.RowRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RowRange {
    fn default() -> &'a RowRange {
        <RowRange as ::protobuf::Message>::default_instance()
    }
}

impl RowRange {
    pub fn new() -> RowRange {
        ::std::default::Default::default()
    }

    // bytes start_key_closed = 1;

    pub fn start_key_closed(&self) -> &[u8] {
        match self.start_key {
            ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_start_key_closed(&mut self) {
        self.start_key = ::std::option::Option::None;
    }

    pub fn has_start_key_closed(&self) -> bool {
        match self.start_key {
            ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_key_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_key_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(_)) = self.start_key {
        } else {
            self.start_key = ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(::std::vec::Vec::new()));
        }
        match self.start_key {
            ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_key_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_key_closed() {
            match self.start_key.take() {
                ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_key_open = 2;

    pub fn start_key_open(&self) -> &[u8] {
        match self.start_key {
            ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_start_key_open(&mut self) {
        self.start_key = ::std::option::Option::None;
    }

    pub fn has_start_key_open(&self) -> bool {
        match self.start_key {
            ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_key_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_key_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(_)) = self.start_key {
        } else {
            self.start_key = ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(::std::vec::Vec::new()));
        }
        match self.start_key {
            ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_key_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_key_open() {
            match self.start_key.take() {
                ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_key_open = 3;

    pub fn end_key_open(&self) -> &[u8] {
        match self.end_key {
            ::std::option::Option::Some(row_range::End_key::EndKeyOpen(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_end_key_open(&mut self) {
        self.end_key = ::std::option::Option::None;
    }

    pub fn has_end_key_open(&self) -> bool {
        match self.end_key {
            ::std::option::Option::Some(row_range::End_key::EndKeyOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_key_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = ::std::option::Option::Some(row_range::End_key::EndKeyOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_key_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(row_range::End_key::EndKeyOpen(_)) = self.end_key {
        } else {
            self.end_key = ::std::option::Option::Some(row_range::End_key::EndKeyOpen(::std::vec::Vec::new()));
        }
        match self.end_key {
            ::std::option::Option::Some(row_range::End_key::EndKeyOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_key_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_key_open() {
            match self.end_key.take() {
                ::std::option::Option::Some(row_range::End_key::EndKeyOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_key_closed = 4;

    pub fn end_key_closed(&self) -> &[u8] {
        match self.end_key {
            ::std::option::Option::Some(row_range::End_key::EndKeyClosed(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_end_key_closed(&mut self) {
        self.end_key = ::std::option::Option::None;
    }

    pub fn has_end_key_closed(&self) -> bool {
        match self.end_key {
            ::std::option::Option::Some(row_range::End_key::EndKeyClosed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_key_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = ::std::option::Option::Some(row_range::End_key::EndKeyClosed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_key_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(row_range::End_key::EndKeyClosed(_)) = self.end_key {
        } else {
            self.end_key = ::std::option::Option::Some(row_range::End_key::EndKeyClosed(::std::vec::Vec::new()));
        }
        match self.end_key {
            ::std::option::Option::Some(row_range::End_key::EndKeyClosed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_key_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_key_closed() {
            match self.end_key.take() {
                ::std::option::Option::Some(row_range::End_key::EndKeyClosed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(2);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "start_key_closed",
            RowRange::has_start_key_closed,
            RowRange::start_key_closed,
            RowRange::set_start_key_closed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "start_key_open",
            RowRange::has_start_key_open,
            RowRange::start_key_open,
            RowRange::set_start_key_open,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "end_key_open",
            RowRange::has_end_key_open,
            RowRange::end_key_open,
            RowRange::set_end_key_open,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "end_key_closed",
            RowRange::has_end_key_closed,
            RowRange::end_key_closed,
            RowRange::set_end_key_closed,
        ));
        oneofs.push(row_range::Start_key::generated_oneof_descriptor_data());
        oneofs.push(row_range::End_key::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RowRange>(
            "RowRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RowRange {
    const NAME: &'static str = "RowRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.start_key = ::std::option::Option::Some(row_range::Start_key::StartKeyClosed(is.read_bytes()?));
                },
                18 => {
                    self.start_key = ::std::option::Option::Some(row_range::Start_key::StartKeyOpen(is.read_bytes()?));
                },
                26 => {
                    self.end_key = ::std::option::Option::Some(row_range::End_key::EndKeyOpen(is.read_bytes()?));
                },
                34 => {
                    self.end_key = ::std::option::Option::Some(row_range::End_key::EndKeyClosed(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.start_key {
            match v {
                &row_range::Start_key::StartKeyClosed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &row_range::Start_key::StartKeyOpen(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_key {
            match v {
                &row_range::End_key::EndKeyOpen(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &row_range::End_key::EndKeyClosed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.start_key {
            match v {
                &row_range::Start_key::StartKeyClosed(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &row_range::Start_key::StartKeyOpen(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_key {
            match v {
                &row_range::End_key::EndKeyOpen(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &row_range::End_key::EndKeyClosed(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RowRange {
        RowRange::new()
    }

    fn clear(&mut self) {
        self.start_key = ::std::option::Option::None;
        self.start_key = ::std::option::Option::None;
        self.end_key = ::std::option::Option::None;
        self.end_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RowRange {
        static instance: RowRange = RowRange {
            start_key: ::std::option::Option::None,
            end_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RowRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RowRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RowRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RowRange`
pub mod row_range {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.RowRange.start_key)
    pub enum Start_key {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowRange.start_key_closed)
        StartKeyClosed(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowRange.start_key_open)
        StartKeyOpen(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Start_key {
    }

    impl ::protobuf::OneofFull for Start_key {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RowRange as ::protobuf::MessageFull>::descriptor().oneof_by_name("start_key").unwrap()).clone()
        }
    }

    impl Start_key {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Start_key>("start_key")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.RowRange.end_key)
    pub enum End_key {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowRange.end_key_open)
        EndKeyOpen(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowRange.end_key_closed)
        EndKeyClosed(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for End_key {
    }

    impl ::protobuf::OneofFull for End_key {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RowRange as ::protobuf::MessageFull>::descriptor().oneof_by_name("end_key").unwrap()).clone()
        }
    }

    impl End_key {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<End_key>("end_key")
        }
    }
}

///  Specifies a non-contiguous set of rows.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.RowSet)
pub struct RowSet {
    // message fields
    ///  Single rows included in the set.
    // @@protoc_insertion_point(field:google.bigtable.v2.RowSet.row_keys)
    pub row_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
    ///  Contiguous row ranges included in the set.
    // @@protoc_insertion_point(field:google.bigtable.v2.RowSet.row_ranges)
    pub row_ranges: ::std::vec::Vec<RowRange>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.RowSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RowSet {
    fn default() -> &'a RowSet {
        <RowSet as ::protobuf::Message>::default_instance()
    }
}

impl RowSet {
    pub fn new() -> RowSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "row_keys",
            |m: &RowSet| { &m.row_keys },
            |m: &mut RowSet| { &mut m.row_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "row_ranges",
            |m: &RowSet| { &m.row_ranges },
            |m: &mut RowSet| { &mut m.row_ranges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RowSet>(
            "RowSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RowSet {
    const NAME: &'static str = "RowSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.row_keys.push(is.read_bytes()?);
                },
                18 => {
                    self.row_ranges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.row_keys {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in &self.row_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.row_keys {
            os.write_bytes(1, &v)?;
        };
        for v in &self.row_ranges {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RowSet {
        RowSet::new()
    }

    fn clear(&mut self) {
        self.row_keys.clear();
        self.row_ranges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RowSet {
        static instance: RowSet = RowSet {
            row_keys: ::std::vec::Vec::new(),
            row_ranges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RowSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RowSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RowSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Specifies a contiguous range of columns within a single column family.
///  The range spans from &lt;column_family&gt;:&lt;start_qualifier&gt; to
///  &lt;column_family&gt;:&lt;end_qualifier&gt;, where both bounds can be either
///  inclusive or exclusive.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.ColumnRange)
pub struct ColumnRange {
    // message fields
    ///  The name of the column family within which this range falls.
    // @@protoc_insertion_point(field:google.bigtable.v2.ColumnRange.family_name)
    pub family_name: ::std::string::String,
    // message oneof groups
    pub start_qualifier: ::std::option::Option<column_range::Start_qualifier>,
    pub end_qualifier: ::std::option::Option<column_range::End_qualifier>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.ColumnRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColumnRange {
    fn default() -> &'a ColumnRange {
        <ColumnRange as ::protobuf::Message>::default_instance()
    }
}

impl ColumnRange {
    pub fn new() -> ColumnRange {
        ::std::default::Default::default()
    }

    // bytes start_qualifier_closed = 2;

    pub fn start_qualifier_closed(&self) -> &[u8] {
        match self.start_qualifier {
            ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_start_qualifier_closed(&mut self) {
        self.start_qualifier = ::std::option::Option::None;
    }

    pub fn has_start_qualifier_closed(&self) -> bool {
        match self.start_qualifier {
            ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_qualifier_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_qualifier = ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_qualifier_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(_)) = self.start_qualifier {
        } else {
            self.start_qualifier = ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(::std::vec::Vec::new()));
        }
        match self.start_qualifier {
            ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_qualifier_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_qualifier_closed() {
            match self.start_qualifier.take() {
                ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_qualifier_open = 3;

    pub fn start_qualifier_open(&self) -> &[u8] {
        match self.start_qualifier {
            ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_start_qualifier_open(&mut self) {
        self.start_qualifier = ::std::option::Option::None;
    }

    pub fn has_start_qualifier_open(&self) -> bool {
        match self.start_qualifier {
            ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_qualifier_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_qualifier = ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_qualifier_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(_)) = self.start_qualifier {
        } else {
            self.start_qualifier = ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(::std::vec::Vec::new()));
        }
        match self.start_qualifier {
            ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_qualifier_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_qualifier_open() {
            match self.start_qualifier.take() {
                ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_qualifier_closed = 4;

    pub fn end_qualifier_closed(&self) -> &[u8] {
        match self.end_qualifier {
            ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_end_qualifier_closed(&mut self) {
        self.end_qualifier = ::std::option::Option::None;
    }

    pub fn has_end_qualifier_closed(&self) -> bool {
        match self.end_qualifier {
            ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_qualifier_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_qualifier = ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_qualifier_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(_)) = self.end_qualifier {
        } else {
            self.end_qualifier = ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(::std::vec::Vec::new()));
        }
        match self.end_qualifier {
            ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_qualifier_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_qualifier_closed() {
            match self.end_qualifier.take() {
                ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_qualifier_open = 5;

    pub fn end_qualifier_open(&self) -> &[u8] {
        match self.end_qualifier {
            ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_end_qualifier_open(&mut self) {
        self.end_qualifier = ::std::option::Option::None;
    }

    pub fn has_end_qualifier_open(&self) -> bool {
        match self.end_qualifier {
            ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_qualifier_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_qualifier = ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_qualifier_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(_)) = self.end_qualifier {
        } else {
            self.end_qualifier = ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(::std::vec::Vec::new()));
        }
        match self.end_qualifier {
            ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_qualifier_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_qualifier_open() {
            match self.end_qualifier.take() {
                ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(2);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "family_name",
            |m: &ColumnRange| { &m.family_name },
            |m: &mut ColumnRange| { &mut m.family_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "start_qualifier_closed",
            ColumnRange::has_start_qualifier_closed,
            ColumnRange::start_qualifier_closed,
            ColumnRange::set_start_qualifier_closed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "start_qualifier_open",
            ColumnRange::has_start_qualifier_open,
            ColumnRange::start_qualifier_open,
            ColumnRange::set_start_qualifier_open,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "end_qualifier_closed",
            ColumnRange::has_end_qualifier_closed,
            ColumnRange::end_qualifier_closed,
            ColumnRange::set_end_qualifier_closed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "end_qualifier_open",
            ColumnRange::has_end_qualifier_open,
            ColumnRange::end_qualifier_open,
            ColumnRange::set_end_qualifier_open,
        ));
        oneofs.push(column_range::Start_qualifier::generated_oneof_descriptor_data());
        oneofs.push(column_range::End_qualifier::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColumnRange>(
            "ColumnRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColumnRange {
    const NAME: &'static str = "ColumnRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.family_name = is.read_string()?;
                },
                18 => {
                    self.start_qualifier = ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierClosed(is.read_bytes()?));
                },
                26 => {
                    self.start_qualifier = ::std::option::Option::Some(column_range::Start_qualifier::StartQualifierOpen(is.read_bytes()?));
                },
                34 => {
                    self.end_qualifier = ::std::option::Option::Some(column_range::End_qualifier::EndQualifierClosed(is.read_bytes()?));
                },
                42 => {
                    self.end_qualifier = ::std::option::Option::Some(column_range::End_qualifier::EndQualifierOpen(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if let ::std::option::Option::Some(ref v) = self.start_qualifier {
            match v {
                &column_range::Start_qualifier::StartQualifierClosed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &column_range::Start_qualifier::StartQualifierOpen(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_qualifier {
            match v {
                &column_range::End_qualifier::EndQualifierClosed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &column_range::End_qualifier::EndQualifierOpen(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.start_qualifier {
            match v {
                &column_range::Start_qualifier::StartQualifierClosed(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &column_range::Start_qualifier::StartQualifierOpen(ref v) => {
                    os.write_bytes(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_qualifier {
            match v {
                &column_range::End_qualifier::EndQualifierClosed(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &column_range::End_qualifier::EndQualifierOpen(ref v) => {
                    os.write_bytes(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColumnRange {
        ColumnRange::new()
    }

    fn clear(&mut self) {
        self.family_name.clear();
        self.start_qualifier = ::std::option::Option::None;
        self.start_qualifier = ::std::option::Option::None;
        self.end_qualifier = ::std::option::Option::None;
        self.end_qualifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColumnRange {
        static instance: ColumnRange = ColumnRange {
            family_name: ::std::string::String::new(),
            start_qualifier: ::std::option::Option::None,
            end_qualifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColumnRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColumnRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColumnRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ColumnRange`
pub mod column_range {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.ColumnRange.start_qualifier)
    pub enum Start_qualifier {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ColumnRange.start_qualifier_closed)
        StartQualifierClosed(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ColumnRange.start_qualifier_open)
        StartQualifierOpen(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Start_qualifier {
    }

    impl ::protobuf::OneofFull for Start_qualifier {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ColumnRange as ::protobuf::MessageFull>::descriptor().oneof_by_name("start_qualifier").unwrap()).clone()
        }
    }

    impl Start_qualifier {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Start_qualifier>("start_qualifier")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.ColumnRange.end_qualifier)
    pub enum End_qualifier {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ColumnRange.end_qualifier_closed)
        EndQualifierClosed(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ColumnRange.end_qualifier_open)
        EndQualifierOpen(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for End_qualifier {
    }

    impl ::protobuf::OneofFull for End_qualifier {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ColumnRange as ::protobuf::MessageFull>::descriptor().oneof_by_name("end_qualifier").unwrap()).clone()
        }
    }

    impl End_qualifier {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<End_qualifier>("end_qualifier")
        }
    }
}

///  Specified a contiguous range of microsecond timestamps.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.TimestampRange)
pub struct TimestampRange {
    // message fields
    ///  Inclusive lower bound. If left empty, interpreted as 0.
    // @@protoc_insertion_point(field:google.bigtable.v2.TimestampRange.start_timestamp_micros)
    pub start_timestamp_micros: i64,
    ///  Exclusive upper bound. If left empty, interpreted as infinity.
    // @@protoc_insertion_point(field:google.bigtable.v2.TimestampRange.end_timestamp_micros)
    pub end_timestamp_micros: i64,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.TimestampRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimestampRange {
    fn default() -> &'a TimestampRange {
        <TimestampRange as ::protobuf::Message>::default_instance()
    }
}

impl TimestampRange {
    pub fn new() -> TimestampRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_timestamp_micros",
            |m: &TimestampRange| { &m.start_timestamp_micros },
            |m: &mut TimestampRange| { &mut m.start_timestamp_micros },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_timestamp_micros",
            |m: &TimestampRange| { &m.end_timestamp_micros },
            |m: &mut TimestampRange| { &mut m.end_timestamp_micros },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimestampRange>(
            "TimestampRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimestampRange {
    const NAME: &'static str = "TimestampRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_timestamp_micros = is.read_int64()?;
                },
                16 => {
                    self.end_timestamp_micros = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.start_timestamp_micros != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.start_timestamp_micros);
        }
        if self.end_timestamp_micros != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.end_timestamp_micros);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.start_timestamp_micros != 0 {
            os.write_int64(1, self.start_timestamp_micros)?;
        }
        if self.end_timestamp_micros != 0 {
            os.write_int64(2, self.end_timestamp_micros)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimestampRange {
        TimestampRange::new()
    }

    fn clear(&mut self) {
        self.start_timestamp_micros = 0;
        self.end_timestamp_micros = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimestampRange {
        static instance: TimestampRange = TimestampRange {
            start_timestamp_micros: 0,
            end_timestamp_micros: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimestampRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimestampRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimestampRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Specifies a contiguous range of raw byte values.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.ValueRange)
pub struct ValueRange {
    // message oneof groups
    pub start_value: ::std::option::Option<value_range::Start_value>,
    pub end_value: ::std::option::Option<value_range::End_value>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.ValueRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValueRange {
    fn default() -> &'a ValueRange {
        <ValueRange as ::protobuf::Message>::default_instance()
    }
}

impl ValueRange {
    pub fn new() -> ValueRange {
        ::std::default::Default::default()
    }

    // bytes start_value_closed = 1;

    pub fn start_value_closed(&self) -> &[u8] {
        match self.start_value {
            ::std::option::Option::Some(value_range::Start_value::StartValueClosed(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_start_value_closed(&mut self) {
        self.start_value = ::std::option::Option::None;
    }

    pub fn has_start_value_closed(&self) -> bool {
        match self.start_value {
            ::std::option::Option::Some(value_range::Start_value::StartValueClosed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_value_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_value = ::std::option::Option::Some(value_range::Start_value::StartValueClosed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_value_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(value_range::Start_value::StartValueClosed(_)) = self.start_value {
        } else {
            self.start_value = ::std::option::Option::Some(value_range::Start_value::StartValueClosed(::std::vec::Vec::new()));
        }
        match self.start_value {
            ::std::option::Option::Some(value_range::Start_value::StartValueClosed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_value_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_value_closed() {
            match self.start_value.take() {
                ::std::option::Option::Some(value_range::Start_value::StartValueClosed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_value_open = 2;

    pub fn start_value_open(&self) -> &[u8] {
        match self.start_value {
            ::std::option::Option::Some(value_range::Start_value::StartValueOpen(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_start_value_open(&mut self) {
        self.start_value = ::std::option::Option::None;
    }

    pub fn has_start_value_open(&self) -> bool {
        match self.start_value {
            ::std::option::Option::Some(value_range::Start_value::StartValueOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_value_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_value = ::std::option::Option::Some(value_range::Start_value::StartValueOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_value_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(value_range::Start_value::StartValueOpen(_)) = self.start_value {
        } else {
            self.start_value = ::std::option::Option::Some(value_range::Start_value::StartValueOpen(::std::vec::Vec::new()));
        }
        match self.start_value {
            ::std::option::Option::Some(value_range::Start_value::StartValueOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_value_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_value_open() {
            match self.start_value.take() {
                ::std::option::Option::Some(value_range::Start_value::StartValueOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_value_closed = 3;

    pub fn end_value_closed(&self) -> &[u8] {
        match self.end_value {
            ::std::option::Option::Some(value_range::End_value::EndValueClosed(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_end_value_closed(&mut self) {
        self.end_value = ::std::option::Option::None;
    }

    pub fn has_end_value_closed(&self) -> bool {
        match self.end_value {
            ::std::option::Option::Some(value_range::End_value::EndValueClosed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_value_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_value = ::std::option::Option::Some(value_range::End_value::EndValueClosed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_value_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(value_range::End_value::EndValueClosed(_)) = self.end_value {
        } else {
            self.end_value = ::std::option::Option::Some(value_range::End_value::EndValueClosed(::std::vec::Vec::new()));
        }
        match self.end_value {
            ::std::option::Option::Some(value_range::End_value::EndValueClosed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_value_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_value_closed() {
            match self.end_value.take() {
                ::std::option::Option::Some(value_range::End_value::EndValueClosed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_value_open = 4;

    pub fn end_value_open(&self) -> &[u8] {
        match self.end_value {
            ::std::option::Option::Some(value_range::End_value::EndValueOpen(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_end_value_open(&mut self) {
        self.end_value = ::std::option::Option::None;
    }

    pub fn has_end_value_open(&self) -> bool {
        match self.end_value {
            ::std::option::Option::Some(value_range::End_value::EndValueOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_value_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_value = ::std::option::Option::Some(value_range::End_value::EndValueOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_value_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(value_range::End_value::EndValueOpen(_)) = self.end_value {
        } else {
            self.end_value = ::std::option::Option::Some(value_range::End_value::EndValueOpen(::std::vec::Vec::new()));
        }
        match self.end_value {
            ::std::option::Option::Some(value_range::End_value::EndValueOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_value_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_value_open() {
            match self.end_value.take() {
                ::std::option::Option::Some(value_range::End_value::EndValueOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(2);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "start_value_closed",
            ValueRange::has_start_value_closed,
            ValueRange::start_value_closed,
            ValueRange::set_start_value_closed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "start_value_open",
            ValueRange::has_start_value_open,
            ValueRange::start_value_open,
            ValueRange::set_start_value_open,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "end_value_closed",
            ValueRange::has_end_value_closed,
            ValueRange::end_value_closed,
            ValueRange::set_end_value_closed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "end_value_open",
            ValueRange::has_end_value_open,
            ValueRange::end_value_open,
            ValueRange::set_end_value_open,
        ));
        oneofs.push(value_range::Start_value::generated_oneof_descriptor_data());
        oneofs.push(value_range::End_value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueRange>(
            "ValueRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValueRange {
    const NAME: &'static str = "ValueRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.start_value = ::std::option::Option::Some(value_range::Start_value::StartValueClosed(is.read_bytes()?));
                },
                18 => {
                    self.start_value = ::std::option::Option::Some(value_range::Start_value::StartValueOpen(is.read_bytes()?));
                },
                26 => {
                    self.end_value = ::std::option::Option::Some(value_range::End_value::EndValueClosed(is.read_bytes()?));
                },
                34 => {
                    self.end_value = ::std::option::Option::Some(value_range::End_value::EndValueOpen(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.start_value {
            match v {
                &value_range::Start_value::StartValueClosed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &value_range::Start_value::StartValueOpen(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_value {
            match v {
                &value_range::End_value::EndValueClosed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &value_range::End_value::EndValueOpen(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.start_value {
            match v {
                &value_range::Start_value::StartValueClosed(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &value_range::Start_value::StartValueOpen(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_value {
            match v {
                &value_range::End_value::EndValueClosed(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &value_range::End_value::EndValueOpen(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValueRange {
        ValueRange::new()
    }

    fn clear(&mut self) {
        self.start_value = ::std::option::Option::None;
        self.start_value = ::std::option::Option::None;
        self.end_value = ::std::option::Option::None;
        self.end_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValueRange {
        static instance: ValueRange = ValueRange {
            start_value: ::std::option::Option::None,
            end_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValueRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValueRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValueRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ValueRange`
pub mod value_range {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.ValueRange.start_value)
    pub enum Start_value {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ValueRange.start_value_closed)
        StartValueClosed(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ValueRange.start_value_open)
        StartValueOpen(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Start_value {
    }

    impl ::protobuf::OneofFull for Start_value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ValueRange as ::protobuf::MessageFull>::descriptor().oneof_by_name("start_value").unwrap()).clone()
        }
    }

    impl Start_value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Start_value>("start_value")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.ValueRange.end_value)
    pub enum End_value {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ValueRange.end_value_closed)
        EndValueClosed(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ValueRange.end_value_open)
        EndValueOpen(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for End_value {
    }

    impl ::protobuf::OneofFull for End_value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ValueRange as ::protobuf::MessageFull>::descriptor().oneof_by_name("end_value").unwrap()).clone()
        }
    }

    impl End_value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<End_value>("end_value")
        }
    }
}

///  Takes a row as input and produces an alternate view of the row based on
///  specified rules. For example, a RowFilter might trim down a row to include
///  just the cells from columns matching a given regular expression, or might
///  return all the cells of a row but not their values. More complicated filters
///  can be composed out of these components to express requests such as, "within
///  every column of a particular family, give just the two most recent cells
///  which are older than timestamp X."
///
///  There are two broad categories of RowFilters (true filters and transformers),
///  as well as two ways to compose simple filters into more complex ones
///  (chains and interleaves). They work as follows:
///
///  * True filters alter the input row by excluding some of its cells wholesale
///  from the output row. An example of a true filter is the `value_regex_filter`,
///  which excludes cells whose values don't match the specified pattern. All
///  regex true filters use RE2 syntax (https://github.com/google/re2/wiki/Syntax)
///  in raw byte mode (RE2::Latin1), and are evaluated as full matches. An
///  important point to keep in mind is that `RE2(.)` is equivalent by default to
///  `RE2([^\n])`, meaning that it does not match newlines. When attempting to
///  match an arbitrary byte, you should therefore use the escape sequence `\C`,
///  which may need to be further escaped as `\\C` in your client language.
///
///  * Transformers alter the input row by changing the values of some of its
///  cells in the output, without excluding them completely. Currently, the only
///  supported transformer is the `strip_value_transformer`, which replaces every
///  cell's value with the empty string.
///
///  * Chains and interleaves are described in more detail in the
///  RowFilter.Chain and RowFilter.Interleave documentation.
///
///  The total serialized size of a RowFilter message must not
///  exceed 4096 bytes, and RowFilters may not be nested within each other
///  (in Chains or Interleaves) to a depth of more than 20.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.RowFilter)
pub struct RowFilter {
    // message oneof groups
    pub filter: ::std::option::Option<row_filter::Filter>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.RowFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RowFilter {
    fn default() -> &'a RowFilter {
        <RowFilter as ::protobuf::Message>::default_instance()
    }
}

impl RowFilter {
    pub fn new() -> RowFilter {
        ::std::default::Default::default()
    }

    // .google.bigtable.v2.RowFilter.Chain chain = 1;

    pub fn chain(&self) -> &row_filter::Chain {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Chain(ref v)) => v,
            _ => <row_filter::Chain as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_chain(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_chain(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Chain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chain(&mut self, v: row_filter::Chain) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::Chain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chain(&mut self) -> &mut row_filter::Chain {
        if let ::std::option::Option::Some(row_filter::Filter::Chain(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::Chain(row_filter::Chain::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Chain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chain(&mut self) -> row_filter::Chain {
        if self.has_chain() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::Chain(v)) => v,
                _ => panic!(),
            }
        } else {
            row_filter::Chain::new()
        }
    }

    // .google.bigtable.v2.RowFilter.Interleave interleave = 2;

    pub fn interleave(&self) -> &row_filter::Interleave {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Interleave(ref v)) => v,
            _ => <row_filter::Interleave as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_interleave(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_interleave(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Interleave(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_interleave(&mut self, v: row_filter::Interleave) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::Interleave(v))
    }

    // Mutable pointer to the field.
    pub fn mut_interleave(&mut self) -> &mut row_filter::Interleave {
        if let ::std::option::Option::Some(row_filter::Filter::Interleave(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::Interleave(row_filter::Interleave::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Interleave(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_interleave(&mut self) -> row_filter::Interleave {
        if self.has_interleave() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::Interleave(v)) => v,
                _ => panic!(),
            }
        } else {
            row_filter::Interleave::new()
        }
    }

    // .google.bigtable.v2.RowFilter.Condition condition = 3;

    pub fn condition(&self) -> &row_filter::Condition {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Condition(ref v)) => v,
            _ => <row_filter::Condition as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_condition(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_condition(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Condition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: row_filter::Condition) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::Condition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_condition(&mut self) -> &mut row_filter::Condition {
        if let ::std::option::Option::Some(row_filter::Filter::Condition(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::Condition(row_filter::Condition::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Condition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_condition(&mut self) -> row_filter::Condition {
        if self.has_condition() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::Condition(v)) => v,
                _ => panic!(),
            }
        } else {
            row_filter::Condition::new()
        }
    }

    // bool sink = 16;

    pub fn sink(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Sink(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sink(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_sink(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::Sink(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::Sink(v))
    }

    // bool pass_all_filter = 17;

    pub fn pass_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::PassAllFilter(v)) => v,
            _ => false,
        }
    }

    pub fn clear_pass_all_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_pass_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::PassAllFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pass_all_filter(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::PassAllFilter(v))
    }

    // bool block_all_filter = 18;

    pub fn block_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::BlockAllFilter(v)) => v,
            _ => false,
        }
    }

    pub fn clear_block_all_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_block_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::BlockAllFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_all_filter(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::BlockAllFilter(v))
    }

    // bytes row_key_regex_filter = 4;

    pub fn row_key_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_row_key_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_row_key_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row_key_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_row_key_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_row_key_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_row_key_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // double row_sample_filter = 14;

    pub fn row_sample_filter(&self) -> f64 {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::RowSampleFilter(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_row_sample_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_row_sample_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::RowSampleFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row_sample_filter(&mut self, v: f64) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::RowSampleFilter(v))
    }

    // string family_name_regex_filter = 5;

    pub fn family_name_regex_filter(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_family_name_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_family_name_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_family_name_regex_filter(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_family_name_regex_filter(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_family_name_regex_filter(&mut self) -> ::std::string::String {
        if self.has_family_name_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes column_qualifier_regex_filter = 6;

    pub fn column_qualifier_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_column_qualifier_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_column_qualifier_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_column_qualifier_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_column_qualifier_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_column_qualifier_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.bigtable.v2.ColumnRange column_range_filter = 7;

    pub fn column_range_filter(&self) -> &ColumnRange {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(ref v)) => v,
            _ => <ColumnRange as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_column_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_column_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_column_range_filter(&mut self, v: ColumnRange) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_column_range_filter(&mut self) -> &mut ColumnRange {
        if let ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(ColumnRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_column_range_filter(&mut self) -> ColumnRange {
        if self.has_column_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            ColumnRange::new()
        }
    }

    // .google.bigtable.v2.TimestampRange timestamp_range_filter = 8;

    pub fn timestamp_range_filter(&self) -> &TimestampRange {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(ref v)) => v,
            _ => <TimestampRange as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_timestamp_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_timestamp_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timestamp_range_filter(&mut self, v: TimestampRange) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp_range_filter(&mut self) -> &mut TimestampRange {
        if let ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(TimestampRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timestamp_range_filter(&mut self) -> TimestampRange {
        if self.has_timestamp_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            TimestampRange::new()
        }
    }

    // bytes value_regex_filter = 9;

    pub fn value_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_value_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_value_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_value_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.bigtable.v2.ValueRange value_range_filter = 15;

    pub fn value_range_filter(&self) -> &ValueRange {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(ref v)) => v,
            _ => <ValueRange as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_value_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_value_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_range_filter(&mut self, v: ValueRange) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_range_filter(&mut self) -> &mut ValueRange {
        if let ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(ValueRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_range_filter(&mut self) -> ValueRange {
        if self.has_value_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            ValueRange::new()
        }
    }

    // int32 cells_per_row_offset_filter = 10;

    pub fn cells_per_row_offset_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::CellsPerRowOffsetFilter(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_cells_per_row_offset_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_row_offset_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::CellsPerRowOffsetFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_row_offset_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::CellsPerRowOffsetFilter(v))
    }

    // int32 cells_per_row_limit_filter = 11;

    pub fn cells_per_row_limit_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::CellsPerRowLimitFilter(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_cells_per_row_limit_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_row_limit_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::CellsPerRowLimitFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_row_limit_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::CellsPerRowLimitFilter(v))
    }

    // int32 cells_per_column_limit_filter = 12;

    pub fn cells_per_column_limit_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::CellsPerColumnLimitFilter(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_cells_per_column_limit_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_column_limit_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::CellsPerColumnLimitFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_column_limit_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::CellsPerColumnLimitFilter(v))
    }

    // bool strip_value_transformer = 13;

    pub fn strip_value_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::StripValueTransformer(v)) => v,
            _ => false,
        }
    }

    pub fn clear_strip_value_transformer(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_strip_value_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::StripValueTransformer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_strip_value_transformer(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::StripValueTransformer(v))
    }

    // string apply_label_transformer = 19;

    pub fn apply_label_transformer(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_apply_label_transformer(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_apply_label_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_label_transformer(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_label_transformer(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_label_transformer(&mut self) -> ::std::string::String {
        if self.has_apply_label_transformer() {
            match self.filter.take() {
                ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, row_filter::Chain>(
            "chain",
            RowFilter::has_chain,
            RowFilter::chain,
            RowFilter::mut_chain,
            RowFilter::set_chain,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, row_filter::Interleave>(
            "interleave",
            RowFilter::has_interleave,
            RowFilter::interleave,
            RowFilter::mut_interleave,
            RowFilter::set_interleave,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, row_filter::Condition>(
            "condition",
            RowFilter::has_condition,
            RowFilter::condition,
            RowFilter::mut_condition,
            RowFilter::set_condition,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sink",
            RowFilter::has_sink,
            RowFilter::sink,
            RowFilter::set_sink,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "pass_all_filter",
            RowFilter::has_pass_all_filter,
            RowFilter::pass_all_filter,
            RowFilter::set_pass_all_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "block_all_filter",
            RowFilter::has_block_all_filter,
            RowFilter::block_all_filter,
            RowFilter::set_block_all_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "row_key_regex_filter",
            RowFilter::has_row_key_regex_filter,
            RowFilter::row_key_regex_filter,
            RowFilter::set_row_key_regex_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "row_sample_filter",
            RowFilter::has_row_sample_filter,
            RowFilter::row_sample_filter,
            RowFilter::set_row_sample_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "family_name_regex_filter",
            RowFilter::has_family_name_regex_filter,
            RowFilter::family_name_regex_filter,
            RowFilter::set_family_name_regex_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "column_qualifier_regex_filter",
            RowFilter::has_column_qualifier_regex_filter,
            RowFilter::column_qualifier_regex_filter,
            RowFilter::set_column_qualifier_regex_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ColumnRange>(
            "column_range_filter",
            RowFilter::has_column_range_filter,
            RowFilter::column_range_filter,
            RowFilter::mut_column_range_filter,
            RowFilter::set_column_range_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TimestampRange>(
            "timestamp_range_filter",
            RowFilter::has_timestamp_range_filter,
            RowFilter::timestamp_range_filter,
            RowFilter::mut_timestamp_range_filter,
            RowFilter::set_timestamp_range_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "value_regex_filter",
            RowFilter::has_value_regex_filter,
            RowFilter::value_regex_filter,
            RowFilter::set_value_regex_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValueRange>(
            "value_range_filter",
            RowFilter::has_value_range_filter,
            RowFilter::value_range_filter,
            RowFilter::mut_value_range_filter,
            RowFilter::set_value_range_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cells_per_row_offset_filter",
            RowFilter::has_cells_per_row_offset_filter,
            RowFilter::cells_per_row_offset_filter,
            RowFilter::set_cells_per_row_offset_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cells_per_row_limit_filter",
            RowFilter::has_cells_per_row_limit_filter,
            RowFilter::cells_per_row_limit_filter,
            RowFilter::set_cells_per_row_limit_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cells_per_column_limit_filter",
            RowFilter::has_cells_per_column_limit_filter,
            RowFilter::cells_per_column_limit_filter,
            RowFilter::set_cells_per_column_limit_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "strip_value_transformer",
            RowFilter::has_strip_value_transformer,
            RowFilter::strip_value_transformer,
            RowFilter::set_strip_value_transformer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "apply_label_transformer",
            RowFilter::has_apply_label_transformer,
            RowFilter::apply_label_transformer,
            RowFilter::set_apply_label_transformer,
        ));
        oneofs.push(row_filter::Filter::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RowFilter>(
            "RowFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RowFilter {
    const NAME: &'static str = "RowFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::Chain(is.read_message()?));
                },
                18 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::Interleave(is.read_message()?));
                },
                26 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::Condition(is.read_message()?));
                },
                128 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::Sink(is.read_bool()?));
                },
                136 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::PassAllFilter(is.read_bool()?));
                },
                144 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::BlockAllFilter(is.read_bool()?));
                },
                34 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::RowKeyRegexFilter(is.read_bytes()?));
                },
                113 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::RowSampleFilter(is.read_double()?));
                },
                42 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::FamilyNameRegexFilter(is.read_string()?));
                },
                50 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::ColumnQualifierRegexFilter(is.read_bytes()?));
                },
                58 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::ColumnRangeFilter(is.read_message()?));
                },
                66 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::TimestampRangeFilter(is.read_message()?));
                },
                74 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::ValueRegexFilter(is.read_bytes()?));
                },
                122 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::ValueRangeFilter(is.read_message()?));
                },
                80 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::CellsPerRowOffsetFilter(is.read_int32()?));
                },
                88 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::CellsPerRowLimitFilter(is.read_int32()?));
                },
                96 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::CellsPerColumnLimitFilter(is.read_int32()?));
                },
                104 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::StripValueTransformer(is.read_bool()?));
                },
                154 => {
                    self.filter = ::std::option::Option::Some(row_filter::Filter::ApplyLabelTransformer(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &row_filter::Filter::Chain(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &row_filter::Filter::Interleave(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &row_filter::Filter::Condition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &row_filter::Filter::Sink(v) => {
                    my_size += 2 + 1;
                },
                &row_filter::Filter::PassAllFilter(v) => {
                    my_size += 2 + 1;
                },
                &row_filter::Filter::BlockAllFilter(v) => {
                    my_size += 2 + 1;
                },
                &row_filter::Filter::RowKeyRegexFilter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &row_filter::Filter::RowSampleFilter(v) => {
                    my_size += 1 + 8;
                },
                &row_filter::Filter::FamilyNameRegexFilter(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &row_filter::Filter::ColumnQualifierRegexFilter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(6, &v);
                },
                &row_filter::Filter::ColumnRangeFilter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &row_filter::Filter::TimestampRangeFilter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &row_filter::Filter::ValueRegexFilter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(9, &v);
                },
                &row_filter::Filter::ValueRangeFilter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &row_filter::Filter::CellsPerRowOffsetFilter(v) => {
                    my_size += ::protobuf::rt::int32_size(10, v);
                },
                &row_filter::Filter::CellsPerRowLimitFilter(v) => {
                    my_size += ::protobuf::rt::int32_size(11, v);
                },
                &row_filter::Filter::CellsPerColumnLimitFilter(v) => {
                    my_size += ::protobuf::rt::int32_size(12, v);
                },
                &row_filter::Filter::StripValueTransformer(v) => {
                    my_size += 1 + 1;
                },
                &row_filter::Filter::ApplyLabelTransformer(ref v) => {
                    my_size += ::protobuf::rt::string_size(19, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &row_filter::Filter::Chain(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &row_filter::Filter::Interleave(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &row_filter::Filter::Condition(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &row_filter::Filter::Sink(v) => {
                    os.write_bool(16, v)?;
                },
                &row_filter::Filter::PassAllFilter(v) => {
                    os.write_bool(17, v)?;
                },
                &row_filter::Filter::BlockAllFilter(v) => {
                    os.write_bool(18, v)?;
                },
                &row_filter::Filter::RowKeyRegexFilter(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &row_filter::Filter::RowSampleFilter(v) => {
                    os.write_double(14, v)?;
                },
                &row_filter::Filter::FamilyNameRegexFilter(ref v) => {
                    os.write_string(5, v)?;
                },
                &row_filter::Filter::ColumnQualifierRegexFilter(ref v) => {
                    os.write_bytes(6, v)?;
                },
                &row_filter::Filter::ColumnRangeFilter(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &row_filter::Filter::TimestampRangeFilter(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &row_filter::Filter::ValueRegexFilter(ref v) => {
                    os.write_bytes(9, v)?;
                },
                &row_filter::Filter::ValueRangeFilter(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &row_filter::Filter::CellsPerRowOffsetFilter(v) => {
                    os.write_int32(10, v)?;
                },
                &row_filter::Filter::CellsPerRowLimitFilter(v) => {
                    os.write_int32(11, v)?;
                },
                &row_filter::Filter::CellsPerColumnLimitFilter(v) => {
                    os.write_int32(12, v)?;
                },
                &row_filter::Filter::StripValueTransformer(v) => {
                    os.write_bool(13, v)?;
                },
                &row_filter::Filter::ApplyLabelTransformer(ref v) => {
                    os.write_string(19, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RowFilter {
        RowFilter::new()
    }

    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RowFilter {
        static instance: RowFilter = RowFilter {
            filter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RowFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RowFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RowFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RowFilter`
pub mod row_filter {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.RowFilter.filter)
    pub enum Filter {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.chain)
        Chain(Chain),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.interleave)
        Interleave(Interleave),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.condition)
        Condition(Condition),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.sink)
        Sink(bool),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.pass_all_filter)
        PassAllFilter(bool),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.block_all_filter)
        BlockAllFilter(bool),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.row_key_regex_filter)
        RowKeyRegexFilter(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.row_sample_filter)
        RowSampleFilter(f64),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.family_name_regex_filter)
        FamilyNameRegexFilter(::std::string::String),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.column_qualifier_regex_filter)
        ColumnQualifierRegexFilter(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.column_range_filter)
        ColumnRangeFilter(super::ColumnRange),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.timestamp_range_filter)
        TimestampRangeFilter(super::TimestampRange),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.value_regex_filter)
        ValueRegexFilter(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.value_range_filter)
        ValueRangeFilter(super::ValueRange),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.cells_per_row_offset_filter)
        CellsPerRowOffsetFilter(i32),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.cells_per_row_limit_filter)
        CellsPerRowLimitFilter(i32),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.cells_per_column_limit_filter)
        CellsPerColumnLimitFilter(i32),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.strip_value_transformer)
        StripValueTransformer(bool),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.RowFilter.apply_label_transformer)
        ApplyLabelTransformer(::std::string::String),
    }

    impl ::protobuf::Oneof for Filter {
    }

    impl ::protobuf::OneofFull for Filter {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RowFilter as ::protobuf::MessageFull>::descriptor().oneof_by_name("filter").unwrap()).clone()
        }
    }

    impl Filter {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Filter>("filter")
        }
    }
    ///  A RowFilter which sends rows through several RowFilters in sequence.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.bigtable.v2.RowFilter.Chain)
    pub struct Chain {
        // message fields
        ///  The elements of "filters" are chained together to process the input row:
        ///  in row -> f(0) -> intermediate row -> f(1) -> ... -> f(N) -> out row
        ///  The full chain is executed atomically.
        // @@protoc_insertion_point(field:google.bigtable.v2.RowFilter.Chain.filters)
        pub filters: ::std::vec::Vec<super::RowFilter>,
        // special fields
        // @@protoc_insertion_point(special_field:google.bigtable.v2.RowFilter.Chain.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Chain {
        fn default() -> &'a Chain {
            <Chain as ::protobuf::Message>::default_instance()
        }
    }

    impl Chain {
        pub fn new() -> Chain {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "filters",
                |m: &Chain| { &m.filters },
                |m: &mut Chain| { &mut m.filters },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Chain>(
                "RowFilter.Chain",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Chain {
        const NAME: &'static str = "Chain";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.filters.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.filters {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.filters {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Chain {
            Chain::new()
        }

        fn clear(&mut self) {
            self.filters.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Chain {
            static instance: Chain = Chain {
                filters: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Chain {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RowFilter.Chain").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Chain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Chain {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  A RowFilter which sends each row to each of several component
    ///  RowFilters and interleaves the results.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.bigtable.v2.RowFilter.Interleave)
    pub struct Interleave {
        // message fields
        // @@protoc_insertion_point(field:google.bigtable.v2.RowFilter.Interleave.filters)
        pub filters: ::std::vec::Vec<super::RowFilter>,
        // special fields
        // @@protoc_insertion_point(special_field:google.bigtable.v2.RowFilter.Interleave.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Interleave {
        fn default() -> &'a Interleave {
            <Interleave as ::protobuf::Message>::default_instance()
        }
    }

    impl Interleave {
        pub fn new() -> Interleave {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "filters",
                |m: &Interleave| { &m.filters },
                |m: &mut Interleave| { &mut m.filters },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Interleave>(
                "RowFilter.Interleave",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Interleave {
        const NAME: &'static str = "Interleave";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.filters.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.filters {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.filters {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Interleave {
            Interleave::new()
        }

        fn clear(&mut self) {
            self.filters.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Interleave {
            static instance: Interleave = Interleave {
                filters: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Interleave {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RowFilter.Interleave").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Interleave {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Interleave {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  A RowFilter which evaluates one of two possible RowFilters, depending on
    ///  whether or not a predicate RowFilter outputs any cells from the input row.
    ///
    ///  IMPORTANT NOTE: The predicate filter does not execute atomically with the
    ///  true and false filters, which may lead to inconsistent or unexpected
    ///  results. Additionally, Condition filters have poor performance, especially
    ///  when filters are set for the false condition.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.bigtable.v2.RowFilter.Condition)
    pub struct Condition {
        // message fields
        ///  If `predicate_filter` outputs any cells, then `true_filter` will be
        ///  evaluated on the input row. Otherwise, `false_filter` will be evaluated.
        // @@protoc_insertion_point(field:google.bigtable.v2.RowFilter.Condition.predicate_filter)
        pub predicate_filter: ::protobuf::MessageField<super::RowFilter>,
        ///  The filter to apply to the input row if `predicate_filter` returns any
        ///  results. If not provided, no results will be returned in the true case.
        // @@protoc_insertion_point(field:google.bigtable.v2.RowFilter.Condition.true_filter)
        pub true_filter: ::protobuf::MessageField<super::RowFilter>,
        ///  The filter to apply to the input row if `predicate_filter` does not
        ///  return any results. If not provided, no results will be returned in the
        ///  false case.
        // @@protoc_insertion_point(field:google.bigtable.v2.RowFilter.Condition.false_filter)
        pub false_filter: ::protobuf::MessageField<super::RowFilter>,
        // special fields
        // @@protoc_insertion_point(special_field:google.bigtable.v2.RowFilter.Condition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Condition {
        fn default() -> &'a Condition {
            <Condition as ::protobuf::Message>::default_instance()
        }
    }

    impl Condition {
        pub fn new() -> Condition {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::RowFilter>(
                "predicate_filter",
                |m: &Condition| { &m.predicate_filter },
                |m: &mut Condition| { &mut m.predicate_filter },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::RowFilter>(
                "true_filter",
                |m: &Condition| { &m.true_filter },
                |m: &mut Condition| { &mut m.true_filter },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::RowFilter>(
                "false_filter",
                |m: &Condition| { &m.false_filter },
                |m: &mut Condition| { &mut m.false_filter },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Condition>(
                "RowFilter.Condition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Condition {
        const NAME: &'static str = "Condition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.predicate_filter)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.true_filter)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.false_filter)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.predicate_filter.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.true_filter.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.false_filter.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.predicate_filter.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.true_filter.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.false_filter.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Condition {
            Condition::new()
        }

        fn clear(&mut self) {
            self.predicate_filter.clear();
            self.true_filter.clear();
            self.false_filter.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Condition {
            static instance: Condition = Condition {
                predicate_filter: ::protobuf::MessageField::none(),
                true_filter: ::protobuf::MessageField::none(),
                false_filter: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Condition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RowFilter.Condition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Condition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Condition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Specifies a particular change to be made to the contents of a row.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.Mutation)
pub struct Mutation {
    // message oneof groups
    pub mutation: ::std::option::Option<mutation::Mutation>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.Mutation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Mutation {
    fn default() -> &'a Mutation {
        <Mutation as ::protobuf::Message>::default_instance()
    }
}

impl Mutation {
    pub fn new() -> Mutation {
        ::std::default::Default::default()
    }

    // .google.bigtable.v2.Mutation.SetCell set_cell = 1;

    pub fn set_cell(&self) -> &mutation::SetCell {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::SetCell(ref v)) => v,
            _ => <mutation::SetCell as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_cell(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_set_cell(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::SetCell(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_cell(&mut self, v: mutation::SetCell) {
        self.mutation = ::std::option::Option::Some(mutation::Mutation::SetCell(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_cell(&mut self) -> &mut mutation::SetCell {
        if let ::std::option::Option::Some(mutation::Mutation::SetCell(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(mutation::Mutation::SetCell(mutation::SetCell::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::SetCell(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_cell(&mut self) -> mutation::SetCell {
        if self.has_set_cell() {
            match self.mutation.take() {
                ::std::option::Option::Some(mutation::Mutation::SetCell(v)) => v,
                _ => panic!(),
            }
        } else {
            mutation::SetCell::new()
        }
    }

    // .google.bigtable.v2.Mutation.DeleteFromColumn delete_from_column = 2;

    pub fn delete_from_column(&self) -> &mutation::DeleteFromColumn {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(ref v)) => v,
            _ => <mutation::DeleteFromColumn as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_from_column(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_column(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_column(&mut self, v: mutation::DeleteFromColumn) {
        self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_column(&mut self) -> &mut mutation::DeleteFromColumn {
        if let ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(mutation::DeleteFromColumn::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_column(&mut self) -> mutation::DeleteFromColumn {
        if self.has_delete_from_column() {
            match self.mutation.take() {
                ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(v)) => v,
                _ => panic!(),
            }
        } else {
            mutation::DeleteFromColumn::new()
        }
    }

    // .google.bigtable.v2.Mutation.DeleteFromFamily delete_from_family = 3;

    pub fn delete_from_family(&self) -> &mutation::DeleteFromFamily {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(ref v)) => v,
            _ => <mutation::DeleteFromFamily as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_from_family(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_family(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_family(&mut self, v: mutation::DeleteFromFamily) {
        self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_family(&mut self) -> &mut mutation::DeleteFromFamily {
        if let ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(mutation::DeleteFromFamily::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_family(&mut self) -> mutation::DeleteFromFamily {
        if self.has_delete_from_family() {
            match self.mutation.take() {
                ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(v)) => v,
                _ => panic!(),
            }
        } else {
            mutation::DeleteFromFamily::new()
        }
    }

    // .google.bigtable.v2.Mutation.DeleteFromRow delete_from_row = 4;

    pub fn delete_from_row(&self) -> &mutation::DeleteFromRow {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(ref v)) => v,
            _ => <mutation::DeleteFromRow as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_from_row(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_row(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_row(&mut self, v: mutation::DeleteFromRow) {
        self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_row(&mut self) -> &mut mutation::DeleteFromRow {
        if let ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(mutation::DeleteFromRow::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_row(&mut self) -> mutation::DeleteFromRow {
        if self.has_delete_from_row() {
            match self.mutation.take() {
                ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(v)) => v,
                _ => panic!(),
            }
        } else {
            mutation::DeleteFromRow::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, mutation::SetCell>(
            "set_cell",
            Mutation::has_set_cell,
            Mutation::set_cell,
            Mutation::mut_set_cell,
            Mutation::set_set_cell,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, mutation::DeleteFromColumn>(
            "delete_from_column",
            Mutation::has_delete_from_column,
            Mutation::delete_from_column,
            Mutation::mut_delete_from_column,
            Mutation::set_delete_from_column,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, mutation::DeleteFromFamily>(
            "delete_from_family",
            Mutation::has_delete_from_family,
            Mutation::delete_from_family,
            Mutation::mut_delete_from_family,
            Mutation::set_delete_from_family,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, mutation::DeleteFromRow>(
            "delete_from_row",
            Mutation::has_delete_from_row,
            Mutation::delete_from_row,
            Mutation::mut_delete_from_row,
            Mutation::set_delete_from_row,
        ));
        oneofs.push(mutation::Mutation::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Mutation>(
            "Mutation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Mutation {
    const NAME: &'static str = "Mutation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mutation = ::std::option::Option::Some(mutation::Mutation::SetCell(is.read_message()?));
                },
                18 => {
                    self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromColumn(is.read_message()?));
                },
                26 => {
                    self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromFamily(is.read_message()?));
                },
                34 => {
                    self.mutation = ::std::option::Option::Some(mutation::Mutation::DeleteFromRow(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &mutation::Mutation::SetCell(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &mutation::Mutation::DeleteFromColumn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &mutation::Mutation::DeleteFromFamily(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &mutation::Mutation::DeleteFromRow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &mutation::Mutation::SetCell(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &mutation::Mutation::DeleteFromColumn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &mutation::Mutation::DeleteFromFamily(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &mutation::Mutation::DeleteFromRow(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Mutation {
        Mutation::new()
    }

    fn clear(&mut self) {
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Mutation {
        static instance: Mutation = Mutation {
            mutation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Mutation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Mutation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Mutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Mutation`
pub mod mutation {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.Mutation.mutation)
    pub enum Mutation {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.Mutation.set_cell)
        SetCell(SetCell),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.Mutation.delete_from_column)
        DeleteFromColumn(DeleteFromColumn),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.Mutation.delete_from_family)
        DeleteFromFamily(DeleteFromFamily),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.Mutation.delete_from_row)
        DeleteFromRow(DeleteFromRow),
    }

    impl ::protobuf::Oneof for Mutation {
    }

    impl ::protobuf::OneofFull for Mutation {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Mutation as ::protobuf::MessageFull>::descriptor().oneof_by_name("mutation").unwrap()).clone()
        }
    }

    impl Mutation {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Mutation>("mutation")
        }
    }
    ///  A Mutation which sets the value of the specified cell.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.bigtable.v2.Mutation.SetCell)
    pub struct SetCell {
        // message fields
        ///  The name of the family into which new data should be written.
        ///  Must match `[-_.a-zA-Z0-9]+`
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.SetCell.family_name)
        pub family_name: ::std::string::String,
        ///  The qualifier of the column into which new data should be written.
        ///  Can be any byte string, including the empty string.
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.SetCell.column_qualifier)
        pub column_qualifier: ::std::vec::Vec<u8>,
        ///  The timestamp of the cell into which new data should be written.
        ///  Use -1 for current Bigtable server time.
        ///  Otherwise, the client should set this value itself, noting that the
        ///  default value is a timestamp of zero if the field is left unspecified.
        ///  Values must match the granularity of the table (e.g. micros, millis).
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.SetCell.timestamp_micros)
        pub timestamp_micros: i64,
        ///  The value to be written into the specified cell.
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.SetCell.value)
        pub value: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:google.bigtable.v2.Mutation.SetCell.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetCell {
        fn default() -> &'a SetCell {
            <SetCell as ::protobuf::Message>::default_instance()
        }
    }

    impl SetCell {
        pub fn new() -> SetCell {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "family_name",
                |m: &SetCell| { &m.family_name },
                |m: &mut SetCell| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "column_qualifier",
                |m: &SetCell| { &m.column_qualifier },
                |m: &mut SetCell| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timestamp_micros",
                |m: &SetCell| { &m.timestamp_micros },
                |m: &mut SetCell| { &mut m.timestamp_micros },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &SetCell| { &m.value },
                |m: &mut SetCell| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetCell>(
                "Mutation.SetCell",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetCell {
        const NAME: &'static str = "SetCell";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.family_name = is.read_string()?;
                    },
                    18 => {
                        self.column_qualifier = is.read_bytes()?;
                    },
                    24 => {
                        self.timestamp_micros = is.read_int64()?;
                    },
                    34 => {
                        self.value = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.family_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.family_name);
            }
            if !self.column_qualifier.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
            }
            if self.timestamp_micros != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.timestamp_micros);
            }
            if !self.value.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.family_name.is_empty() {
                os.write_string(1, &self.family_name)?;
            }
            if !self.column_qualifier.is_empty() {
                os.write_bytes(2, &self.column_qualifier)?;
            }
            if self.timestamp_micros != 0 {
                os.write_int64(3, self.timestamp_micros)?;
            }
            if !self.value.is_empty() {
                os.write_bytes(4, &self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetCell {
            SetCell::new()
        }

        fn clear(&mut self) {
            self.family_name.clear();
            self.column_qualifier.clear();
            self.timestamp_micros = 0;
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetCell {
            static instance: SetCell = SetCell {
                family_name: ::std::string::String::new(),
                column_qualifier: ::std::vec::Vec::new(),
                timestamp_micros: 0,
                value: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetCell {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Mutation.SetCell").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetCell {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetCell {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  A Mutation which deletes cells from the specified column, optionally
    ///  restricting the deletions to a given timestamp range.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.bigtable.v2.Mutation.DeleteFromColumn)
    pub struct DeleteFromColumn {
        // message fields
        ///  The name of the family from which cells should be deleted.
        ///  Must match `[-_.a-zA-Z0-9]+`
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.DeleteFromColumn.family_name)
        pub family_name: ::std::string::String,
        ///  The qualifier of the column from which cells should be deleted.
        ///  Can be any byte string, including the empty string.
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.DeleteFromColumn.column_qualifier)
        pub column_qualifier: ::std::vec::Vec<u8>,
        ///  The range of timestamps within which cells should be deleted.
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.DeleteFromColumn.time_range)
        pub time_range: ::protobuf::MessageField<super::TimestampRange>,
        // special fields
        // @@protoc_insertion_point(special_field:google.bigtable.v2.Mutation.DeleteFromColumn.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeleteFromColumn {
        fn default() -> &'a DeleteFromColumn {
            <DeleteFromColumn as ::protobuf::Message>::default_instance()
        }
    }

    impl DeleteFromColumn {
        pub fn new() -> DeleteFromColumn {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "family_name",
                |m: &DeleteFromColumn| { &m.family_name },
                |m: &mut DeleteFromColumn| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "column_qualifier",
                |m: &DeleteFromColumn| { &m.column_qualifier },
                |m: &mut DeleteFromColumn| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::TimestampRange>(
                "time_range",
                |m: &DeleteFromColumn| { &m.time_range },
                |m: &mut DeleteFromColumn| { &mut m.time_range },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteFromColumn>(
                "Mutation.DeleteFromColumn",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeleteFromColumn {
        const NAME: &'static str = "DeleteFromColumn";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.family_name = is.read_string()?;
                    },
                    18 => {
                        self.column_qualifier = is.read_bytes()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.time_range)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.family_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.family_name);
            }
            if !self.column_qualifier.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
            }
            if let Some(v) = self.time_range.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.family_name.is_empty() {
                os.write_string(1, &self.family_name)?;
            }
            if !self.column_qualifier.is_empty() {
                os.write_bytes(2, &self.column_qualifier)?;
            }
            if let Some(v) = self.time_range.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeleteFromColumn {
            DeleteFromColumn::new()
        }

        fn clear(&mut self) {
            self.family_name.clear();
            self.column_qualifier.clear();
            self.time_range.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeleteFromColumn {
            static instance: DeleteFromColumn = DeleteFromColumn {
                family_name: ::std::string::String::new(),
                column_qualifier: ::std::vec::Vec::new(),
                time_range: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeleteFromColumn {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Mutation.DeleteFromColumn").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeleteFromColumn {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeleteFromColumn {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  A Mutation which deletes all cells from the specified column family.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.bigtable.v2.Mutation.DeleteFromFamily)
    pub struct DeleteFromFamily {
        // message fields
        ///  The name of the family from which cells should be deleted.
        ///  Must match `[-_.a-zA-Z0-9]+`
        // @@protoc_insertion_point(field:google.bigtable.v2.Mutation.DeleteFromFamily.family_name)
        pub family_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:google.bigtable.v2.Mutation.DeleteFromFamily.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeleteFromFamily {
        fn default() -> &'a DeleteFromFamily {
            <DeleteFromFamily as ::protobuf::Message>::default_instance()
        }
    }

    impl DeleteFromFamily {
        pub fn new() -> DeleteFromFamily {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "family_name",
                |m: &DeleteFromFamily| { &m.family_name },
                |m: &mut DeleteFromFamily| { &mut m.family_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteFromFamily>(
                "Mutation.DeleteFromFamily",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeleteFromFamily {
        const NAME: &'static str = "DeleteFromFamily";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.family_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.family_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.family_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.family_name.is_empty() {
                os.write_string(1, &self.family_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeleteFromFamily {
            DeleteFromFamily::new()
        }

        fn clear(&mut self) {
            self.family_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeleteFromFamily {
            static instance: DeleteFromFamily = DeleteFromFamily {
                family_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeleteFromFamily {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Mutation.DeleteFromFamily").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeleteFromFamily {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeleteFromFamily {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  A Mutation which deletes all cells from the containing row.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.bigtable.v2.Mutation.DeleteFromRow)
    pub struct DeleteFromRow {
        // special fields
        // @@protoc_insertion_point(special_field:google.bigtable.v2.Mutation.DeleteFromRow.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeleteFromRow {
        fn default() -> &'a DeleteFromRow {
            <DeleteFromRow as ::protobuf::Message>::default_instance()
        }
    }

    impl DeleteFromRow {
        pub fn new() -> DeleteFromRow {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteFromRow>(
                "Mutation.DeleteFromRow",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeleteFromRow {
        const NAME: &'static str = "DeleteFromRow";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeleteFromRow {
            DeleteFromRow::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeleteFromRow {
            static instance: DeleteFromRow = DeleteFromRow {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeleteFromRow {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Mutation.DeleteFromRow").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeleteFromRow {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeleteFromRow {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Specifies an atomic read/modify/write operation on the latest value of the
///  specified column.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.bigtable.v2.ReadModifyWriteRule)
pub struct ReadModifyWriteRule {
    // message fields
    ///  The name of the family to which the read/modify/write should be applied.
    ///  Must match `[-_.a-zA-Z0-9]+`
    // @@protoc_insertion_point(field:google.bigtable.v2.ReadModifyWriteRule.family_name)
    pub family_name: ::std::string::String,
    ///  The qualifier of the column to which the read/modify/write should be
    ///  applied.
    ///  Can be any byte string, including the empty string.
    // @@protoc_insertion_point(field:google.bigtable.v2.ReadModifyWriteRule.column_qualifier)
    pub column_qualifier: ::std::vec::Vec<u8>,
    // message oneof groups
    pub rule: ::std::option::Option<read_modify_write_rule::Rule>,
    // special fields
    // @@protoc_insertion_point(special_field:google.bigtable.v2.ReadModifyWriteRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadModifyWriteRule {
    fn default() -> &'a ReadModifyWriteRule {
        <ReadModifyWriteRule as ::protobuf::Message>::default_instance()
    }
}

impl ReadModifyWriteRule {
    pub fn new() -> ReadModifyWriteRule {
        ::std::default::Default::default()
    }

    // bytes append_value = 3;

    pub fn append_value(&self) -> &[u8] {
        match self.rule {
            ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_append_value(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_append_value(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_append_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.rule = ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_append_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(::std::vec::Vec::new()));
        }
        match self.rule {
            ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_append_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_append_value() {
            match self.rule.take() {
                ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // int64 increment_amount = 4;

    pub fn increment_amount(&self) -> i64 {
        match self.rule {
            ::std::option::Option::Some(read_modify_write_rule::Rule::IncrementAmount(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_increment_amount(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_increment_amount(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(read_modify_write_rule::Rule::IncrementAmount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_increment_amount(&mut self, v: i64) {
        self.rule = ::std::option::Option::Some(read_modify_write_rule::Rule::IncrementAmount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "family_name",
            |m: &ReadModifyWriteRule| { &m.family_name },
            |m: &mut ReadModifyWriteRule| { &mut m.family_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "column_qualifier",
            |m: &ReadModifyWriteRule| { &m.column_qualifier },
            |m: &mut ReadModifyWriteRule| { &mut m.column_qualifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "append_value",
            ReadModifyWriteRule::has_append_value,
            ReadModifyWriteRule::append_value,
            ReadModifyWriteRule::set_append_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "increment_amount",
            ReadModifyWriteRule::has_increment_amount,
            ReadModifyWriteRule::increment_amount,
            ReadModifyWriteRule::set_increment_amount,
        ));
        oneofs.push(read_modify_write_rule::Rule::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadModifyWriteRule>(
            "ReadModifyWriteRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadModifyWriteRule {
    const NAME: &'static str = "ReadModifyWriteRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.family_name = is.read_string()?;
                },
                18 => {
                    self.column_qualifier = is.read_bytes()?;
                },
                26 => {
                    self.rule = ::std::option::Option::Some(read_modify_write_rule::Rule::AppendValue(is.read_bytes()?));
                },
                32 => {
                    self.rule = ::std::option::Option::Some(read_modify_write_rule::Rule::IncrementAmount(is.read_int64()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if !self.column_qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
        }
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &read_modify_write_rule::Rule::AppendValue(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &read_modify_write_rule::Rule::IncrementAmount(v) => {
                    my_size += ::protobuf::rt::int64_size(4, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if !self.column_qualifier.is_empty() {
            os.write_bytes(2, &self.column_qualifier)?;
        }
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &read_modify_write_rule::Rule::AppendValue(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &read_modify_write_rule::Rule::IncrementAmount(v) => {
                    os.write_int64(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadModifyWriteRule {
        ReadModifyWriteRule::new()
    }

    fn clear(&mut self) {
        self.family_name.clear();
        self.column_qualifier.clear();
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadModifyWriteRule {
        static instance: ReadModifyWriteRule = ReadModifyWriteRule {
            family_name: ::std::string::String::new(),
            column_qualifier: ::std::vec::Vec::new(),
            rule: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadModifyWriteRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadModifyWriteRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadModifyWriteRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadModifyWriteRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReadModifyWriteRule`
pub mod read_modify_write_rule {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.bigtable.v2.ReadModifyWriteRule.rule)
    pub enum Rule {
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ReadModifyWriteRule.append_value)
        AppendValue(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:google.bigtable.v2.ReadModifyWriteRule.increment_amount)
        IncrementAmount(i64),
    }

    impl ::protobuf::Oneof for Rule {
    }

    impl ::protobuf::OneofFull for Rule {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ReadModifyWriteRule as ::protobuf::MessageFull>::descriptor().oneof_by_name("rule").unwrap()).clone()
        }
    }

    impl Rule {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Rule>("rule")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dgoogle/bigtable/v2/data.proto\x12\x12google.bigtable.v2\"O\n\x03Ro\
    w\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x126\n\x08families\x18\
    \x02\x20\x03(\x0b2\x1a.google.bigtable.v2.FamilyR\x08families\"R\n\x06Fa\
    mily\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x124\n\x07columns\x18\
    \x02\x20\x03(\x0b2\x1a.google.bigtable.v2.ColumnR\x07columns\"V\n\x06Col\
    umn\x12\x1c\n\tqualifier\x18\x01\x20\x01(\x0cR\tqualifier\x12.\n\x05cell\
    s\x18\x02\x20\x03(\x0b2\x18.google.bigtable.v2.CellR\x05cells\"_\n\x04Ce\
    ll\x12)\n\x10timestamp_micros\x18\x01\x20\x01(\x03R\x0ftimestampMicros\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\x12\x16\n\x06labels\
    \x18\x03\x20\x03(\tR\x06labels\"\xc2\x01\n\x08RowRange\x12*\n\x10start_k\
    ey_closed\x18\x01\x20\x01(\x0cH\0R\x0estartKeyClosed\x12&\n\x0estart_key\
    _open\x18\x02\x20\x01(\x0cH\0R\x0cstartKeyOpen\x12\"\n\x0cend_key_open\
    \x18\x03\x20\x01(\x0cH\x01R\nendKeyOpen\x12&\n\x0eend_key_closed\x18\x04\
    \x20\x01(\x0cH\x01R\x0cendKeyClosedB\x0b\n\tstart_keyB\t\n\x07end_key\"`\
    \n\x06RowSet\x12\x19\n\x08row_keys\x18\x01\x20\x03(\x0cR\x07rowKeys\x12;\
    \n\nrow_ranges\x18\x02\x20\x03(\x0b2\x1c.google.bigtable.v2.RowRangeR\tr\
    owRanges\"\xa2\x02\n\x0bColumnRange\x12\x1f\n\x0bfamily_name\x18\x01\x20\
    \x01(\tR\nfamilyName\x126\n\x16start_qualifier_closed\x18\x02\x20\x01(\
    \x0cH\0R\x14startQualifierClosed\x122\n\x14start_qualifier_open\x18\x03\
    \x20\x01(\x0cH\0R\x12startQualifierOpen\x122\n\x14end_qualifier_closed\
    \x18\x04\x20\x01(\x0cH\x01R\x12endQualifierClosed\x12.\n\x12end_qualifie\
    r_open\x18\x05\x20\x01(\x0cH\x01R\x10endQualifierOpenB\x11\n\x0fstart_qu\
    alifierB\x0f\n\rend_qualifier\"x\n\x0eTimestampRange\x124\n\x16start_tim\
    estamp_micros\x18\x01\x20\x01(\x03R\x14startTimestampMicros\x120\n\x14en\
    d_timestamp_micros\x18\x02\x20\x01(\x03R\x12endTimestampMicros\"\xd8\x01\
    \n\nValueRange\x12.\n\x12start_value_closed\x18\x01\x20\x01(\x0cH\0R\x10\
    startValueClosed\x12*\n\x10start_value_open\x18\x02\x20\x01(\x0cH\0R\x0e\
    startValueOpen\x12*\n\x10end_value_closed\x18\x03\x20\x01(\x0cH\x01R\x0e\
    endValueClosed\x12&\n\x0eend_value_open\x18\x04\x20\x01(\x0cH\x01R\x0cen\
    dValueOpenB\r\n\x0bstart_valueB\x0b\n\tend_value\"\xfc\x0b\n\tRowFilter\
    \x12;\n\x05chain\x18\x01\x20\x01(\x0b2#.google.bigtable.v2.RowFilter.Cha\
    inH\0R\x05chain\x12J\n\ninterleave\x18\x02\x20\x01(\x0b2(.google.bigtabl\
    e.v2.RowFilter.InterleaveH\0R\ninterleave\x12G\n\tcondition\x18\x03\x20\
    \x01(\x0b2'.google.bigtable.v2.RowFilter.ConditionH\0R\tcondition\x12\
    \x14\n\x04sink\x18\x10\x20\x01(\x08H\0R\x04sink\x12(\n\x0fpass_all_filte\
    r\x18\x11\x20\x01(\x08H\0R\rpassAllFilter\x12*\n\x10block_all_filter\x18\
    \x12\x20\x01(\x08H\0R\x0eblockAllFilter\x121\n\x14row_key_regex_filter\
    \x18\x04\x20\x01(\x0cH\0R\x11rowKeyRegexFilter\x12,\n\x11row_sample_filt\
    er\x18\x0e\x20\x01(\x01H\0R\x0frowSampleFilter\x129\n\x18family_name_reg\
    ex_filter\x18\x05\x20\x01(\tH\0R\x15familyNameRegexFilter\x12C\n\x1dcolu\
    mn_qualifier_regex_filter\x18\x06\x20\x01(\x0cH\0R\x1acolumnQualifierReg\
    exFilter\x12Q\n\x13column_range_filter\x18\x07\x20\x01(\x0b2\x1f.google.\
    bigtable.v2.ColumnRangeH\0R\x11columnRangeFilter\x12Z\n\x16timestamp_ran\
    ge_filter\x18\x08\x20\x01(\x0b2\".google.bigtable.v2.TimestampRangeH\0R\
    \x14timestampRangeFilter\x12.\n\x12value_regex_filter\x18\t\x20\x01(\x0c\
    H\0R\x10valueRegexFilter\x12N\n\x12value_range_filter\x18\x0f\x20\x01(\
    \x0b2\x1e.google.bigtable.v2.ValueRangeH\0R\x10valueRangeFilter\x12>\n\
    \x1bcells_per_row_offset_filter\x18\n\x20\x01(\x05H\0R\x17cellsPerRowOff\
    setFilter\x12<\n\x1acells_per_row_limit_filter\x18\x0b\x20\x01(\x05H\0R\
    \x16cellsPerRowLimitFilter\x12B\n\x1dcells_per_column_limit_filter\x18\
    \x0c\x20\x01(\x05H\0R\x19cellsPerColumnLimitFilter\x128\n\x17strip_value\
    _transformer\x18\r\x20\x01(\x08H\0R\x15stripValueTransformer\x128\n\x17a\
    pply_label_transformer\x18\x13\x20\x01(\tH\0R\x15applyLabelTransformer\
    \x1a@\n\x05Chain\x127\n\x07filters\x18\x01\x20\x03(\x0b2\x1d.google.bigt\
    able.v2.RowFilterR\x07filters\x1aE\n\nInterleave\x127\n\x07filters\x18\
    \x01\x20\x03(\x0b2\x1d.google.bigtable.v2.RowFilterR\x07filters\x1a\xd7\
    \x01\n\tCondition\x12H\n\x10predicate_filter\x18\x01\x20\x01(\x0b2\x1d.g\
    oogle.bigtable.v2.RowFilterR\x0fpredicateFilter\x12>\n\x0btrue_filter\
    \x18\x02\x20\x01(\x0b2\x1d.google.bigtable.v2.RowFilterR\ntrueFilter\x12\
    @\n\x0cfalse_filter\x18\x03\x20\x01(\x0b2\x1d.google.bigtable.v2.RowFilt\
    erR\x0bfalseFilterB\x08\n\x06filter\"\xf0\x05\n\x08Mutation\x12A\n\x08se\
    t_cell\x18\x01\x20\x01(\x0b2$.google.bigtable.v2.Mutation.SetCellH\0R\
    \x07setCell\x12]\n\x12delete_from_column\x18\x02\x20\x01(\x0b2-.google.b\
    igtable.v2.Mutation.DeleteFromColumnH\0R\x10deleteFromColumn\x12]\n\x12d\
    elete_from_family\x18\x03\x20\x01(\x0b2-.google.bigtable.v2.Mutation.Del\
    eteFromFamilyH\0R\x10deleteFromFamily\x12T\n\x0fdelete_from_row\x18\x04\
    \x20\x01(\x0b2*.google.bigtable.v2.Mutation.DeleteFromRowH\0R\rdeleteFro\
    mRow\x1a\x96\x01\n\x07SetCell\x12\x1f\n\x0bfamily_name\x18\x01\x20\x01(\
    \tR\nfamilyName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0cR\x0fcolu\
    mnQualifier\x12)\n\x10timestamp_micros\x18\x03\x20\x01(\x03R\x0ftimestam\
    pMicros\x12\x14\n\x05value\x18\x04\x20\x01(\x0cR\x05value\x1a\xa1\x01\n\
    \x10DeleteFromColumn\x12\x1f\n\x0bfamily_name\x18\x01\x20\x01(\tR\nfamil\
    yName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0cR\x0fcolumnQualifie\
    r\x12A\n\ntime_range\x18\x03\x20\x01(\x0b2\".google.bigtable.v2.Timestam\
    pRangeR\ttimeRange\x1a3\n\x10DeleteFromFamily\x12\x1f\n\x0bfamily_name\
    \x18\x01\x20\x01(\tR\nfamilyName\x1a\x0f\n\rDeleteFromRowB\n\n\x08mutati\
    on\"\xbb\x01\n\x13ReadModifyWriteRule\x12\x1f\n\x0bfamily_name\x18\x01\
    \x20\x01(\tR\nfamilyName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0c\
    R\x0fcolumnQualifier\x12#\n\x0cappend_value\x18\x03\x20\x01(\x0cH\0R\x0b\
    appendValue\x12+\n\x10increment_amount\x18\x04\x20\x01(\x03H\0R\x0fincre\
    mentAmountB\x06\n\x04ruleB\x97\x01\n\x16com.google.bigtable.v2B\tDataPro\
    toP\x01Z:google.golang.org/genproto/googleapis/bigtable/v2;bigtable\xaa\
    \x02\x18Google.Cloud.Bigtable.V2\xca\x02\x18Google\\Cloud\\Bigtable\\V2J\
    \xb1\xb5\x01\n\x07\x12\x05\x0f\0\x96\x04\x01\n\xbe\x04\n\x01\x0c\x12\x03\
    \x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20LLC.\n\n\x20Licens\
    ed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"\
    License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20i\
    n\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20\
    a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://ww\
    w.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20app\
    licable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20\
    distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\
    \x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITION\
    S\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\
    \x20the\x20License\x20for\x20the\x20specific\x20language\x20governing\
    \x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\
    \n\x08\n\x01\x02\x12\x03\x11\0\x1b\n\x08\n\x01\x08\x12\x03\x13\05\n\t\n\
    \x02\x08%\x12\x03\x13\05\n\x08\n\x01\x08\x12\x03\x14\0Q\n\t\n\x02\x08\
    \x0b\x12\x03\x14\0Q\n\x08\n\x01\x08\x12\x03\x15\0\"\n\t\n\x02\x08\n\x12\
    \x03\x15\0\"\n\x08\n\x01\x08\x12\x03\x16\0*\n\t\n\x02\x08\x08\x12\x03\
    \x16\0*\n\x08\n\x01\x08\x12\x03\x17\0/\n\t\n\x02\x08\x01\x12\x03\x17\0/\
    \n\x08\n\x01\x08\x12\x03\x18\05\n\t\n\x02\x08)\x12\x03\x18\05\n\x90\x01\
    \n\x02\x04\0\x12\x04\x1c\0%\x01\x1a\x83\x01\x20Specifies\x20the\x20compl\
    ete\x20(requested)\x20contents\x20of\x20a\x20single\x20row\x20of\x20a\
    \x20table.\n\x20Rows\x20which\x20exceed\x20256MiB\x20in\x20size\x20canno\
    t\x20be\x20read\x20in\x20full.\n\n\n\n\x03\x04\0\x01\x12\x03\x1c\x08\x0b\
    \n\xe2\x01\n\x04\x04\0\x02\0\x12\x03\x20\x02\x10\x1a\xd4\x01\x20The\x20u\
    nique\x20key\x20which\x20identifies\x20this\x20row\x20within\x20its\x20t\
    able.\x20This\x20is\x20the\x20same\n\x20key\x20that's\x20used\x20to\x20i\
    dentify\x20the\x20row\x20in,\x20for\x20example,\x20a\x20MutateRowRequest\
    .\n\x20May\x20contain\x20any\x20non-empty\x20byte\x20string\x20up\x20to\
    \x204KiB\x20in\x20length.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x20\x02\
    \x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x20\x08\x0b\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03\x20\x0e\x0f\n{\n\x04\x04\0\x02\x01\x12\x03$\x02\x1f\
    \x1an\x20May\x20be\x20empty,\x20but\x20only\x20if\x20the\x20entire\x20ro\
    w\x20is\x20empty.\n\x20The\x20mutual\x20ordering\x20of\x20column\x20fami\
    lies\x20is\x20not\x20specified.\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03$\
    \x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03$\x0b\x11\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x03$\x12\x1a\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03$\x1d\
    \x1e\nf\n\x02\x04\x01\x12\x04)\04\x01\x1aZ\x20Specifies\x20(some\x20of)\
    \x20the\x20contents\x20of\x20a\x20single\x20row/column\x20family\x20inte\
    rsection\n\x20of\x20a\x20table.\n\n\n\n\x03\x04\x01\x01\x12\x03)\x08\x0e\
    \n\x85\x03\n\x04\x04\x01\x02\0\x12\x030\x02\x12\x1a\xf7\x02\x20The\x20un\
    ique\x20key\x20which\x20identifies\x20this\x20family\x20within\x20its\
    \x20row.\x20This\x20is\x20the\n\x20same\x20key\x20that's\x20used\x20to\
    \x20identify\x20the\x20family\x20in,\x20for\x20example,\x20a\x20RowFilte\
    r\n\x20which\x20sets\x20its\x20\"family_name_regex_filter\"\x20field.\n\
    \x20Must\x20match\x20`[-_.a-zA-Z0-9]+`,\x20except\x20that\x20Aggregating\
    RowProcessors\x20may\n\x20produce\x20cells\x20in\x20a\x20sentinel\x20fam\
    ily\x20with\x20an\x20empty\x20name.\n\x20Must\x20be\x20no\x20greater\x20\
    than\x2064\x20characters\x20in\x20length.\n\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x030\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x030\t\r\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x030\x10\x11\nL\n\x04\x04\x01\x02\x01\x12\x03\
    3\x02\x1e\x1a?\x20Must\x20not\x20be\x20empty.\x20Sorted\x20in\x20order\
    \x20of\x20increasing\x20\"qualifier\".\n\n\x0c\n\x05\x04\x01\x02\x01\x04\
    \x12\x033\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x033\x0b\x11\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x033\x12\x19\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x033\x1c\x1d\n_\n\x02\x04\x02\x12\x048\0B\x01\x1aS\x20Specifies\
    \x20(some\x20of)\x20the\x20contents\x20of\x20a\x20single\x20row/column\
    \x20intersection\x20of\x20a\n\x20table.\n\n\n\n\x03\x04\x02\x01\x12\x038\
    \x08\x0e\n\xad\x02\n\x04\x04\x02\x02\0\x12\x03>\x02\x16\x1a\x9f\x02\x20T\
    he\x20unique\x20key\x20which\x20identifies\x20this\x20column\x20within\
    \x20its\x20family.\x20This\x20is\x20the\n\x20same\x20key\x20that's\x20us\
    ed\x20to\x20identify\x20the\x20column\x20in,\x20for\x20example,\x20a\x20\
    RowFilter\n\x20which\x20sets\x20its\x20`column_qualifier_regex_filter`\
    \x20field.\n\x20May\x20contain\x20any\x20byte\x20string,\x20including\
    \x20the\x20empty\x20string,\x20up\x20to\x2016kiB\x20in\n\x20length.\n\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03>\x02\x07\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03>\x08\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03>\x14\x15\nS\
    \n\x04\x04\x02\x02\x01\x12\x03A\x02\x1a\x1aF\x20Must\x20not\x20be\x20emp\
    ty.\x20Sorted\x20in\x20order\x20of\x20decreasing\x20\"timestamp_micros\"\
    .\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03A\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x01\x06\x12\x03A\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03A\
    \x10\x15\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03A\x18\x19\n[\n\x02\x04\
    \x03\x12\x04E\0U\x01\x1aO\x20Specifies\x20(some\x20of)\x20the\x20content\
    s\x20of\x20a\x20single\x20row/column/timestamp\x20of\x20a\x20table.\n\n\
    \n\n\x03\x04\x03\x01\x12\x03E\x08\x0c\n\xf6\x02\n\x04\x04\x03\x02\0\x12\
    \x03L\x02\x1d\x1a\xe8\x02\x20The\x20cell's\x20stored\x20timestamp,\x20wh\
    ich\x20also\x20uniquely\x20identifies\x20it\x20within\n\x20its\x20column\
    .\n\x20Values\x20are\x20always\x20expressed\x20in\x20microseconds,\x20bu\
    t\x20individual\x20tables\x20may\x20set\n\x20a\x20coarser\x20granularity\
    \x20to\x20further\x20restrict\x20the\x20allowed\x20values.\x20For\n\x20e\
    xample,\x20a\x20table\x20which\x20specifies\x20millisecond\x20granularit\
    y\x20will\x20only\x20allow\n\x20values\x20of\x20`timestamp_micros`\x20wh\
    ich\x20are\x20multiples\x20of\x201000.\n\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x03L\x02\x07\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03L\x08\x18\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x03L\x1b\x1c\n\x7f\n\x04\x04\x03\x02\x01\x12\
    \x03Q\x02\x12\x1ar\x20The\x20value\x20stored\x20in\x20the\x20cell.\n\x20\
    May\x20contain\x20any\x20byte\x20string,\x20including\x20the\x20empty\
    \x20string,\x20up\x20to\x20100MiB\x20in\n\x20length.\n\n\x0c\n\x05\x04\
    \x03\x02\x01\x05\x12\x03Q\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\
    \x03Q\x08\r\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03Q\x10\x11\nY\n\x04\
    \x04\x03\x02\x02\x12\x03T\x02\x1d\x1aL\x20Labels\x20applied\x20to\x20the\
    \x20cell\x20by\x20a\x20[RowFilter][google.bigtable.v2.RowFilter].\n\n\
    \x0c\n\x05\x04\x03\x02\x02\x04\x12\x03T\x02\n\n\x0c\n\x05\x04\x03\x02\
    \x02\x05\x12\x03T\x0b\x11\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03T\x12\
    \x18\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03T\x1b\x1c\n3\n\x02\x04\x04\
    \x12\x04X\0l\x01\x1a'\x20Specifies\x20a\x20contiguous\x20range\x20of\x20\
    rows.\n\n\n\n\x03\x04\x04\x01\x12\x03X\x08\x10\n~\n\x04\x04\x04\x08\0\
    \x12\x04[\x02a\x03\x1ap\x20The\x20row\x20key\x20at\x20which\x20to\x20sta\
    rt\x20the\x20range.\n\x20If\x20neither\x20field\x20is\x20set,\x20interpr\
    eted\x20as\x20the\x20empty\x20string,\x20inclusive.\n\n\x0c\n\x05\x04\
    \x04\x08\0\x01\x12\x03[\x08\x11\nG\n\x04\x04\x04\x02\0\x12\x03]\x04\x1f\
    \x1a:\x20Used\x20when\x20giving\x20an\x20inclusive\x20lower\x20bound\x20\
    for\x20the\x20range.\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03]\x04\t\n\
    \x0c\n\x05\x04\x04\x02\0\x01\x12\x03]\n\x1a\n\x0c\n\x05\x04\x04\x02\0\
    \x03\x12\x03]\x1d\x1e\nG\n\x04\x04\x04\x02\x01\x12\x03`\x04\x1d\x1a:\x20\
    Used\x20when\x20giving\x20an\x20exclusive\x20lower\x20bound\x20for\x20th\
    e\x20range.\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03`\x04\t\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03`\n\x18\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03`\x1b\x1c\n\x80\x01\n\x04\x04\x04\x08\x01\x12\x04e\x02k\x03\x1ar\x20\
    The\x20row\x20key\x20at\x20which\x20to\x20end\x20the\x20range.\n\x20If\
    \x20neither\x20field\x20is\x20set,\x20interpreted\x20as\x20the\x20infini\
    te\x20row\x20key,\x20exclusive.\n\n\x0c\n\x05\x04\x04\x08\x01\x01\x12\
    \x03e\x08\x0f\nG\n\x04\x04\x04\x02\x02\x12\x03g\x04\x1b\x1a:\x20Used\x20\
    when\x20giving\x20an\x20exclusive\x20upper\x20bound\x20for\x20the\x20ran\
    ge.\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03g\x04\t\n\x0c\n\x05\x04\x04\
    \x02\x02\x01\x12\x03g\n\x16\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03g\x19\
    \x1a\nG\n\x04\x04\x04\x02\x03\x12\x03j\x04\x1d\x1a:\x20Used\x20when\x20g\
    iving\x20an\x20inclusive\x20upper\x20bound\x20for\x20the\x20range.\n\n\
    \x0c\n\x05\x04\x04\x02\x03\x05\x12\x03j\x04\t\n\x0c\n\x05\x04\x04\x02\
    \x03\x01\x12\x03j\n\x18\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03j\x1b\x1c\
    \n5\n\x02\x04\x05\x12\x04o\0u\x01\x1a)\x20Specifies\x20a\x20non-contiguo\
    us\x20set\x20of\x20rows.\n\n\n\n\x03\x04\x05\x01\x12\x03o\x08\x0e\n/\n\
    \x04\x04\x05\x02\0\x12\x03q\x02\x1e\x1a\"\x20Single\x20rows\x20included\
    \x20in\x20the\x20set.\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03q\x02\n\n\
    \x0c\n\x05\x04\x05\x02\0\x05\x12\x03q\x0b\x10\n\x0c\n\x05\x04\x05\x02\0\
    \x01\x12\x03q\x11\x19\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03q\x1c\x1d\n9\
    \n\x04\x04\x05\x02\x01\x12\x03t\x02#\x1a,\x20Contiguous\x20row\x20ranges\
    \x20included\x20in\x20the\x20set.\n\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\
    \x03t\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03t\x0b\x13\n\x0c\n\x05\
    \x04\x05\x02\x01\x01\x12\x03t\x14\x1e\n\x0c\n\x05\x04\x05\x02\x01\x03\
    \x12\x03t!\"\n\x84\x02\n\x02\x04\x06\x12\x05{\0\x92\x01\x01\x1a\xf6\x01\
    \x20Specifies\x20a\x20contiguous\x20range\x20of\x20columns\x20within\x20\
    a\x20single\x20column\x20family.\n\x20The\x20range\x20spans\x20from\x20&\
    lt;column_family&gt;:&lt;start_qualifier&gt;\x20to\n\x20&lt;column_famil\
    y&gt;:&lt;end_qualifier&gt;,\x20where\x20both\x20bounds\x20can\x20be\x20\
    either\n\x20inclusive\x20or\x20exclusive.\n\n\n\n\x03\x04\x06\x01\x12\
    \x03{\x08\x13\nK\n\x04\x04\x06\x02\0\x12\x03}\x02\x19\x1a>\x20The\x20nam\
    e\x20of\x20the\x20column\x20family\x20within\x20which\x20this\x20range\
    \x20falls.\n\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03}\x02\x08\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03}\t\x14\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03}\
    \x17\x18\n\xa3\x01\n\x04\x04\x06\x08\0\x12\x06\x81\x01\x02\x87\x01\x03\
    \x1a\x92\x01\x20The\x20column\x20qualifier\x20at\x20which\x20to\x20start\
    \x20the\x20range\x20(within\x20`column_family`).\n\x20If\x20neither\x20f\
    ield\x20is\x20set,\x20interpreted\x20as\x20the\x20empty\x20string,\x20in\
    clusive.\n\n\r\n\x05\x04\x06\x08\0\x01\x12\x04\x81\x01\x08\x17\nH\n\x04\
    \x04\x06\x02\x01\x12\x04\x83\x01\x04%\x1a:\x20Used\x20when\x20giving\x20\
    an\x20inclusive\x20lower\x20bound\x20for\x20the\x20range.\n\n\r\n\x05\
    \x04\x06\x02\x01\x05\x12\x04\x83\x01\x04\t\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\x83\x01\n\x20\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x83\x01#$\n\
    H\n\x04\x04\x06\x02\x02\x12\x04\x86\x01\x04#\x1a:\x20Used\x20when\x20giv\
    ing\x20an\x20exclusive\x20lower\x20bound\x20for\x20the\x20range.\n\n\r\n\
    \x05\x04\x06\x02\x02\x05\x12\x04\x86\x01\x04\t\n\r\n\x05\x04\x06\x02\x02\
    \x01\x12\x04\x86\x01\n\x1e\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x86\x01\
    !\"\n\xa4\x01\n\x04\x04\x06\x08\x01\x12\x06\x8b\x01\x02\x91\x01\x03\x1a\
    \x93\x01\x20The\x20column\x20qualifier\x20at\x20which\x20to\x20end\x20th\
    e\x20range\x20(within\x20`column_family`).\n\x20If\x20neither\x20field\
    \x20is\x20set,\x20interpreted\x20as\x20the\x20infinite\x20string,\x20exc\
    lusive.\n\n\r\n\x05\x04\x06\x08\x01\x01\x12\x04\x8b\x01\x08\x15\nH\n\x04\
    \x04\x06\x02\x03\x12\x04\x8d\x01\x04#\x1a:\x20Used\x20when\x20giving\x20\
    an\x20inclusive\x20upper\x20bound\x20for\x20the\x20range.\n\n\r\n\x05\
    \x04\x06\x02\x03\x05\x12\x04\x8d\x01\x04\t\n\r\n\x05\x04\x06\x02\x03\x01\
    \x12\x04\x8d\x01\n\x1e\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\x8d\x01!\"\
    \nH\n\x04\x04\x06\x02\x04\x12\x04\x90\x01\x04!\x1a:\x20Used\x20when\x20g\
    iving\x20an\x20exclusive\x20upper\x20bound\x20for\x20the\x20range.\n\n\r\
    \n\x05\x04\x06\x02\x04\x05\x12\x04\x90\x01\x04\t\n\r\n\x05\x04\x06\x02\
    \x04\x01\x12\x04\x90\x01\n\x1c\n\r\n\x05\x04\x06\x02\x04\x03\x12\x04\x90\
    \x01\x1f\x20\nG\n\x02\x04\x07\x12\x06\x95\x01\0\x9b\x01\x01\x1a9\x20Spec\
    ified\x20a\x20contiguous\x20range\x20of\x20microsecond\x20timestamps.\n\
    \n\x0b\n\x03\x04\x07\x01\x12\x04\x95\x01\x08\x16\nG\n\x04\x04\x07\x02\0\
    \x12\x04\x97\x01\x02#\x1a9\x20Inclusive\x20lower\x20bound.\x20If\x20left\
    \x20empty,\x20interpreted\x20as\x200.\n\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\x97\x01\x02\x07\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x97\x01\x08\x1e\
    \n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x97\x01!\"\nN\n\x04\x04\x07\x02\x01\
    \x12\x04\x9a\x01\x02!\x1a@\x20Exclusive\x20upper\x20bound.\x20If\x20left\
    \x20empty,\x20interpreted\x20as\x20infinity.\n\n\r\n\x05\x04\x07\x02\x01\
    \x05\x12\x04\x9a\x01\x02\x07\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x9a\
    \x01\x08\x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x9a\x01\x1f\x20\n@\n\
    \x02\x04\x08\x12\x06\x9e\x01\0\xb2\x01\x01\x1a2\x20Specifies\x20a\x20con\
    tiguous\x20range\x20of\x20raw\x20byte\x20values.\n\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\x9e\x01\x08\x12\n~\n\x04\x04\x08\x08\0\x12\x06\xa1\x01\x02\
    \xa7\x01\x03\x1an\x20The\x20value\x20at\x20which\x20to\x20start\x20the\
    \x20range.\n\x20If\x20neither\x20field\x20is\x20set,\x20interpreted\x20a\
    s\x20the\x20empty\x20string,\x20inclusive.\n\n\r\n\x05\x04\x08\x08\0\x01\
    \x12\x04\xa1\x01\x08\x13\nH\n\x04\x04\x08\x02\0\x12\x04\xa3\x01\x04!\x1a\
    :\x20Used\x20when\x20giving\x20an\x20inclusive\x20lower\x20bound\x20for\
    \x20the\x20range.\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xa3\x01\x04\t\n\
    \r\n\x05\x04\x08\x02\0\x01\x12\x04\xa3\x01\n\x1c\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xa3\x01\x1f\x20\nH\n\x04\x04\x08\x02\x01\x12\x04\xa6\x01\
    \x04\x1f\x1a:\x20Used\x20when\x20giving\x20an\x20exclusive\x20lower\x20b\
    ound\x20for\x20the\x20range.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xa6\
    \x01\x04\t\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xa6\x01\n\x1a\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\xa6\x01\x1d\x1e\n\x7f\n\x04\x04\x08\x08\x01\
    \x12\x06\xab\x01\x02\xb1\x01\x03\x1ao\x20The\x20value\x20at\x20which\x20\
    to\x20end\x20the\x20range.\n\x20If\x20neither\x20field\x20is\x20set,\x20\
    interpreted\x20as\x20the\x20infinite\x20string,\x20exclusive.\n\n\r\n\
    \x05\x04\x08\x08\x01\x01\x12\x04\xab\x01\x08\x11\nH\n\x04\x04\x08\x02\
    \x02\x12\x04\xad\x01\x04\x1f\x1a:\x20Used\x20when\x20giving\x20an\x20inc\
    lusive\x20upper\x20bound\x20for\x20the\x20range.\n\n\r\n\x05\x04\x08\x02\
    \x02\x05\x12\x04\xad\x01\x04\t\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xad\
    \x01\n\x1a\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xad\x01\x1d\x1e\nH\n\
    \x04\x04\x08\x02\x03\x12\x04\xb0\x01\x04\x1d\x1a:\x20Used\x20when\x20giv\
    ing\x20an\x20exclusive\x20upper\x20bound\x20for\x20the\x20range.\n\n\r\n\
    \x05\x04\x08\x02\x03\x05\x12\x04\xb0\x01\x04\t\n\r\n\x05\x04\x08\x02\x03\
    \x01\x12\x04\xb0\x01\n\x18\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xb0\x01\
    \x1b\x1c\n\xa9\x0f\n\x02\x04\t\x12\x06\xd5\x01\0\xb8\x03\x01\x1a\x9a\x0f\
    \x20Takes\x20a\x20row\x20as\x20input\x20and\x20produces\x20an\x20alterna\
    te\x20view\x20of\x20the\x20row\x20based\x20on\n\x20specified\x20rules.\
    \x20For\x20example,\x20a\x20RowFilter\x20might\x20trim\x20down\x20a\x20r\
    ow\x20to\x20include\n\x20just\x20the\x20cells\x20from\x20columns\x20matc\
    hing\x20a\x20given\x20regular\x20expression,\x20or\x20might\n\x20return\
    \x20all\x20the\x20cells\x20of\x20a\x20row\x20but\x20not\x20their\x20valu\
    es.\x20More\x20complicated\x20filters\n\x20can\x20be\x20composed\x20out\
    \x20of\x20these\x20components\x20to\x20express\x20requests\x20such\x20as\
    ,\x20\"within\n\x20every\x20column\x20of\x20a\x20particular\x20family,\
    \x20give\x20just\x20the\x20two\x20most\x20recent\x20cells\n\x20which\x20\
    are\x20older\x20than\x20timestamp\x20X.\"\n\n\x20There\x20are\x20two\x20\
    broad\x20categories\x20of\x20RowFilters\x20(true\x20filters\x20and\x20tr\
    ansformers),\n\x20as\x20well\x20as\x20two\x20ways\x20to\x20compose\x20si\
    mple\x20filters\x20into\x20more\x20complex\x20ones\n\x20(chains\x20and\
    \x20interleaves).\x20They\x20work\x20as\x20follows:\n\n\x20*\x20True\x20\
    filters\x20alter\x20the\x20input\x20row\x20by\x20excluding\x20some\x20of\
    \x20its\x20cells\x20wholesale\n\x20from\x20the\x20output\x20row.\x20An\
    \x20example\x20of\x20a\x20true\x20filter\x20is\x20the\x20`value_regex_fi\
    lter`,\n\x20which\x20excludes\x20cells\x20whose\x20values\x20don't\x20ma\
    tch\x20the\x20specified\x20pattern.\x20All\n\x20regex\x20true\x20filters\
    \x20use\x20RE2\x20syntax\x20(https://github.com/google/re2/wiki/Syntax)\
    \n\x20in\x20raw\x20byte\x20mode\x20(RE2::Latin1),\x20and\x20are\x20evalu\
    ated\x20as\x20full\x20matches.\x20An\n\x20important\x20point\x20to\x20ke\
    ep\x20in\x20mind\x20is\x20that\x20`RE2(.)`\x20is\x20equivalent\x20by\x20\
    default\x20to\n\x20`RE2([^\\n])`,\x20meaning\x20that\x20it\x20does\x20no\
    t\x20match\x20newlines.\x20When\x20attempting\x20to\n\x20match\x20an\x20\
    arbitrary\x20byte,\x20you\x20should\x20therefore\x20use\x20the\x20escape\
    \x20sequence\x20`\\C`,\n\x20which\x20may\x20need\x20to\x20be\x20further\
    \x20escaped\x20as\x20`\\\\C`\x20in\x20your\x20client\x20language.\n\n\
    \x20*\x20Transformers\x20alter\x20the\x20input\x20row\x20by\x20changing\
    \x20the\x20values\x20of\x20some\x20of\x20its\n\x20cells\x20in\x20the\x20\
    output,\x20without\x20excluding\x20them\x20completely.\x20Currently,\x20\
    the\x20only\n\x20supported\x20transformer\x20is\x20the\x20`strip_value_t\
    ransformer`,\x20which\x20replaces\x20every\n\x20cell's\x20value\x20with\
    \x20the\x20empty\x20string.\n\n\x20*\x20Chains\x20and\x20interleaves\x20\
    are\x20described\x20in\x20more\x20detail\x20in\x20the\n\x20RowFilter.Cha\
    in\x20and\x20RowFilter.Interleave\x20documentation.\n\n\x20The\x20total\
    \x20serialized\x20size\x20of\x20a\x20RowFilter\x20message\x20must\x20not\
    \n\x20exceed\x204096\x20bytes,\x20and\x20RowFilters\x20may\x20not\x20be\
    \x20nested\x20within\x20each\x20other\n\x20(in\x20Chains\x20or\x20Interl\
    eaves)\x20to\x20a\x20depth\x20of\x20more\x20than\x2020.\n\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xd5\x01\x08\x11\nV\n\x04\x04\t\x03\0\x12\x06\xd7\x01\
    \x02\xdc\x01\x03\x1aF\x20A\x20RowFilter\x20which\x20sends\x20rows\x20thr\
    ough\x20several\x20RowFilters\x20in\x20sequence.\n\n\r\n\x05\x04\t\x03\0\
    \x01\x12\x04\xd7\x01\n\x0f\n\xc9\x01\n\x06\x04\t\x03\0\x02\0\x12\x04\xdb\
    \x01\x04#\x1a\xb8\x01\x20The\x20elements\x20of\x20\"filters\"\x20are\x20\
    chained\x20together\x20to\x20process\x20the\x20input\x20row:\n\x20in\x20\
    row\x20->\x20f(0)\x20->\x20intermediate\x20row\x20->\x20f(1)\x20->\x20..\
    .\x20->\x20f(N)\x20->\x20out\x20row\n\x20The\x20full\x20chain\x20is\x20e\
    xecuted\x20atomically.\n\n\x0f\n\x07\x04\t\x03\0\x02\0\x04\x12\x04\xdb\
    \x01\x04\x0c\n\x0f\n\x07\x04\t\x03\0\x02\0\x06\x12\x04\xdb\x01\r\x16\n\
    \x0f\n\x07\x04\t\x03\0\x02\0\x01\x12\x04\xdb\x01\x17\x1e\n\x0f\n\x07\x04\
    \t\x03\0\x02\0\x03\x12\x04\xdb\x01!\"\nx\n\x04\x04\t\x03\x01\x12\x06\xe0\
    \x01\x02\xfb\x01\x03\x1ah\x20A\x20RowFilter\x20which\x20sends\x20each\
    \x20row\x20to\x20each\x20of\x20several\x20component\n\x20RowFilters\x20a\
    nd\x20interleaves\x20the\x20results.\n\n\r\n\x05\x04\t\x03\x01\x01\x12\
    \x04\xe0\x01\n\x14\n\x93\x0b\n\x06\x04\t\x03\x01\x02\0\x12\x04\xfa\x01\
    \x04#\x1a\x82\x0b\x20The\x20elements\x20of\x20\"filters\"\x20all\x20proc\
    ess\x20a\x20copy\x20of\x20the\x20input\x20row,\x20and\x20the\n\x20result\
    s\x20are\x20pooled,\x20sorted,\x20and\x20combined\x20into\x20a\x20single\
    \x20output\x20row.\n\x20If\x20multiple\x20cells\x20are\x20produced\x20wi\
    th\x20the\x20same\x20column\x20and\x20timestamp,\n\x20they\x20will\x20al\
    l\x20appear\x20in\x20the\x20output\x20row\x20in\x20an\x20unspecified\x20\
    mutual\x20order.\n\x20Consider\x20the\x20following\x20example,\x20with\
    \x20three\x20filters:\n\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20input\x20row\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20------------------------------------------------\
    -----\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20f(0)\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20f(1)\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20f(2)\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x201:\x20foo,bar\
    ,10,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20foo,bar,10,z\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,bar,7,a\n\
    \x20\x20\x20\x20\x202:\x20foo,blah,11,z\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20far,blah,5,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20far,blah,5,x\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20------------------------\
    -----------------------------\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x201:\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20foo,bar,10,z\x20\x20\x20//\x20could\x20have\x20switched\x20w\
    ith\x20#2\n\x20\x20\x20\x20\x202:\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20foo,bar,10,x\x20\x20\
    \x20//\x20could\x20have\x20switched\x20with\x20#1\n\x20\x20\x20\x20\x203\
    :\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20foo,blah,11,z\n\x20\x20\x20\x20\x204:\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20far,bar,7,a\n\x20\x20\x20\x20\x205:\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,blah,5,x\x20\
    \x20\x20//\x20identical\x20to\x20#6\n\x20\x20\x20\x20\x206:\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20far,blah,5,x\x20\x20\x20//\x20identical\x20to\x20#5\n\n\x20All\x20in\
    terleaved\x20filters\x20are\x20executed\x20atomically.\n\n\x0f\n\x07\x04\
    \t\x03\x01\x02\0\x04\x12\x04\xfa\x01\x04\x0c\n\x0f\n\x07\x04\t\x03\x01\
    \x02\0\x06\x12\x04\xfa\x01\r\x16\n\x0f\n\x07\x04\t\x03\x01\x02\0\x01\x12\
    \x04\xfa\x01\x17\x1e\n\x0f\n\x07\x04\t\x03\x01\x02\0\x03\x12\x04\xfa\x01\
    !\"\n\xb4\x03\n\x04\x04\t\x03\x02\x12\x06\x84\x02\x02\x91\x02\x03\x1a\
    \xa3\x03\x20A\x20RowFilter\x20which\x20evaluates\x20one\x20of\x20two\x20\
    possible\x20RowFilters,\x20depending\x20on\n\x20whether\x20or\x20not\x20\
    a\x20predicate\x20RowFilter\x20outputs\x20any\x20cells\x20from\x20the\
    \x20input\x20row.\n\n\x20IMPORTANT\x20NOTE:\x20The\x20predicate\x20filte\
    r\x20does\x20not\x20execute\x20atomically\x20with\x20the\n\x20true\x20an\
    d\x20false\x20filters,\x20which\x20may\x20lead\x20to\x20inconsistent\x20\
    or\x20unexpected\n\x20results.\x20Additionally,\x20Condition\x20filters\
    \x20have\x20poor\x20performance,\x20especially\n\x20when\x20filters\x20a\
    re\x20set\x20for\x20the\x20false\x20condition.\n\n\r\n\x05\x04\t\x03\x02\
    \x01\x12\x04\x84\x02\n\x13\n\xa0\x01\n\x06\x04\t\x03\x02\x02\0\x12\x04\
    \x87\x02\x04#\x1a\x8f\x01\x20If\x20`predicate_filter`\x20outputs\x20any\
    \x20cells,\x20then\x20`true_filter`\x20will\x20be\n\x20evaluated\x20on\
    \x20the\x20input\x20row.\x20Otherwise,\x20`false_filter`\x20will\x20be\
    \x20evaluated.\n\n\x0f\n\x07\x04\t\x03\x02\x02\0\x06\x12\x04\x87\x02\x04\
    \r\n\x0f\n\x07\x04\t\x03\x02\x02\0\x01\x12\x04\x87\x02\x0e\x1e\n\x0f\n\
    \x07\x04\t\x03\x02\x02\0\x03\x12\x04\x87\x02!\"\n\xa2\x01\n\x06\x04\t\
    \x03\x02\x02\x01\x12\x04\x8b\x02\x04\x1e\x1a\x91\x01\x20The\x20filter\
    \x20to\x20apply\x20to\x20the\x20input\x20row\x20if\x20`predicate_filter`\
    \x20returns\x20any\n\x20results.\x20If\x20not\x20provided,\x20no\x20resu\
    lts\x20will\x20be\x20returned\x20in\x20the\x20true\x20case.\n\n\x0f\n\
    \x07\x04\t\x03\x02\x02\x01\x06\x12\x04\x8b\x02\x04\r\n\x0f\n\x07\x04\t\
    \x03\x02\x02\x01\x01\x12\x04\x8b\x02\x0e\x19\n\x0f\n\x07\x04\t\x03\x02\
    \x02\x01\x03\x12\x04\x8b\x02\x1c\x1d\n\xac\x01\n\x06\x04\t\x03\x02\x02\
    \x02\x12\x04\x90\x02\x04\x1f\x1a\x9b\x01\x20The\x20filter\x20to\x20apply\
    \x20to\x20the\x20input\x20row\x20if\x20`predicate_filter`\x20does\x20not\
    \n\x20return\x20any\x20results.\x20If\x20not\x20provided,\x20no\x20resul\
    ts\x20will\x20be\x20returned\x20in\x20the\n\x20false\x20case.\n\n\x0f\n\
    \x07\x04\t\x03\x02\x02\x02\x06\x12\x04\x90\x02\x04\r\n\x0f\n\x07\x04\t\
    \x03\x02\x02\x02\x01\x12\x04\x90\x02\x0e\x1a\n\x0f\n\x07\x04\t\x03\x02\
    \x02\x02\x03\x12\x04\x90\x02\x1d\x1e\n\x86\x01\n\x04\x04\t\x08\0\x12\x06\
    \x95\x02\x02\xb7\x03\x03\x1av\x20Which\x20of\x20the\x20possible\x20RowFi\
    lter\x20types\x20to\x20apply.\x20If\x20none\x20are\x20set,\x20this\n\x20\
    RowFilter\x20returns\x20all\x20cells\x20in\x20the\x20input\x20row.\n\n\r\
    \n\x05\x04\t\x08\0\x01\x12\x04\x95\x02\x08\x0e\ni\n\x04\x04\t\x02\0\x12\
    \x04\x98\x02\x04\x14\x1a[\x20Applies\x20several\x20RowFilters\x20to\x20t\
    he\x20data\x20in\x20sequence,\x20progressively\n\x20narrowing\x20the\x20\
    results.\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x98\x02\x04\t\n\r\n\x05\x04\
    \t\x02\0\x01\x12\x04\x98\x02\n\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x98\
    \x02\x12\x13\n]\n\x04\x04\t\x02\x01\x12\x04\x9c\x02\x04\x1e\x1aO\x20Appl\
    ies\x20several\x20RowFilters\x20to\x20the\x20data\x20in\x20parallel\x20a\
    nd\x20combines\x20the\n\x20results.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\
    \x04\x9c\x02\x04\x0e\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x9c\x02\x0f\x19\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x9c\x02\x1c\x1d\nq\n\x04\x04\t\x02\
    \x02\x12\x04\xa0\x02\x04\x1c\x1ac\x20Applies\x20one\x20of\x20two\x20poss\
    ible\x20RowFilters\x20to\x20the\x20data\x20based\x20on\x20the\x20output\
    \x20of\n\x20a\x20predicate\x20RowFilter.\n\n\r\n\x05\x04\t\x02\x02\x06\
    \x12\x04\xa0\x02\x04\r\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xa0\x02\x0e\
    \x17\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xa0\x02\x1a\x1b\n\xb7\x14\n\x04\
    \x04\t\x02\x03\x12\x04\xdd\x02\x04\x13\x1a\xa8\x14\x20ADVANCED\x20USE\
    \x20ONLY.\n\x20Hook\x20for\x20introspection\x20into\x20the\x20RowFilter.\
    \x20Outputs\x20all\x20cells\x20directly\x20to\n\x20the\x20output\x20of\
    \x20the\x20read\x20rather\x20than\x20to\x20any\x20parent\x20filter.\x20C\
    onsider\x20the\n\x20following\x20example:\n\n\x20\x20\x20\x20\x20Chain(\
    \n\x20\x20\x20\x20\x20\x20\x20FamilyRegex(\"A\"),\n\x20\x20\x20\x20\x20\
    \x20\x20Interleave(\n\x20\x20\x20\x20\x20\x20\x20\x20\x20All(),\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20Chain(Label(\"foo\"),\x20Sink())\n\x20\
    \x20\x20\x20\x20\x20\x20),\n\x20\x20\x20\x20\x20\x20\x20QualifierRegex(\
    \"B\")\n\x20\x20\x20\x20\x20)\n\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,A,1,w\
    \n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    B,B,4,z\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20Fami\
    lyRegex(\"A\")\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,A,1,w\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20+------------+-------------+\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20All()\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20Label(foo)\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20A,A,1,w\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,A,1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,B,2,x,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20Sink()\x20--------------+\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20+------------+\x20\
    \x20\x20\x20\x20\x20x------+\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,A,\
    1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,B,2,x,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,A,\
    1,w\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20QualifierRegex(\"B\")\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20+-----------------------\
    ---------+\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20A,A,1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x,\
    labels:[foo]\x20\x20//\x20could\x20be\x20switched\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20//\x20could\x20be\x20switched\n\n\x20Despite\x20being\x20excluded\
    \x20by\x20the\x20qualifier\x20filter,\x20a\x20copy\x20of\x20every\x20cel\
    l\n\x20that\x20reaches\x20the\x20sink\x20is\x20present\x20in\x20the\x20f\
    inal\x20result.\n\n\x20As\x20with\x20an\x20[Interleave][google.bigtable.\
    v2.RowFilter.Interleave],\n\x20duplicate\x20cells\x20are\x20possible,\
    \x20and\x20appear\x20in\x20an\x20unspecified\x20mutual\x20order.\n\x20In\
    \x20this\x20case\x20we\x20have\x20a\x20duplicate\x20with\x20column\x20\"\
    A:B\"\x20and\x20timestamp\x202,\n\x20because\x20one\x20copy\x20passed\
    \x20through\x20the\x20all\x20filter\x20while\x20the\x20other\x20was\n\
    \x20passed\x20through\x20the\x20label\x20and\x20sink.\x20Note\x20that\
    \x20one\x20copy\x20has\x20label\x20\"foo\",\n\x20while\x20the\x20other\
    \x20does\x20not.\n\n\x20Cannot\x20be\x20used\x20within\x20the\x20`predic\
    ate_filter`,\x20`true_filter`,\x20or\n\x20`false_filter`\x20of\x20a\x20[\
    Condition][google.bigtable.v2.RowFilter.Condition].\n\n\r\n\x05\x04\t\
    \x02\x03\x05\x12\x04\xdd\x02\x04\x08\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\
    \xdd\x02\t\r\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xdd\x02\x10\x12\n\x8a\
    \x01\n\x04\x04\t\x02\x04\x12\x04\xe1\x02\x04\x1e\x1a|\x20Matches\x20all\
    \x20cells,\x20regardless\x20of\x20input.\x20Functionally\x20equivalent\
    \x20to\n\x20leaving\x20`filter`\x20unset,\x20but\x20included\x20for\x20c\
    ompleteness.\n\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xe1\x02\x04\x08\n\r\n\
    \x05\x04\t\x02\x04\x01\x12\x04\xe1\x02\t\x18\n\r\n\x05\x04\t\x02\x04\x03\
    \x12\x04\xe1\x02\x1b\x1d\nw\n\x04\x04\t\x02\x05\x12\x04\xe5\x02\x04\x1f\
    \x1ai\x20Does\x20not\x20match\x20any\x20cells,\x20regardless\x20of\x20in\
    put.\x20Useful\x20for\x20temporarily\n\x20disabling\x20just\x20part\x20o\
    f\x20a\x20filter.\n\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xe5\x02\x04\x08\
    \n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xe5\x02\t\x19\n\r\n\x05\x04\t\x02\
    \x05\x03\x12\x04\xe5\x02\x1c\x1e\n\xa4\x03\n\x04\x04\t\x02\x06\x12\x04\
    \xee\x02\x04#\x1a\x95\x03\x20Matches\x20only\x20cells\x20from\x20rows\
    \x20whose\x20keys\x20satisfy\x20the\x20given\x20RE2\x20regex.\x20In\n\
    \x20other\x20words,\x20passes\x20through\x20the\x20entire\x20row\x20when\
    \x20the\x20key\x20matches,\x20and\n\x20otherwise\x20produces\x20an\x20em\
    pty\x20row.\n\x20Note\x20that,\x20since\x20row\x20keys\x20can\x20contain\
    \x20arbitrary\x20bytes,\x20the\x20`\\C`\x20escape\n\x20sequence\x20must\
    \x20be\x20used\x20if\x20a\x20true\x20wildcard\x20is\x20desired.\x20The\
    \x20`.`\x20character\n\x20will\x20not\x20match\x20the\x20new\x20line\x20\
    character\x20`\\n`,\x20which\x20may\x20be\x20present\x20in\x20a\n\x20bin\
    ary\x20key.\n\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xee\x02\x04\t\n\r\n\
    \x05\x04\t\x02\x06\x01\x12\x04\xee\x02\n\x1e\n\r\n\x05\x04\t\x02\x06\x03\
    \x12\x04\xee\x02!\"\ny\n\x04\x04\t\x02\x07\x12\x04\xf2\x02\x04\"\x1ak\
    \x20Matches\x20all\x20cells\x20from\x20a\x20row\x20with\x20probability\
    \x20p,\x20and\x20matches\x20no\x20cells\n\x20from\x20the\x20row\x20with\
    \x20probability\x201-p.\n\n\r\n\x05\x04\t\x02\x07\x05\x12\x04\xf2\x02\
    \x04\n\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xf2\x02\x0b\x1c\n\r\n\x05\x04\
    \t\x02\x07\x03\x12\x04\xf2\x02\x1f!\n\xf0\x02\n\x04\x04\t\x02\x08\x12\
    \x04\xfa\x02\x04(\x1a\xe1\x02\x20Matches\x20only\x20cells\x20from\x20col\
    umns\x20whose\x20families\x20satisfy\x20the\x20given\x20RE2\n\x20regex.\
    \x20For\x20technical\x20reasons,\x20the\x20regex\x20must\x20not\x20conta\
    in\x20the\x20`:`\n\x20character,\x20even\x20if\x20it\x20is\x20not\x20bei\
    ng\x20used\x20as\x20a\x20literal.\n\x20Note\x20that,\x20since\x20column\
    \x20families\x20cannot\x20contain\x20the\x20new\x20line\x20character\n\
    \x20`\\n`,\x20it\x20is\x20sufficient\x20to\x20use\x20`.`\x20as\x20a\x20f\
    ull\x20wildcard\x20when\x20matching\n\x20column\x20family\x20names.\n\n\
    \r\n\x05\x04\t\x02\x08\x05\x12\x04\xfa\x02\x04\n\n\r\n\x05\x04\t\x02\x08\
    \x01\x12\x04\xfa\x02\x0b#\n\r\n\x05\x04\t\x02\x08\x03\x12\x04\xfa\x02&'\
    \n\xd2\x02\n\x04\x04\t\x02\t\x12\x04\x82\x03\x04,\x1a\xc3\x02\x20Matches\
    \x20only\x20cells\x20from\x20columns\x20whose\x20qualifiers\x20satisfy\
    \x20the\x20given\x20RE2\n\x20regex.\n\x20Note\x20that,\x20since\x20colum\
    n\x20qualifiers\x20can\x20contain\x20arbitrary\x20bytes,\x20the\x20`\\C`\
    \n\x20escape\x20sequence\x20must\x20be\x20used\x20if\x20a\x20true\x20wil\
    dcard\x20is\x20desired.\x20The\x20`.`\n\x20character\x20will\x20not\x20m\
    atch\x20the\x20new\x20line\x20character\x20`\\n`,\x20which\x20may\x20be\
    \n\x20present\x20in\x20a\x20binary\x20qualifier.\n\n\r\n\x05\x04\t\x02\t\
    \x05\x12\x04\x82\x03\x04\t\n\r\n\x05\x04\t\x02\t\x01\x12\x04\x82\x03\n'\
    \n\r\n\x05\x04\t\x02\t\x03\x12\x04\x82\x03*+\nG\n\x04\x04\t\x02\n\x12\
    \x04\x85\x03\x04(\x1a9\x20Matches\x20only\x20cells\x20from\x20columns\
    \x20within\x20the\x20given\x20range.\n\n\r\n\x05\x04\t\x02\n\x06\x12\x04\
    \x85\x03\x04\x0f\n\r\n\x05\x04\t\x02\n\x01\x12\x04\x85\x03\x10#\n\r\n\
    \x05\x04\t\x02\n\x03\x12\x04\x85\x03&'\nJ\n\x04\x04\t\x02\x0b\x12\x04\
    \x88\x03\x04.\x1a<\x20Matches\x20only\x20cells\x20with\x20timestamps\x20\
    within\x20the\x20given\x20range.\n\n\r\n\x05\x04\t\x02\x0b\x06\x12\x04\
    \x88\x03\x04\x12\n\r\n\x05\x04\t\x02\x0b\x01\x12\x04\x88\x03\x13)\n\r\n\
    \x05\x04\t\x02\x0b\x03\x12\x04\x88\x03,-\n\xc3\x02\n\x04\x04\t\x02\x0c\
    \x12\x04\x8f\x03\x04!\x1a\xb4\x02\x20Matches\x20only\x20cells\x20with\
    \x20values\x20that\x20satisfy\x20the\x20given\x20regular\x20expression.\
    \n\x20Note\x20that,\x20since\x20cell\x20values\x20can\x20contain\x20arbi\
    trary\x20bytes,\x20the\x20`\\C`\x20escape\n\x20sequence\x20must\x20be\
    \x20used\x20if\x20a\x20true\x20wildcard\x20is\x20desired.\x20The\x20`.`\
    \x20character\n\x20will\x20not\x20match\x20the\x20new\x20line\x20charact\
    er\x20`\\n`,\x20which\x20may\x20be\x20present\x20in\x20a\n\x20binary\x20\
    value.\n\n\r\n\x05\x04\t\x02\x0c\x05\x12\x04\x8f\x03\x04\t\n\r\n\x05\x04\
    \t\x02\x0c\x01\x12\x04\x8f\x03\n\x1c\n\r\n\x05\x04\t\x02\x0c\x03\x12\x04\
    \x8f\x03\x1f\x20\nP\n\x04\x04\t\x02\r\x12\x04\x92\x03\x04'\x1aB\x20Match\
    es\x20only\x20cells\x20with\x20values\x20that\x20fall\x20within\x20the\
    \x20given\x20range.\n\n\r\n\x05\x04\t\x02\r\x06\x12\x04\x92\x03\x04\x0e\
    \n\r\n\x05\x04\t\x02\r\x01\x12\x04\x92\x03\x0f!\n\r\n\x05\x04\t\x02\r\
    \x03\x12\x04\x92\x03$&\n\xcc\x01\n\x04\x04\t\x02\x0e\x12\x04\x97\x03\x04\
    +\x1a\xbd\x01\x20Skips\x20the\x20first\x20N\x20cells\x20of\x20each\x20ro\
    w,\x20matching\x20all\x20subsequent\x20cells.\n\x20If\x20duplicate\x20ce\
    lls\x20are\x20present,\x20as\x20is\x20possible\x20when\x20using\x20an\
    \x20Interleave,\n\x20each\x20copy\x20of\x20the\x20cell\x20is\x20counted\
    \x20separately.\n\n\r\n\x05\x04\t\x02\x0e\x05\x12\x04\x97\x03\x04\t\n\r\
    \n\x05\x04\t\x02\x0e\x01\x12\x04\x97\x03\n%\n\r\n\x05\x04\t\x02\x0e\x03\
    \x12\x04\x97\x03(*\n\xb4\x01\n\x04\x04\t\x02\x0f\x12\x04\x9c\x03\x04*\
    \x1a\xa5\x01\x20Matches\x20only\x20the\x20first\x20N\x20cells\x20of\x20e\
    ach\x20row.\n\x20If\x20duplicate\x20cells\x20are\x20present,\x20as\x20is\
    \x20possible\x20when\x20using\x20an\x20Interleave,\n\x20each\x20copy\x20\
    of\x20the\x20cell\x20is\x20counted\x20separately.\n\n\r\n\x05\x04\t\x02\
    \x0f\x05\x12\x04\x9c\x03\x04\t\n\r\n\x05\x04\t\x02\x0f\x01\x12\x04\x9c\
    \x03\n$\n\r\n\x05\x04\t\x02\x0f\x03\x12\x04\x9c\x03')\n\xf3\x02\n\x04\
    \x04\t\x02\x10\x12\x04\xa4\x03\x04-\x1a\xe4\x02\x20Matches\x20only\x20th\
    e\x20most\x20recent\x20N\x20cells\x20within\x20each\x20column.\x20For\
    \x20example,\n\x20if\x20N=2,\x20this\x20filter\x20would\x20match\x20colu\
    mn\x20`foo:bar`\x20at\x20timestamps\x2010\x20and\x209,\n\x20skip\x20all\
    \x20earlier\x20cells\x20in\x20`foo:bar`,\x20and\x20then\x20begin\x20matc\
    hing\x20again\x20in\n\x20column\x20`foo:bar2`.\n\x20If\x20duplicate\x20c\
    ells\x20are\x20present,\x20as\x20is\x20possible\x20when\x20using\x20an\
    \x20Interleave,\n\x20each\x20copy\x20of\x20the\x20cell\x20is\x20counted\
    \x20separately.\n\n\r\n\x05\x04\t\x02\x10\x05\x12\x04\xa4\x03\x04\t\n\r\
    \n\x05\x04\t\x02\x10\x01\x12\x04\xa4\x03\n'\n\r\n\x05\x04\t\x02\x10\x03\
    \x12\x04\xa4\x03*,\nA\n\x04\x04\t\x02\x11\x12\x04\xa7\x03\x04&\x1a3\x20R\
    eplaces\x20each\x20cell's\x20value\x20with\x20the\x20empty\x20string.\n\
    \n\r\n\x05\x04\t\x02\x11\x05\x12\x04\xa7\x03\x04\x08\n\r\n\x05\x04\t\x02\
    \x11\x01\x12\x04\xa7\x03\t\x20\n\r\n\x05\x04\t\x02\x11\x03\x12\x04\xa7\
    \x03#%\n\xfb\x04\n\x04\x04\t\x02\x12\x12\x04\xb6\x03\x04(\x1a\xec\x04\
    \x20Applies\x20the\x20given\x20label\x20to\x20all\x20cells\x20in\x20the\
    \x20output\x20row.\x20This\x20allows\n\x20the\x20client\x20to\x20determi\
    ne\x20which\x20results\x20were\x20produced\x20from\x20which\x20part\x20o\
    f\n\x20the\x20filter.\n\n\x20Values\x20must\x20be\x20at\x20most\x2015\
    \x20characters\x20in\x20length,\x20and\x20match\x20the\x20RE2\n\x20patte\
    rn\x20`[a-z0-9\\\\-]+`\n\n\x20Due\x20to\x20a\x20technical\x20limitation,\
    \x20it\x20is\x20not\x20currently\x20possible\x20to\x20apply\n\x20multipl\
    e\x20labels\x20to\x20a\x20cell.\x20As\x20a\x20result,\x20a\x20Chain\x20m\
    ay\x20have\x20no\x20more\x20than\n\x20one\x20sub-filter\x20which\x20cont\
    ains\x20a\x20`apply_label_transformer`.\x20It\x20is\x20okay\x20for\n\x20\
    an\x20Interleave\x20to\x20contain\x20multiple\x20`apply_label_transforme\
    rs`,\x20as\x20they\n\x20will\x20be\x20applied\x20to\x20separate\x20copie\
    s\x20of\x20the\x20input.\x20This\x20may\x20be\x20relaxed\x20in\n\x20the\
    \x20future.\n\n\r\n\x05\x04\t\x02\x12\x05\x12\x04\xb6\x03\x04\n\n\r\n\
    \x05\x04\t\x02\x12\x01\x12\x04\xb6\x03\x0b\"\n\r\n\x05\x04\t\x02\x12\x03\
    \x12\x04\xb6\x03%'\nR\n\x02\x04\n\x12\x06\xbb\x03\0\xfa\x03\x01\x1aD\x20\
    Specifies\x20a\x20particular\x20change\x20to\x20be\x20made\x20to\x20the\
    \x20contents\x20of\x20a\x20row.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xbb\x03\
    \x08\x10\nH\n\x04\x04\n\x03\0\x12\x06\xbd\x03\x02\xcf\x03\x03\x1a8\x20A\
    \x20Mutation\x20which\x20sets\x20the\x20value\x20of\x20the\x20specified\
    \x20cell.\n\n\r\n\x05\x04\n\x03\0\x01\x12\x04\xbd\x03\n\x11\nm\n\x06\x04\
    \n\x03\0\x02\0\x12\x04\xc0\x03\x04\x1b\x1a]\x20The\x20name\x20of\x20the\
    \x20family\x20into\x20which\x20new\x20data\x20should\x20be\x20written.\n\
    \x20Must\x20match\x20`[-_.a-zA-Z0-9]+`\n\n\x0f\n\x07\x04\n\x03\0\x02\0\
    \x05\x12\x04\xc0\x03\x04\n\n\x0f\n\x07\x04\n\x03\0\x02\0\x01\x12\x04\xc0\
    \x03\x0b\x16\n\x0f\n\x07\x04\n\x03\0\x02\0\x03\x12\x04\xc0\x03\x19\x1a\n\
    \x89\x01\n\x06\x04\n\x03\0\x02\x01\x12\x04\xc4\x03\x04\x1f\x1ay\x20The\
    \x20qualifier\x20of\x20the\x20column\x20into\x20which\x20new\x20data\x20\
    should\x20be\x20written.\n\x20Can\x20be\x20any\x20byte\x20string,\x20inc\
    luding\x20the\x20empty\x20string.\n\n\x0f\n\x07\x04\n\x03\0\x02\x01\x05\
    \x12\x04\xc4\x03\x04\t\n\x0f\n\x07\x04\n\x03\0\x02\x01\x01\x12\x04\xc4\
    \x03\n\x1a\n\x0f\n\x07\x04\n\x03\0\x02\x01\x03\x12\x04\xc4\x03\x1d\x1e\n\
    \xd1\x02\n\x06\x04\n\x03\0\x02\x02\x12\x04\xcb\x03\x04\x1f\x1a\xc0\x02\
    \x20The\x20timestamp\x20of\x20the\x20cell\x20into\x20which\x20new\x20dat\
    a\x20should\x20be\x20written.\n\x20Use\x20-1\x20for\x20current\x20Bigtab\
    le\x20server\x20time.\n\x20Otherwise,\x20the\x20client\x20should\x20set\
    \x20this\x20value\x20itself,\x20noting\x20that\x20the\n\x20default\x20va\
    lue\x20is\x20a\x20timestamp\x20of\x20zero\x20if\x20the\x20field\x20is\
    \x20left\x20unspecified.\n\x20Values\x20must\x20match\x20the\x20granular\
    ity\x20of\x20the\x20table\x20(e.g.\x20micros,\x20millis).\n\n\x0f\n\x07\
    \x04\n\x03\0\x02\x02\x05\x12\x04\xcb\x03\x04\t\n\x0f\n\x07\x04\n\x03\0\
    \x02\x02\x01\x12\x04\xcb\x03\n\x1a\n\x0f\n\x07\x04\n\x03\0\x02\x02\x03\
    \x12\x04\xcb\x03\x1d\x1e\nB\n\x06\x04\n\x03\0\x02\x03\x12\x04\xce\x03\
    \x04\x14\x1a2\x20The\x20value\x20to\x20be\x20written\x20into\x20the\x20s\
    pecified\x20cell.\n\n\x0f\n\x07\x04\n\x03\0\x02\x03\x05\x12\x04\xce\x03\
    \x04\t\n\x0f\n\x07\x04\n\x03\0\x02\x03\x01\x12\x04\xce\x03\n\x0f\n\x0f\n\
    \x07\x04\n\x03\0\x02\x03\x03\x12\x04\xce\x03\x12\x13\n\x8d\x01\n\x04\x04\
    \n\x03\x01\x12\x06\xd3\x03\x02\xde\x03\x03\x1a}\x20A\x20Mutation\x20whic\
    h\x20deletes\x20cells\x20from\x20the\x20specified\x20column,\x20optional\
    ly\n\x20restricting\x20the\x20deletions\x20to\x20a\x20given\x20timestamp\
    \x20range.\n\n\r\n\x05\x04\n\x03\x01\x01\x12\x04\xd3\x03\n\x1a\nj\n\x06\
    \x04\n\x03\x01\x02\0\x12\x04\xd6\x03\x04\x1b\x1aZ\x20The\x20name\x20of\
    \x20the\x20family\x20from\x20which\x20cells\x20should\x20be\x20deleted.\
    \n\x20Must\x20match\x20`[-_.a-zA-Z0-9]+`\n\n\x0f\n\x07\x04\n\x03\x01\x02\
    \0\x05\x12\x04\xd6\x03\x04\n\n\x0f\n\x07\x04\n\x03\x01\x02\0\x01\x12\x04\
    \xd6\x03\x0b\x16\n\x0f\n\x07\x04\n\x03\x01\x02\0\x03\x12\x04\xd6\x03\x19\
    \x1a\n\x86\x01\n\x06\x04\n\x03\x01\x02\x01\x12\x04\xda\x03\x04\x1f\x1av\
    \x20The\x20qualifier\x20of\x20the\x20column\x20from\x20which\x20cells\
    \x20should\x20be\x20deleted.\n\x20Can\x20be\x20any\x20byte\x20string,\
    \x20including\x20the\x20empty\x20string.\n\n\x0f\n\x07\x04\n\x03\x01\x02\
    \x01\x05\x12\x04\xda\x03\x04\t\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x01\x12\
    \x04\xda\x03\n\x1a\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x03\x12\x04\xda\x03\
    \x1d\x1e\nO\n\x06\x04\n\x03\x01\x02\x02\x12\x04\xdd\x03\x04\"\x1a?\x20Th\
    e\x20range\x20of\x20timestamps\x20within\x20which\x20cells\x20should\x20\
    be\x20deleted.\n\n\x0f\n\x07\x04\n\x03\x01\x02\x02\x06\x12\x04\xdd\x03\
    \x04\x12\n\x0f\n\x07\x04\n\x03\x01\x02\x02\x01\x12\x04\xdd\x03\x13\x1d\n\
    \x0f\n\x07\x04\n\x03\x01\x02\x02\x03\x12\x04\xdd\x03\x20!\nV\n\x04\x04\n\
    \x03\x02\x12\x06\xe1\x03\x02\xe5\x03\x03\x1aF\x20A\x20Mutation\x20which\
    \x20deletes\x20all\x20cells\x20from\x20the\x20specified\x20column\x20fam\
    ily.\n\n\r\n\x05\x04\n\x03\x02\x01\x12\x04\xe1\x03\n\x1a\nj\n\x06\x04\n\
    \x03\x02\x02\0\x12\x04\xe4\x03\x04\x1b\x1aZ\x20The\x20name\x20of\x20the\
    \x20family\x20from\x20which\x20cells\x20should\x20be\x20deleted.\n\x20Mu\
    st\x20match\x20`[-_.a-zA-Z0-9]+`\n\n\x0f\n\x07\x04\n\x03\x02\x02\0\x05\
    \x12\x04\xe4\x03\x04\n\n\x0f\n\x07\x04\n\x03\x02\x02\0\x01\x12\x04\xe4\
    \x03\x0b\x16\n\x0f\n\x07\x04\n\x03\x02\x02\0\x03\x12\x04\xe4\x03\x19\x1a\
    \nM\n\x04\x04\n\x03\x03\x12\x06\xe8\x03\x02\xea\x03\x03\x1a=\x20A\x20Mut\
    ation\x20which\x20deletes\x20all\x20cells\x20from\x20the\x20containing\
    \x20row.\n\n\r\n\x05\x04\n\x03\x03\x01\x12\x04\xe8\x03\n\x17\n@\n\x04\
    \x04\n\x08\0\x12\x06\xed\x03\x02\xf9\x03\x03\x1a0\x20Which\x20of\x20the\
    \x20possible\x20Mutation\x20types\x20to\x20apply.\n\n\r\n\x05\x04\n\x08\
    \0\x01\x12\x04\xed\x03\x08\x10\n#\n\x04\x04\n\x02\0\x12\x04\xef\x03\x04\
    \x19\x1a\x15\x20Set\x20a\x20cell's\x20value.\n\n\r\n\x05\x04\n\x02\0\x06\
    \x12\x04\xef\x03\x04\x0b\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xef\x03\x0c\
    \x14\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xef\x03\x17\x18\n,\n\x04\x04\n\
    \x02\x01\x12\x04\xf2\x03\x04,\x1a\x1e\x20Deletes\x20cells\x20from\x20a\
    \x20column.\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xf2\x03\x04\x14\n\r\n\
    \x05\x04\n\x02\x01\x01\x12\x04\xf2\x03\x15'\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\xf2\x03*+\n3\n\x04\x04\n\x02\x02\x12\x04\xf5\x03\x04,\x1a%\x20D\
    eletes\x20cells\x20from\x20a\x20column\x20family.\n\n\r\n\x05\x04\n\x02\
    \x02\x06\x12\x04\xf5\x03\x04\x14\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xf5\
    \x03\x15'\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xf5\x03*+\n2\n\x04\x04\n\
    \x02\x03\x12\x04\xf8\x03\x04&\x1a$\x20Deletes\x20cells\x20from\x20the\
    \x20entire\x20row.\n\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\xf8\x03\x04\x11\
    \n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xf8\x03\x12!\n\r\n\x05\x04\n\x02\
    \x03\x03\x12\x04\xf8\x03$%\nm\n\x02\x04\x0b\x12\x06\xfe\x03\0\x96\x04\
    \x01\x1a_\x20Specifies\x20an\x20atomic\x20read/modify/write\x20operation\
    \x20on\x20the\x20latest\x20value\x20of\x20the\n\x20specified\x20column.\
    \n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xfe\x03\x08\x1b\nv\n\x04\x04\x0b\x02\
    \0\x12\x04\x81\x04\x02\x19\x1ah\x20The\x20name\x20of\x20the\x20family\
    \x20to\x20which\x20the\x20read/modify/write\x20should\x20be\x20applied.\
    \n\x20Must\x20match\x20`[-_.a-zA-Z0-9]+`\n\n\r\n\x05\x04\x0b\x02\0\x05\
    \x12\x04\x81\x04\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x81\x04\t\
    \x14\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x81\x04\x17\x18\n\x94\x01\n\x04\
    \x04\x0b\x02\x01\x12\x04\x86\x04\x02\x1d\x1a\x85\x01\x20The\x20qualifier\
    \x20of\x20the\x20column\x20to\x20which\x20the\x20read/modify/write\x20sh\
    ould\x20be\n\x20applied.\n\x20Can\x20be\x20any\x20byte\x20string,\x20inc\
    luding\x20the\x20empty\x20string.\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\
    \x04\x86\x04\x02\x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x86\x04\x08\
    \x18\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x86\x04\x1b\x1c\nj\n\x04\x04\
    \x0b\x08\0\x12\x06\x8a\x04\x02\x95\x04\x03\x1aZ\x20The\x20rule\x20used\
    \x20to\x20determine\x20the\x20column's\x20new\x20latest\x20value\x20from\
    \x20its\x20current\n\x20latest\x20value.\n\n\r\n\x05\x04\x0b\x08\0\x01\
    \x12\x04\x8a\x04\x08\x0c\n\xab\x01\n\x04\x04\x0b\x02\x02\x12\x04\x8e\x04\
    \x04\x1b\x1a\x9c\x01\x20Rule\x20specifying\x20that\x20`append_value`\x20\
    be\x20appended\x20to\x20the\x20existing\x20value.\n\x20If\x20the\x20targ\
    eted\x20cell\x20is\x20unset,\x20it\x20will\x20be\x20treated\x20as\x20con\
    taining\x20the\n\x20empty\x20string.\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\
    \x04\x8e\x04\x04\t\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x8e\x04\n\x16\n\
    \r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x8e\x04\x19\x1a\n\xb3\x02\n\x04\x04\
    \x0b\x02\x03\x12\x04\x94\x04\x04\x1f\x1a\xa4\x02\x20Rule\x20specifying\
    \x20that\x20`increment_amount`\x20be\x20added\x20to\x20the\x20existing\
    \x20value.\n\x20If\x20the\x20targeted\x20cell\x20is\x20unset,\x20it\x20w\
    ill\x20be\x20treated\x20as\x20containing\x20a\x20zero.\n\x20Otherwise,\
    \x20the\x20targeted\x20cell\x20must\x20contain\x20an\x208-byte\x20value\
    \x20(interpreted\n\x20as\x20a\x2064-bit\x20big-endian\x20signed\x20integ\
    er),\x20or\x20the\x20entire\x20request\x20will\x20fail.\n\n\r\n\x05\x04\
    \x0b\x02\x03\x05\x12\x04\x94\x04\x04\t\n\r\n\x05\x04\x0b\x02\x03\x01\x12\
    \x04\x94\x04\n\x1a\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x94\x04\x1d\x1e\
    b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(19);
            messages.push(Row::generated_message_descriptor_data());
            messages.push(Family::generated_message_descriptor_data());
            messages.push(Column::generated_message_descriptor_data());
            messages.push(Cell::generated_message_descriptor_data());
            messages.push(RowRange::generated_message_descriptor_data());
            messages.push(RowSet::generated_message_descriptor_data());
            messages.push(ColumnRange::generated_message_descriptor_data());
            messages.push(TimestampRange::generated_message_descriptor_data());
            messages.push(ValueRange::generated_message_descriptor_data());
            messages.push(RowFilter::generated_message_descriptor_data());
            messages.push(Mutation::generated_message_descriptor_data());
            messages.push(ReadModifyWriteRule::generated_message_descriptor_data());
            messages.push(row_filter::Chain::generated_message_descriptor_data());
            messages.push(row_filter::Interleave::generated_message_descriptor_data());
            messages.push(row_filter::Condition::generated_message_descriptor_data());
            messages.push(mutation::SetCell::generated_message_descriptor_data());
            messages.push(mutation::DeleteFromColumn::generated_message_descriptor_data());
            messages.push(mutation::DeleteFromFamily::generated_message_descriptor_data());
            messages.push(mutation::DeleteFromRow::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
