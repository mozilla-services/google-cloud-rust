// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/bigtable/admin/v2/instance.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Instance {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub state: Instance_State,
    pub field_type: Instance_Type,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub _satisfies_pzs: ::std::option::Option<Instance_oneof__satisfies_pzs>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Instance {
    fn default() -> &'a Instance {
        <Instance as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Instance_oneof__satisfies_pzs {
    satisfies_pzs(bool),
}

impl Instance {
    pub fn new() -> Instance {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.bigtable.admin.v2.Instance.State state = 3;


    pub fn get_state(&self) -> Instance_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Instance_State::STATE_NOT_KNOWN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Instance_State) {
        self.state = v;
    }

    // .google.bigtable.admin.v2.Instance.Type type = 4;


    pub fn get_field_type(&self) -> Instance_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Instance_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Instance_Type) {
        self.field_type = v;
    }

    // repeated .google.bigtable.admin.v2.Instance.LabelsEntry labels = 5;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // .google.protobuf.Timestamp create_time = 7;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool satisfies_pzs = 8;


    pub fn get_satisfies_pzs(&self) -> bool {
        match self._satisfies_pzs {
            ::std::option::Option::Some(Instance_oneof__satisfies_pzs::satisfies_pzs(v)) => v,
            _ => false,
        }
    }
    pub fn clear_satisfies_pzs(&mut self) {
        self._satisfies_pzs = ::std::option::Option::None;
    }

    pub fn has_satisfies_pzs(&self) -> bool {
        match self._satisfies_pzs {
            ::std::option::Option::Some(Instance_oneof__satisfies_pzs::satisfies_pzs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_satisfies_pzs(&mut self, v: bool) {
        self._satisfies_pzs = ::std::option::Option::Some(Instance_oneof__satisfies_pzs::satisfies_pzs(v))
    }
}

impl ::protobuf::Message for Instance {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._satisfies_pzs = ::std::option::Option::Some(Instance_oneof__satisfies_pzs::satisfies_pzs(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if self.state != Instance_State::STATE_NOT_KNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if self.field_type != Instance_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.labels);
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self._satisfies_pzs {
            match v {
                &Instance_oneof__satisfies_pzs::satisfies_pzs(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if self.state != Instance_State::STATE_NOT_KNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.field_type != Instance_Type::TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.labels, os)?;
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self._satisfies_pzs {
            match v {
                &Instance_oneof__satisfies_pzs::satisfies_pzs(v) => {
                    os.write_bool(8, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instance {
        Instance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Instance| { &m.name },
                |m: &mut Instance| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &Instance| { &m.display_name },
                |m: &mut Instance| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Instance_State>>(
                "state",
                |m: &Instance| { &m.state },
                |m: &mut Instance| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Instance_Type>>(
                "type",
                |m: &Instance| { &m.field_type },
                |m: &mut Instance| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Instance| { &m.labels },
                |m: &mut Instance| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &Instance| { &m.create_time },
                |m: &mut Instance| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "satisfies_pzs",
                Instance::has_satisfies_pzs,
                Instance::get_satisfies_pzs,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Instance>(
                "Instance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Instance {
        static instance: ::protobuf::rt::LazyV2<Instance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Instance::new)
    }
}

impl ::protobuf::Clear for Instance {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.state = Instance_State::STATE_NOT_KNOWN;
        self.field_type = Instance_Type::TYPE_UNSPECIFIED;
        self.labels.clear();
        self.create_time.clear();
        self._satisfies_pzs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Instance_State {
    STATE_NOT_KNOWN = 0,
    READY = 1,
    CREATING = 2,
}

impl ::protobuf::ProtobufEnum for Instance_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Instance_State> {
        match value {
            0 => ::std::option::Option::Some(Instance_State::STATE_NOT_KNOWN),
            1 => ::std::option::Option::Some(Instance_State::READY),
            2 => ::std::option::Option::Some(Instance_State::CREATING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Instance_State] = &[
            Instance_State::STATE_NOT_KNOWN,
            Instance_State::READY,
            Instance_State::CREATING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Instance_State>("Instance.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Instance_State {
}

impl ::std::default::Default for Instance_State {
    fn default() -> Self {
        Instance_State::STATE_NOT_KNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Instance_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Instance_Type {
    TYPE_UNSPECIFIED = 0,
    PRODUCTION = 1,
    DEVELOPMENT = 2,
}

impl ::protobuf::ProtobufEnum for Instance_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Instance_Type> {
        match value {
            0 => ::std::option::Option::Some(Instance_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Instance_Type::PRODUCTION),
            2 => ::std::option::Option::Some(Instance_Type::DEVELOPMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Instance_Type] = &[
            Instance_Type::TYPE_UNSPECIFIED,
            Instance_Type::PRODUCTION,
            Instance_Type::DEVELOPMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Instance_Type>("Instance.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Instance_Type {
}

impl ::std::default::Default for Instance_Type {
    fn default() -> Self {
        Instance_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Instance_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AutoscalingTargets {
    // message fields
    pub cpu_utilization_percent: i32,
    pub storage_utilization_gib_per_node: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AutoscalingTargets {
    fn default() -> &'a AutoscalingTargets {
        <AutoscalingTargets as ::protobuf::Message>::default_instance()
    }
}

impl AutoscalingTargets {
    pub fn new() -> AutoscalingTargets {
        ::std::default::Default::default()
    }

    // int32 cpu_utilization_percent = 2;


    pub fn get_cpu_utilization_percent(&self) -> i32 {
        self.cpu_utilization_percent
    }
    pub fn clear_cpu_utilization_percent(&mut self) {
        self.cpu_utilization_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_utilization_percent(&mut self, v: i32) {
        self.cpu_utilization_percent = v;
    }

    // int32 storage_utilization_gib_per_node = 3;


    pub fn get_storage_utilization_gib_per_node(&self) -> i32 {
        self.storage_utilization_gib_per_node
    }
    pub fn clear_storage_utilization_gib_per_node(&mut self) {
        self.storage_utilization_gib_per_node = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_utilization_gib_per_node(&mut self, v: i32) {
        self.storage_utilization_gib_per_node = v;
    }
}

impl ::protobuf::Message for AutoscalingTargets {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cpu_utilization_percent = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.storage_utilization_gib_per_node = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cpu_utilization_percent != 0 {
            my_size += ::protobuf::rt::value_size(2, self.cpu_utilization_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storage_utilization_gib_per_node != 0 {
            my_size += ::protobuf::rt::value_size(3, self.storage_utilization_gib_per_node, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cpu_utilization_percent != 0 {
            os.write_int32(2, self.cpu_utilization_percent)?;
        }
        if self.storage_utilization_gib_per_node != 0 {
            os.write_int32(3, self.storage_utilization_gib_per_node)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AutoscalingTargets {
        AutoscalingTargets::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cpu_utilization_percent",
                |m: &AutoscalingTargets| { &m.cpu_utilization_percent },
                |m: &mut AutoscalingTargets| { &mut m.cpu_utilization_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "storage_utilization_gib_per_node",
                |m: &AutoscalingTargets| { &m.storage_utilization_gib_per_node },
                |m: &mut AutoscalingTargets| { &mut m.storage_utilization_gib_per_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AutoscalingTargets>(
                "AutoscalingTargets",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AutoscalingTargets {
        static instance: ::protobuf::rt::LazyV2<AutoscalingTargets> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AutoscalingTargets::new)
    }
}

impl ::protobuf::Clear for AutoscalingTargets {
    fn clear(&mut self) {
        self.cpu_utilization_percent = 0;
        self.storage_utilization_gib_per_node = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AutoscalingTargets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AutoscalingTargets {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AutoscalingLimits {
    // message fields
    pub min_serve_nodes: i32,
    pub max_serve_nodes: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AutoscalingLimits {
    fn default() -> &'a AutoscalingLimits {
        <AutoscalingLimits as ::protobuf::Message>::default_instance()
    }
}

impl AutoscalingLimits {
    pub fn new() -> AutoscalingLimits {
        ::std::default::Default::default()
    }

    // int32 min_serve_nodes = 1;


    pub fn get_min_serve_nodes(&self) -> i32 {
        self.min_serve_nodes
    }
    pub fn clear_min_serve_nodes(&mut self) {
        self.min_serve_nodes = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_serve_nodes(&mut self, v: i32) {
        self.min_serve_nodes = v;
    }

    // int32 max_serve_nodes = 2;


    pub fn get_max_serve_nodes(&self) -> i32 {
        self.max_serve_nodes
    }
    pub fn clear_max_serve_nodes(&mut self) {
        self.max_serve_nodes = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_serve_nodes(&mut self, v: i32) {
        self.max_serve_nodes = v;
    }
}

impl ::protobuf::Message for AutoscalingLimits {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_serve_nodes = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_serve_nodes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_serve_nodes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.min_serve_nodes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_serve_nodes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_serve_nodes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_serve_nodes != 0 {
            os.write_int32(1, self.min_serve_nodes)?;
        }
        if self.max_serve_nodes != 0 {
            os.write_int32(2, self.max_serve_nodes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AutoscalingLimits {
        AutoscalingLimits::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_serve_nodes",
                |m: &AutoscalingLimits| { &m.min_serve_nodes },
                |m: &mut AutoscalingLimits| { &mut m.min_serve_nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_serve_nodes",
                |m: &AutoscalingLimits| { &m.max_serve_nodes },
                |m: &mut AutoscalingLimits| { &mut m.max_serve_nodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AutoscalingLimits>(
                "AutoscalingLimits",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AutoscalingLimits {
        static instance: ::protobuf::rt::LazyV2<AutoscalingLimits> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AutoscalingLimits::new)
    }
}

impl ::protobuf::Clear for AutoscalingLimits {
    fn clear(&mut self) {
        self.min_serve_nodes = 0;
        self.max_serve_nodes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AutoscalingLimits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AutoscalingLimits {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cluster {
    // message fields
    pub name: ::std::string::String,
    pub location: ::std::string::String,
    pub state: Cluster_State,
    pub serve_nodes: i32,
    pub default_storage_type: super::common::StorageType,
    pub encryption_config: ::protobuf::SingularPtrField<Cluster_EncryptionConfig>,
    // message oneof groups
    pub config: ::std::option::Option<Cluster_oneof_config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cluster {
    fn default() -> &'a Cluster {
        <Cluster as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Cluster_oneof_config {
    cluster_config(Cluster_ClusterConfig),
}

impl Cluster {
    pub fn new() -> Cluster {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string location = 2;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // .google.bigtable.admin.v2.Cluster.State state = 3;


    pub fn get_state(&self) -> Cluster_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Cluster_State::STATE_NOT_KNOWN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Cluster_State) {
        self.state = v;
    }

    // int32 serve_nodes = 4;


    pub fn get_serve_nodes(&self) -> i32 {
        self.serve_nodes
    }
    pub fn clear_serve_nodes(&mut self) {
        self.serve_nodes = 0;
    }

    // Param is passed by value, moved
    pub fn set_serve_nodes(&mut self, v: i32) {
        self.serve_nodes = v;
    }

    // .google.bigtable.admin.v2.Cluster.ClusterConfig cluster_config = 7;


    pub fn get_cluster_config(&self) -> &Cluster_ClusterConfig {
        match self.config {
            ::std::option::Option::Some(Cluster_oneof_config::cluster_config(ref v)) => v,
            _ => <Cluster_ClusterConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cluster_config(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_cluster_config(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(Cluster_oneof_config::cluster_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_config(&mut self, v: Cluster_ClusterConfig) {
        self.config = ::std::option::Option::Some(Cluster_oneof_config::cluster_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_config(&mut self) -> &mut Cluster_ClusterConfig {
        if let ::std::option::Option::Some(Cluster_oneof_config::cluster_config(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(Cluster_oneof_config::cluster_config(Cluster_ClusterConfig::new()));
        }
        match self.config {
            ::std::option::Option::Some(Cluster_oneof_config::cluster_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_config(&mut self) -> Cluster_ClusterConfig {
        if self.has_cluster_config() {
            match self.config.take() {
                ::std::option::Option::Some(Cluster_oneof_config::cluster_config(v)) => v,
                _ => panic!(),
            }
        } else {
            Cluster_ClusterConfig::new()
        }
    }

    // .google.bigtable.admin.v2.StorageType default_storage_type = 5;


    pub fn get_default_storage_type(&self) -> super::common::StorageType {
        self.default_storage_type
    }
    pub fn clear_default_storage_type(&mut self) {
        self.default_storage_type = super::common::StorageType::STORAGE_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_default_storage_type(&mut self, v: super::common::StorageType) {
        self.default_storage_type = v;
    }

    // .google.bigtable.admin.v2.Cluster.EncryptionConfig encryption_config = 6;


    pub fn get_encryption_config(&self) -> &Cluster_EncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <Cluster_EncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: Cluster_EncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut Cluster_EncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> Cluster_EncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| Cluster_EncryptionConfig::new())
    }
}

impl ::protobuf::Message for Cluster {
    fn is_initialized(&self) -> bool {
        if let Some(Cluster_oneof_config::cluster_config(ref v)) = self.config {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.serve_nodes = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config = ::std::option::Option::Some(Cluster_oneof_config::cluster_config(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.default_storage_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.location);
        }
        if self.state != Cluster_State::STATE_NOT_KNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if self.serve_nodes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.serve_nodes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.default_storage_type != super::common::StorageType::STORAGE_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.default_storage_type);
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &Cluster_oneof_config::cluster_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.location.is_empty() {
            os.write_string(2, &self.location)?;
        }
        if self.state != Cluster_State::STATE_NOT_KNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.serve_nodes != 0 {
            os.write_int32(4, self.serve_nodes)?;
        }
        if self.default_storage_type != super::common::StorageType::STORAGE_TYPE_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.default_storage_type))?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &Cluster_oneof_config::cluster_config(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cluster {
        Cluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Cluster| { &m.name },
                |m: &mut Cluster| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Cluster| { &m.location },
                |m: &mut Cluster| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Cluster_State>>(
                "state",
                |m: &Cluster| { &m.state },
                |m: &mut Cluster| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "serve_nodes",
                |m: &Cluster| { &m.serve_nodes },
                |m: &mut Cluster| { &mut m.serve_nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Cluster_ClusterConfig>(
                "cluster_config",
                Cluster::has_cluster_config,
                Cluster::get_cluster_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::StorageType>>(
                "default_storage_type",
                |m: &Cluster| { &m.default_storage_type },
                |m: &mut Cluster| { &mut m.default_storage_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cluster_EncryptionConfig>>(
                "encryption_config",
                |m: &Cluster| { &m.encryption_config },
                |m: &mut Cluster| { &mut m.encryption_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cluster>(
                "Cluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cluster {
        static instance: ::protobuf::rt::LazyV2<Cluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cluster::new)
    }
}

impl ::protobuf::Clear for Cluster {
    fn clear(&mut self) {
        self.name.clear();
        self.location.clear();
        self.state = Cluster_State::STATE_NOT_KNOWN;
        self.serve_nodes = 0;
        self.config = ::std::option::Option::None;
        self.default_storage_type = super::common::StorageType::STORAGE_TYPE_UNSPECIFIED;
        self.encryption_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cluster_ClusterAutoscalingConfig {
    // message fields
    pub autoscaling_limits: ::protobuf::SingularPtrField<AutoscalingLimits>,
    pub autoscaling_targets: ::protobuf::SingularPtrField<AutoscalingTargets>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cluster_ClusterAutoscalingConfig {
    fn default() -> &'a Cluster_ClusterAutoscalingConfig {
        <Cluster_ClusterAutoscalingConfig as ::protobuf::Message>::default_instance()
    }
}

impl Cluster_ClusterAutoscalingConfig {
    pub fn new() -> Cluster_ClusterAutoscalingConfig {
        ::std::default::Default::default()
    }

    // .google.bigtable.admin.v2.AutoscalingLimits autoscaling_limits = 1;


    pub fn get_autoscaling_limits(&self) -> &AutoscalingLimits {
        self.autoscaling_limits.as_ref().unwrap_or_else(|| <AutoscalingLimits as ::protobuf::Message>::default_instance())
    }
    pub fn clear_autoscaling_limits(&mut self) {
        self.autoscaling_limits.clear();
    }

    pub fn has_autoscaling_limits(&self) -> bool {
        self.autoscaling_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoscaling_limits(&mut self, v: AutoscalingLimits) {
        self.autoscaling_limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autoscaling_limits(&mut self) -> &mut AutoscalingLimits {
        if self.autoscaling_limits.is_none() {
            self.autoscaling_limits.set_default();
        }
        self.autoscaling_limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_autoscaling_limits(&mut self) -> AutoscalingLimits {
        self.autoscaling_limits.take().unwrap_or_else(|| AutoscalingLimits::new())
    }

    // .google.bigtable.admin.v2.AutoscalingTargets autoscaling_targets = 2;


    pub fn get_autoscaling_targets(&self) -> &AutoscalingTargets {
        self.autoscaling_targets.as_ref().unwrap_or_else(|| <AutoscalingTargets as ::protobuf::Message>::default_instance())
    }
    pub fn clear_autoscaling_targets(&mut self) {
        self.autoscaling_targets.clear();
    }

    pub fn has_autoscaling_targets(&self) -> bool {
        self.autoscaling_targets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoscaling_targets(&mut self, v: AutoscalingTargets) {
        self.autoscaling_targets = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autoscaling_targets(&mut self) -> &mut AutoscalingTargets {
        if self.autoscaling_targets.is_none() {
            self.autoscaling_targets.set_default();
        }
        self.autoscaling_targets.as_mut().unwrap()
    }

    // Take field
    pub fn take_autoscaling_targets(&mut self) -> AutoscalingTargets {
        self.autoscaling_targets.take().unwrap_or_else(|| AutoscalingTargets::new())
    }
}

impl ::protobuf::Message for Cluster_ClusterAutoscalingConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.autoscaling_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.autoscaling_targets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.autoscaling_limits)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.autoscaling_targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.autoscaling_limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.autoscaling_targets.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.autoscaling_limits.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.autoscaling_targets.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cluster_ClusterAutoscalingConfig {
        Cluster_ClusterAutoscalingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AutoscalingLimits>>(
                "autoscaling_limits",
                |m: &Cluster_ClusterAutoscalingConfig| { &m.autoscaling_limits },
                |m: &mut Cluster_ClusterAutoscalingConfig| { &mut m.autoscaling_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AutoscalingTargets>>(
                "autoscaling_targets",
                |m: &Cluster_ClusterAutoscalingConfig| { &m.autoscaling_targets },
                |m: &mut Cluster_ClusterAutoscalingConfig| { &mut m.autoscaling_targets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cluster_ClusterAutoscalingConfig>(
                "Cluster.ClusterAutoscalingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cluster_ClusterAutoscalingConfig {
        static instance: ::protobuf::rt::LazyV2<Cluster_ClusterAutoscalingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cluster_ClusterAutoscalingConfig::new)
    }
}

impl ::protobuf::Clear for Cluster_ClusterAutoscalingConfig {
    fn clear(&mut self) {
        self.autoscaling_limits.clear();
        self.autoscaling_targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cluster_ClusterAutoscalingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster_ClusterAutoscalingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cluster_ClusterConfig {
    // message fields
    pub cluster_autoscaling_config: ::protobuf::SingularPtrField<Cluster_ClusterAutoscalingConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cluster_ClusterConfig {
    fn default() -> &'a Cluster_ClusterConfig {
        <Cluster_ClusterConfig as ::protobuf::Message>::default_instance()
    }
}

impl Cluster_ClusterConfig {
    pub fn new() -> Cluster_ClusterConfig {
        ::std::default::Default::default()
    }

    // .google.bigtable.admin.v2.Cluster.ClusterAutoscalingConfig cluster_autoscaling_config = 1;


    pub fn get_cluster_autoscaling_config(&self) -> &Cluster_ClusterAutoscalingConfig {
        self.cluster_autoscaling_config.as_ref().unwrap_or_else(|| <Cluster_ClusterAutoscalingConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cluster_autoscaling_config(&mut self) {
        self.cluster_autoscaling_config.clear();
    }

    pub fn has_cluster_autoscaling_config(&self) -> bool {
        self.cluster_autoscaling_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_autoscaling_config(&mut self, v: Cluster_ClusterAutoscalingConfig) {
        self.cluster_autoscaling_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_autoscaling_config(&mut self) -> &mut Cluster_ClusterAutoscalingConfig {
        if self.cluster_autoscaling_config.is_none() {
            self.cluster_autoscaling_config.set_default();
        }
        self.cluster_autoscaling_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster_autoscaling_config(&mut self) -> Cluster_ClusterAutoscalingConfig {
        self.cluster_autoscaling_config.take().unwrap_or_else(|| Cluster_ClusterAutoscalingConfig::new())
    }
}

impl ::protobuf::Message for Cluster_ClusterConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.cluster_autoscaling_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster_autoscaling_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cluster_autoscaling_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cluster_autoscaling_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cluster_ClusterConfig {
        Cluster_ClusterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cluster_ClusterAutoscalingConfig>>(
                "cluster_autoscaling_config",
                |m: &Cluster_ClusterConfig| { &m.cluster_autoscaling_config },
                |m: &mut Cluster_ClusterConfig| { &mut m.cluster_autoscaling_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cluster_ClusterConfig>(
                "Cluster.ClusterConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cluster_ClusterConfig {
        static instance: ::protobuf::rt::LazyV2<Cluster_ClusterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cluster_ClusterConfig::new)
    }
}

impl ::protobuf::Clear for Cluster_ClusterConfig {
    fn clear(&mut self) {
        self.cluster_autoscaling_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cluster_ClusterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster_ClusterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cluster_EncryptionConfig {
    // message fields
    pub kms_key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cluster_EncryptionConfig {
    fn default() -> &'a Cluster_EncryptionConfig {
        <Cluster_EncryptionConfig as ::protobuf::Message>::default_instance()
    }
}

impl Cluster_EncryptionConfig {
    pub fn new() -> Cluster_EncryptionConfig {
        ::std::default::Default::default()
    }

    // string kms_key_name = 1;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Cluster_EncryptionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kms_key_name.is_empty() {
            os.write_string(1, &self.kms_key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cluster_EncryptionConfig {
        Cluster_EncryptionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &Cluster_EncryptionConfig| { &m.kms_key_name },
                |m: &mut Cluster_EncryptionConfig| { &mut m.kms_key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cluster_EncryptionConfig>(
                "Cluster.EncryptionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cluster_EncryptionConfig {
        static instance: ::protobuf::rt::LazyV2<Cluster_EncryptionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cluster_EncryptionConfig::new)
    }
}

impl ::protobuf::Clear for Cluster_EncryptionConfig {
    fn clear(&mut self) {
        self.kms_key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cluster_EncryptionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster_EncryptionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Cluster_State {
    STATE_NOT_KNOWN = 0,
    READY = 1,
    CREATING = 2,
    RESIZING = 3,
    DISABLED = 4,
}

impl ::protobuf::ProtobufEnum for Cluster_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Cluster_State> {
        match value {
            0 => ::std::option::Option::Some(Cluster_State::STATE_NOT_KNOWN),
            1 => ::std::option::Option::Some(Cluster_State::READY),
            2 => ::std::option::Option::Some(Cluster_State::CREATING),
            3 => ::std::option::Option::Some(Cluster_State::RESIZING),
            4 => ::std::option::Option::Some(Cluster_State::DISABLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Cluster_State] = &[
            Cluster_State::STATE_NOT_KNOWN,
            Cluster_State::READY,
            Cluster_State::CREATING,
            Cluster_State::RESIZING,
            Cluster_State::DISABLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Cluster_State>("Cluster.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Cluster_State {
}

impl ::std::default::Default for Cluster_State {
    fn default() -> Self {
        Cluster_State::STATE_NOT_KNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppProfile {
    // message fields
    pub name: ::std::string::String,
    pub etag: ::std::string::String,
    pub description: ::std::string::String,
    // message oneof groups
    pub routing_policy: ::std::option::Option<AppProfile_oneof_routing_policy>,
    pub isolation: ::std::option::Option<AppProfile_oneof_isolation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppProfile {
    fn default() -> &'a AppProfile {
        <AppProfile as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AppProfile_oneof_routing_policy {
    multi_cluster_routing_use_any(AppProfile_MultiClusterRoutingUseAny),
    single_cluster_routing(AppProfile_SingleClusterRouting),
}

#[derive(Clone,PartialEq,Debug)]
pub enum AppProfile_oneof_isolation {
    priority(AppProfile_Priority),
    standard_isolation(AppProfile_StandardIsolation),
}

impl AppProfile {
    pub fn new() -> AppProfile {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string etag = 2;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.bigtable.admin.v2.AppProfile.MultiClusterRoutingUseAny multi_cluster_routing_use_any = 5;


    pub fn get_multi_cluster_routing_use_any(&self) -> &AppProfile_MultiClusterRoutingUseAny {
        match self.routing_policy {
            ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(ref v)) => v,
            _ => <AppProfile_MultiClusterRoutingUseAny as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_multi_cluster_routing_use_any(&mut self) {
        self.routing_policy = ::std::option::Option::None;
    }

    pub fn has_multi_cluster_routing_use_any(&self) -> bool {
        match self.routing_policy {
            ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_cluster_routing_use_any(&mut self, v: AppProfile_MultiClusterRoutingUseAny) {
        self.routing_policy = ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_cluster_routing_use_any(&mut self) -> &mut AppProfile_MultiClusterRoutingUseAny {
        if let ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(_)) = self.routing_policy {
        } else {
            self.routing_policy = ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(AppProfile_MultiClusterRoutingUseAny::new()));
        }
        match self.routing_policy {
            ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_cluster_routing_use_any(&mut self) -> AppProfile_MultiClusterRoutingUseAny {
        if self.has_multi_cluster_routing_use_any() {
            match self.routing_policy.take() {
                ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(v)) => v,
                _ => panic!(),
            }
        } else {
            AppProfile_MultiClusterRoutingUseAny::new()
        }
    }

    // .google.bigtable.admin.v2.AppProfile.SingleClusterRouting single_cluster_routing = 6;


    pub fn get_single_cluster_routing(&self) -> &AppProfile_SingleClusterRouting {
        match self.routing_policy {
            ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(ref v)) => v,
            _ => <AppProfile_SingleClusterRouting as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_single_cluster_routing(&mut self) {
        self.routing_policy = ::std::option::Option::None;
    }

    pub fn has_single_cluster_routing(&self) -> bool {
        match self.routing_policy {
            ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_cluster_routing(&mut self, v: AppProfile_SingleClusterRouting) {
        self.routing_policy = ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single_cluster_routing(&mut self) -> &mut AppProfile_SingleClusterRouting {
        if let ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(_)) = self.routing_policy {
        } else {
            self.routing_policy = ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(AppProfile_SingleClusterRouting::new()));
        }
        match self.routing_policy {
            ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single_cluster_routing(&mut self) -> AppProfile_SingleClusterRouting {
        if self.has_single_cluster_routing() {
            match self.routing_policy.take() {
                ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(v)) => v,
                _ => panic!(),
            }
        } else {
            AppProfile_SingleClusterRouting::new()
        }
    }

    // .google.bigtable.admin.v2.AppProfile.Priority priority = 7;


    pub fn get_priority(&self) -> AppProfile_Priority {
        match self.isolation {
            ::std::option::Option::Some(AppProfile_oneof_isolation::priority(v)) => v,
            _ => AppProfile_Priority::PRIORITY_UNSPECIFIED,
        }
    }
    pub fn clear_priority(&mut self) {
        self.isolation = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        match self.isolation {
            ::std::option::Option::Some(AppProfile_oneof_isolation::priority(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: AppProfile_Priority) {
        self.isolation = ::std::option::Option::Some(AppProfile_oneof_isolation::priority(v))
    }

    // .google.bigtable.admin.v2.AppProfile.StandardIsolation standard_isolation = 11;


    pub fn get_standard_isolation(&self) -> &AppProfile_StandardIsolation {
        match self.isolation {
            ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(ref v)) => v,
            _ => <AppProfile_StandardIsolation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_standard_isolation(&mut self) {
        self.isolation = ::std::option::Option::None;
    }

    pub fn has_standard_isolation(&self) -> bool {
        match self.isolation {
            ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_standard_isolation(&mut self, v: AppProfile_StandardIsolation) {
        self.isolation = ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_standard_isolation(&mut self) -> &mut AppProfile_StandardIsolation {
        if let ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(_)) = self.isolation {
        } else {
            self.isolation = ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(AppProfile_StandardIsolation::new()));
        }
        match self.isolation {
            ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_standard_isolation(&mut self) -> AppProfile_StandardIsolation {
        if self.has_standard_isolation() {
            match self.isolation.take() {
                ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(v)) => v,
                _ => panic!(),
            }
        } else {
            AppProfile_StandardIsolation::new()
        }
    }
}

impl ::protobuf::Message for AppProfile {
    fn is_initialized(&self) -> bool {
        if let Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(ref v)) = self.routing_policy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AppProfile_oneof_routing_policy::single_cluster_routing(ref v)) = self.routing_policy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AppProfile_oneof_isolation::standard_isolation(ref v)) = self.isolation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.routing_policy = ::std::option::Option::Some(AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.routing_policy = ::std::option::Option::Some(AppProfile_oneof_routing_policy::single_cluster_routing(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isolation = ::std::option::Option::Some(AppProfile_oneof_isolation::priority(is.read_enum()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isolation = ::std::option::Option::Some(AppProfile_oneof_isolation::standard_isolation(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.etag);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if let ::std::option::Option::Some(ref v) = self.routing_policy {
            match v {
                &AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AppProfile_oneof_routing_policy::single_cluster_routing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.isolation {
            match v {
                &AppProfile_oneof_isolation::priority(v) => {
                    my_size += ::protobuf::rt::enum_size(7, v);
                },
                &AppProfile_oneof_isolation::standard_isolation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.etag.is_empty() {
            os.write_string(2, &self.etag)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if let ::std::option::Option::Some(ref v) = self.routing_policy {
            match v {
                &AppProfile_oneof_routing_policy::multi_cluster_routing_use_any(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AppProfile_oneof_routing_policy::single_cluster_routing(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.isolation {
            match v {
                &AppProfile_oneof_isolation::priority(v) => {
                    os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &AppProfile_oneof_isolation::standard_isolation(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppProfile {
        AppProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AppProfile| { &m.name },
                |m: &mut AppProfile| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &AppProfile| { &m.etag },
                |m: &mut AppProfile| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &AppProfile| { &m.description },
                |m: &mut AppProfile| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AppProfile_MultiClusterRoutingUseAny>(
                "multi_cluster_routing_use_any",
                AppProfile::has_multi_cluster_routing_use_any,
                AppProfile::get_multi_cluster_routing_use_any,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AppProfile_SingleClusterRouting>(
                "single_cluster_routing",
                AppProfile::has_single_cluster_routing,
                AppProfile::get_single_cluster_routing,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, AppProfile_Priority>(
                "priority",
                AppProfile::has_priority,
                AppProfile::get_priority,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AppProfile_StandardIsolation>(
                "standard_isolation",
                AppProfile::has_standard_isolation,
                AppProfile::get_standard_isolation,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppProfile>(
                "AppProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppProfile {
        static instance: ::protobuf::rt::LazyV2<AppProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppProfile::new)
    }
}

impl ::protobuf::Clear for AppProfile {
    fn clear(&mut self) {
        self.name.clear();
        self.etag.clear();
        self.description.clear();
        self.routing_policy = ::std::option::Option::None;
        self.routing_policy = ::std::option::Option::None;
        self.isolation = ::std::option::Option::None;
        self.isolation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppProfile_MultiClusterRoutingUseAny {
    // message fields
    pub cluster_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppProfile_MultiClusterRoutingUseAny {
    fn default() -> &'a AppProfile_MultiClusterRoutingUseAny {
        <AppProfile_MultiClusterRoutingUseAny as ::protobuf::Message>::default_instance()
    }
}

impl AppProfile_MultiClusterRoutingUseAny {
    pub fn new() -> AppProfile_MultiClusterRoutingUseAny {
        ::std::default::Default::default()
    }

    // repeated string cluster_ids = 1;


    pub fn get_cluster_ids(&self) -> &[::std::string::String] {
        &self.cluster_ids
    }
    pub fn clear_cluster_ids(&mut self) {
        self.cluster_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cluster_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cluster_ids
    }

    // Take field
    pub fn take_cluster_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cluster_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AppProfile_MultiClusterRoutingUseAny {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cluster_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cluster_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cluster_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppProfile_MultiClusterRoutingUseAny {
        AppProfile_MultiClusterRoutingUseAny::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_ids",
                |m: &AppProfile_MultiClusterRoutingUseAny| { &m.cluster_ids },
                |m: &mut AppProfile_MultiClusterRoutingUseAny| { &mut m.cluster_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppProfile_MultiClusterRoutingUseAny>(
                "AppProfile.MultiClusterRoutingUseAny",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppProfile_MultiClusterRoutingUseAny {
        static instance: ::protobuf::rt::LazyV2<AppProfile_MultiClusterRoutingUseAny> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppProfile_MultiClusterRoutingUseAny::new)
    }
}

impl ::protobuf::Clear for AppProfile_MultiClusterRoutingUseAny {
    fn clear(&mut self) {
        self.cluster_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppProfile_MultiClusterRoutingUseAny {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppProfile_MultiClusterRoutingUseAny {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppProfile_SingleClusterRouting {
    // message fields
    pub cluster_id: ::std::string::String,
    pub allow_transactional_writes: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppProfile_SingleClusterRouting {
    fn default() -> &'a AppProfile_SingleClusterRouting {
        <AppProfile_SingleClusterRouting as ::protobuf::Message>::default_instance()
    }
}

impl AppProfile_SingleClusterRouting {
    pub fn new() -> AppProfile_SingleClusterRouting {
        ::std::default::Default::default()
    }

    // string cluster_id = 1;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // bool allow_transactional_writes = 2;


    pub fn get_allow_transactional_writes(&self) -> bool {
        self.allow_transactional_writes
    }
    pub fn clear_allow_transactional_writes(&mut self) {
        self.allow_transactional_writes = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_transactional_writes(&mut self, v: bool) {
        self.allow_transactional_writes = v;
    }
}

impl ::protobuf::Message for AppProfile_SingleClusterRouting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_transactional_writes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cluster_id);
        }
        if self.allow_transactional_writes != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cluster_id.is_empty() {
            os.write_string(1, &self.cluster_id)?;
        }
        if self.allow_transactional_writes != false {
            os.write_bool(2, self.allow_transactional_writes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppProfile_SingleClusterRouting {
        AppProfile_SingleClusterRouting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &AppProfile_SingleClusterRouting| { &m.cluster_id },
                |m: &mut AppProfile_SingleClusterRouting| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_transactional_writes",
                |m: &AppProfile_SingleClusterRouting| { &m.allow_transactional_writes },
                |m: &mut AppProfile_SingleClusterRouting| { &mut m.allow_transactional_writes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppProfile_SingleClusterRouting>(
                "AppProfile.SingleClusterRouting",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppProfile_SingleClusterRouting {
        static instance: ::protobuf::rt::LazyV2<AppProfile_SingleClusterRouting> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppProfile_SingleClusterRouting::new)
    }
}

impl ::protobuf::Clear for AppProfile_SingleClusterRouting {
    fn clear(&mut self) {
        self.cluster_id.clear();
        self.allow_transactional_writes = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppProfile_SingleClusterRouting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppProfile_SingleClusterRouting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppProfile_StandardIsolation {
    // message fields
    pub priority: AppProfile_Priority,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppProfile_StandardIsolation {
    fn default() -> &'a AppProfile_StandardIsolation {
        <AppProfile_StandardIsolation as ::protobuf::Message>::default_instance()
    }
}

impl AppProfile_StandardIsolation {
    pub fn new() -> AppProfile_StandardIsolation {
        ::std::default::Default::default()
    }

    // .google.bigtable.admin.v2.AppProfile.Priority priority = 1;


    pub fn get_priority(&self) -> AppProfile_Priority {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = AppProfile_Priority::PRIORITY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: AppProfile_Priority) {
        self.priority = v;
    }
}

impl ::protobuf::Message for AppProfile_StandardIsolation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.priority, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.priority != AppProfile_Priority::PRIORITY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.priority);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.priority != AppProfile_Priority::PRIORITY_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.priority))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppProfile_StandardIsolation {
        AppProfile_StandardIsolation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AppProfile_Priority>>(
                "priority",
                |m: &AppProfile_StandardIsolation| { &m.priority },
                |m: &mut AppProfile_StandardIsolation| { &mut m.priority },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppProfile_StandardIsolation>(
                "AppProfile.StandardIsolation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppProfile_StandardIsolation {
        static instance: ::protobuf::rt::LazyV2<AppProfile_StandardIsolation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppProfile_StandardIsolation::new)
    }
}

impl ::protobuf::Clear for AppProfile_StandardIsolation {
    fn clear(&mut self) {
        self.priority = AppProfile_Priority::PRIORITY_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppProfile_StandardIsolation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppProfile_StandardIsolation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AppProfile_Priority {
    PRIORITY_UNSPECIFIED = 0,
    PRIORITY_LOW = 1,
    PRIORITY_MEDIUM = 2,
    PRIORITY_HIGH = 3,
}

impl ::protobuf::ProtobufEnum for AppProfile_Priority {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AppProfile_Priority> {
        match value {
            0 => ::std::option::Option::Some(AppProfile_Priority::PRIORITY_UNSPECIFIED),
            1 => ::std::option::Option::Some(AppProfile_Priority::PRIORITY_LOW),
            2 => ::std::option::Option::Some(AppProfile_Priority::PRIORITY_MEDIUM),
            3 => ::std::option::Option::Some(AppProfile_Priority::PRIORITY_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AppProfile_Priority] = &[
            AppProfile_Priority::PRIORITY_UNSPECIFIED,
            AppProfile_Priority::PRIORITY_LOW,
            AppProfile_Priority::PRIORITY_MEDIUM,
            AppProfile_Priority::PRIORITY_HIGH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AppProfile_Priority>("AppProfile.Priority", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AppProfile_Priority {
}

impl ::std::default::Default for AppProfile_Priority {
    fn default() -> Self {
        AppProfile_Priority::PRIORITY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AppProfile_Priority {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HotTablet {
    // message fields
    pub name: ::std::string::String,
    pub table_name: ::std::string::String,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub start_key: ::std::string::String,
    pub end_key: ::std::string::String,
    pub node_cpu_usage_percent: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HotTablet {
    fn default() -> &'a HotTablet {
        <HotTablet as ::protobuf::Message>::default_instance()
    }
}

impl HotTablet {
    pub fn new() -> HotTablet {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string table_name = 2;


    pub fn get_table_name(&self) -> &str {
        &self.table_name
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        &mut self.table_name
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table_name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp start_time = 3;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 4;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string start_key = 5;


    pub fn get_start_key(&self) -> &str {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::string::String) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::string::String {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.start_key, ::std::string::String::new())
    }

    // string end_key = 6;


    pub fn get_end_key(&self) -> &str {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::string::String) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::string::String {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.end_key, ::std::string::String::new())
    }

    // float node_cpu_usage_percent = 7;


    pub fn get_node_cpu_usage_percent(&self) -> f32 {
        self.node_cpu_usage_percent
    }
    pub fn clear_node_cpu_usage_percent(&mut self) {
        self.node_cpu_usage_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_node_cpu_usage_percent(&mut self, v: f32) {
        self.node_cpu_usage_percent = v;
    }
}

impl ::protobuf::Message for HotTablet {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.start_key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.end_key)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.node_cpu_usage_percent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.table_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table_name);
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.end_key);
        }
        if self.node_cpu_usage_percent != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.table_name.is_empty() {
            os.write_string(2, &self.table_name)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.start_key.is_empty() {
            os.write_string(5, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_string(6, &self.end_key)?;
        }
        if self.node_cpu_usage_percent != 0. {
            os.write_float(7, self.node_cpu_usage_percent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HotTablet {
        HotTablet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HotTablet| { &m.name },
                |m: &mut HotTablet| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &HotTablet| { &m.table_name },
                |m: &mut HotTablet| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &HotTablet| { &m.start_time },
                |m: &mut HotTablet| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &HotTablet| { &m.end_time },
                |m: &mut HotTablet| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start_key",
                |m: &HotTablet| { &m.start_key },
                |m: &mut HotTablet| { &mut m.start_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "end_key",
                |m: &HotTablet| { &m.end_key },
                |m: &mut HotTablet| { &mut m.end_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "node_cpu_usage_percent",
                |m: &HotTablet| { &m.node_cpu_usage_percent },
                |m: &mut HotTablet| { &mut m.node_cpu_usage_percent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HotTablet>(
                "HotTablet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HotTablet {
        static instance: ::protobuf::rt::LazyV2<HotTablet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HotTablet::new)
    }
}

impl ::protobuf::Clear for HotTablet {
    fn clear(&mut self) {
        self.name.clear();
        self.table_name.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.start_key.clear();
        self.end_key.clear();
        self.node_cpu_usage_percent = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HotTablet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HotTablet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'google/bigtable/admin/v2/instance.proto\x12\x18google.bigtable.admin.\
    v2\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.pro\
    to\x1a%google/bigtable/admin/v2/common.proto\x1a\x1fgoogle/protobuf/time\
    stamp.proto\"\x94\x05\n\x08Instance\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12&\n\x0cdisplay_name\x18\x02\x20\x01(\tR\x0bdisplayNameB\x03\
    \xe0A\x02\x12>\n\x05state\x18\x03\x20\x01(\x0e2(.google.bigtable.admin.v\
    2.Instance.StateR\x05state\x12;\n\x04type\x18\x04\x20\x01(\x0e2'.google.\
    bigtable.admin.v2.Instance.TypeR\x04type\x12F\n\x06labels\x18\x05\x20\
    \x03(\x0b2..google.bigtable.admin.v2.Instance.LabelsEntryR\x06labels\x12\
    @\n\x0bcreate_time\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \ncreateTimeB\x03\xe0A\x03\x12-\n\rsatisfies_pzs\x18\x08\x20\x01(\x08H\0\
    R\x0csatisfiesPzsB\x03\xe0A\x03\x88\x01\x01\x1a9\n\x0bLabelsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"5\n\x05State\x12\x13\n\x0fSTATE_NOT_KNOWN\
    \x10\0\x12\t\n\x05READY\x10\x01\x12\x0c\n\x08CREATING\x10\x02\"=\n\x04Ty\
    pe\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\x0e\n\nPRODUCTION\x10\x01\x12\
    \x0f\n\x0bDEVELOPMENT\x10\x02B\x10\n\x0e_satisfies_pzs:S\xeaAP\n%bigtabl\
    eadmin.googleapis.com/Instance\x12'projects/{project}/instances/{instanc\
    e}\"\x94\x01\n\x12AutoscalingTargets\x126\n\x17cpu_utilization_percent\
    \x18\x02\x20\x01(\x05R\x15cpuUtilizationPercent\x12F\n\x20storage_utiliz\
    ation_gib_per_node\x18\x03\x20\x01(\x05R\x1cstorageUtilizationGibPerNode\
    \"m\n\x11AutoscalingLimits\x12+\n\x0fmin_serve_nodes\x18\x01\x20\x01(\
    \x05R\rminServeNodesB\x03\xe0A\x02\x12+\n\x0fmax_serve_nodes\x18\x02\x20\
    \x01(\x05R\rmaxServeNodesB\x03\xe0A\x02\"\xf7\x08\n\x07Cluster\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12E\n\x08location\x18\x02\x20\x01(\
    \tR\x08locationB)\xfaA#\n!locations.googleapis.com/Location\xe0A\x05\x12\
    B\n\x05state\x18\x03\x20\x01(\x0e2'.google.bigtable.admin.v2.Cluster.Sta\
    teR\x05stateB\x03\xe0A\x03\x12\x1f\n\x0bserve_nodes\x18\x04\x20\x01(\x05\
    R\nserveNodes\x12X\n\x0ecluster_config\x18\x07\x20\x01(\x0b2/.google.big\
    table.admin.v2.Cluster.ClusterConfigH\0R\rclusterConfig\x12\\\n\x14defau\
    lt_storage_type\x18\x05\x20\x01(\x0e2%.google.bigtable.admin.v2.StorageT\
    ypeR\x12defaultStorageTypeB\x03\xe0A\x05\x12d\n\x11encryption_config\x18\
    \x06\x20\x01(\x0b22.google.bigtable.admin.v2.Cluster.EncryptionConfigR\
    \x10encryptionConfigB\x03\xe0A\x05\x1a\xdf\x01\n\x18ClusterAutoscalingCo\
    nfig\x12_\n\x12autoscaling_limits\x18\x01\x20\x01(\x0b2+.google.bigtable\
    .admin.v2.AutoscalingLimitsR\x11autoscalingLimitsB\x03\xe0A\x02\x12b\n\
    \x13autoscaling_targets\x18\x02\x20\x01(\x0b2,.google.bigtable.admin.v2.\
    AutoscalingTargetsR\x12autoscalingTargetsB\x03\xe0A\x02\x1a\x89\x01\n\rC\
    lusterConfig\x12x\n\x1acluster_autoscaling_config\x18\x01\x20\x01(\x0b2:\
    .google.bigtable.admin.v2.Cluster.ClusterAutoscalingConfigR\x18clusterAu\
    toscalingConfig\x1a\\\n\x10EncryptionConfig\x12H\n\x0ckms_key_name\x18\
    \x01\x20\x01(\tR\nkmsKeyNameB&\xfaA#\n!cloudkms.googleapis.com/CryptoKey\
    \"Q\n\x05State\x12\x13\n\x0fSTATE_NOT_KNOWN\x10\0\x12\t\n\x05READY\x10\
    \x01\x12\x0c\n\x08CREATING\x10\x02\x12\x0c\n\x08RESIZING\x10\x03\x12\x0c\
    \n\x08DISABLED\x10\x04B\x08\n\x06config:e\xeaAb\n$bigtableadmin.googleap\
    is.com/Cluster\x12:projects/{project}/instances/{instance}/clusters/{clu\
    ster}\"\x8b\x08\n\nAppProfile\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x12\x12\n\x04etag\x18\x02\x20\x01(\tR\x04etag\x12\x20\n\x0bdescripti\
    on\x18\x03\x20\x01(\tR\x0bdescription\x12\x82\x01\n\x1dmulti_cluster_rou\
    ting_use_any\x18\x05\x20\x01(\x0b2>.google.bigtable.admin.v2.AppProfile.\
    MultiClusterRoutingUseAnyH\0R\x19multiClusterRoutingUseAny\x12q\n\x16sin\
    gle_cluster_routing\x18\x06\x20\x01(\x0b29.google.bigtable.admin.v2.AppP\
    rofile.SingleClusterRoutingH\0R\x14singleClusterRouting\x12O\n\x08priori\
    ty\x18\x07\x20\x01(\x0e2-.google.bigtable.admin.v2.AppProfile.PriorityH\
    \x01R\x08priorityB\x02\x18\x01\x12g\n\x12standard_isolation\x18\x0b\x20\
    \x01(\x0b26.google.bigtable.admin.v2.AppProfile.StandardIsolationH\x01R\
    \x11standardIsolation\x1a<\n\x19MultiClusterRoutingUseAny\x12\x1f\n\x0bc\
    luster_ids\x18\x01\x20\x03(\tR\nclusterIds\x1as\n\x14SingleClusterRoutin\
    g\x12\x1d\n\ncluster_id\x18\x01\x20\x01(\tR\tclusterId\x12<\n\x1aallow_t\
    ransactional_writes\x18\x02\x20\x01(\x08R\x18allowTransactionalWrites\
    \x1a^\n\x11StandardIsolation\x12I\n\x08priority\x18\x01\x20\x01(\x0e2-.g\
    oogle.bigtable.admin.v2.AppProfile.PriorityR\x08priority\"^\n\x08Priorit\
    y\x12\x18\n\x14PRIORITY_UNSPECIFIED\x10\0\x12\x10\n\x0cPRIORITY_LOW\x10\
    \x01\x12\x13\n\x0fPRIORITY_MEDIUM\x10\x02\x12\x11\n\rPRIORITY_HIGH\x10\
    \x03B\x10\n\x0erouting_policyB\x0b\n\tisolation:o\xeaAl\n'bigtableadmin.\
    googleapis.com/AppProfile\x12Aprojects/{project}/instances/{instance}/ap\
    pProfiles/{app_profile}\"\xd4\x03\n\tHotTablet\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12F\n\ntable_name\x18\x02\x20\x01(\tR\ttableNameB'\
    \xfaA$\n\"bigtableadmin.googleapis.com/Table\x12>\n\nstart_time\x18\x03\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTimeB\x03\xe0A\x03\
    \x12:\n\x08end_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x07endTimeB\x03\xe0A\x03\x12\x1b\n\tstart_key\x18\x05\x20\x01(\tR\x08st\
    artKey\x12\x17\n\x07end_key\x18\x06\x20\x01(\tR\x06endKey\x128\n\x16node\
    _cpu_usage_percent\x18\x07\x20\x01(\x02R\x13nodeCpuUsagePercentB\x03\xe0\
    A\x03:\x7f\xeaA|\n&bigtableadmin.googleapis.com/HotTablet\x12Rprojects/{\
    project}/instances/{instance}/clusters/{cluster}/hotTablets/{hot_tablet}\
    B\xd0\x02\n\x1ccom.google.bigtable.admin.v2B\rInstanceProtoP\x01Z=google\
    .golang.org/genproto/googleapis/bigtable/admin/v2;admin\xaa\x02\x1eGoogl\
    e.Cloud.Bigtable.Admin.V2\xca\x02\x1eGoogle\\Cloud\\Bigtable\\Admin\\V2\
    \xea\x02\"Google::Cloud::Bigtable::Admin::V2\xeaAx\n!cloudkms.googleapis\
    .com/CryptoKey\x12Sprojects/{project}/locations/{location}/keyRings/{key\
    _ring}/cryptoKeys/{crypto_key}J\x85s\n\x07\x12\x05\x0e\0\xfc\x02\x01\n\
    \xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202023\x20Go\
    ogle\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ver\
    sion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20th\
    is\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0!\n\t\n\x02\x03\0\
    \x12\x03\x12\0)\n\t\n\x02\x03\x01\x12\x03\x13\0#\n\t\n\x02\x03\x02\x12\
    \x03\x14\0/\n\t\n\x02\x03\x03\x12\x03\x15\0)\n\x08\n\x01\x08\x12\x03\x17\
    \0;\n\t\n\x02\x08%\x12\x03\x17\0;\n\x08\n\x01\x08\x12\x03\x18\0T\n\t\n\
    \x02\x08\x0b\x12\x03\x18\0T\n\x08\n\x01\x08\x12\x03\x19\0\"\n\t\n\x02\
    \x08\n\x12\x03\x19\0\"\n\x08\n\x01\x08\x12\x03\x1a\0.\n\t\n\x02\x08\x08\
    \x12\x03\x1a\0.\n\x08\n\x01\x08\x12\x03\x1b\05\n\t\n\x02\x08\x01\x12\x03\
    \x1b\05\n\x08\n\x01\x08\x12\x03\x1c\0<\n\t\n\x02\x08)\x12\x03\x1c\0<\n\
    \x08\n\x01\x08\x12\x03\x1d\0;\n\t\n\x02\x08-\x12\x03\x1d\0;\n\t\n\x01\
    \x08\x12\x04\x1e\0!\x02\n\x0c\n\x04\x08\x9d\x08\0\x12\x04\x1e\0!\x02\n\
    \xe2\x01\n\x02\x04\0\x12\x04'\0p\x01\x1a\xd5\x01\x20A\x20collection\x20o\
    f\x20Bigtable\x20[Tables][google.bigtable.admin.v2.Table]\x20and\n\x20th\
    e\x20resources\x20that\x20serve\x20them.\n\x20All\x20tables\x20in\x20an\
    \x20instance\x20are\x20served\x20from\x20all\n\x20[Clusters][google.bigt\
    able.admin.v2.Cluster]\x20in\x20the\x20instance.\n\n\n\n\x03\x04\0\x01\
    \x12\x03'\x08\x10\n\x0b\n\x03\x04\0\x07\x12\x04(\x02+\x04\n\r\n\x05\x04\
    \0\x07\x9d\x08\x12\x04(\x02+\x04\n/\n\x04\x04\0\x04\0\x12\x04.\x029\x03\
    \x1a!\x20Possible\x20states\x20of\x20an\x20instance.\n\n\x0c\n\x05\x04\0\
    \x04\0\x01\x12\x03.\x07\x0c\nC\n\x06\x04\0\x04\0\x02\0\x12\x030\x04\x18\
    \x1a4\x20The\x20state\x20of\x20the\x20instance\x20could\x20not\x20be\x20\
    determined.\n\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x030\x04\x13\n\x0e\n\
    \x07\x04\0\x04\0\x02\0\x02\x12\x030\x16\x17\nb\n\x06\x04\0\x04\0\x02\x01\
    \x12\x034\x04\x0e\x1aS\x20The\x20instance\x20has\x20been\x20successfully\
    \x20created\x20and\x20can\x20serve\x20requests\n\x20to\x20its\x20tables.\
    \n\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x034\x04\t\n\x0e\n\x07\x04\0\
    \x04\0\x02\x01\x02\x12\x034\x0c\r\n|\n\x06\x04\0\x04\0\x02\x02\x12\x038\
    \x04\x11\x1am\x20The\x20instance\x20is\x20currently\x20being\x20created,\
    \x20and\x20may\x20be\x20destroyed\n\x20if\x20the\x20creation\x20process\
    \x20encounters\x20an\x20error.\n\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\
    \x038\x04\x0c\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x038\x0f\x10\n)\n\
    \x04\x04\0\x04\x01\x12\x04<\x02I\x03\x1a\x1b\x20The\x20type\x20of\x20the\
    \x20instance.\n\n\x0c\n\x05\x04\0\x04\x01\x01\x12\x03<\x07\x0b\n\xca\x01\
    \n\x06\x04\0\x04\x01\x02\0\x12\x03@\x04\x19\x1a\xba\x01\x20The\x20type\
    \x20of\x20the\x20instance\x20is\x20unspecified.\x20If\x20set\x20when\x20\
    creating\x20an\n\x20instance,\x20a\x20`PRODUCTION`\x20instance\x20will\
    \x20be\x20created.\x20If\x20set\x20when\x20updating\n\x20an\x20instance,\
    \x20the\x20type\x20will\x20be\x20left\x20unchanged.\n\n\x0e\n\x07\x04\0\
    \x04\x01\x02\0\x01\x12\x03@\x04\x14\n\x0e\n\x07\x04\0\x04\x01\x02\0\x02\
    \x12\x03@\x17\x18\na\n\x06\x04\0\x04\x01\x02\x01\x12\x03D\x04\x13\x1aR\
    \x20An\x20instance\x20meant\x20for\x20production\x20use.\x20`serve_nodes\
    `\x20must\x20be\x20set\n\x20on\x20the\x20cluster.\n\n\x0e\n\x07\x04\0\
    \x04\x01\x02\x01\x01\x12\x03D\x04\x0e\n\x0e\n\x07\x04\0\x04\x01\x02\x01\
    \x02\x12\x03D\x11\x12\n\x89\x01\n\x06\x04\0\x04\x01\x02\x02\x12\x03H\x04\
    \x14\x1az\x20DEPRECATED:\x20Prefer\x20PRODUCTION\x20for\x20all\x20use\
    \x20cases,\x20as\x20it\x20no\x20longer\x20enforces\n\x20a\x20higher\x20m\
    inimum\x20node\x20count\x20than\x20DEVELOPMENT.\n\n\x0e\n\x07\x04\0\x04\
    \x01\x02\x02\x01\x12\x03H\x04\x0f\n\x0e\n\x07\x04\0\x04\x01\x02\x02\x02\
    \x12\x03H\x12\x13\n\x81\x01\n\x04\x04\0\x02\0\x12\x03M\x02\x12\x1at\x20T\
    he\x20unique\x20name\x20of\x20the\x20instance.\x20Values\x20are\x20of\
    \x20the\x20form\n\x20`projects/{project}/instances/[a-z][a-z0-9\\\\-]+[a\
    -z0-9]`.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03M\x02\x08\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03M\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03M\x10\x11\n\
    \xab\x01\n\x04\x04\0\x02\x01\x12\x03R\x02C\x1a\x9d\x01\x20Required.\x20T\
    he\x20descriptive\x20name\x20for\x20this\x20instance\x20as\x20it\x20appe\
    ars\x20in\x20UIs.\n\x20Can\x20be\x20changed\x20at\x20any\x20time,\x20but\
    \x20should\x20be\x20kept\x20globally\x20unique\n\x20to\x20avoid\x20confu\
    sion.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03R\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x03R\t\x15\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03R\x18\
    \x19\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03R\x1aB\n\x0f\n\x08\x04\0\x02\
    \x01\x08\x9c\x08\0\x12\x03R\x1bA\nA\n\x04\x04\0\x02\x02\x12\x03V\x02\x12\
    \x1a4\x20(`OutputOnly`)\n\x20The\x20current\x20state\x20of\x20the\x20ins\
    tance.\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03V\x02\x07\n\x0c\n\x05\x04\
    \0\x02\x02\x01\x12\x03V\x08\r\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03V\x10\
    \x11\nB\n\x04\x04\0\x02\x03\x12\x03Y\x02\x10\x1a5\x20The\x20type\x20of\
    \x20the\x20instance.\x20Defaults\x20to\x20`PRODUCTION`.\n\n\x0c\n\x05\
    \x04\0\x02\x03\x06\x12\x03Y\x02\x06\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03Y\x07\x0b\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03Y\x0e\x0f\n\x82\x05\n\
    \x04\x04\0\x02\x04\x12\x03f\x02!\x1a\xf4\x04\x20Labels\x20are\x20a\x20fl\
    exible\x20and\x20lightweight\x20mechanism\x20for\x20organizing\x20cloud\
    \n\x20resources\x20into\x20groups\x20that\x20reflect\x20a\x20customer's\
    \x20organizational\x20needs\x20and\n\x20deployment\x20strategies.\x20The\
    y\x20can\x20be\x20used\x20to\x20filter\x20resources\x20and\x20aggregate\
    \n\x20metrics.\n\n\x20*\x20Label\x20keys\x20must\x20be\x20between\x201\
    \x20and\x2063\x20characters\x20long\x20and\x20must\x20conform\x20to\n\
    \x20\x20\x20the\x20regular\x20expression:\x20`[\\p{Ll}\\p{Lo}][\\p{Ll}\\\
    p{Lo}\\p{N}_-]{0,62}`.\n\x20*\x20Label\x20values\x20must\x20be\x20betwee\
    n\x200\x20and\x2063\x20characters\x20long\x20and\x20must\x20conform\x20t\
    o\n\x20\x20\x20the\x20regular\x20expression:\x20`[\\p{Ll}\\p{Lo}\\p{N}_-\
    ]{0,63}`.\n\x20*\x20No\x20more\x20than\x2064\x20labels\x20can\x20be\x20a\
    ssociated\x20with\x20a\x20given\x20resource.\n\x20*\x20Keys\x20and\x20va\
    lues\x20must\x20both\x20be\x20under\x20128\x20bytes.\n\n\x0c\n\x05\x04\0\
    \x02\x04\x06\x12\x03f\x02\x15\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03f\x16\
    \x1c\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03f\x1f\x20\n\xcf\x01\n\x04\x04\
    \0\x02\x05\x12\x04k\x02l2\x1a\xc0\x01\x20Output\x20only.\x20A\x20server-\
    assigned\x20timestamp\x20representing\x20when\x20this\x20Instance\n\x20w\
    as\x20created.\x20For\x20instances\x20created\x20before\x20this\x20field\
    \x20was\x20added\x20(August\n\x202021),\x20this\x20value\x20is\x20`secon\
    ds:\x200,\x20nanos:\x201`.\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03k\x02\
    \x1b\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03k\x1c'\n\x0c\n\x05\x04\0\x02\
    \x05\x03\x12\x03k*+\n\x0c\n\x05\x04\0\x02\x05\x08\x12\x03l\x061\n\x0f\n\
    \x08\x04\0\x02\x05\x08\x9c\x08\0\x12\x03l\x070\n4\n\x04\x04\0\x02\x06\
    \x12\x03o\x02N\x1a'\x20Output\x20only.\x20Reserved\x20for\x20future\x20u\
    se.\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\0\x02\
    \x06\x05\x12\x03o\x0b\x0f\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03o\x10\x1d\
    \n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03o\x20!\n\x0c\n\x05\x04\0\x02\x06\
    \x08\x12\x03o\"M\n\x0f\n\x08\x04\0\x02\x06\x08\x9c\x08\0\x12\x03o#L\n\\\
    \n\x02\x04\x01\x12\x05s\0\x81\x01\x01\x1aO\x20The\x20Autoscaling\x20targ\
    ets\x20for\x20a\x20Cluster.\x20These\x20determine\x20the\x20recommended\
    \x20nodes.\n\n\n\n\x03\x04\x01\x01\x12\x03s\x08\x1a\n\xf8\x01\n\x04\x04\
    \x01\x02\0\x12\x03x\x02$\x1a\xea\x01\x20The\x20cpu\x20utilization\x20tha\
    t\x20the\x20Autoscaler\x20should\x20be\x20trying\x20to\x20achieve.\n\x20\
    This\x20number\x20is\x20on\x20a\x20scale\x20from\x200\x20(no\x20utilizat\
    ion)\x20to\n\x20100\x20(total\x20utilization),\x20and\x20is\x20limited\
    \x20between\x2010\x20and\x2080,\x20otherwise\x20it\n\x20will\x20return\
    \x20INVALID_ARGUMENT\x20error.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03x\
    \x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03x\x08\x1f\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03x\"#\n\x8e\x03\n\x04\x04\x01\x02\x01\x12\x04\x80\
    \x01\x02-\x1a\xff\x02\x20The\x20storage\x20utilization\x20that\x20the\
    \x20Autoscaler\x20should\x20be\x20trying\x20to\x20achieve.\n\x20This\x20\
    number\x20is\x20limited\x20between\x202560\x20(2.5TiB)\x20and\x205120\
    \x20(5TiB)\x20for\x20a\x20SSD\n\x20cluster\x20and\x20between\x208192\x20\
    (8TiB)\x20and\x2016384\x20(16TiB)\x20for\x20an\x20HDD\x20cluster,\n\x20o\
    therwise\x20it\x20will\x20return\x20INVALID_ARGUMENT\x20error.\x20If\x20\
    this\x20value\x20is\x20set\x20to\x200,\n\x20it\x20will\x20be\x20treated\
    \x20as\x20if\x20it\x20were\x20set\x20to\x20the\x20default\x20value:\x202\
    560\x20for\x20SSD,\n\x208192\x20for\x20HDD.\n\n\r\n\x05\x04\x01\x02\x01\
    \x05\x12\x04\x80\x01\x02\x07\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\x80\
    \x01\x08(\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x80\x01+,\nR\n\x02\x04\
    \x02\x12\x06\x84\x01\0\x8a\x01\x01\x1aD\x20Limits\x20for\x20the\x20numbe\
    r\x20of\x20nodes\x20a\x20Cluster\x20can\x20autoscale\x20up/down\x20to.\n\
    \n\x0b\n\x03\x04\x02\x01\x12\x04\x84\x01\x08\x19\nC\n\x04\x04\x02\x02\0\
    \x12\x04\x86\x01\x02E\x1a5\x20Required.\x20Minimum\x20number\x20of\x20no\
    des\x20to\x20scale\x20down\x20to.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\
    \x86\x01\x02\x07\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x86\x01\x08\x17\n\r\
    \n\x05\x04\x02\x02\0\x03\x12\x04\x86\x01\x1a\x1b\n\r\n\x05\x04\x02\x02\0\
    \x08\x12\x04\x86\x01\x1cD\n\x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\
    \x04\x86\x01\x1dC\nA\n\x04\x04\x02\x02\x01\x12\x04\x89\x01\x02E\x1a3\x20\
    Required.\x20Maximum\x20number\x20of\x20nodes\x20to\x20scale\x20up\x20to\
    .\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\x89\x01\x02\x07\n\r\n\x05\x04\
    \x02\x02\x01\x01\x12\x04\x89\x01\x08\x17\n\r\n\x05\x04\x02\x02\x01\x03\
    \x12\x04\x89\x01\x1a\x1b\n\r\n\x05\x04\x02\x02\x01\x08\x12\x04\x89\x01\
    \x1cD\n\x10\n\x08\x04\x02\x02\x01\x08\x9c\x08\0\x12\x04\x89\x01\x1dC\n\
    \xca\x01\n\x02\x04\x03\x12\x06\x8f\x01\0\xf4\x01\x01\x1a\xbb\x01\x20A\
    \x20resizable\x20group\x20of\x20nodes\x20in\x20a\x20particular\x20cloud\
    \x20location,\x20capable\n\x20of\x20serving\x20all\x20[Tables][google.bi\
    gtable.admin.v2.Table]\x20in\x20the\x20parent\n\x20[Instance][google.big\
    table.admin.v2.Instance].\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x8f\x01\x08\
    \x0f\n\r\n\x03\x04\x03\x07\x12\x06\x90\x01\x02\x93\x01\x04\n\x0f\n\x05\
    \x04\x03\x07\x9d\x08\x12\x06\x90\x01\x02\x93\x01\x04\n/\n\x04\x04\x03\
    \x04\0\x12\x06\x96\x01\x02\xac\x01\x03\x1a\x1f\x20Possible\x20states\x20\
    of\x20a\x20cluster.\n\n\r\n\x05\x04\x03\x04\0\x01\x12\x04\x96\x01\x07\
    \x0c\nC\n\x06\x04\x03\x04\0\x02\0\x12\x04\x98\x01\x04\x18\x1a3\x20The\
    \x20state\x20of\x20the\x20cluster\x20could\x20not\x20be\x20determined.\n\
    \n\x0f\n\x07\x04\x03\x04\0\x02\0\x01\x12\x04\x98\x01\x04\x13\n\x0f\n\x07\
    \x04\x03\x04\0\x02\0\x02\x12\x04\x98\x01\x16\x17\n[\n\x06\x04\x03\x04\0\
    \x02\x01\x12\x04\x9b\x01\x04\x0e\x1aK\x20The\x20cluster\x20has\x20been\
    \x20successfully\x20created\x20and\x20is\x20ready\x20to\x20serve\x20requ\
    ests.\n\n\x0f\n\x07\x04\x03\x04\0\x02\x01\x01\x12\x04\x9b\x01\x04\t\n\
    \x0f\n\x07\x04\x03\x04\0\x02\x01\x02\x12\x04\x9b\x01\x0c\r\n\xbf\x01\n\
    \x06\x04\x03\x04\0\x02\x02\x12\x04\xa0\x01\x04\x11\x1a\xae\x01\x20The\
    \x20cluster\x20is\x20currently\x20being\x20created,\x20and\x20may\x20be\
    \x20destroyed\n\x20if\x20the\x20creation\x20process\x20encounters\x20an\
    \x20error.\n\x20A\x20cluster\x20may\x20not\x20be\x20able\x20to\x20serve\
    \x20requests\x20while\x20being\x20created.\n\n\x0f\n\x07\x04\x03\x04\0\
    \x02\x02\x01\x12\x04\xa0\x01\x04\x0c\n\x0f\n\x07\x04\x03\x04\0\x02\x02\
    \x02\x12\x04\xa0\x01\x0f\x10\n\xbe\x02\n\x06\x04\x03\x04\0\x02\x03\x12\
    \x04\xa7\x01\x04\x11\x1a\xad\x02\x20The\x20cluster\x20is\x20currently\
    \x20being\x20resized,\x20and\x20may\x20revert\x20to\x20its\x20previous\n\
    \x20node\x20count\x20if\x20the\x20process\x20encounters\x20an\x20error.\
    \n\x20A\x20cluster\x20is\x20still\x20capable\x20of\x20serving\x20request\
    s\x20while\x20being\x20resized,\n\x20but\x20may\x20exhibit\x20performanc\
    e\x20as\x20if\x20its\x20number\x20of\x20allocated\x20nodes\x20is\n\x20be\
    tween\x20the\x20starting\x20and\x20requested\x20states.\n\n\x0f\n\x07\
    \x04\x03\x04\0\x02\x03\x01\x12\x04\xa7\x01\x04\x0c\n\x0f\n\x07\x04\x03\
    \x04\0\x02\x03\x02\x12\x04\xa7\x01\x0f\x10\n\x86\x01\n\x06\x04\x03\x04\0\
    \x02\x04\x12\x04\xab\x01\x04\x11\x1av\x20The\x20cluster\x20has\x20no\x20\
    backing\x20nodes.\x20The\x20data\x20(tables)\x20still\n\x20exist,\x20but\
    \x20no\x20operations\x20can\x20be\x20performed\x20on\x20the\x20cluster.\
    \n\n\x0f\n\x07\x04\x03\x04\0\x02\x04\x01\x12\x04\xab\x01\x04\x0c\n\x0f\n\
    \x07\x04\x03\x04\0\x02\x04\x02\x12\x04\xab\x01\x0f\x10\n3\n\x04\x04\x03\
    \x03\0\x12\x06\xaf\x01\x02\xb7\x01\x03\x1a#\x20Autoscaling\x20config\x20\
    for\x20a\x20cluster.\n\n\r\n\x05\x04\x03\x03\0\x01\x12\x04\xaf\x01\n\"\n\
    B\n\x06\x04\x03\x03\0\x02\0\x12\x06\xb1\x01\x04\xb2\x011\x1a0\x20Require\
    d.\x20Autoscaling\x20limits\x20for\x20this\x20cluster.\n\n\x0f\n\x07\x04\
    \x03\x03\0\x02\0\x06\x12\x04\xb1\x01\x04\x15\n\x0f\n\x07\x04\x03\x03\0\
    \x02\0\x01\x12\x04\xb1\x01\x16(\n\x0f\n\x07\x04\x03\x03\0\x02\0\x03\x12\
    \x04\xb1\x01+,\n\x0f\n\x07\x04\x03\x03\0\x02\0\x08\x12\x04\xb2\x01\x080\
    \n\x12\n\n\x04\x03\x03\0\x02\0\x08\x9c\x08\0\x12\x04\xb2\x01\t/\nC\n\x06\
    \x04\x03\x03\0\x02\x01\x12\x06\xb5\x01\x04\xb6\x011\x1a1\x20Required.\
    \x20Autoscaling\x20targets\x20for\x20this\x20cluster.\n\n\x0f\n\x07\x04\
    \x03\x03\0\x02\x01\x06\x12\x04\xb5\x01\x04\x16\n\x0f\n\x07\x04\x03\x03\0\
    \x02\x01\x01\x12\x04\xb5\x01\x17*\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x03\
    \x12\x04\xb5\x01-.\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x08\x12\x04\xb6\x01\
    \x080\n\x12\n\n\x04\x03\x03\0\x02\x01\x08\x9c\x08\0\x12\x04\xb6\x01\t/\n\
    .\n\x04\x04\x03\x03\x01\x12\x06\xba\x01\x02\xbd\x01\x03\x1a\x1e\x20Confi\
    guration\x20for\x20a\x20cluster.\n\n\r\n\x05\x04\x03\x03\x01\x01\x12\x04\
    \xba\x01\n\x17\n=\n\x06\x04\x03\x03\x01\x02\0\x12\x04\xbc\x01\x04<\x1a-\
    \x20Autoscaling\x20configuration\x20for\x20this\x20cluster.\n\n\x0f\n\
    \x07\x04\x03\x03\x01\x02\0\x06\x12\x04\xbc\x01\x04\x1c\n\x0f\n\x07\x04\
    \x03\x03\x01\x02\0\x01\x12\x04\xbc\x01\x1d7\n\x0f\n\x07\x04\x03\x03\x01\
    \x02\0\x03\x12\x04\xbc\x01:;\nb\n\x04\x04\x03\x03\x02\x12\x06\xc1\x01\
    \x02\xcf\x01\x03\x1aR\x20Cloud\x20Key\x20Management\x20Service\x20(Cloud\
    \x20KMS)\x20settings\x20for\x20a\x20CMEK-protected\n\x20cluster.\n\n\r\n\
    \x05\x04\x03\x03\x02\x01\x12\x04\xc1\x01\n\x1a\n\xe5\x04\n\x06\x04\x03\
    \x03\x02\x02\0\x12\x06\xcc\x01\x04\xce\x01\x07\x1a\xd2\x04\x20Describes\
    \x20the\x20Cloud\x20KMS\x20encryption\x20key\x20that\x20will\x20be\x20us\
    ed\x20to\x20protect\x20the\n\x20destination\x20Bigtable\x20cluster.\x20T\
    he\x20requirements\x20for\x20this\x20key\x20are:\n\x20\x201)\x20The\x20C\
    loud\x20Bigtable\x20service\x20account\x20associated\x20with\x20the\x20p\
    roject\x20that\n\x20\x20contains\x20this\x20cluster\x20must\x20be\x20gra\
    nted\x20the\n\x20\x20`cloudkms.cryptoKeyEncrypterDecrypter`\x20role\x20o\
    n\x20the\x20CMEK\x20key.\n\x20\x202)\x20Only\x20regional\x20keys\x20can\
    \x20be\x20used\x20and\x20the\x20region\x20of\x20the\x20CMEK\x20key\x20mu\
    st\n\x20\x20match\x20the\x20region\x20of\x20the\x20cluster.\n\x20\x203)\
    \x20All\x20clusters\x20within\x20an\x20instance\x20must\x20use\x20the\
    \x20same\x20CMEK\x20key.\n\x20Values\x20are\x20of\x20the\x20form\n\x20`p\
    rojects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{ke\
    y}`\n\n\x0f\n\x07\x04\x03\x03\x02\x02\0\x05\x12\x04\xcc\x01\x04\n\n\x0f\
    \n\x07\x04\x03\x03\x02\x02\0\x01\x12\x04\xcc\x01\x0b\x17\n\x0f\n\x07\x04\
    \x03\x03\x02\x02\0\x03\x12\x04\xcc\x01\x1a\x1b\n\x11\n\x07\x04\x03\x03\
    \x02\x02\0\x08\x12\x06\xcc\x01\x1c\xce\x01\x06\n\x13\n\t\x04\x03\x03\x02\
    \x02\0\x08\x9f\x08\x12\x06\xcc\x01\x1d\xce\x01\x05\n\x8b\x01\n\x04\x04\
    \x03\x02\0\x12\x04\xd3\x01\x02\x12\x1a}\x20The\x20unique\x20name\x20of\
    \x20the\x20cluster.\x20Values\x20are\x20of\x20the\x20form\n\x20`projects\
    /{project}/instances/{instance}/clusters/[a-z][-a-z0-9]*`.\n\n\r\n\x05\
    \x04\x03\x02\0\x05\x12\x04\xd3\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\
    \x12\x04\xd3\x01\t\r\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xd3\x01\x10\x11\
    \n\x9d\x02\n\x04\x04\x03\x02\x01\x12\x06\xd9\x01\x02\xde\x01\x04\x1a\x8c\
    \x02\x20Immutable.\x20The\x20location\x20where\x20this\x20cluster's\x20n\
    odes\x20and\x20storage\x20reside.\x20For\n\x20best\x20performance,\x20cl\
    ients\x20should\x20be\x20located\x20as\x20close\x20as\x20possible\x20to\
    \x20this\n\x20cluster.\x20Currently\x20only\x20zones\x20are\x20supported\
    ,\x20so\x20values\x20should\x20be\x20of\x20the\n\x20form\x20`projects/{p\
    roject}/locations/{zone}`.\n\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xd9\
    \x01\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xd9\x01\t\x11\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\xd9\x01\x14\x15\n\x0f\n\x05\x04\x03\x02\
    \x01\x08\x12\x06\xd9\x01\x16\xde\x01\x03\n\x10\n\x08\x04\x03\x02\x01\x08\
    \x9c\x08\0\x12\x04\xda\x01\x04+\n\x11\n\x07\x04\x03\x02\x01\x08\x9f\x08\
    \x12\x06\xdb\x01\x04\xdd\x01\x05\n>\n\x04\x04\x03\x02\x02\x12\x04\xe1\
    \x01\x02>\x1a0\x20Output\x20only.\x20The\x20current\x20state\x20of\x20th\
    e\x20cluster.\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\xe1\x01\x02\x07\n\
    \r\n\x05\x04\x03\x02\x02\x01\x12\x04\xe1\x01\x08\r\n\r\n\x05\x04\x03\x02\
    \x02\x03\x12\x04\xe1\x01\x10\x11\n\r\n\x05\x04\x03\x02\x02\x08\x12\x04\
    \xe1\x01\x12=\n\x10\n\x08\x04\x03\x02\x02\x08\x9c\x08\0\x12\x04\xe1\x01\
    \x13<\n\x84\x01\n\x04\x04\x03\x02\x03\x12\x04\xe5\x01\x02\x18\x1av\x20Th\
    e\x20number\x20of\x20nodes\x20allocated\x20to\x20this\x20cluster.\x20Mor\
    e\x20nodes\x20enable\x20higher\n\x20throughput\x20and\x20more\x20consist\
    ent\x20performance.\n\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\xe5\x01\x02\
    \x07\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xe5\x01\x08\x13\n\r\n\x05\x04\
    \x03\x02\x03\x03\x12\x04\xe5\x01\x16\x17\n\x0e\n\x04\x04\x03\x08\0\x12\
    \x06\xe7\x01\x02\xea\x01\x03\n\r\n\x05\x04\x03\x08\0\x01\x12\x04\xe7\x01\
    \x08\x0e\n/\n\x04\x04\x03\x02\x04\x12\x04\xe9\x01\x04%\x1a!\x20Configura\
    tion\x20for\x20this\x20cluster.\n\n\r\n\x05\x04\x03\x02\x04\x06\x12\x04\
    \xe9\x01\x04\x11\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xe9\x01\x12\x20\n\
    \r\n\x05\x04\x03\x02\x04\x03\x12\x04\xe9\x01#$\n\x8b\x01\n\x04\x04\x03\
    \x02\x05\x12\x06\xee\x01\x02\xef\x010\x1a{\x20Immutable.\x20The\x20type\
    \x20of\x20storage\x20used\x20by\x20this\x20cluster\x20to\x20serve\x20its\
    \n\x20parent\x20instance's\x20tables,\x20unless\x20explicitly\x20overrid\
    den.\n\n\r\n\x05\x04\x03\x02\x05\x06\x12\x04\xee\x01\x02\r\n\r\n\x05\x04\
    \x03\x02\x05\x01\x12\x04\xee\x01\x0e\"\n\r\n\x05\x04\x03\x02\x05\x03\x12\
    \x04\xee\x01%&\n\r\n\x05\x04\x03\x02\x05\x08\x12\x04\xef\x01\x06/\n\x10\
    \n\x08\x04\x03\x02\x05\x08\x9c\x08\0\x12\x04\xef\x01\x07.\nV\n\x04\x04\
    \x03\x02\x06\x12\x06\xf2\x01\x02\xf3\x010\x1aF\x20Immutable.\x20The\x20e\
    ncryption\x20configuration\x20for\x20CMEK-protected\x20clusters.\n\n\r\n\
    \x05\x04\x03\x02\x06\x06\x12\x04\xf2\x01\x02\x12\n\r\n\x05\x04\x03\x02\
    \x06\x01\x12\x04\xf2\x01\x13$\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\xf2\
    \x01'(\n\r\n\x05\x04\x03\x02\x06\x08\x12\x04\xf3\x01\x06/\n\x10\n\x08\
    \x04\x03\x02\x06\x08\x9c\x08\0\x12\x04\xf3\x01\x07.\n\x82\x01\n\x02\x04\
    \x04\x12\x06\xf8\x01\0\xd2\x02\x01\x1at\x20A\x20configuration\x20object\
    \x20describing\x20how\x20Cloud\x20Bigtable\x20should\x20treat\x20traffic\
    \n\x20from\x20a\x20particular\x20end\x20user\x20application.\n\n\x0b\n\
    \x03\x04\x04\x01\x12\x04\xf8\x01\x08\x12\n\r\n\x03\x04\x04\x07\x12\x06\
    \xf9\x01\x02\xfc\x01\x04\n\x0f\n\x05\x04\x04\x07\x9d\x08\x12\x06\xf9\x01\
    \x02\xfc\x01\x04\n\xcc\x02\n\x04\x04\x04\x03\0\x12\x06\x83\x02\x02\x87\
    \x02\x03\x1a\xbb\x02\x20Read/write\x20requests\x20are\x20routed\x20to\
    \x20the\x20nearest\x20cluster\x20in\x20the\x20instance,\x20and\n\x20will\
    \x20fail\x20over\x20to\x20the\x20nearest\x20cluster\x20that\x20is\x20ava\
    ilable\x20in\x20the\x20event\x20of\n\x20transient\x20errors\x20or\x20del\
    ays.\x20Clusters\x20in\x20a\x20region\x20are\x20considered\n\x20equidist\
    ant.\x20Choosing\x20this\x20option\x20sacrifices\x20read-your-writes\x20\
    consistency\n\x20to\x20improve\x20availability.\n\n\r\n\x05\x04\x04\x03\
    \0\x01\x12\x04\x83\x02\n#\n\xa1\x01\n\x06\x04\x04\x03\0\x02\0\x12\x04\
    \x86\x02\x04$\x1a\x90\x01\x20The\x20set\x20of\x20clusters\x20to\x20route\
    \x20to.\x20The\x20order\x20is\x20ignored;\x20clusters\x20will\x20be\n\
    \x20tried\x20in\x20order\x20of\x20distance.\x20If\x20left\x20empty,\x20a\
    ll\x20clusters\x20are\x20eligible.\n\n\x0f\n\x07\x04\x04\x03\0\x02\0\x04\
    \x12\x04\x86\x02\x04\x0c\n\x0f\n\x07\x04\x04\x03\0\x02\0\x05\x12\x04\x86\
    \x02\r\x13\n\x0f\n\x07\x04\x04\x03\0\x02\0\x01\x12\x04\x86\x02\x14\x1f\n\
    \x0f\n\x07\x04\x04\x03\0\x02\0\x03\x12\x04\x86\x02\"#\n\xb0\x01\n\x04\
    \x04\x04\x03\x01\x12\x06\x8c\x02\x02\x94\x02\x03\x1a\x9f\x01\x20Uncondit\
    ionally\x20routes\x20all\x20read/write\x20requests\x20to\x20a\x20specifi\
    c\x20cluster.\n\x20This\x20option\x20preserves\x20read-your-writes\x20co\
    nsistency\x20but\x20does\x20not\x20improve\n\x20availability.\n\n\r\n\
    \x05\x04\x04\x03\x01\x01\x12\x04\x8c\x02\n\x1e\nL\n\x06\x04\x04\x03\x01\
    \x02\0\x12\x04\x8e\x02\x04\x1a\x1a<\x20The\x20cluster\x20to\x20which\x20\
    read/write\x20requests\x20should\x20be\x20routed.\n\n\x0f\n\x07\x04\x04\
    \x03\x01\x02\0\x05\x12\x04\x8e\x02\x04\n\n\x0f\n\x07\x04\x04\x03\x01\x02\
    \0\x01\x12\x04\x8e\x02\x0b\x15\n\x0f\n\x07\x04\x04\x03\x01\x02\0\x03\x12\
    \x04\x8e\x02\x18\x19\n\xd1\x01\n\x06\x04\x04\x03\x01\x02\x01\x12\x04\x93\
    \x02\x04(\x1a\xc0\x01\x20Whether\x20or\x20not\x20`CheckAndMutateRow`\x20\
    and\x20`ReadModifyWriteRow`\x20requests\x20are\n\x20allowed\x20by\x20thi\
    s\x20app\x20profile.\x20It\x20is\x20unsafe\x20to\x20send\x20these\x20req\
    uests\x20to\n\x20the\x20same\x20table/row/column\x20in\x20multiple\x20cl\
    usters.\n\n\x0f\n\x07\x04\x04\x03\x01\x02\x01\x05\x12\x04\x93\x02\x04\
    \x08\n\x0f\n\x07\x04\x04\x03\x01\x02\x01\x01\x12\x04\x93\x02\t#\n\x0f\n\
    \x07\x04\x04\x03\x01\x02\x01\x03\x12\x04\x93\x02&'\n\xde\x01\n\x04\x04\
    \x04\x04\0\x12\x06\x99\x02\x02\xa2\x02\x03\x1a\xcd\x01\x20Possible\x20pr\
    iorities\x20for\x20an\x20app\x20profile.\x20Note\x20that\x20higher\x20pr\
    iority\x20writes\n\x20can\x20sometimes\x20queue\x20behind\x20lower\x20pr\
    iority\x20writes\x20to\x20the\x20same\x20tablet,\x20as\n\x20writes\x20mu\
    st\x20be\x20strictly\x20sequenced\x20in\x20the\x20durability\x20log.\n\n\
    \r\n\x05\x04\x04\x04\0\x01\x12\x04\x99\x02\x07\x0f\n[\n\x06\x04\x04\x04\
    \0\x02\0\x12\x04\x9b\x02\x04\x1d\x1aK\x20Default\x20value.\x20Mapped\x20\
    to\x20PRIORITY_HIGH\x20(the\x20legacy\x20behavior)\x20on\x20creation.\n\
    \n\x0f\n\x07\x04\x04\x04\0\x02\0\x01\x12\x04\x9b\x02\x04\x18\n\x0f\n\x07\
    \x04\x04\x04\0\x02\0\x02\x12\x04\x9b\x02\x1b\x1c\n\x0e\n\x06\x04\x04\x04\
    \0\x02\x01\x12\x04\x9d\x02\x04\x15\n\x0f\n\x07\x04\x04\x04\0\x02\x01\x01\
    \x12\x04\x9d\x02\x04\x10\n\x0f\n\x07\x04\x04\x04\0\x02\x01\x02\x12\x04\
    \x9d\x02\x13\x14\n\x0e\n\x06\x04\x04\x04\0\x02\x02\x12\x04\x9f\x02\x04\
    \x18\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x04\x9f\x02\x04\x13\n\x0f\
    \n\x07\x04\x04\x04\0\x02\x02\x02\x12\x04\x9f\x02\x16\x17\n\x0e\n\x06\x04\
    \x04\x04\0\x02\x03\x12\x04\xa1\x02\x04\x16\n\x0f\n\x07\x04\x04\x04\0\x02\
    \x03\x01\x12\x04\xa1\x02\x04\x11\n\x0f\n\x07\x04\x04\x04\0\x02\x03\x02\
    \x12\x04\xa1\x02\x14\x15\nb\n\x04\x04\x04\x03\x02\x12\x06\xa6\x02\x02\
    \xa9\x02\x03\x1aR\x20Standard\x20options\x20for\x20isolating\x20this\x20\
    app\x20profile's\x20traffic\x20from\x20other\x20use\n\x20cases.\n\n\r\n\
    \x05\x04\x04\x03\x02\x01\x12\x04\xa6\x02\n\x1b\nG\n\x06\x04\x04\x03\x02\
    \x02\0\x12\x04\xa8\x02\x04\x1a\x1a7\x20The\x20priority\x20of\x20requests\
    \x20sent\x20using\x20this\x20app\x20profile.\n\n\x0f\n\x07\x04\x04\x03\
    \x02\x02\0\x06\x12\x04\xa8\x02\x04\x0c\n\x0f\n\x07\x04\x04\x03\x02\x02\0\
    \x01\x12\x04\xa8\x02\r\x15\n\x0f\n\x07\x04\x04\x03\x02\x02\0\x03\x12\x04\
    \xa8\x02\x18\x19\n\x9f\x01\n\x04\x04\x04\x02\0\x12\x04\xad\x02\x02\x12\
    \x1a\x90\x01\x20The\x20unique\x20name\x20of\x20the\x20app\x20profile.\
    \x20Values\x20are\x20of\x20the\x20form\n\x20`projects/{project}/instance\
    s/{instance}/appProfiles/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.\n\n\r\n\x05\x04\
    \x04\x02\0\x05\x12\x04\xad\x02\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\
    \x04\xad\x02\t\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xad\x02\x10\x11\n\
    \xcd\x03\n\x04\x04\x04\x02\x01\x12\x04\xb7\x02\x02\x12\x1a\xbe\x03\x20St\
    rongly\x20validated\x20etag\x20for\x20optimistic\x20concurrency\x20contr\
    ol.\x20Preserve\x20the\n\x20value\x20returned\x20from\x20`GetAppProfile`\
    \x20when\x20calling\x20`UpdateAppProfile`\x20to\n\x20fail\x20the\x20requ\
    est\x20if\x20there\x20has\x20been\x20a\x20modification\x20in\x20the\x20m\
    ean\x20time.\x20The\n\x20`update_mask`\x20of\x20the\x20request\x20need\
    \x20not\x20include\x20`etag`\x20for\x20this\x20protection\n\x20to\x20app\
    ly.\n\x20See\x20[Wikipedia](https://en.wikipedia.org/wiki/HTTP_ETag)\x20\
    and\n\x20[RFC\x207232](https://tools.ietf.org/html/rfc7232#section-2.3)\
    \x20for\x20more\n\x20details.\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\
    \xb7\x02\x02\x08\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xb7\x02\t\r\n\r\n\
    \x05\x04\x04\x02\x01\x03\x12\x04\xb7\x02\x10\x11\nJ\n\x04\x04\x04\x02\
    \x02\x12\x04\xba\x02\x02\x19\x1a<\x20Long\x20form\x20description\x20of\
    \x20the\x20use\x20case\x20for\x20this\x20AppProfile.\n\n\r\n\x05\x04\x04\
    \x02\x02\x05\x12\x04\xba\x02\x02\x08\n\r\n\x05\x04\x04\x02\x02\x01\x12\
    \x04\xba\x02\t\x14\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xba\x02\x17\x18\
    \n|\n\x04\x04\x04\x08\0\x12\x06\xbe\x02\x02\xc4\x02\x03\x1al\x20The\x20r\
    outing\x20policy\x20for\x20all\x20read/write\x20requests\x20that\x20use\
    \x20this\x20app\x20profile.\n\x20A\x20value\x20must\x20be\x20explicitly\
    \x20set.\n\n\r\n\x05\x04\x04\x08\0\x01\x12\x04\xbe\x02\x08\x16\n3\n\x04\
    \x04\x04\x02\x03\x12\x04\xc0\x02\x04@\x1a%\x20Use\x20a\x20multi-cluster\
    \x20routing\x20policy.\n\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\xc0\x02\
    \x04\x1d\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xc0\x02\x1e;\n\r\n\x05\
    \x04\x04\x02\x03\x03\x12\x04\xc0\x02>?\n4\n\x04\x04\x04\x02\x04\x12\x04\
    \xc3\x02\x044\x1a&\x20Use\x20a\x20single-cluster\x20routing\x20policy.\n\
    \n\r\n\x05\x04\x04\x02\x04\x06\x12\x04\xc3\x02\x04\x18\n\r\n\x05\x04\x04\
    \x02\x04\x01\x12\x04\xc3\x02\x19/\n\r\n\x05\x04\x04\x02\x04\x03\x12\x04\
    \xc3\x0223\nX\n\x04\x04\x04\x08\x01\x12\x06\xc7\x02\x02\xd1\x02\x03\x1aH\
    \x20Options\x20for\x20isolating\x20this\x20app\x20profile's\x20traffic\
    \x20from\x20other\x20use\x20cases.\n\n\r\n\x05\x04\x04\x08\x01\x01\x12\
    \x04\xc7\x02\x08\x11\n\xdd\x01\n\x04\x04\x04\x02\x05\x12\x04\xcc\x02\x04\
    .\x1a\xce\x01\x20This\x20field\x20has\x20been\x20deprecated\x20in\x20fav\
    or\x20of\x20`standard_isolation.priority`.\n\x20If\x20you\x20set\x20this\
    \x20field,\x20`standard_isolation.priority`\x20will\x20be\x20set\x20inst\
    ead.\n\n\x20The\x20priority\x20of\x20requests\x20sent\x20using\x20this\
    \x20app\x20profile.\n\n\r\n\x05\x04\x04\x02\x05\x06\x12\x04\xcc\x02\x04\
    \x0c\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\xcc\x02\r\x15\n\r\n\x05\x04\
    \x04\x02\x05\x03\x12\x04\xcc\x02\x18\x19\n\r\n\x05\x04\x04\x02\x05\x08\
    \x12\x04\xcc\x02\x1a-\n\x0e\n\x06\x04\x04\x02\x05\x08\x03\x12\x04\xcc\
    \x02\x1b,\ni\n\x04\x04\x04\x02\x06\x12\x04\xd0\x02\x04.\x1a[\x20The\x20s\
    tandard\x20options\x20used\x20for\x20isolating\x20this\x20app\x20profile\
    's\x20traffic\x20from\n\x20other\x20use\x20cases.\n\n\r\n\x05\x04\x04\
    \x02\x06\x06\x12\x04\xd0\x02\x04\x15\n\r\n\x05\x04\x04\x02\x06\x01\x12\
    \x04\xd0\x02\x16(\n\r\n\x05\x04\x04\x02\x06\x03\x12\x04\xd0\x02+-\n\xcb\
    \x02\n\x02\x04\x05\x12\x06\xd9\x02\0\xfc\x02\x01\x1a\xbc\x02\x20A\x20tab\
    let\x20is\x20a\x20defined\x20by\x20a\x20start\x20and\x20end\x20key\x20an\
    d\x20is\x20explained\x20in\n\x20https://cloud.google.com/bigtable/docs/o\
    verview#architecture\x20and\n\x20https://cloud.google.com/bigtable/docs/\
    performance#optimization.\n\x20A\x20Hot\x20tablet\x20is\x20a\x20tablet\
    \x20that\x20exhibits\x20high\x20average\x20cpu\x20usage\x20during\x20the\
    \x20time\n\x20interval\x20from\x20start\x20time\x20to\x20end\x20time.\n\
    \n\x0b\n\x03\x04\x05\x01\x12\x04\xd9\x02\x08\x11\n\r\n\x03\x04\x05\x07\
    \x12\x06\xda\x02\x02\xdd\x02\x04\n\x0f\n\x05\x04\x05\x07\x9d\x08\x12\x06\
    \xda\x02\x02\xdd\x02\x04\n\xa3\x01\n\x04\x04\x05\x02\0\x12\x04\xe1\x02\
    \x02\x12\x1a\x94\x01\x20The\x20unique\x20name\x20of\x20the\x20hot\x20tab\
    let.\x20Values\x20are\x20of\x20the\x20form\n\x20`projects/{project}/inst\
    ances/{instance}/clusters/{cluster}/hotTablets/[a-zA-Z0-9_-]*`.\n\n\r\n\
    \x05\x04\x05\x02\0\x05\x12\x04\xe1\x02\x02\x08\n\r\n\x05\x04\x05\x02\0\
    \x01\x12\x04\xe1\x02\t\r\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xe1\x02\x10\
    \x11\n\xa4\x01\n\x04\x04\x05\x02\x01\x12\x06\xe5\x02\x02\xe7\x02\x05\x1a\
    \x93\x01\x20Name\x20of\x20the\x20table\x20that\x20contains\x20the\x20tab\
    let.\x20Values\x20are\x20of\x20the\x20form\n\x20`projects/{project}/inst\
    ances/{instance}/tables/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.\n\n\r\n\x05\x04\
    \x05\x02\x01\x05\x12\x04\xe5\x02\x02\x08\n\r\n\x05\x04\x05\x02\x01\x01\
    \x12\x04\xe5\x02\t\x13\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xe5\x02\x16\
    \x17\n\x0f\n\x05\x04\x05\x02\x01\x08\x12\x06\xe5\x02\x18\xe7\x02\x04\n\
    \x11\n\x07\x04\x05\x02\x01\x08\x9f\x08\x12\x06\xe5\x02\x19\xe7\x02\x03\n\
    @\n\x04\x04\x05\x02\x02\x12\x06\xea\x02\x02\xeb\x022\x1a0\x20Output\x20o\
    nly.\x20The\x20start\x20time\x20of\x20the\x20hot\x20tablet.\n\n\r\n\x05\
    \x04\x05\x02\x02\x06\x12\x04\xea\x02\x02\x1b\n\r\n\x05\x04\x05\x02\x02\
    \x01\x12\x04\xea\x02\x1c&\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xea\x02)\
    *\n\r\n\x05\x04\x05\x02\x02\x08\x12\x04\xeb\x02\x061\n\x10\n\x08\x04\x05\
    \x02\x02\x08\x9c\x08\0\x12\x04\xeb\x02\x070\n>\n\x04\x04\x05\x02\x03\x12\
    \x06\xee\x02\x02\xef\x022\x1a.\x20Output\x20only.\x20The\x20end\x20time\
    \x20of\x20the\x20hot\x20tablet.\n\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\
    \xee\x02\x02\x1b\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xee\x02\x1c$\n\r\
    \n\x05\x04\x05\x02\x03\x03\x12\x04\xee\x02'(\n\r\n\x05\x04\x05\x02\x03\
    \x08\x12\x04\xef\x02\x061\n\x10\n\x08\x04\x05\x02\x03\x08\x9c\x08\0\x12\
    \x04\xef\x02\x070\n-\n\x04\x04\x05\x02\x04\x12\x04\xf2\x02\x02\x17\x1a\
    \x1f\x20Tablet\x20Start\x20Key\x20(inclusive).\n\n\r\n\x05\x04\x05\x02\
    \x04\x05\x12\x04\xf2\x02\x02\x08\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\
    \xf2\x02\t\x12\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\xf2\x02\x15\x16\n+\
    \n\x04\x04\x05\x02\x05\x12\x04\xf5\x02\x02\x15\x1a\x1d\x20Tablet\x20End\
    \x20Key\x20(inclusive).\n\n\r\n\x05\x04\x05\x02\x05\x05\x12\x04\xf5\x02\
    \x02\x08\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\xf5\x02\t\x10\n\r\n\x05\
    \x04\x05\x02\x05\x03\x12\x04\xf5\x02\x13\x14\n\xb0\x02\n\x04\x04\x05\x02\
    \x06\x12\x04\xfb\x02\x02O\x1a\xa1\x02\x20Output\x20only.\x20The\x20avera\
    ge\x20CPU\x20usage\x20spent\x20by\x20a\x20node\x20on\x20this\x20tablet\
    \x20over\x20the\n\x20start_time\x20to\x20end_time\x20time\x20range.\x20T\
    he\x20percentage\x20is\x20the\x20amount\x20of\x20CPU\x20used\n\x20by\x20\
    the\x20node\x20to\x20serve\x20the\x20tablet,\x20from\x200%\x20(tablet\
    \x20was\x20not\x20interacted\x20with)\n\x20to\x20100%\x20(the\x20node\
    \x20spent\x20all\x20cycles\x20serving\x20the\x20hot\x20tablet).\n\n\r\n\
    \x05\x04\x05\x02\x06\x05\x12\x04\xfb\x02\x02\x07\n\r\n\x05\x04\x05\x02\
    \x06\x01\x12\x04\xfb\x02\x08\x1e\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\
    \xfb\x02!\"\n\r\n\x05\x04\x05\x02\x06\x08\x12\x04\xfb\x02#N\n\x10\n\x08\
    \x04\x05\x02\x06\x08\x9c\x08\0\x12\x04\xfb\x02$Mb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
